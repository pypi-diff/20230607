# Comparing `tmp/bosdyn_client-3.2.3-py2.py3-none-any.whl.zip` & `tmp/bosdyn_client-3.3.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,87 +1,92 @@
-Zip file size: 240353 bytes, number of entries: 85
--rw-r--r--  2.0 unx      330 b- defN 23-Mar-24 15:44 bosdyn/__init__.py
--rw-r--r--  2.0 unx     1396 b- defN 23-Mar-24 15:44 bosdyn/client/__init__.py
--rw-r--r--  2.0 unx      466 b- defN 23-Mar-24 15:44 bosdyn/client/__main__.py
--rw-r--r--  2.0 unx     6212 b- defN 23-Mar-24 15:44 bosdyn/client/area_callback.py
--rw-r--r--  2.0 unx    14659 b- defN 23-Mar-24 15:44 bosdyn/client/area_callback_region_handler_base.py
--rw-r--r--  2.0 unx     1869 b- defN 23-Mar-24 15:44 bosdyn/client/area_callback_service_runner.py
--rw-r--r--  2.0 unx    11013 b- defN 23-Mar-24 15:44 bosdyn/client/area_callback_service_servicer.py
--rw-r--r--  2.0 unx     1566 b- defN 23-Mar-24 15:44 bosdyn/client/area_callback_service_utils.py
--rw-r--r--  2.0 unx     3710 b- defN 23-Mar-24 15:44 bosdyn/client/arm_surface_contact.py
--rw-r--r--  2.0 unx     5625 b- defN 23-Mar-24 15:44 bosdyn/client/async_tasks.py
--rw-r--r--  2.0 unx     6253 b- defN 23-Mar-24 15:44 bosdyn/client/auth.py
--rw-r--r--  2.0 unx     4486 b- defN 23-Mar-24 15:44 bosdyn/client/auto_return.py
--rw-r--r--  2.0 unx     5682 b- defN 23-Mar-24 15:44 bosdyn/client/autowalk.py
--rw-r--r--  2.0 unx     1763 b- defN 23-Mar-24 15:44 bosdyn/client/bddf.py
--rw-r--r--  2.0 unx     7586 b- defN 23-Mar-24 15:44 bosdyn/client/bddf_download.py
--rw-r--r--  2.0 unx     8902 b- defN 23-Mar-24 15:44 bosdyn/client/channel.py
--rw-r--r--  2.0 unx    78069 b- defN 23-Mar-24 15:44 bosdyn/client/command_line.py
--rw-r--r--  2.0 unx    20644 b- defN 23-Mar-24 15:44 bosdyn/client/common.py
--rw-r--r--  2.0 unx    13075 b- defN 23-Mar-24 15:44 bosdyn/client/data_acquisition.py
--rw-r--r--  2.0 unx    14882 b- defN 23-Mar-24 15:44 bosdyn/client/data_acquisition_helpers.py
--rw-r--r--  2.0 unx     5025 b- defN 23-Mar-24 15:44 bosdyn/client/data_acquisition_plugin.py
--rw-r--r--  2.0 unx    24120 b- defN 23-Mar-24 15:44 bosdyn/client/data_acquisition_plugin_service.py
--rw-r--r--  2.0 unx    12273 b- defN 23-Mar-24 15:44 bosdyn/client/data_acquisition_store.py
--rw-r--r--  2.0 unx    25851 b- defN 23-Mar-24 15:44 bosdyn/client/data_buffer.py
--rw-r--r--  2.0 unx     5240 b- defN 23-Mar-24 15:44 bosdyn/client/data_service.py
--rw-r--r--  2.0 unx     4906 b- defN 23-Mar-24 15:44 bosdyn/client/directory.py
--rw-r--r--  2.0 unx    19696 b- defN 23-Mar-24 15:44 bosdyn/client/directory_registration.py
--rw-r--r--  2.0 unx    17488 b- defN 23-Mar-24 15:44 bosdyn/client/docking.py
--rw-r--r--  2.0 unx     3110 b- defN 23-Mar-24 15:44 bosdyn/client/door.py
--rw-r--r--  2.0 unx    31826 b- defN 23-Mar-24 15:44 bosdyn/client/estop.py
--rw-r--r--  2.0 unx     4670 b- defN 23-Mar-24 15:44 bosdyn/client/exceptions.py
--rw-r--r--  2.0 unx     6050 b- defN 23-Mar-24 15:44 bosdyn/client/fault.py
--rw-r--r--  2.0 unx    11936 b- defN 23-Mar-24 15:44 bosdyn/client/frame_helpers.py
--rw-r--r--  2.0 unx    61778 b- defN 23-Mar-24 15:44 bosdyn/client/graph_nav.py
--rw-r--r--  2.0 unx     2631 b- defN 23-Mar-24 15:44 bosdyn/client/gripper_camera_param.py
--rw-r--r--  2.0 unx    20146 b- defN 23-Mar-24 15:44 bosdyn/client/image.py
--rw-r--r--  2.0 unx    30074 b- defN 23-Mar-24 15:44 bosdyn/client/image_service_helpers.py
--rw-r--r--  2.0 unx     2153 b- defN 23-Mar-24 15:44 bosdyn/client/ir_enable_disable.py
--rw-r--r--  2.0 unx    45013 b- defN 23-Mar-24 15:44 bosdyn/client/lease.py
--rw-r--r--  2.0 unx     3070 b- defN 23-Mar-24 15:44 bosdyn/client/lease_resource_hierarchy.py
--rw-r--r--  2.0 unx    14531 b- defN 23-Mar-24 15:44 bosdyn/client/lease_validator.py
--rw-r--r--  2.0 unx     1736 b- defN 23-Mar-24 15:44 bosdyn/client/license.py
--rw-r--r--  2.0 unx     3475 b- defN 23-Mar-24 15:44 bosdyn/client/local_grid.py
--rw-r--r--  2.0 unx    15547 b- defN 23-Mar-24 15:44 bosdyn/client/log_annotation.py
--rw-r--r--  2.0 unx     4203 b- defN 23-Mar-24 15:44 bosdyn/client/manipulation_api_client.py
--rw-r--r--  2.0 unx     9868 b- defN 23-Mar-24 15:44 bosdyn/client/map_processing.py
--rw-r--r--  2.0 unx    45005 b- defN 23-Mar-24 15:44 bosdyn/client/math_helpers.py
--rw-r--r--  2.0 unx     7568 b- defN 23-Mar-24 15:44 bosdyn/client/network_compute_bridge_client.py
--rw-r--r--  2.0 unx     2310 b- defN 23-Mar-24 15:44 bosdyn/client/payload.py
--rw-r--r--  2.0 unx    22355 b- defN 23-Mar-24 15:44 bosdyn/client/payload_registration.py
--rw-r--r--  2.0 unx     8421 b- defN 23-Mar-24 15:44 bosdyn/client/point_cloud.py
--rw-r--r--  2.0 unx    24711 b- defN 23-Mar-24 15:44 bosdyn/client/power.py
--rw-r--r--  2.0 unx     1275 b- defN 23-Mar-24 15:44 bosdyn/client/processors.py
--rw-r--r--  2.0 unx     4465 b- defN 23-Mar-24 15:44 bosdyn/client/ray_cast.py
--rw-r--r--  2.0 unx    24729 b- defN 23-Mar-24 15:44 bosdyn/client/recording.py
--rw-r--r--  2.0 unx    29963 b- defN 23-Mar-24 15:44 bosdyn/client/robot.py
--rw-r--r--  2.0 unx    89797 b- defN 23-Mar-24 15:44 bosdyn/client/robot_command.py
--rw-r--r--  2.0 unx     2359 b- defN 23-Mar-24 15:44 bosdyn/client/robot_id.py
--rw-r--r--  2.0 unx     6215 b- defN 23-Mar-24 15:44 bosdyn/client/robot_state.py
--rw-r--r--  2.0 unx    12699 b- defN 23-Mar-24 15:44 bosdyn/client/sdk.py
--rw-r--r--  2.0 unx    10199 b- defN 23-Mar-24 15:44 bosdyn/client/server_util.py
--rw-r--r--  2.0 unx    14647 b- defN 23-Mar-24 15:44 bosdyn/client/spot_check.py
--rw-r--r--  2.0 unx    21284 b- defN 23-Mar-24 15:44 bosdyn/client/time_sync.py
--rw-r--r--  2.0 unx     3507 b- defN 23-Mar-24 15:44 bosdyn/client/token_cache.py
--rw-r--r--  2.0 unx     3144 b- defN 23-Mar-24 15:44 bosdyn/client/token_manager.py
--rw-r--r--  2.0 unx    19106 b- defN 23-Mar-24 15:44 bosdyn/client/util.py
--rw-r--r--  2.0 unx    16843 b- defN 23-Mar-24 15:44 bosdyn/client/world_object.py
--rw-r--r--  2.0 unx      265 b- defN 23-Mar-24 15:44 bosdyn/client/resources/__init__.py
--rw-r--r--  2.0 unx     1874 b- defN 23-Mar-24 15:44 bosdyn/client/resources/robot.pem
--rw-r--r--  2.0 unx      790 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/__init__.py
--rw-r--r--  2.0 unx     9843 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/audio.py
--rw-r--r--  2.0 unx     7889 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/compositor.py
--rw-r--r--  2.0 unx     4707 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/health.py
--rw-r--r--  2.0 unx     3089 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/lighting.py
--rw-r--r--  2.0 unx     3963 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/lights_helper.py
--rw-r--r--  2.0 unx    10372 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/media_log.py
--rw-r--r--  2.0 unx     3023 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/network.py
--rw-r--r--  2.0 unx     5181 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/power.py
--rw-r--r--  2.0 unx     6942 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/ptz.py
--rw-r--r--  2.0 unx     4453 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/streamquality.py
--rw-r--r--  2.0 unx     2856 b- defN 23-Mar-24 15:44 bosdyn/client/spot_cam/version.py
--rw-r--r--  2.0 unx     3740 b- defN 23-Mar-24 15:44 bosdyn_client-3.2.3.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Mar-24 15:44 bosdyn_client-3.2.3.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 23-Mar-24 15:44 bosdyn_client-3.2.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     7442 b- defN 23-Mar-24 15:44 bosdyn_client-3.2.3.dist-info/RECORD
-85 files, 1041752 bytes uncompressed, 228617 bytes compressed:  78.1%
+Zip file size: 262497 bytes, number of entries: 90
+-rw-r--r--  2.0 unx      330 b- defN 23-Jun-07 02:50 bosdyn/__init__.py
+-rw-r--r--  2.0 unx     1439 b- defN 23-Jun-07 02:50 bosdyn/client/__init__.py
+-rw-r--r--  2.0 unx      466 b- defN 23-Jun-07 02:50 bosdyn/client/__main__.py
+-rw-r--r--  2.0 unx     6270 b- defN 23-Jun-07 02:50 bosdyn/client/area_callback.py
+-rw-r--r--  2.0 unx    15819 b- defN 23-Jun-07 02:50 bosdyn/client/area_callback_region_handler_base.py
+-rw-r--r--  2.0 unx     1869 b- defN 23-Jun-07 02:50 bosdyn/client/area_callback_service_runner.py
+-rw-r--r--  2.0 unx    11538 b- defN 23-Jun-07 02:50 bosdyn/client/area_callback_service_servicer.py
+-rw-r--r--  2.0 unx     6095 b- defN 23-Jun-07 02:50 bosdyn/client/area_callback_service_utils.py
+-rw-r--r--  2.0 unx     3710 b- defN 23-Jun-07 02:50 bosdyn/client/arm_surface_contact.py
+-rw-r--r--  2.0 unx     5594 b- defN 23-Jun-07 02:50 bosdyn/client/async_tasks.py
+-rw-r--r--  2.0 unx     6253 b- defN 23-Jun-07 02:50 bosdyn/client/auth.py
+-rw-r--r--  2.0 unx     5598 b- defN 23-Jun-07 02:50 bosdyn/client/auto_return.py
+-rw-r--r--  2.0 unx     5731 b- defN 23-Jun-07 02:50 bosdyn/client/autowalk.py
+-rw-r--r--  2.0 unx     1763 b- defN 23-Jun-07 02:50 bosdyn/client/bddf.py
+-rw-r--r--  2.0 unx     7586 b- defN 23-Jun-07 02:50 bosdyn/client/bddf_download.py
+-rw-r--r--  2.0 unx     8902 b- defN 23-Jun-07 02:50 bosdyn/client/channel.py
+-rw-r--r--  2.0 unx    87380 b- defN 23-Jun-07 02:50 bosdyn/client/command_line.py
+-rw-r--r--  2.0 unx    22549 b- defN 23-Jun-07 02:50 bosdyn/client/common.py
+-rw-r--r--  2.0 unx    13123 b- defN 23-Jun-07 02:50 bosdyn/client/data_acquisition.py
+-rw-r--r--  2.0 unx    14837 b- defN 23-Jun-07 02:50 bosdyn/client/data_acquisition_helpers.py
+-rw-r--r--  2.0 unx     6166 b- defN 23-Jun-07 02:50 bosdyn/client/data_acquisition_plugin.py
+-rw-r--r--  2.0 unx    25078 b- defN 23-Jun-07 02:50 bosdyn/client/data_acquisition_plugin_service.py
+-rw-r--r--  2.0 unx    12272 b- defN 23-Jun-07 02:50 bosdyn/client/data_acquisition_store.py
+-rw-r--r--  2.0 unx    25812 b- defN 23-Jun-07 02:50 bosdyn/client/data_buffer.py
+-rw-r--r--  2.0 unx     1958 b- defN 23-Jun-07 02:50 bosdyn/client/data_chunk.py
+-rw-r--r--  2.0 unx     5201 b- defN 23-Jun-07 02:50 bosdyn/client/data_service.py
+-rw-r--r--  2.0 unx     4906 b- defN 23-Jun-07 02:50 bosdyn/client/directory.py
+-rw-r--r--  2.0 unx    19696 b- defN 23-Jun-07 02:50 bosdyn/client/directory_registration.py
+-rw-r--r--  2.0 unx    17596 b- defN 23-Jun-07 02:50 bosdyn/client/docking.py
+-rw-r--r--  2.0 unx     3110 b- defN 23-Jun-07 02:50 bosdyn/client/door.py
+-rw-r--r--  2.0 unx    32073 b- defN 23-Jun-07 02:50 bosdyn/client/estop.py
+-rw-r--r--  2.0 unx     5418 b- defN 23-Jun-07 02:50 bosdyn/client/exceptions.py
+-rw-r--r--  2.0 unx     6050 b- defN 23-Jun-07 02:50 bosdyn/client/fault.py
+-rw-r--r--  2.0 unx    12480 b- defN 23-Jun-07 02:50 bosdyn/client/frame_helpers.py
+-rw-r--r--  2.0 unx    64764 b- defN 23-Jun-07 02:50 bosdyn/client/graph_nav.py
+-rw-r--r--  2.0 unx     2631 b- defN 23-Jun-07 02:50 bosdyn/client/gripper_camera_param.py
+-rw-r--r--  2.0 unx    20435 b- defN 23-Jun-07 02:50 bosdyn/client/image.py
+-rw-r--r--  2.0 unx    39462 b- defN 23-Jun-07 02:50 bosdyn/client/image_service_helpers.py
+-rw-r--r--  2.0 unx     1708 b- defN 23-Jun-07 02:50 bosdyn/client/inverse_kinematics.py
+-rw-r--r--  2.0 unx     2153 b- defN 23-Jun-07 02:50 bosdyn/client/ir_enable_disable.py
+-rw-r--r--  2.0 unx    13214 b- defN 23-Jun-07 02:50 bosdyn/client/keepalive.py
+-rw-r--r--  2.0 unx    45001 b- defN 23-Jun-07 02:50 bosdyn/client/lease.py
+-rw-r--r--  2.0 unx     3070 b- defN 23-Jun-07 02:50 bosdyn/client/lease_resource_hierarchy.py
+-rw-r--r--  2.0 unx    14531 b- defN 23-Jun-07 02:50 bosdyn/client/lease_validator.py
+-rw-r--r--  2.0 unx     1736 b- defN 23-Jun-07 02:50 bosdyn/client/license.py
+-rw-r--r--  2.0 unx     3475 b- defN 23-Jun-07 02:50 bosdyn/client/local_grid.py
+-rw-r--r--  2.0 unx    15506 b- defN 23-Jun-07 02:50 bosdyn/client/log_annotation.py
+-rw-r--r--  2.0 unx    11317 b- defN 23-Jun-07 02:50 bosdyn/client/log_status.py
+-rw-r--r--  2.0 unx     4203 b- defN 23-Jun-07 02:50 bosdyn/client/manipulation_api_client.py
+-rw-r--r--  2.0 unx     9830 b- defN 23-Jun-07 02:50 bosdyn/client/map_processing.py
+-rw-r--r--  2.0 unx    47499 b- defN 23-Jun-07 02:50 bosdyn/client/math_helpers.py
+-rw-r--r--  2.0 unx     7695 b- defN 23-Jun-07 02:50 bosdyn/client/network_compute_bridge_client.py
+-rw-r--r--  2.0 unx     2271 b- defN 23-Jun-07 02:50 bosdyn/client/payload.py
+-rw-r--r--  2.0 unx    22316 b- defN 23-Jun-07 02:50 bosdyn/client/payload_registration.py
+-rw-r--r--  2.0 unx     8382 b- defN 23-Jun-07 02:50 bosdyn/client/point_cloud.py
+-rw-r--r--  2.0 unx    24938 b- defN 23-Jun-07 02:50 bosdyn/client/power.py
+-rw-r--r--  2.0 unx     1275 b- defN 23-Jun-07 02:50 bosdyn/client/processors.py
+-rw-r--r--  2.0 unx     4465 b- defN 23-Jun-07 02:50 bosdyn/client/ray_cast.py
+-rw-r--r--  2.0 unx    26016 b- defN 23-Jun-07 02:50 bosdyn/client/recording.py
+-rw-r--r--  2.0 unx    30775 b- defN 23-Jun-07 02:50 bosdyn/client/robot.py
+-rw-r--r--  2.0 unx   100454 b- defN 23-Jun-07 02:50 bosdyn/client/robot_command.py
+-rw-r--r--  2.0 unx     2359 b- defN 23-Jun-07 02:50 bosdyn/client/robot_id.py
+-rw-r--r--  2.0 unx     6215 b- defN 23-Jun-07 02:50 bosdyn/client/robot_state.py
+-rw-r--r--  2.0 unx    12932 b- defN 23-Jun-07 02:50 bosdyn/client/sdk.py
+-rw-r--r--  2.0 unx    10199 b- defN 23-Jun-07 02:50 bosdyn/client/server_util.py
+-rw-r--r--  2.0 unx    22568 b- defN 23-Jun-07 02:50 bosdyn/client/service_customization_helpers.py
+-rw-r--r--  2.0 unx    14614 b- defN 23-Jun-07 02:50 bosdyn/client/spot_check.py
+-rw-r--r--  2.0 unx    21284 b- defN 23-Jun-07 02:50 bosdyn/client/time_sync.py
+-rw-r--r--  2.0 unx     3507 b- defN 23-Jun-07 02:50 bosdyn/client/token_cache.py
+-rw-r--r--  2.0 unx     3144 b- defN 23-Jun-07 02:50 bosdyn/client/token_manager.py
+-rw-r--r--  2.0 unx    19043 b- defN 23-Jun-07 02:50 bosdyn/client/util.py
+-rw-r--r--  2.0 unx    18679 b- defN 23-Jun-07 02:50 bosdyn/client/world_object.py
+-rw-r--r--  2.0 unx      265 b- defN 23-Jun-07 02:50 bosdyn/client/resources/__init__.py
+-rw-r--r--  2.0 unx     1874 b- defN 23-Jun-07 02:50 bosdyn/client/resources/robot.pem
+-rw-r--r--  2.0 unx      790 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/__init__.py
+-rw-r--r--  2.0 unx     9845 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/audio.py
+-rw-r--r--  2.0 unx    10294 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/compositor.py
+-rw-r--r--  2.0 unx     4707 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/health.py
+-rw-r--r--  2.0 unx     3089 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/lighting.py
+-rw-r--r--  2.0 unx     3963 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/lights_helper.py
+-rw-r--r--  2.0 unx    10379 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/media_log.py
+-rw-r--r--  2.0 unx     3023 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/network.py
+-rw-r--r--  2.0 unx     5181 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/power.py
+-rw-r--r--  2.0 unx    10177 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/ptz.py
+-rw-r--r--  2.0 unx     6411 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/streamquality.py
+-rw-r--r--  2.0 unx     2856 b- defN 23-Jun-07 02:50 bosdyn/client/spot_cam/version.py
+-rw-r--r--  2.0 unx     3904 b- defN 23-Jun-07 02:50 bosdyn_client-3.3.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-07 02:50 bosdyn_client-3.3.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Jun-07 02:50 bosdyn_client-3.3.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7893 b- defN 23-Jun-07 02:50 bosdyn_client-3.3.0.dist-info/RECORD
+90 files, 1153084 bytes uncompressed, 250059 bytes compressed:  78.3%
```

## zipnote {}

```diff
@@ -66,14 +66,17 @@
 
 Filename: bosdyn/client/data_acquisition_store.py
 Comment: 
 
 Filename: bosdyn/client/data_buffer.py
 Comment: 
 
+Filename: bosdyn/client/data_chunk.py
+Comment: 
+
 Filename: bosdyn/client/data_service.py
 Comment: 
 
 Filename: bosdyn/client/directory.py
 Comment: 
 
 Filename: bosdyn/client/directory_registration.py
@@ -105,17 +108,23 @@
 
 Filename: bosdyn/client/image.py
 Comment: 
 
 Filename: bosdyn/client/image_service_helpers.py
 Comment: 
 
+Filename: bosdyn/client/inverse_kinematics.py
+Comment: 
+
 Filename: bosdyn/client/ir_enable_disable.py
 Comment: 
 
+Filename: bosdyn/client/keepalive.py
+Comment: 
+
 Filename: bosdyn/client/lease.py
 Comment: 
 
 Filename: bosdyn/client/lease_resource_hierarchy.py
 Comment: 
 
 Filename: bosdyn/client/lease_validator.py
@@ -126,14 +135,17 @@
 
 Filename: bosdyn/client/local_grid.py
 Comment: 
 
 Filename: bosdyn/client/log_annotation.py
 Comment: 
 
+Filename: bosdyn/client/log_status.py
+Comment: 
+
 Filename: bosdyn/client/manipulation_api_client.py
 Comment: 
 
 Filename: bosdyn/client/map_processing.py
 Comment: 
 
 Filename: bosdyn/client/math_helpers.py
@@ -177,14 +189,17 @@
 
 Filename: bosdyn/client/sdk.py
 Comment: 
 
 Filename: bosdyn/client/server_util.py
 Comment: 
 
+Filename: bosdyn/client/service_customization_helpers.py
+Comment: 
+
 Filename: bosdyn/client/spot_check.py
 Comment: 
 
 Filename: bosdyn/client/time_sync.py
 Comment: 
 
 Filename: bosdyn/client/token_cache.py
@@ -237,20 +252,20 @@
 
 Filename: bosdyn/client/spot_cam/streamquality.py
 Comment: 
 
 Filename: bosdyn/client/spot_cam/version.py
 Comment: 
 
-Filename: bosdyn_client-3.2.3.dist-info/METADATA
+Filename: bosdyn_client-3.3.0.dist-info/METADATA
 Comment: 
 
-Filename: bosdyn_client-3.2.3.dist-info/WHEEL
+Filename: bosdyn_client-3.3.0.dist-info/WHEEL
 Comment: 
 
-Filename: bosdyn_client-3.2.3.dist-info/top_level.txt
+Filename: bosdyn_client-3.3.0.dist-info/top_level.txt
 Comment: 
 
-Filename: bosdyn_client-3.2.3.dist-info/RECORD
+Filename: bosdyn_client-3.3.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## bosdyn/__init__.py

```diff
@@ -1,7 +1,7 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 __path__ = __import__('pkgutil').extend_path(__path__, __name__)
```

## bosdyn/client/__init__.py

```diff
@@ -1,24 +1,25 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """The client library package.
 Sets up some convenience imports for commonly used classes.
 """
 # yapf: enable
 from .auth import (AuthClient, ExpiredApplicationTokenError, InvalidApplicationTokenError,
                    InvalidLoginError, InvalidTokenError)
 from .common import BaseClient
 # yapf: disable
-from .exceptions import (ClientCancelledOperationError, Error, InternalServerError,
-                         InvalidAppTokenError, InvalidClientCertificateError, InvalidRequestError,
-                         LeaseUseError, LicenseError, NonexistentAuthorityError, NotFoundError,
-                         PersistentRpcError, ProxyConnectionError, ResponseError, RetryableRpcError,
+from .exceptions import (ClientCancelledOperationError, CustomParamError, Error,
+                         InternalServerError, InvalidAppTokenError, InvalidClientCertificateError,
+                         InvalidRequestError, LeaseUseError, LicenseError,
+                         NonexistentAuthorityError, NotFoundError, PersistentRpcError,
+                         ProxyConnectionError, ResponseError, RetryableRpcError,
                          RetryableUnavailableError, RpcError, ServerError,
                          ServiceFailedDuringExecutionError, ServiceUnavailableError, TimedOutError,
                          TooManyRequestsError, UnableToConnectToRobotError, UnauthenticatedError,
                          UnimplementedError, UnknownDnsNameError, UnsetStatusError)
 from .robot import Robot
 from .sdk import BOSDYN_RESOURCE_ROOT, Sdk, create_standard_sdk
```

## bosdyn/client/__main__.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Command-line tool for interacting with robot services"""
 __package__ = 'bosdyn.client'
```

## bosdyn/client/area_callback.py

```diff
@@ -1,19 +1,19 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 import collections
 
 from bosdyn.api.graph_nav import area_callback_pb2, area_callback_service_pb2_grpc
 from bosdyn.client.common import (BaseClient, common_header_errors, error_factory, error_pair,
-                                  handle_common_header_errors, handle_lease_use_result_errors,
-                                  handle_unset_status_error)
+                                  handle_common_header_errors, handle_custom_params_errors,
+                                  handle_lease_use_result_errors, handle_unset_status_error)
 from bosdyn.client.exceptions import LeaseUseError, ResponseError
 
 
 class AreaCallbackClient(BaseClient):
     service_type = 'bosdyn.api.graph_nav.AreaCallbackService'
     default_service_name = None
 
@@ -73,14 +73,15 @@
 _BEGIN_CALLBACK_TO_ERROR.update({
     area_callback_pb2.BeginCallbackResponse.STATUS_OK: (None, None),
     area_callback_pb2.BeginCallbackResponse.STATUS_INVALID_CONFIGURATION: error_pair(InvalidConfigError),
     area_callback_pb2.BeginCallbackResponse.STATUS_EXPIRED_END_TIME: error_pair(ExpiredEndTimeError),
 })
 
 @handle_common_header_errors
+@handle_custom_params_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _begin_callback_error(response):
     return error_factory(response, response.status,
                          status_to_string=area_callback_pb2.BeginCallbackResponse.Status.Name,
                          status_to_error=_BEGIN_CALLBACK_TO_ERROR)
 
 _BEGIN_CONTROL_TO_ERROR = collections.defaultdict(
```

## bosdyn/client/area_callback_region_handler_base.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 import copy
 import logging
@@ -14,18 +14,24 @@
 from bosdyn.client.area_callback_service_utils import AreaCallbackServiceConfig
 from bosdyn.client.common import LeaseUseError
 from bosdyn.client.robot import Robot
 
 _LOGGER = logging.getLogger(__name__)
 
 
+class PathBlocked(Exception):
+    """The callback reports the that path/area it's trying to traverse is blocked and the robot
+    should take another route or action.
+    """
+
+
 class IncorrectUsage(Exception):
     """Error raised by calling a helper function incorrectly.
 
-    Raised when a call would block forever has otherwise been used in an incorrect manner.
+    Raised when a call would block forever or has otherwise been used in an incorrect manner.
     This exception is not intended to be caught, but indicates a programming error.
     """
 
 
 class HandlerError(Exception):
     """Error base class for errors raised from the internals of the AreaCallbackRegionHandlerBase.
 
@@ -93,15 +99,15 @@
     def end(self):
         """This function is called after run thread has finished and client calls EndCallback."""
         raise NotImplementedError("Derived class must implement this function.")
 
     @property
     def area_callback_information(self) -> area_callback_pb2.AreaCallbackInformation:
         """Get area_callback_pb2.AreaCallbackInformation."""
-        return self._config.area_callback_information()
+        return self._config.area_callback_information
 
     @property
     def config(self) -> AreaCallbackServiceConfig:
         """Get AreaCallbackServiceConfig"""
         return self._config
 
     # Policy functions, which change the policy that the callback is returning to the robot.
@@ -144,14 +150,30 @@
         with self._lock:
             self._update_response.policy.at_end = UpdateCallbackResponse.NavPolicy.OPTION_CONTROL
 
     def set_complete(self):
         with self._lock:
             self._update_response.complete.SetInParent()
 
+    def set_localization_at_end(self):
+        """Set the localization hint to the end of the callback region, indicating that graph nav 
+        that navigation should continue from this point.
+        Robot control is required to set this. It should be called after walking to the end of
+        the region, but before ceding control. 
+
+        Raises:
+            IncorrectUsage: When called without robot control.
+        """
+        if not self.has_control():
+            raise IncorrectUsage(
+                'set_localization_at_end should only be called with robot control.')
+        with self._lock:
+            self._update_response.localization.change = \
+                UpdateCallbackResponse.UpdateLocalization.LOCALIZATION_AT_END
+
     # Blocking functions to check for a particular event.
 
     def block_until_control(self):
         """Block waiting for the robot to pass the sublease to this callback.
 
         Raises:
             HandlerError: When a shutdown is requested before a lease is received.
@@ -301,14 +323,18 @@
         self._shutdown_event = shutdown_event
         _LOGGER.info('Beginning callback')
         try:
             self.run()
             with self._lock:
                 if not self._update_response.HasField("error"):
                     self._update_response.complete.SetInParent()
+        except PathBlocked:
+            _LOGGER.warning('run() reported the path is blocked.')
+            with self._lock:
+                self._update_response.error.error = UpdateCallbackResponse.Error.ERROR_BLOCKED
         except LeaseUseError as lease_use_error:
             _LOGGER.warning('Something else has taken control, aborting.')
             error = UpdateCallbackResponse.Error()
             error.error = UpdateCallbackResponse.Error.ERROR_LEASE
             if hasattr(lease_use_error.response, "lease_use_result"):
                 error.lease_use_results.add().CopyFrom(lease_use_error.response.lease_use_result)
             elif hasattr(lease_use_error.response, "lease_use_results"):
@@ -323,12 +349,12 @@
                 self._update_response.error.error = UpdateCallbackResponse.Error.ERROR_TIMED_OUT
         except CallbackEnded:
             # This was raised to cause run() to stop due to EndCallback. This is not an error.
             self.set_complete()
         except IncorrectUsage:
             raise
         # We want to keep running and just report an error regardless of what run() raises.
-        except Exception:  # pylint: disable=broad-except
-            _LOGGER.exception('Failed during run()')
+        except Exception as e:  # pylint: disable=broad-except
+            _LOGGER.exception('Failed during run(): %s', str(e))
             with self._lock:
                 self._update_response.error.error = UpdateCallbackResponse.Error.ERROR_CALLBACK_FAILED
         _LOGGER.info('Callback ended')
```

## bosdyn/client/area_callback_service_runner.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 # pylint: disable=missing-module-docstring
 from bosdyn.api.graph_nav import area_callback_service_pb2_grpc
```

## bosdyn/client/area_callback_service_servicer.py

```diff
@@ -1,21 +1,22 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 # pylint: disable=missing-module-docstring
 import copy
 import logging
 from threading import Event, Lock, Thread
 from typing import Callable
 
 from bosdyn.api import lease_pb2
 from bosdyn.api.graph_nav import area_callback_pb2, area_callback_service_pb2_grpc
+from bosdyn.client import service_customization_helpers
 from bosdyn.client.area_callback_region_handler_base import AreaCallbackRegionHandlerBase
 from bosdyn.client.area_callback_service_utils import AreaCallbackServiceConfig
 from bosdyn.client.data_buffer import DataBufferClient
 from bosdyn.client.lease import Lease, LeaseNotOwnedByWallet, NoSuchLease
 from bosdyn.client.lease_validator import LeaseValidator, LeaseValidatorResponseProcessor
 from bosdyn.client.robot import Robot
 from bosdyn.client.server_util import ResponseContext
@@ -43,14 +44,16 @@
         super().__init__()
         self.area_callback_service_config = config
         self.area_callback_builder_fn = area_callback_builder_fn
         self.area_callback_region_handler = None
         self.area_callback_active_thread = None
         self.area_callback_active_thread_event = None
         self.robot = robot
+        self.param_validator = service_customization_helpers.create_value_validator(
+            self.area_callback_service_config.area_callback_information.custom_params)
 
         self._lock = Lock()
         self._next_command_id = 1
         self._active_command_id = None
         self._rpc_logger = self.robot.ensure_client(DataBufferClient.default_service_name)
         self._lease_validator = LeaseValidator(self.robot)
         self._shutdown_timeout = 5
@@ -68,14 +71,19 @@
         """Begin the callback in a new region."""
         _LOGGER.info('Received BeginCallback')
         request_to_log = request
         if not self.area_callback_service_config.log_begin_callback_data:
             request_to_log = copy.deepcopy(request)
         response = area_callback_pb2.BeginCallbackResponse()
         with ResponseContext(response, request_to_log, self._rpc_logger), self._lock:
+            param_error = self.param_validator(request.custom_params)
+            if param_error:
+                response.status = area_callback_pb2.BeginCallbackResponse.STATUS_CUSTOM_PARAMS_ERROR
+                response.custom_param_error.CopyFrom(param_error)
+                return response
             if self._is_expired(request.end_time):
                 response.status = area_callback_pb2.BeginCallbackResponse.STATUS_EXPIRED_END_TIME
                 return response
             self._begin_callback_region_handler(request, response)
             if response.status == area_callback_pb2.BeginCallbackResponse.STATUS_OK:
                 self.area_callback_active_thread_event = Event()
                 self.area_callback_active_thread = Thread(
```

## bosdyn/client/area_callback_service_utils.py

```diff
@@ -1,40 +1,140 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
-from typing import List, Optional
-
-from google.protobuf.wrappers_pb2 import DoubleValue
+import logging
+import time
+from typing import List
 
+from bosdyn.api import service_fault_pb2
 from bosdyn.api.graph_nav import area_callback_pb2
-from bosdyn.util import seconds_to_duration
+from bosdyn.api.service_customization_pb2 import DictParam
+from bosdyn.client.directory import NonexistentServiceError
+from bosdyn.client.exceptions import RpcError
+from bosdyn.client.fault import (FaultResponseError, ServiceFaultAlreadyExistsError,
+                                 ServiceFaultDoesNotExistError)
+
+_LOGGER = logging.getLogger(__name__)
 
 
 class AreaCallbackServiceConfig:
     """Config data required to run a area callback service."""
 
     def __init__(self, service_name: str, required_lease_resources: List[str] = (),
-                 log_begin_callback_data: bool = False):
+                 log_begin_callback_data: bool = False,
+                 area_callback_information: area_callback_pb2.AreaCallbackInformation = None):
         """AreaCallbackServiceConfig constructor.
 
         Args:
             service_name (str): The name of the service, for registering with directory.
             required_lease_resources (List[str]): List of required lease resources.
             log_begin_callback_data (bool): Log the data field of the begin callback request.
+            area_callback_information (area_callback_pb2.AreaCallbackInformation): Information describing the area callback.
         """
         self.service_name = service_name
         self.required_lease_resources = required_lease_resources
 
         self.log_begin_callback_data = log_begin_callback_data
-
-    @property
-    def area_callback_information(self):
-        """area_callback_pb2.AreaCallbackInformation for a specific AreaCallback implementation.
-
-        Returns:
-            area_callback_pb2.AreaCallbackInformation
+        self.area_callback_information = area_callback_information or \
+                                         area_callback_pb2.AreaCallbackInformation(
+                                            required_lease_resources=self.required_lease_resources)
+
+    def parse_params(self, params: DictParam):
+        """ Parse params and validate they agree with the spec stored in area_callback_information.
+        
+        Args:
+            params (DictParam): The parameters being validated.
         """
-        return area_callback_pb2.AreaCallbackInformation(
-            required_lease_resources=self.required_lease_resources)
+
+        spec = self.area_callback_information.custom_params
+        values = {}
+        for (key, param) in params.values.items():
+            if key not in spec.specs:
+                raise ValueError(f"No spec provided for parameter {key}.")
+
+            param_spec = spec.specs[key].spec
+            spec_field = param_spec.WhichOneof("spec")
+            value_field = spec_field.replace("spec", "value")
+            if not param.HasField(value_field):
+                raise ValueError(f"Param {key} has a {spec_field}, but has no {value_field}.")
+
+            type_spec = getattr(param_spec, spec_field)
+            param_value = getattr(param, value_field)
+
+            # For numerical values, check bounds.
+            if hasattr(type_spec, "min_value") and \
+                type_spec.HasField("min_value") and \
+                param_value.value < type_spec.min_value.value:
+                raise ValueError(f"Value for {key} too low; minimum is {type_spec.min_value.value} " \
+                                f"but passed value of {param_value.value}")
+
+            if hasattr(type_spec, "max_value") and \
+                type_spec.HasField("max_value") and \
+                param_value.value > type_spec.max_value.value:
+                raise ValueError(f"Value for {key} too high; maximum is {type_spec.max_value.value} " \
+                                f"but passed value of {param_value.value}")
+
+            values[key] = param_value.value
+
+        return values
+
+
+# Helper to raise service faults when other services are unavailable.
+def handle_service_faults(fault_client, robot_state_client, directory_client, service_name,
+                          prereq_services):
+    service_fault = service_fault_pb2.ServiceFault()
+    service_fault.fault_id.fault_name = f'{service_name}'
+    service_fault.fault_id.service_name = service_name
+    service_fault.severity = service_fault_pb2.ServiceFault.SEVERITY_CRITICAL
+    check_period = 0.5  # seconds.
+
+    while True:
+        time.sleep(check_period)
+
+        # Don't fault the service if it doesn't actually exist.
+        try:
+            registered_service = directory_client.get_entry(service_name)
+        except NonexistentServiceError as exc:
+            continue
+
+        set_fault = False
+        unavailable_services = []
+        for service in prereq_services:
+            # Make sure the prereq service exists.
+            try:
+                registered_service = directory_client.get_entry(service)
+            except NonexistentServiceError as exc:
+                set_fault = True
+                unavailable_services.append(service)
+                continue
+
+            # Make sure the prereq service isn't faulted.
+            state = robot_state_client.get_robot_state()
+            for fault in state.service_fault_state.faults:
+                if fault.fault_id.service_name == service:
+                    set_fault = True
+                    unavailable_services.append(service)
+                    break
+
+        # Fault the service.
+        if set_fault:
+            service_fault.error_message = 'Faulted due to issues with ' + ','.join(
+                unavailable_services)
+            try:
+                fault_client.trigger_service_fault(service_fault)
+            except ServiceFaultAlreadyExistsError:
+                pass
+            except (RpcError, FaultResponseError) as exc:
+                _LOGGER.error(f"Failed to set {service_name} fault. {exc}")
+
+        # Otherwise, clear the fault if it exists.
+        else:
+            try:
+                fault_client.clear_service_fault(service_fault.fault_id)
+                set_fault = False
+            except ServiceFaultDoesNotExistError:
+                pass
+            except (RpcError, FaultResponseError) as exc:
+                _LOGGER.error(f"Failed to clear {service_name} fault. {exc}")
```

## bosdyn/client/arm_surface_contact.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 from bosdyn.api import arm_surface_contact_pb2, arm_surface_contact_service_pb2_grpc
 from bosdyn.client.common import BaseClient, common_header_errors
```

## bosdyn/client/async_tasks.py

```diff
@@ -1,19 +1,17 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Utilities for managing periodic tasks consisting of asynchronous GRPC calls."""
 import abc
 import time
 
-import six
-
 from .exceptions import ResponseError, RpcError
 
 
 class AsyncTasks(object):
     """Manages a set of tasks which work by periodically calling an update() method.
 
     Args:
@@ -33,16 +31,16 @@
 
     def update(self):
         """Call this periodically to manage execution of tasks owned by this object."""
         for task in self._tasks:
             task.update()
 
 
-@six.add_metaclass(abc.ABCMeta)  # pylint: disable=too-few-public-methods
-class AsyncGRPCTask(object):
+# pylint: disable=too-few-public-methods
+class AsyncGRPCTask(object, metaclass=abc.ABCMeta):
     """Task to be accomplished using asynchronous GRPC calls.
 
     When it is time to run the task, an async GRPC call is run resulting in a FutureWrapper object.
     The FutureWrapper is monitored for completion, and then an action is taken in response.
     """
 
     def __init__(self):
@@ -91,16 +89,15 @@
                 self._future = None
         elif self._should_query(now_sec):
             self._last_call = now_sec
             self._future = self._start_query()
 
 
 # pylint: disable=too-few-public-methods
-@six.add_metaclass(abc.ABCMeta)
-class AsyncPeriodicGRPCTask(AsyncGRPCTask):
+class AsyncPeriodicGRPCTask(AsyncGRPCTask, metaclass=abc.ABCMeta):
     """Periodic task to be accomplished using asynchronous GRPC calls.
 
     When it is time to run the task, an async GRPC call is run resulting in a FutureWrapper object.
     The FutureWrapper is monitored for completion, and then an action is taken in response.
 
     Args:
         periodic_sec: Time to wait in seconds between queries.
```

## bosdyn/client/auth.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to acquire a user token from the authentication service.
```

## bosdyn/client/auto_return.py

```diff
@@ -1,17 +1,15 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client implementation of the AutoReturn service."""
 
-from __future__ import print_function
-
 import collections
 
 from bosdyn.api.auto_return import auto_return_pb2, auto_return_service_pb2_grpc
 from bosdyn.client.common import (BaseClient, error_factory, error_pair,
                                   handle_common_header_errors, handle_unset_status_error)
 from bosdyn.client.exceptions import ResponseError
 
@@ -30,36 +28,37 @@
     default_service_name = 'auto-return'
     service_type = 'bosdyn.api.auto_return.AutoReturnService'
 
     def __init__(self):
         super(AutoReturnClient, self).__init__(auto_return_service_pb2_grpc.AutoReturnServiceStub)
         self._timesync_endpoint = None
 
-    def configure(self, params, leases, **kwargs):
+    def configure(self, params, leases, clear_buffer=False, **kwargs):
         """Set the configuration of the AutoReturn system.
 
         Args:
           params (bosdyn.api.auto_return.auto_return_pb2.Params): Parameters to use.
           leases (list of bosdyn.client.Lease)
+          clear_buffer (bool): Set True to forget any currently buffered locations.
 
         Raises:
-          AutoReturnResponseError: An invalid request was received by the service.
+          InvalidParameterError: An invalid request was received by the service.
           RpcError: Problem communicating with the service.
 
         Returns:
             The bosdyn.api.auto_return_pb2.ConfigureResponse.
         """
 
-        request = self._configure_request(params, leases)
+        request = self._configure_request(params, leases, clear_buffer)
         return self.call(self._stub.Configure, request, None, configure_error, copy_request=False,
                          **kwargs)
 
-    def configure_async(self, params, leases, **kwargs):
+    def configure_async(self, params, leases, clear_buffer=False, **kwargs):
         """Async version of the configure() RPC."""
-        request = self._configure_request(params, leases)
+        request = self._configure_request(params, leases, clear_buffer)
         return self.call(self._stub.Configure, request, None, configure_error, copy_request=False,
                          **kwargs)
 
     def get_configuration(self, **kwargs):
         """Get the configuration of the AutoReturn system.
 
         Raises:
@@ -74,32 +73,42 @@
 
     def get_configuration_async(self, **kwargs):
         """Async version of the get_configuration() RPC."""
         request = auto_return_pb2.GetConfigurationRequest()
         return self.call_async(self._stub.GetConfiguration, request, None, None, copy_request=False,
                                **kwargs)
 
-    def start(self, **kwargs):
+    def start(self, params=None, leases=[], **kwargs):
         """Start AutoReturn now.
         Raises:
+          InvalidParameterError: An invalid request was received by the service.
           RpcError: Problem communicating with the service.
 
         Returns:
-            The bosdyn.api.auto_return_pb2.GetConfigurationResponse.
+            The bosdyn.api.auto_return_pb2.StartResponse.
         """
-        request = auto_return_pb2.StartRequest()
-        return self.call(self._stub.Start, request, None, None, copy_request=False, **kwargs)
+        request = self._start_request(params, leases)
+        return self.call(self._stub.Start, request, None, start_error, copy_request=False, **kwargs)
 
-    def start_async(self, **kwargs):
+    def start_async(self, params=None, leases=[], **kwargs):
         """Async version of the start() RPC."""
-        request = auto_return_pb2.StartRequest()
-        return self.call_async(self._stub.Start, request, None, None, copy_request=False, **kwargs)
+        request = self._start_request(params, leases)
+        return self.call_async(self._stub.Start, request, None, start_error, copy_request=False,
+                               **kwargs)
+
+    @staticmethod
+    def _configure_request(params, leases, clear_buffer):
+        request = auto_return_pb2.ConfigureRequest(params=params, clear_buffer=clear_buffer)
+        for lease in leases:
+            request.leases.add().CopyFrom(lease.lease_proto)
+        return request
 
-    def _configure_request(self, params, leases):
-        request = auto_return_pb2.ConfigureRequest(params=params)
+    @staticmethod
+    def _start_request(params, leases):
+        request = auto_return_pb2.StartRequest(params=params)
         for lease in leases:
             request.leases.add().CopyFrom(lease.lease_proto)
         return request
 
 
 _CONFIGURE_STATUS_TO_ERROR = collections.defaultdict(lambda: (None, None))
 _CONFIGURE_STATUS_TO_ERROR.update(
@@ -109,7 +118,20 @@
 @handle_common_header_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def configure_error(response):
     """Return a custom exception based on the Configure response, None if no error."""
     return error_factory(response, response.status,
                          status_to_string=auto_return_pb2.ConfigureResponse.Status.Name,
                          status_to_error=_CONFIGURE_STATUS_TO_ERROR)
+
+
+_START_STATUS_TO_ERROR = collections.defaultdict(lambda: (None, None))
+_START_STATUS_TO_ERROR.update(
+    {auto_return_pb2.StartResponse.STATUS_INVALID_PARAMS: error_pair(InvalidParameterError)})
+
+
+@handle_common_header_errors
+def start_error(response):
+    """Return a custom exception based on the Start response, None if no error."""
+    return error_factory(response, response.status,
+                         status_to_string=auto_return_pb2.StartResponse.Status.Name,
+                         status_to_error=_START_STATUS_TO_ERROR)
```

## bosdyn/client/autowalk.py

```diff
@@ -1,77 +1,95 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Autowalk service."""
 
 import collections
 
-from bosdyn.api.autowalk import autowalk_pb2, autowalk_service_pb2_grpc, walks_pb2
-from bosdyn.client.common import (BaseClient, common_header_errors, error_factory,
-                                  handle_common_header_errors, handle_lease_use_result_errors,
-                                  handle_unset_status_error)
-from bosdyn.client.exceptions import ResponseError, TimeSyncRequired
+from bosdyn.api.autowalk import autowalk_pb2, autowalk_service_pb2_grpc
+from bosdyn.client import data_chunk
+from bosdyn.client.common import BaseClient, error_factory, error_pair
+from bosdyn.client.exceptions import ResponseError
 from bosdyn.client.lease import add_lease_wallet_processors
 
+from .data_chunk import chunk_message
+
 
 class AutowalkResponseError(ResponseError):
     """General class of errors for autowalk service."""
 
 
 class CompilationError(AutowalkResponseError):
-    """Walk could not be compiled."""
+    """Provided Walk could not be compiled because the Walk was malformed.
+    """
 
 
 class ValidationError(AutowalkResponseError):
-    """Walk could not be validated."""
+    """Provided Walk could not be validated because some part of the Walk was unable to initialize.
+    """
 
 
 class AutowalkClient(BaseClient):
     """Client for the Autowalk service."""
     default_service_name = 'autowalk-service'
     service_type = 'bosdyn.api.autowalk.AutowalkService'
 
     def __init__(self):
         super(AutowalkClient, self).__init__(autowalk_service_pb2_grpc.AutowalkServiceStub)
 
     def update_from(self, other):
         """Update instance from another object.
-
         Args:
             other: The object where to copy from.
         """
         super(AutowalkClient, self).update_from(other)
         if self.lease_wallet:
             add_lease_wallet_processors(self, self.lease_wallet)
 
     def compile_autowalk(self, walk, data_chunk_byte_size=1000 * 1000, **kwargs):
-        """
-        Send the input walk file to the autowalk service for compilation.
+        """Send the input walk file to the autowalk service for compilation.
+        Args:
+            walk: a walks_pb2.Walk input to be compiled by the autowalk service
+            data_chunk_byte_size: max size of each streamed message
+        Raises:
+            RpcError: Problem communicating with the robot.
+            bosdyn.client.autowalk.CompilationError: The walk failed to compile because it was malformed.
+            bosdyn.client.autowalk.ValidationError: The walk failed to validate because some part of it was unable to initialize.
         """
         request = self._compile_autowalk_request(walk)
         self._apply_request_processors(request, copy_request=False)
         return self.call(self._stub.CompileAutowalk,
-                         BaseClient.chunk_message(request, data_chunk_byte_size),
-                         _get_compile_autowalk_response_from_chunks,
-                         _compile_autowalk_error_from_response, copy_request=False, **kwargs)
+                         data_chunk.chunk_message(request, data_chunk_byte_size),
+                         error_from_response=_compile_autowalk_error_from_response,
+                         assemble_type=autowalk_pb2.CompileAutowalkResponse, copy_request=False,
+                         **kwargs)
 
     def load_autowalk(self, walk, leases=[], data_chunk_byte_size=1000 * 1000, **kwargs):
-        """
-        Send the input walk file to the autowalk service for compilation and
+        """Send the input walk file to the autowalk service for compilation and
         load resulting mission to the Mission Service on the robot.
+        Args:
+            walk: a walks_pb2.Walk input to be loaded onto the robot by the autowalk service
+            leases: Leases the autowalk service will need to use. Unlike other clients, these MUST
+              be specified.
+            data_chunk_byte_size: max size of each streamed message
+        Raises:
+            RpcError: Problem communicating with the robot.
+            bosdyn.client.autowalk.CompilationError: The walk failed to compile because it was malformed.
+            bosdyn.client.autowalk.ValidationError: The walk failed to validate because some part of it was unable to initialize.
         """
         request = self._load_autowalk_request(walk, leases)
         self._apply_request_processors(request, copy_request=False)
         return self.call(self._stub.LoadAutowalk,
-                         BaseClient.chunk_message(request, data_chunk_byte_size),
-                         _get_load_autowalk_response_from_chunks,
-                         _load_autowalk_error_from_response, copy_request=False, **kwargs)
+                         data_chunk.chunk_message(request, data_chunk_byte_size),
+                         error_from_response=_load_autowalk_error_from_response,
+                         assemble_type=autowalk_pb2.LoadAutowalkResponse, copy_request=False,
+                         **kwargs)
 
     @staticmethod
     def _compile_autowalk_request(walk):
         request = autowalk_pb2.CompileAutowalkRequest(walk=walk)
         return request
 
     @staticmethod
@@ -81,63 +99,29 @@
             request.leases.add().CopyFrom(lease.lease_proto)
         return request
 
 
 _COMPILE_AUTOWALK_STATUS_TO_ERROR = collections.defaultdict(lambda: (AutowalkResponseError, None))
 _COMPILE_AUTOWALK_STATUS_TO_ERROR.update({
     autowalk_pb2.CompileAutowalkResponse.STATUS_OK: (None, None),
-    autowalk_pb2.CompileAutowalkResponse.STATUS_COMPILE_ERROR: (CompilationError, None),
+    autowalk_pb2.CompileAutowalkResponse.STATUS_COMPILE_ERROR: error_pair(CompilationError),
 })
 
 
 def _compile_autowalk_error_from_response(response):
-    response = _get_compile_autowalk_response_from_chunks(response)
     return error_factory(response, response.status,
                          status_to_string=autowalk_pb2.CompileAutowalkResponse.Status.Name,
                          status_to_error=_COMPILE_AUTOWALK_STATUS_TO_ERROR)
 
 
 _LOAD_AUTOWALK_STATUS_TO_ERROR = collections.defaultdict(lambda: (AutowalkResponseError, None))
 _LOAD_AUTOWALK_STATUS_TO_ERROR.update({
     autowalk_pb2.LoadAutowalkResponse.STATUS_OK: (None, None),
-    autowalk_pb2.LoadAutowalkResponse.STATUS_COMPILE_ERROR: (CompilationError, None),
-    autowalk_pb2.LoadAutowalkResponse.STATUS_VALIDATE_ERROR: (ValidationError, None),
+    autowalk_pb2.LoadAutowalkResponse.STATUS_COMPILE_ERROR: error_pair(CompilationError),
+    autowalk_pb2.LoadAutowalkResponse.STATUS_VALIDATE_ERROR: error_pair(ValidationError),
 })
 
 
 def _load_autowalk_error_from_response(response):
-    response = _get_load_autowalk_response_from_chunks(response)
     return error_factory(response, response.status,
                          status_to_string=autowalk_pb2.LoadAutowalkResponse.Status.Name,
                          status_to_error=_LOAD_AUTOWALK_STATUS_TO_ERROR)
-
-
-def _get_load_autowalk_response_from_chunks(response):
-    """Reads a streamed response to recreate load autowalk response."""
-    data = ''
-    num_chunks = 0
-    for resp in response:
-        if num_chunks == 0:
-            data = resp.data
-        else:
-            data += resp.data
-        num_chunks += 1
-    load_autowalk_response = autowalk_pb2.LoadAutowalkResponse()
-    if (num_chunks > 0):
-        load_autowalk_response.ParseFromString(data)
-    return load_autowalk_response
-
-
-def _get_compile_autowalk_response_from_chunks(response):
-    """Reads a streamed response to recreate compile autowalk response."""
-    data = ''
-    num_chunks = 0
-    for resp in response:
-        if num_chunks == 0:
-            data = resp.data
-        else:
-            data += resp.data
-        num_chunks += 1
-    compile_autowalk_response = autowalk_pb2.CompileAutowalkResponse()
-    if (num_chunks > 0):
-        compile_autowalk_response.ParseFromString(data)
-    return compile_autowalk_response
```

## bosdyn/client/bddf.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Use bosdyn.bddf instead."""
```

## bosdyn/client/bddf_download.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Code for downloading robot data in bddf format."""
 import logging
```

## bosdyn/client/channel.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 import logging
 import warnings
```

## bosdyn/client/command_line.py

```diff
@@ -1,33 +1,33 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Command-line utility code for interacting with robot services."""
 
-from __future__ import division, print_function
+from __future__ import division
 
 import abc
 import argparse
 import datetime
 import os
 import signal
 import sys
 import threading
 import time
 
-import six
 from google.protobuf import json_format
 
 import bosdyn.client
 from bosdyn.api import data_acquisition_pb2, image_pb2
 from bosdyn.api.data_buffer_pb2 import Event, TextMessage
 from bosdyn.api.data_index_pb2 import EventsCommentsSpec
+from bosdyn.api.robot_state_pb2 import BehaviorFault
 from bosdyn.util import duration_str, timestamp_to_datetime
 
 from .auth import InvalidLoginError, InvalidTokenError
 from .data_acquisition import DataAcquisitionClient
 from .data_acquisition_helpers import acquire_and_process_request
 from .data_buffer import DataBufferClient
 from .data_service import DataServiceClient
@@ -36,27 +36,28 @@
 from .estop import EstopClient, EstopEndpoint, EstopKeepAlive
 from .exceptions import Error, InvalidAppTokenError, InvalidRequestError, ProxyConnectionError
 from .image import (ImageClient, ImageResponseError, UnknownImageSourceError, build_image_request,
                     save_images_as_files)
 from .lease import LeaseClient
 from .license import LicenseClient
 from .local_grid import LocalGridClient
+from .log_status import InactiveLogError, LogStatusClient
 from .payload import PayloadClient
 from .payload_registration import PayloadAlreadyExistsError, PayloadRegistrationClient
 from .power import (PowerClient, power_cycle_robot, power_off_payload_ports, power_off_robot,
                     power_off_wifi_radio, power_on_payload_ports, power_on_wifi_radio)
 from .robot_id import RobotIdClient
 from .robot_state import RobotStateClient
 from .time_sync import TimeSyncClient, TimeSyncEndpoint, TimeSyncError, timespec_to_robot_timespan
 from .util import add_common_arguments, authenticate, setup_logging
 
 
 
 # pylint: disable=too-few-public-methods
-class Command(object, six.with_metaclass(abc.ABCMeta)):
+class Command(object, metaclass=abc.ABCMeta):
     """Command-line command.
 
     Args:
         subparsers: List of argument parsers.
         command_dict: Dictionary of command names which take parsed options.
     """
 
@@ -77,15 +78,16 @@
         Args:
             robot: Robot object on which to run the command.
             options: Parsed command-line arguments.
         """
 
         try:
             if self.NEED_AUTHENTICATION:
-                if options.username or options.password:
+                if hasattr(options, 'username') and hasattr(
+                        options, 'password') and (options.username or options.password):
                     robot.authenticate(options.username, options.password)
                 else:
                     authenticate(robot)
                 robot.sync_with_directory()  # Make sure that we can use all registered services.
             return self._run(robot, options)
         except ProxyConnectionError:
             print('Could not contact robot with hostname "{}".'.format(options.hostname),
@@ -570,47 +572,71 @@
             subparsers: List of argument parsers.
             command_dict: Dictionary of command names which take parsed options.
         """
         super(FaultCommands, self).__init__(subparsers, command_dict,
                                             [FaultShowCommand, FaultWatchCommand])
 
 
-def _show_service_faults(robot):
-    """Print service faults for the robot.
+def _show_all_faults(robot):
+    """Print faults for the robot.
 
     Args:
         robot: Robot object used to get the list of services.
     """
-
     robot_state_client = robot.ensure_client(RobotStateClient.default_service_name)
-    service_fault_state = robot_state_client.get_robot_state().service_fault_state
+    robot_state = robot_state_client.get_robot_state()
+    system_fault_state = robot_state.system_fault_state
+    behavior_fault_state = robot_state.behavior_fault_state
+    service_fault_state = robot_state.service_fault_state
+
+    print('\n' + '-' * 80)
+    if len(system_fault_state.faults) == 0:
+        print("No active system faults.")
+    else:
+        for fault in system_fault_state.faults:
+            print('''
+{fault.name}
+    Error Message: {fault.error_message}
+    Onset Time: {timestamp}''' \
+              .format(fault=fault, timestamp=timestamp_to_datetime(fault.onset_timestamp)))
 
-    print("\n\n\n" + "-" * 80)
+    print()
+    if len(behavior_fault_state.faults) == 0:
+        print("No active behavior faults.")
+    else:
+        for fault in behavior_fault_state.faults:
+            print('''
+{cause}
+    Onset Time: {timestamp}
+    Clearable: {clearable}''' \
+                  .format(cause=BehaviorFault.Cause.Name(fault.cause),
+                          timestamp=timestamp_to_datetime(fault.onset_timestamp),
+                          clearable=BehaviorFault.Status.Name(fault.status)))
+
+    print()
     if len(service_fault_state.faults) == 0:
         print("No active service faults.")
-        return
-
-    for fault in service_fault_state.faults:
-        print('''
+    else:
+        for fault in service_fault_state.faults:
+            print('''
 {fault.fault_id.fault_name}
     Service Name: {fault.fault_id.service_name}
     Payload GUID: {fault.fault_id.payload_guid}
     Error Message: {fault.error_message}
     Onset Time: {timestamp}'''\
     .format(fault=fault, timestamp=timestamp_to_datetime(fault.onset_timestamp)))
-    return
 
 
 class FaultShowCommand(Command):
-    """Show all service faults currently active in robot state."""
+    """Show all faults currently active in robot state."""
 
     NAME = 'show'
 
     def __init__(self, subparsers, command_dict):
-        """Show all service faults currently active in robot state.
+        """Show all faults currently active in robot state.
 
         Args:
             subparsers: List of argument parsers.
             command_dict: Dictionary of command names which take parsed options.
         """
         super(FaultShowCommand, self).__init__(subparsers, command_dict)
 
@@ -620,20 +646,20 @@
         Args:
             robot: Robot object on which to run the command.
             options: Parsed command-line arguments.
 
         Returns:
             True
         """
-        _show_service_faults(robot)
+        _show_all_faults(robot)
         return True
 
 
 class FaultWatchCommand(Command):
-    """Watch all service faults in robot state and print them out."""
+    """Watch all faults in robot state and print them out."""
 
     NAME = 'watch'
 
     def __init__(self, subparsers, command_dict):
         """Watch all service faults in robot state and print them out.
 
         Args:
@@ -649,18 +675,267 @@
             robot: Robot object on which to run the command.
             options: Parsed command-line arguments.
 
         Returns:
             True
         """
         print('Press Ctrl-C or send SIGINT to exit\n\n')
-        while True:
-            _show_service_faults(robot)
-            time.sleep(1)
+        try:
+            while True:
+                _show_all_faults(robot)
+                time.sleep(1)
+        except KeyboardInterrupt:
+            pass
+
+        return True
+
+
+class LogStatusCommands(Subcommands):
+    """Interact with start, update and terminate experiment logs, start and update retro logs and check status of active logs for robot."""
+
+    NAME = 'log-status'
+    NEED_AUTHENTICATION = True
+
+    def __init__(self, subparsers, command_dict):
+        """Interact with logs for robot
+
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(LogStatusCommands, self).__init__(subparsers, command_dict, [
+            GetLogCommand,
+            GetActiveLogStatusesCommand,
+            ExperimentLogCommand,
+            StartRetroLogCommand,
+            TerminateLogCommand,
+        ])
+
+
+class GetLogCommand(Command):
+    """Get log status but log id."""
+
+    NAME = 'get'
+
+    def __init__(self, subparsers, command_dict):
+        """Get log status from robot
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(GetLogCommand, self).__init__(subparsers, command_dict)
+        self._parser.add_argument('id', help='id of log bundle to display')
+
+    def _run(self, robot, options):
+        """Implementation of the command.
+        Args:
+            robot: Robot object on which to run the command.
+            options: Parsed command-line arguments.
+        Returns:
+            True
+        """
+
+        client = robot.ensure_client(LogStatusClient.default_service_name)
+        response = client.get_log_status(options.id)
+        print(response.log_status)
+        return True
+
+
+class GetActiveLogStatusesCommand(Command):
+    """Get active log bundles for robot."""
+
+    NAME = 'active'
+
+    def __init__(self, subparsers, command_dict):
+        """Retrieve active log statuses for robot.
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(GetActiveLogStatusesCommand, self).__init__(subparsers, command_dict)
+
+    def _run(self, robot, options):
+        """Implementation of the command.
+        Args:
+            robot: Robot object on which to run the command.
+            options: Parsed command-line arguments.
+        Returns:
+            True
+        """
+        client = robot.ensure_client(LogStatusClient.default_service_name)
+        response = client.get_active_log_statuses()
+        print(response.log_statuses)
+        return True
+
+
+class ExperimentLogCommand(Subcommands):
+    """Give experiment log commands to robot."""
+
+    NAME = 'experiment'
+
+    def __init__(self, subparsers, command_dict):
+        """List log bundles with status for robot.
+
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(ExperimentLogCommand, self).__init__(subparsers, command_dict, [
+            StartTimedExperimentLogCommand,
+            StartContinuousExperimentLogCommand,
+        ])
+
+
+class StartTimedExperimentLogCommand(Command):
+    """Start a timed experiment log."""
+
+    NAME = 'timed'
+
+    def __init__(self, subparsers, command_dict):
+        """Start timed experiment log
+
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(StartTimedExperimentLogCommand, self).__init__(subparsers, command_dict)
+        self._parser.add_argument('seconds', type=float, help='how long should the experiment run?')
+
+    def _run(self, robot, options):
+        """Implementation of the command.
+
+        Args:
+            robot: Robot object on which to run the command.
+            options: Parsed command-line arguments.
+
+        Returns:
+            True
+        """
+
+        client = robot.ensure_client(LogStatusClient.default_service_name)
+        response = client.start_experiment_log(options.seconds)
+        print(response.log_status)
+        return True
+
+
+class StartContinuousExperimentLogCommand(Command):
+    """Start a continuous experiment log."""
+
+    NAME = 'continuous'
+
+    def __init__(self, subparsers, command_dict):
+        """Start continuous experiment log, defaulted to update keep alive time by 10 seconds every 5 seconds.
+
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(StartContinuousExperimentLogCommand, self).__init__(subparsers, command_dict)
+        self._parser.add_argument('-sleep', type=float, default=5,
+                                  help='how long should thread sleep before extending')
+
+    @staticmethod
+    def handle_keyboard_interruption(client, log_id):
+        try:
+            print(" Received keyboard interruption\n\n")
+            response = client.terminate_log(log_id)
+            print(response.log_status)
+        except KeyboardInterrupt:
+            client.terminate_log_async(log_id)
+            print("Log will terminate shortly")
+            response = client.get_log_status(log_id)
+            print(response.log_status)
+
+    def _run(self, robot, options):
+        """Implementation of the command.
+
+        Args:
+            robot: Robot object on which to run the command.
+            options: Parsed command-line arguments.
+
+        Returns:
+            True
+        """
+
+        client = robot.ensure_client(LogStatusClient.default_service_name)
+        response = client.start_experiment_log(options.sleep * 2)
+        log_id = response.log_status.id
+        print("Experiment log id: ", log_id)
+        print('Use terminate command, press Ctrl-C or send SIGINT to complete log\n\n')
+
+        try:
+            while True:
+                time.sleep(options.sleep)
+                client.update_experiment(log_id, options.sleep * 2)
+        except InactiveLogError:
+            response = client.get_log_status(log_id)
+            print(response.log_status)
+        except KeyboardInterrupt:
+            self.handle_keyboard_interruption(client, log_id)
+        return True
+
+
+class StartRetroLogCommand(Command):
+    """Start a retro log."""
+
+    NAME = 'retro'
+
+    def __init__(self, subparsers, command_dict):
+        """Start a retroactive log
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(StartRetroLogCommand, self).__init__(subparsers, command_dict)
+        self._parser.add_argument('seconds', type=float, help='how long should the retro log run?')
+
+    def _run(self, robot, options):
+        """Implementation of the command.
+        Args:
+            robot: Robot object on which to run the command.
+            options: Parsed command-line arguments.
+        Returns:
+            True
+        """
+
+        client = robot.ensure_client(LogStatusClient.default_service_name)
+        response = client.start_retro_log(options.seconds)
+        print(response.log_status)
+        return True
+
+
+class TerminateLogCommand(Command):
+    """Terminate log gathering process."""
+
+    NAME = 'terminate'
+
+    def __init__(self, subparsers, command_dict):
+        """Terminate log on robot
+
+        Args:
+            subparsers: List of argument parsers.
+            command_dict: Dictionary of command names which take parsed options.
+        """
+        super(TerminateLogCommand, self).__init__(subparsers, command_dict)
+        self._parser.add_argument('id', help='id of log to terminate')
+
+    def _run(self, robot, options):
+        """Implementation of the command.
+
+        Args:
+            robot: Robot object on which to run the command.
+            options: Parsed command-line arguments.
+
+        Returns:
+            True
+        """
 
+        client = robot.ensure_client(LogStatusClient.default_service_name)
+        response = client.terminate_log(options.id)
+        print(response.log_status)
         return True
 
 
 class RobotIdCommand(Command):
     """Show robot-id."""
 
     NAME = 'id'
@@ -1861,16 +2136,16 @@
         print("-" * (self._data_type_width + self._data_name_width + self._service_name_width))
         for data_name in capabilities.data_sources:
             self._format_and_print_capability("data", data_name.name, data_name.service_name)
         for img_service in capabilities.image_sources:
             for img in img_service.image_source_names:
                 self._format_and_print_capability("image", img, img_service.service_name)
         for ncb_worker in capabilities.network_compute_sources:
-            for model in ncb_worker.available_models:
-                self._format_and_print_capability("models", model,
+            for model in ncb_worker.models.data:
+                self._format_and_print_capability("models", model.model_name,
                                                   ncb_worker.server_config.service_name)
         return True
 
 
 class DataAcquisitionStatusCommand(Command):
     """Get status of an acquisition request based on the request id."""
 
@@ -2069,14 +2344,15 @@
 
     # Register commands that can be run.
     DirectoryCommands(subparsers, command_dict)
     PayloadCommands(subparsers, command_dict)
     FaultCommands(subparsers, command_dict)
     RobotIdCommand(subparsers, command_dict)
     LicenseCommand(subparsers, command_dict)
+    LogStatusCommands(subparsers, command_dict)
     RobotStateCommands(subparsers, command_dict)
     DataBufferCommands(subparsers, command_dict)
     DataServiceCommands(subparsers, command_dict)
     TimeSyncCommand(subparsers, command_dict)
     LeaseCommands(subparsers, command_dict)
     BecomeEstopCommand(subparsers, command_dict)
     ImageCommands(subparsers, command_dict)
```

## bosdyn/client/common.py

```diff
@@ -1,44 +1,49 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Contains elements common to all service clients."""
 import copy
 import functools
 import logging
 import math
 import socket
 import types
 
 import grpc
-import six
+from deprecated.sphinx import deprecated
+
+from bosdyn.api.header_pb2 import CommonError
 
 from .channel import TransportError, translate_exception
-from .exceptions import (Error, InternalServerError, InvalidRequestError, LeaseUseError,
-                         LicenseError, UnsetStatusError)
+from .data_chunk import chunk_message, parse_from_chunks
+from .exceptions import (CustomParamError, Error, InternalServerError, InvalidRequestError,
+                         LeaseUseError, LicenseError, ResponseError, UnsetStatusError)
 
 _LOGGER = logging.getLogger(__name__)
 
 from bosdyn.api import data_chunk_pb2, license_pb2
 
 DEFAULT_RPC_TIMEOUT = 30  # seconds
 
 
 def common_header_errors(response):
     """Return an exception based on common response header. None if no error."""
-    if response.header.error.code == response.header.error.CODE_UNSPECIFIED:
+    if response.header.error.code == CommonError.CODE_OK:
+        return None
+    if response.header.error.code == CommonError.CODE_UNSPECIFIED:
         return UnsetStatusError(response)
-    if response.header.error.code == response.header.error.CODE_INTERNAL_SERVER_ERROR:
+    if response.header.error.code == CommonError.CODE_INTERNAL_SERVER_ERROR:
         return InternalServerError(response)
-    if response.header.error.code == response.header.error.CODE_INVALID_REQUEST:
+    if response.header.error.code == CommonError.CODE_INVALID_REQUEST:
         return InvalidRequestError(response)
-    return None
+    return ResponseError(response)
 
 
 def streaming_common_header_errors(response_iterator):
     """Return an exception based on common response header for a streaming
        response iterator. None if no error."""
     for response in response_iterator:
         error = common_header_errors(response)
@@ -61,29 +66,40 @@
         lease_use_results = response.lease_use_results
     else:
         # This means you're using the wrong error handler.
         return InternalServerError(response, 'No LeaseUseResult field found!')
 
     for result in lease_use_results:
         if result.status != result.STATUS_OK:
-            return LeaseUseError(response)
+            return LeaseUseError(response, result)
     return None
 
 
 def streaming_common_lease_errors(response_iterator):
     """Return an exception based on lease use result for a streaming
        response iterator. None if no error."""
     for response in response_iterator:
         error = common_lease_errors(response)
         if error is not None:
             return error
     # No lease use error found.
     return None
 
 
+def custom_params_error(response, status_value=None, status_field_name='status',
+                        error_field_name='custom_param_error', total_response=None):
+    """Return an exception based on having a custom parameter status and message.
+    None if no error."""
+    if status_value is None:
+        status_value = response.STATUS_CUSTOM_PARAMS_ERROR
+    if getattr(response, status_field_name) == status_value:
+        return CustomParamError(total_response or response, getattr(response, error_field_name))
+    return None
+
+
 def error_pair(error_message):
     """Creates a pair of an error class and the associated docstring as the error message
        which can be used by the error_factory.
 
     Args:
         error_message: A class that inherits from the python Error class.
 
@@ -189,14 +205,36 @@
             return streaming_common_lease_errors(*args) or func(*args, **kwargs)
         else:
             return common_lease_errors(*args) or func(*args, **kwargs)
 
     return wrapper
 
 
+def handle_custom_params_errors(*args, status_value=None, status_field_name='status',
+                                error_field_name='custom_param_error'):
+    """Decorate "error from response" functions to handle custom param errors."""
+
+    def decorator(func):
+
+        @functools.wraps(func)
+        def wrapper(*args, **kwargs):
+            # pylint: disable=no-value-for-parameter
+            return custom_params_error(*args, status_value=status_value,
+                                       status_field_name=status_field_name,
+                                       error_field_name=error_field_name) or func(*args, **kwargs)
+
+        return wrapper
+
+    if len(args) == 1 and callable(args[0]):
+        # No arguments, this is the decorator
+        return decorator(args[0])
+
+    return decorator
+
+
 def maybe_raise(exc):
     """raise the provided exception if it is not None"""
     if exc is not None:
         raise exc
 
 
 def print_response(func):
@@ -259,18 +297,22 @@
         self.logger = logging.getLogger(self._name or 'bosdyn.{}'.format(self._service_type_short))
         self.request_processors = []
         self.response_processors = []
         self.lease_wallet = None
         self.client_name = None
 
     @staticmethod
+    @deprecated(reason='Forces serialization even if the logging is not happening.  Do not use.',
+                version='3.3.0')
     def request_trim_for_log(req):
         return '\n{}\n'.format(req)
 
     @staticmethod
+    @deprecated(reason='Forces serialization even if the logging is not happening.  Do not use.',
+                version='3.3.0')
     def response_trim_for_log(resp):
         return '\n{}\n'.format(resp)
 
     @property
     def channel(self):
         if self._channel is None:
             raise Error('Client channel is unset!')
@@ -290,79 +332,90 @@
         self.client_name = other.client_name
 
     def update_request_iterator(self, request_iterator, logger, rpc_method, is_blocking,
                                 copy_request=True):
         for request in request_iterator:
             request = self._apply_request_processors(request, copy_request=copy_request)
             if is_blocking:
-                logger.debug('blocking request: %s %s', rpc_method._method,
-                             self.request_trim_for_log(request))
+                logger.debug('blocking request: %s\n%s', rpc_method._method, request)
             else:
-                logger.debug('async request: %s %s', rpc_method._method,
-                             self.request_trim_for_log(request))
+                logger.debug('async request: %s\n%s', rpc_method._method, request)
             yield request
 
     def update_response_iterator(self, response_iterator, logger, rpc_method, is_blocking):
         try:
             for response in response_iterator:
                 response = self._apply_response_processors(copy.deepcopy(response))
                 if is_blocking:
-                    logger.debug('blocking response: %s %s', rpc_method._method,
-                                 self.request_trim_for_log(response))
+                    logger.debug('blocking response: %s\n%s', rpc_method._method, response)
                 else:
-                    logger.debug('async response: %s %s', rpc_method._method,
-                                 self.request_trim_for_log(response))
+                    logger.debug('async response: %s\n%s', rpc_method._method, response)
                 yield response
         except TransportError as e:
             # Iterating through the response_iterator is the point that transport exceptions will
             # be thrown for streaming rpcs if any are going to occur.
             # Here we make sure that they're translated to our more meaningful exceptions.
             # Any ResponseErrors or other exception types can be let through untranslated.
             # Use the "raise from None" pattern to reset the exception's context, which produces
             # confusing stack traces.
-            six.raise_from(translate_exception(e), None)
+            raise translate_exception(e) from None
 
     @process_kwargs
     def call(self, rpc_method, request, value_from_response=None, error_from_response=None,
-             copy_request=True, **kwargs):
+             assemble_type=None, copy_request=True, **kwargs):
         """Returns result of calling rpc_method(request, kwargs) after running processors.
 
         value_from_response and error_from_response should not raise their own exceptions!
         Additionally, value_from_response and error_from_response that are not common handlers
         must accept streaming responses if it is a grpc streaming response.
         """
         logger = self._get_logger(rpc_method)
         if isinstance(rpc_method, grpc.StreamUnaryMultiCallable) or isinstance(
                 rpc_method, grpc.StreamStreamMultiCallable):
             # The incoming request is a streaming request.
             request = self.update_request_iterator(request, logger, rpc_method, is_blocking=True,
                                                    copy_request=copy_request)
         else:
             request = self._apply_request_processors(request, copy_request=copy_request)
-            logger.debug('blocking request: %s %s', rpc_method._method,
-                         self.request_trim_for_log(request))
+            logger.debug('blocking request: %s\n%s', rpc_method._method, request)
 
         try:
             timeout = kwargs.pop('timeout', DEFAULT_RPC_TIMEOUT)
             response = rpc_method(request, timeout=timeout, **kwargs)
         except TransportError as e:
             # Use the "raise from None" pattern to reset the exception's context, which produces
             # confusing stack traces.
-            six.raise_from(translate_exception(e), None)
+            raise translate_exception(e) from None
 
         if isinstance(rpc_method, grpc.UnaryStreamMultiCallable) or isinstance(
                 rpc_method, grpc.StreamStreamMultiCallable):
             # The outgoing response is a streaming response.
-            response = self.update_response_iterator(response, logger, rpc_method, is_blocking=True)
-            return self.handle_response_streaming(list(response), error_from_response,
-                                                  value_from_response)
+            if assemble_type is not None:
+                # Assemble the data chunks into a message before passing to non-streaming handlers.
+                msg = assemble_type()
+
+                # For server streaming response RPCs, transport errors are not raised during the rpc call.
+                # We cannot explicitly check for them until the RPC deadline has been exceeded.
+                # To make due, we attempt to parse the response and catch transport errors raised while iterating through the responses.
+                try:
+                    parse_from_chunks(response, msg)
+                except TransportError as e:
+                    raise translate_exception(e) from None
+
+                msg = self._apply_response_processors(msg)
+                logger.debug('response: %s\n%s', rpc_method._method, msg)
+                return self.handle_response(msg, error_from_response, value_from_response)
+            else:
+                responses = self.update_response_iterator(response, logger, rpc_method,
+                                                          is_blocking=True)
+                return self.handle_response_streaming(list(responses), error_from_response,
+                                                      value_from_response)
         else:
             response = self._apply_response_processors(response)
-            logger.debug('response: %s %s', rpc_method._method,
-                         self.response_trim_for_log(response))
+            logger.debug('response: %s\n%s', rpc_method._method, response)
             return self.handle_response(response, error_from_response, value_from_response)
 
     def handle_response(self, response, error_from_response, value_from_response):
         if error_from_response is not None:
             exc = error_from_response(response)
         else:
             exc = None
@@ -390,31 +443,30 @@
 
         value_from_response and error_from_response should not raise their own exceptions!
 
         Asynchronous calls cannot be done with streaming rpcs right now.
         """
         request = self._apply_request_processors(request, copy_request=copy_request)
         logger = self._get_logger(rpc_method)
-        logger.debug('async request: %s %s', rpc_method._method, self.request_trim_for_log(request))
+        logger.debug('async request: %s\n%s', rpc_method._method, request)
         timeout = kwargs.pop('timeout', DEFAULT_RPC_TIMEOUT)
         response_future = rpc_method.future(request, timeout=timeout, **kwargs)
 
         def on_finish(fut):
             try:
                 result = fut.result()
             except Exception as exc:  # pylint: disable=broad-except
                 logger.debug('async exception: %s\n%s\n', rpc_method._method, exc)
             else:
                 try:
                     self._apply_response_processors(result)
                 except Exception:  # pylint: disable=broad-except
                     logger.exception("Error applying response processors.")
                 else:
-                    logger.debug('async response: %s %s', rpc_method._method,
-                                 self.response_trim_for_log(result))
+                    logger.debug('async response: %s\n%s', rpc_method._method, result)
 
         response_future.add_done_callback(on_finish)
         return FutureWrapper(response_future, value_from_response, error_from_response)
 
     def _apply_request_processors(self, request, copy_request=True):
         if request is None:
             return
@@ -435,29 +487,16 @@
         method_name = getattr(rpc_method, '_method', None)
         if method_name:
             method_name_short = str(method_name).split(BaseClient._SPLIT_METHOD)[-1]
             # This returns the same instance if it's been created before.
             return self.logger.getChild(method_name_short)
         return self.logger
 
-    @staticmethod
-    def chunk_message(message, data_chunk_byte_size):
-        """Take a message, and split it into data chunks
-        Args:
-            data_chunk_byte_size: max size of each streamed message
-        """
-        serialized = message.SerializeToString()
-        total_bytes_size = len(serialized)
-        num_chunks = math.ceil(total_bytes_size / data_chunk_byte_size)
-        for i in range(num_chunks):
-            start_index = i * data_chunk_byte_size
-            end_index = min(total_bytes_size, (i + 1) * data_chunk_byte_size)
-            chunk = data_chunk_pb2.DataChunk(total_size=total_bytes_size)
-            chunk.data = serialized[start_index:end_index]
-            yield chunk
+    chunk_message = deprecated(reason='Use bosdyn.client.data_chunk.chunk_message() instead.',
+                               version='3.3.0')(chunk_message)
 
 
 class FutureWrapper():
     """Wraps a Future to aid more complicated clients' async calls."""
 
     def __init__(self, future, value_from_response, error_from_response):
         self.original_future = future
```

## bosdyn/client/data_acquisition.py

```diff
@@ -1,17 +1,15 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """General client implementation for the main, on-robot data-acquisition service."""
 
-from __future__ import print_function
-
 import collections
 import functools
 import json
 import time
 
 from google.protobuf import json_format
 
@@ -128,15 +126,15 @@
         """Check the status of a data acquisition based on the request id.
 
         Args:
           request_id (int): The request id associated with an AcquireData request.
 
         Raises:
           RpcError: Problem communicating with the robot.
-          RequestIdDoesNotExistError: The request id provided is incorrect.
+          bosdyn.client.data_acquisition.RequestIdDoesNotExistError: The request id provided is incorrect.
 
         Returns:
             If the RPC is successful, then it will return the full status response, which includes the
             status as well as other information about any possible errors.
         """
         request = data_acquisition.GetStatusRequest(request_id=request_id)
         return self.call(self._stub.GetStatus, request, error_from_response=_get_status_error,
@@ -145,16 +143,16 @@
     def get_status_async(self, request_id, **kwargs):
         """Async version of the get_status() RPC."""
         request = data_acquisition.GetStatusRequest(request_id=request_id)
         return self.call_async(self._stub.GetStatus, request, error_from_response=_get_status_error,
                                copy_request=False, **kwargs)
 
     def get_service_info(self, **kwargs):
-        """Get information from a DAQ service to list its capabilities - which data, metadata,
-        or processing the DAQ service will perform.
+        """Get information from a Data Acquisition service to list its capabilities - which data,
+        metadata,or processing the Data Acquisition service will perform.
 
         Raises:
           RpcError: Problem communicating with the robot.
 
         Returns:
             The GetServiceInfoResponse message, which contains all the different capabilities.
         """
@@ -175,15 +173,15 @@
         """Cancel a data acquisition based on the request id.
         Args:
           request_id (int): The request id associated with an AcquireData request.
         Raises:
           RpcError: Problem communicating with the robot.
           CancellationFailedError: The data acquisitions associated with the request id were unable
                                    to be cancelled.
-          RequestIdDoesNotExistError: The request id provided is incorrect.
+          bosdyn.client.data_acquisition.RequestIdDoesNotExistError: The request id provided is incorrect.
         Returns:
             If the RPC is successful, then it will return the full status response, which includes the
             status as well as other information about any possible errors.
         """
         request = data_acquisition.CancelAcquisitionRequest(request_id=request_id)
         return self.call(self._stub.CancelAcquisition, request,
                          error_from_response=_cancel_acquisition_error, copy_request=False,
```

## bosdyn/client/data_acquisition_helpers.py

```diff
@@ -1,15 +1,13 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
-from __future__ import print_function
-
 import io
 import json
 import logging
 import os
 import ssl
 import time
 from pathlib import Path
@@ -168,15 +166,15 @@
 def clean_filename(filename):
     """Removes bad characters in a filename.
 
     Args:
         filename(string): Original filename to clean.
 
     Returns:
-        Valid filename with removed characters \:\*\?\<\>\|
+        Valid filename with removed characters :*?<>|
     """
 
     return "".join(i for i in filename if i not in ":*?<>|")
 
 
 def make_time_query_params(start_time_secs, end_time_secs, robot):
     """Create time-based query params for the download request.
```

## bosdyn/client/data_acquisition_plugin.py

```diff
@@ -1,23 +1,24 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """General client implementation for all data-acquisition plugin services."""
-
-from __future__ import print_function
-
+import collections
 import sys
 
 from bosdyn.api import data_acquisition_pb2 as data_acquisition
 from bosdyn.api import data_acquisition_plugin_service_pb2_grpc as data_acquisition_plugin_service
-from bosdyn.client.common import BaseClient
-from bosdyn.client.data_acquisition import (DataAcquisitionClient, acquire_data_error,
+from bosdyn.client.common import (BaseClient, error_factory, error_pair,
+                                  handle_common_header_errors, handle_custom_params_errors,
+                                  handle_unset_status_error)
+from bosdyn.client.data_acquisition import (DataAcquisitionClient, DataAcquisitionResponseError,
+                                            UnknownCaptureTypeError, acquire_data_error,
                                             get_request_id, metadata_to_proto)
 from bosdyn.util import now_timestamp
 
 
 class DataAcquisitionPluginClient(BaseClient):
     """A client for triggering data acquisition plugin and logging. This client is not intended for
     use directly by users or applications. All acquisition requests should go to the data
@@ -93,7 +94,27 @@
         get_status_async = DataAcquisitionClient.get_status_async
 
         get_service_info = DataAcquisitionClient.get_service_info
         get_service_info_async = DataAcquisitionClient.get_service_info_async
 
         cancel_acquisition = DataAcquisitionClient.cancel_acquisition
         cancel_acquisition_async = DataAcquisitionClient.cancel_acquisition_async
+
+
+_ACQUIRE_PLUGIN_DATA_STATUS_TO_ERROR = collections.defaultdict(lambda:
+                                                               (DataAcquisitionResponseError, None))
+
+_ACQUIRE_PLUGIN_DATA_STATUS_TO_ERROR.update({
+    data_acquisition.AcquirePluginDataResponse.STATUS_OK: (None, None),
+    data_acquisition.AcquirePluginDataResponse.STATUS_UNKNOWN_CAPTURE_TYPE:
+        error_pair(UnknownCaptureTypeError)
+})
+
+
+@handle_common_header_errors
+@handle_custom_params_errors
+@handle_unset_status_error(unset='STATUS_UNKNOWN')
+def _acquire_plugin_data_error(response):
+    """Return a custom exception based on the AcquireData response, None if no error."""
+    return error_factory(response, response.status,
+                         status_to_string=data_acquisition.AcquireDataResponse.Status.Name,
+                         status_to_error=_ACQUIRE_PLUGIN_DATA_STATUS_TO_ERROR)
```

## bosdyn/client/data_acquisition_plugin_service.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """A set of helper functions for implementing a Data Acquisition plugin service.
 
@@ -38,28 +38,27 @@
         raise
 
 Note, the data acquisition plugin service helper class will monitor and respond to the GetStatus RPC.
 However, the data_collect_fn function should update the status to STATUS_SAVING when it transitions to
 storing the data.
 """
 
-from __future__ import print_function
-
 import concurrent.futures
 import logging
 import threading
 import time
 from concurrent.futures import ThreadPoolExecutor
 
 from bosdyn.api import data_acquisition_pb2, data_acquisition_plugin_service_pb2_grpc, header_pb2
 from bosdyn.api.data_acquisition_pb2 import DataAcquisitionCapability as Capability
 from bosdyn.client import Robot
 from bosdyn.client.data_acquisition_store import DataAcquisitionStoreClient
 from bosdyn.client.data_buffer import DataBufferClient
 from bosdyn.client.server_util import ResponseContext, populate_response_header
+from bosdyn.client.service_customization_helpers import create_value_validator
 
 _LOGGER = logging.getLogger(__name__)
 
 # How long should completed requests be queryable?
 kDefaultRequestExpiration = 30
 
 
@@ -304,22 +303,40 @@
     service_type = 'bosdyn.api.DataAcquisitionPluginService'
 
     def __init__(self, robot, capabilities, data_collect_fn, acquire_response_fn=None,
                  executor=None, logger=None):
         super(DataAcquisitionPluginService, self).__init__()
         self.logger = logger or _LOGGER
         self.capabilities = capabilities
+        self.value_validators = {
+            capture.name: create_value_validator(capture.custom_params)
+            for capture in self.capabilities
+        }
         self.data_collect_fn = data_collect_fn
         self.acquire_response_fn = acquire_response_fn
         self.request_manager = RequestManager()
         self.executor = executor or ThreadPoolExecutor(max_workers=2)
         self.robot = robot
         self.store_client = robot.ensure_client(DataAcquisitionStoreClient.default_service_name)
         self.data_buffer_client = robot.ensure_client(DataBufferClient.default_service_name)
 
+    def validate_params(self, request, response):
+        """Validate that any parameters set in the request are valid according the the spec."""
+        for capture in request.acquisition_requests.data_captures:
+            try:
+                error = self.value_validators[capture.name](capture.custom_params)
+                if error is not None:
+                    response.custom_param_error.CopyFrom(error)
+                    response.status = response.STATUS_CUSTOM_PARAMS_ERROR
+                    return False
+            except KeyError:
+                response.status = response.STATUS_UNKNOWN_CAPTURE_TYPE
+                return False
+        return True
+
     def _data_collection_wrapper(self, request_id, request, state):
         """Helper function which initiates the data collection and storage in sequence.
 
         Args:
             request_id (int): The request_id for the acquisition request being inspected.
             request (DataAcquisitionPluginRequest): The data acquisition request.
             state (RequestState): The associated internal request state for the data.
@@ -365,14 +382,17 @@
         Args:
             request (data_acquisition_pb2.AcquirePluginDataRequest): The data acquisition request.
             response (data_acquisition_pb2.AcquirePluginDataResponse): The data acquisition response.
 
         Returns:
             Mutates the AcquirePluginDataResponse proto and also returns it.
         """
+        if not self.validate_params(request, response):
+            return response
+
         if self.acquire_response_fn is not None:
             try:
                 if not self.acquire_response_fn(request, response):
                     return response
             except Exception as e:
                 self.logger.exception('Failed during call to user acquire response function')
                 populate_response_header(response, request,
```

## bosdyn/client/data_acquisition_store.py

```diff
@@ -1,27 +1,26 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client implementation for data acquisition store service.
 """
 
-from __future__ import print_function
-
 import collections
 import functools
 import json
 
 from google.protobuf import json_format
 
 from bosdyn.api import data_acquisition_store_pb2 as data_acquisition_store
 from bosdyn.api import data_acquisition_store_service_pb2_grpc as data_acquisition_store_service
 from bosdyn.api import image_pb2
+from bosdyn.client import data_chunk
 from bosdyn.client.common import (BaseClient, common_header_errors, error_factory, error_pair,
                                   handle_common_header_errors, handle_unset_status_error)
 from bosdyn.client.exceptions import Error, ResponseError
 from bosdyn.util import now_timestamp
 
 
 class DataAcquisitionStoreClient(BaseClient):
@@ -253,14 +252,15 @@
         request = data_acquisition_store.StoreDataRequest(data=data, data_id=data_id,
                                                           file_extension=file_extension)
         return self.call_async(self._stub.StoreData, request,
                                error_from_response=common_header_errors, copy_request=False,
                                **kwargs)
 
 
+
 def _get_action_ids(response):
     return response.action_ids
 
 
 def _get_data_ids(response):
     return response.data_ids
```

## bosdyn/client/data_buffer.py

```diff
@@ -1,21 +1,19 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the data-buffer service.
 
 This allows client code to log the following to the robot's data buffer: text-messages,
 operator comments, blobs, signal ticks, and protobuf messages.
 """
 
-from __future__ import print_function
-
 import functools
 import logging
 import sys
 import threading
 import time
 import traceback
 import uuid
```

## bosdyn/client/data_service.py

```diff
@@ -1,19 +1,17 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the data-service.
 
 """
 
-from __future__ import print_function
-
 import bosdyn.api.data_index_pb2 as data_index_protos
 import bosdyn.api.data_service_pb2_grpc as data_service
 from bosdyn.client.common import BaseClient, common_header_errors
 from bosdyn.client.exceptions import Error
 
 
 class InvalidArgument(Error):
```

## bosdyn/client/directory.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the directory service.
```

## bosdyn/client/directory_registration.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the directory registration service.
```

## bosdyn/client/docking.py

```diff
@@ -1,19 +1,19 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """A client for the docking service."""
 
 import collections
 import time
 
-from deprecated import deprecated
+from deprecated.sphinx import deprecated
 
 from bosdyn.api.docking import docking_pb2, docking_service_pb2_grpc
 from bosdyn.client import lease
 from bosdyn.client.common import (BaseClient, common_header_errors, common_lease_errors,
                                   error_factory, handle_common_header_errors,
                                   handle_lease_use_result_errors, handle_unset_status_error,
                                   maybe_raise)
@@ -66,27 +66,28 @@
         """Async version of docking_command(). """
         req = self._docking_command_request(lease, station_id, clock_identifier, end_time,
                                             prep_pose_behavior)
         return self.call_async(self._stub.DockingCommand, req, self._docking_id_from_response,
                                _docking_command_error_from_response, copy_request=False, **kwargs)
 
     def docking_command_full(self, station_id, clock_identifier, end_time, prep_pose_behavior=None,
-                             lease=None, **kwargs):
+                             lease=None, require_fiducial=False, **kwargs):
         """Identical to docking_command(), except will return the full DockingCommandResponse."""
         req = self._docking_command_request(lease, station_id, clock_identifier, end_time,
-                                            prep_pose_behavior)
+                                            prep_pose_behavior, require_fiducial)
         return self.call(self._stub.DockingCommand, req,
                          error_from_response=_docking_command_error_from_response,
                          copy_request=False, **kwargs)
 
     def docking_command_full_async(self, station_id, clock_identifier, end_time,
-                                   prep_pose_behavior=None, lease=None, **kwargs):
+                                   prep_pose_behavior=None, lease=None, require_fiducial=False,
+                                   **kwargs):
         """Identical to docking_command_async(), except will return the full DockingCommandResponse."""
         req = self._docking_command_request(lease, station_id, clock_identifier, end_time,
-                                            prep_pose_behavior)
+                                            prep_pose_behavior, require_fiducial)
         return self.call_async(self._stub.DockingCommand, req,
                                error_from_response=_docking_command_error_from_response,
                                copy_request=False, **kwargs)
 
 
     def docking_command_feedback_full(self, command_id, end_time=None, **kwargs):
         """Check the status of a previously issued docking command.
@@ -166,19 +167,20 @@
     def get_docking_state_async(self, **kwargs):
         """Async version of get_docking_state()."""
         req = docking_pb2.GetDockingStateRequest()
         return self.call_async(self._stub.GetDockingState, req, self._docking_state_from_response,
                                _docking_get_state_error_from_response, copy_request=False, **kwargs)
 
     @staticmethod
-    def _docking_command_request(lease, station_id, clock_identifier, end_time, prep_pose_behavior):
-        return docking_pb2.DockingCommandRequest(lease=lease, docking_station_id=station_id,
-                                                 clock_identifier=clock_identifier,
-                                                 end_time=end_time,
-                                                 prep_pose_behavior=prep_pose_behavior)
+    def _docking_command_request(lease, station_id, clock_identifier, end_time, prep_pose_behavior,
+                                 require_fiducial=False):
+        return docking_pb2.DockingCommandRequest(
+            lease=lease, docking_station_id=station_id, clock_identifier=clock_identifier,
+            end_time=end_time, prep_pose_behavior=prep_pose_behavior,
+            require_fiducial=require_fiducial)
 
     @staticmethod
     def _docking_command_feedback_request(command_id, end_time=None):
         req = docking_pb2.DockingCommandFeedbackRequest(docking_command_id=command_id)
         if end_time is not None:
             req.update_docking_params.end_time.CopyFrom(end_time)
         return req
```

## bosdyn/client/door.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the door service."""
```

## bosdyn/client/estop.py

```diff
@@ -1,25 +1,25 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the emergency stop (estop) service."""
 
 import collections
 import ctypes
 import enum
 import logging
 import os
+import queue
 import threading
 import time
 
 from google.protobuf.duration_pb2 import Duration
-from six.moves import queue
 
 from bosdyn.api import estop_pb2, estop_service_pb2_grpc
 
 from .common import (BaseClient, common_header_errors, error_factory, handle_common_header_errors,
                      handle_unset_status_error)
 from .exceptions import Error, ResponseError, RpcError, TimedOutError
 
@@ -233,14 +233,15 @@
 
     def __init__(self, client, name, estop_timeout, role=REQUIRED_ROLE, first_checkin=True,
                  estop_cut_power_timeout=None):
         self.client = client
         self.role = role
         self.estop_timeout = estop_timeout
         self.estop_cut_power_timeout = estop_cut_power_timeout
+        self._last_set_level = None
         self._challenge = None
         self._name = name
         self._unique_id = None
         self._config_id = None
         self._lock = threading.Lock()
         self._locked_first_checkin = first_checkin
 
@@ -249,14 +250,18 @@
     def __str__(self):
         if self.estop_cut_power_timeout is None:
             return '{} (timeout {:.3}s)'.format(self._name, self.estop_timeout)
         else:
             return '{} (timeout {:.3}s, cut_power_timeout {:.3}s)'.format(
                 self._name, self.estop_timeout, self.estop_cut_power_timeout)
 
+    @property
+    def last_set_level(self):
+        return self._last_set_level
+
     def _first_checkin(self):
         with self._lock:
             return self._locked_first_checkin
 
     def _set_first_checkin(self, val):
         with self._lock:
             self._locked_first_checkin = val
@@ -341,14 +346,16 @@
         try:
             self.set_challenge(
                 self.client.check_in(level, self, self.get_challenge(), self._response(),
                                      suppress_incorrect=self._first_checkin(), **kwargs))
         except EstopResponseError as exc:
             self.set_challenge(_challenge_from_check_in_response(exc.response))
             raise
+        else:
+            self._last_set_level = level
         self._set_first_checkin(False)
 
     def deregister(self, **kwargs):
         """Deregister this endpoint from the configuration."""
         self.logger.debug('Deregistering')
         self.client.deregister(self._config_id, self)
 
@@ -486,14 +493,18 @@
 
     def shutdown(self):
         self.logger.debug('Shutting down')
         self._end_periodic_check_in()
         self._thread.join()
 
     @property
+    def last_set_level(self):
+        return self._endpoint.last_set_level
+
+    @property
     def logger(self):
         return self._endpoint.logger
 
     def allow(self):
         with self._lock:
             self._desired_stop_level = StopLevel.ESTOP_LEVEL_NONE
         self._check_in()
```

## bosdyn/client/exceptions.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 class Error(Exception):
     """Base exception that all public api exceptions are derived from."""
@@ -32,14 +32,18 @@
 class InvalidRequestError(ResponseError):
     """The provided request arguments are ill-formed or invalid, independent of the system state."""
 
 
 class LeaseUseError(ResponseError):
     """Request was rejected due to using an invalid lease."""
 
+    def __init__(self, response, lease_use_result):
+        super().__init__(response)
+        self.lease_use_result = lease_use_result
+
 
 class LicenseError(ResponseError):
     """Request was rejected due to using an invalid license."""
 
 
 class ServerError(ResponseError):
     """Service encountered an unrecoverable error."""
@@ -143,7 +147,24 @@
 
 class TransientFailureError(RetryableRpcError):
     """The channel is in state TRANSIENT_FAILURE, often caused by a connection failure."""
 
 
 class TimeSyncRequired(Error):
     """Time synchronization is required but none seems to be established."""
+
+
+class CustomParamError(ResponseError):
+    """A custom parameter that was provided did not match the specification"""
+
+    def __init__(self, response, custom_param_error):
+        super().__init__(response)
+        self.custom_param_error = custom_param_error
+
+    def __str__(self):
+        if self.response is not None:
+            full_classname = self.response.DESCRIPTOR.full_name
+        else:
+            full_classname = "Error"
+        return '{} ({}): Parameter Errors\n{}'.format(
+            full_classname, self.__class__.__name__,
+            '\n'.join(self.custom_param_error.error_messages))
```

## bosdyn/client/fault.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to use the fault service."""
 import collections
```

## bosdyn/client/frame_helpers.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 from bosdyn.api import geometry_pb2
 
@@ -14,14 +14,28 @@
 # string identifier.
 GRAV_ALIGNED_BODY_FRAME_NAME = "flat_body"
 ODOM_FRAME_NAME = "odom"
 GROUND_PLANE_FRAME_NAME = "gpe"
 HAND_FRAME_NAME = "hand"
 UNKNOWN_FRAME_NAME = "unknown"
 RAYCAST_FRAME_NAME = "walkto_raycast_intersection"
+TOOL_FRAME_NAME = "tool"
+DESIRED_TOOL_FRAME_NAME = "desired_tool"
+TASK_FRAME_NAME = "task"
+DESIRED_TOOL_AT_END_FRAME_NAME = "desired_tool_at_end"
+MEASURED_TOOL_AT_START_FRAME_NAME = "measured_tool_at_start"
+GAZE_TARGET_FRAME_NAME = "gaze_target"
+FRONT_LEFT_FOOT_FRAME_NAME = "fl_foot"
+FRONT_RIGHT_FOOT_FRAME_NAME = "fr_foot"
+HIND_LEFT_FOOT_FRAME_NAME = "hl_foot"
+HIND_RIGHT_FOOT_FRAME_NAME = "hr_foot"
+FOOT_FRAME_NAMES = [
+    FRONT_LEFT_FOOT_FRAME_NAME, FRONT_RIGHT_FOOT_FRAME_NAME, HIND_LEFT_FOOT_FRAME_NAME,
+    HIND_RIGHT_FOOT_FRAME_NAME
+]
 
 
 class Error(Exception):
     pass
 
 
 class ValidateFrameTreeError(Error):
```

## bosdyn/client/graph_nav.py

```diff
@@ -1,20 +1,20 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the graphnav service."""
 import collections
 import math
 import os
 import time
 
-from deprecated import deprecated
+from deprecated.sphinx import deprecated
 
 from bosdyn.api import data_chunk_pb2, lease_pb2
 from bosdyn.api.graph_nav import (graph_nav_pb2, graph_nav_service_pb2, graph_nav_service_pb2_grpc,
                                   map_pb2, nav_pb2)
 from bosdyn.client.common import (BaseClient, common_header_errors, common_lease_errors,
                                   error_factory, error_pair, handle_common_header_errors,
                                   handle_lease_use_result_errors, handle_unset_status_error)
@@ -26,27 +26,55 @@
     """Client to the GraphNav service."""
     default_service_name = 'graph-nav-service'
     service_type = 'bosdyn.api.graph_nav.GraphNavService'
 
     def __init__(self):
         super(GraphNavClient, self).__init__(graph_nav_service_pb2_grpc.GraphNavServiceStub)
         self._timesync_endpoint = None
-        self._data_chunk_size = 1000  # bytes = 1 KB
+        self._data_chunk_size = 1024 * 1024  # bytes = 1 MB
 
     def update_from(self, other):
         super(GraphNavClient, self).update_from(other)
         if self.lease_wallet:
             add_lease_wallet_processors(self, self.lease_wallet)
 
         # Grab a timesync endpoint if it is available.
         try:
             self._timesync_endpoint = other.time_sync.endpoint
         except AttributeError:
             pass  # other doesn't have a time_sync accessor
 
+    def set_localization_full_response(
+            self, initial_guess_localization, ko_tform_body=None, max_distance=None, max_yaw=None,
+            fiducial_init=graph_nav_pb2.SetLocalizationRequest.FIDUCIAL_INIT_NEAREST,
+            use_fiducial_id=None, refine_fiducial_result_with_icp=False, do_ambiguity_check=False,
+            refine_with_visual_features=False, verify_visual_features_quality=False, **kwargs):
+        """Version of set_localization which returns the full response,
+        rather than only the Localization message.
+        """
+        req = self._build_set_localization_request(
+            initial_guess_localization, ko_tform_body, max_distance, max_yaw, fiducial_init,
+            use_fiducial_id, refine_fiducial_result_with_icp, do_ambiguity_check,
+            refine_with_visual_features, verify_visual_features_quality)
+        return self.call(self._stub.SetLocalization, req, _get_response, _set_localization_error,
+                         copy_request=False, **kwargs)
+
+    def set_localization_async_full_response(
+            self, initial_guess_localization, ko_tform_body=None, max_distance=None, max_yaw=None,
+            fiducial_init=graph_nav_pb2.SetLocalizationRequest.FIDUCIAL_INIT_NEAREST,
+            use_fiducial_id=None, refine_fiducial_result_with_icp=False, do_ambiguity_check=False,
+            refine_with_visual_features=False, verify_visual_features_quality=False, **kwargs):
+        """Async version of set_localization_full_response()"""
+        req = self._build_set_localization_request(
+            initial_guess_localization, ko_tform_body, max_distance, max_yaw, fiducial_init,
+            use_fiducial_id, refine_fiducial_result_with_icp, do_ambiguity_check,
+            refine_with_visual_features, verify_visual_features_quality)
+        return self.call_async(self._stub.SetLocalization, req, _get_response,
+                               _set_localization_error, copy_request=False, **kwargs)
+
     def set_localization(
             self, initial_guess_localization, ko_tform_body=None, max_distance=None, max_yaw=None,
             fiducial_init=graph_nav_pb2.SetLocalizationRequest.FIDUCIAL_INIT_NEAREST,
             use_fiducial_id=None, refine_fiducial_result_with_icp=False, do_ambiguity_check=False,
             refine_with_visual_features=False, verify_visual_features_quality=False, **kwargs):
         """Trigger a manual localization. Typically done to provide the initial localization.
 
@@ -219,27 +247,29 @@
                                                      destination_waypoint_tform_body_goal)
         return self.call_async(self._stub.NavigateRoute, request,
                                error_from_response=_navigate_route_error, copy_request=False,
                                **kwargs)
 
     def navigate_to(self, destination_waypoint_id, cmd_duration, route_params=None,
                     travel_params=None, leases=None, timesync_endpoint=None, command_id=None,
-                    destination_waypoint_tform_body_goal=None, **kwargs):
+                    destination_waypoint_tform_body_goal=None, route_blocked_behavior=None,
+                    **kwargs):
         """Navigate to a specific waypoint along a route chosen by the GraphNav service.
 
         Args:
             destination_waypoint_id: Waypoint id string for where to go to.
             cmd_duration: Number of seconds the command can run for.
             route_params: API RouteGenParams for the route.
             travel_params: API TravelParams for the route.
             leases: Leases to show ownership of necessary resources. Will use the client's leases by default.
             timesync_endpoint: Use this endpoint for timesync fields. Will use the client's endpoint by default.
             command_id: If not None, this continues an existing navigate_to command with the given ID. If None,
             a new command_id will be used.
             destination_waypoint_tform_body_goal: SE2Pose protobuf of an offset relative to the destination waypoint.
+            route_blocked_behavior: Defines robot behavior when route is block. If None robot will reroute.
         Returns:
             int: Command ID to use in feedback lookup.
         Raises:
             RpcError: Problem communicating with the robot.
             LeaseUseError: Error using provided leases.
             graph_nav.NoTimeSyncError: Missing clock identifier.
             graph_nav.CommandExpiredError: Command already expired.
@@ -252,57 +282,62 @@
             graph_nav.RouteNavigationError: A subclass detailing trouble navigating the route.
         """
         used_endpoint = timesync_endpoint or self._timesync_endpoint
         if not used_endpoint:
             raise GraphNavServiceResponseError(response=None, error_message='No timesync endpoint!')
         request = self._build_navigate_to_request(destination_waypoint_id, travel_params,
                                                   route_params, cmd_duration, leases, used_endpoint,
-                                                  command_id, destination_waypoint_tform_body_goal)
+                                                  command_id, destination_waypoint_tform_body_goal,
+                                                  route_blocked_behavior)
         return self.call(self._stub.NavigateTo, request,
                          value_from_response=_command_id_from_navigate_route_response,
                          error_from_response=_navigate_to_error, copy_request=False, **kwargs)
 
     def navigate_to_async(self, destination_waypoint_id, cmd_duration, route_params=None,
                           travel_params=None, leases=None, timesync_endpoint=None, command_id=None,
-                          destination_waypoint_tform_body_goal=None, **kwargs):
+                          destination_waypoint_tform_body_goal=None, route_blocked_behavior=None,
+                          **kwargs):
         """Async version of navigate_to()."""
         used_endpoint = timesync_endpoint or self._timesync_endpoint
         if not used_endpoint:
             raise GraphNavServiceResponseError(response=None, error_message='No timesync endpoint!')
         request = self._build_navigate_to_request(destination_waypoint_id, travel_params,
                                                   route_params, cmd_duration, leases, used_endpoint,
                                                   command_id, destination_waypoint_tform_body_goal)
         return self.call_async(self._stub.NavigateTo, request,
                                value_from_response=_command_id_from_navigate_route_response,
                                error_from_response=_navigate_to_error, copy_request=False, **kwargs)
 
     def navigate_to_full(self, destination_waypoint_id, cmd_duration, route_params=None,
                          travel_params=None, leases=None, timesync_endpoint=None, command_id=None,
-                         destination_waypoint_tform_body_goal=None, **kwargs):
+                         destination_waypoint_tform_body_goal=None, route_blocked_behavior=None,
+                         **kwargs):
         """Identical to navigate_to(), except will return the full NavigateToResponse."""
         used_endpoint = timesync_endpoint or self._timesync_endpoint
         if not used_endpoint:
             raise GraphNavServiceResponseError(response=None, error_message='No timesync endpoint!')
         request = self._build_navigate_to_request(destination_waypoint_id, travel_params,
                                                   route_params, cmd_duration, leases, used_endpoint,
-                                                  command_id, destination_waypoint_tform_body_goal)
+                                                  command_id, destination_waypoint_tform_body_goal,
+                                                  route_blocked_behavior)
         return self.call(self._stub.NavigateTo, request, error_from_response=_navigate_to_error,
                          copy_request=False, **kwargs)
 
     def navigate_to_full_async(self, destination_waypoint_id, cmd_duration, route_params=None,
                                travel_params=None, leases=None, timesync_endpoint=None,
                                command_id=None, destination_waypoint_tform_body_goal=None,
-                               **kwargs):
+                               route_blocked_behavior=None, **kwargs):
         """Async version of navigate_to_full()."""
         used_endpoint = timesync_endpoint or self._timesync_endpoint
         if not used_endpoint:
             raise GraphNavServiceResponseError(response=None, error_message='No timesync endpoint!')
         request = self._build_navigate_to_request(destination_waypoint_id, travel_params,
                                                   route_params, cmd_duration, leases, used_endpoint,
-                                                  command_id, destination_waypoint_tform_body_goal)
+                                                  command_id, destination_waypoint_tform_body_goal,
+                                                  route_blocked_behavior)
         return self.call_async(self._stub.NavigateTo, request,
                                error_from_response=_navigate_to_error, copy_request=False, **kwargs)
 
     def navigate_to_anchor(self, seed_tform_goal, cmd_duration, route_params=None,
                            travel_params=None, leases=None, timesync_endpoint=None,
                            goal_waypoint_rt_seed_ewrt_seed_tolerance=None, command_id=None,
                            **kwargs):
@@ -616,28 +651,30 @@
         if command_id is not None:
             request.command_id = command_id
         return request
 
     @staticmethod
     def _build_navigate_to_request(destination_waypoint_id, travel_params, route_params,
                                    end_time_secs, leases, timesync_endpoint, command_id,
-                                   destination_waypoint_tform_body_goal):
+                                   destination_waypoint_tform_body_goal, route_blocked_behavior):
         converter = timesync_endpoint.get_robot_time_converter()
         request = graph_nav_pb2.NavigateToRequest(
             destination_waypoint_id=destination_waypoint_id,
             destination_waypoint_tform_body_goal=destination_waypoint_tform_body_goal,
             clock_identifier=timesync_endpoint.clock_identifier)
         request.end_time.CopyFrom(
             converter.robot_timestamp_from_local_secs(time.time() + end_time_secs))
         if travel_params is not None:
             request.travel_params.CopyFrom(travel_params)
         if route_params is not None:
             request.route_params.CopyFrom(route_params)
         if command_id is not None:
             request.command_id = command_id
+        if route_blocked_behavior is not None:
+            request.route_blocked_behavior = route_blocked_behavior
         return request
 
     @staticmethod
     def _build_navigate_to_anchor_request(seed_tform_goal, travel_params, route_params,
                                           end_time_secs, leases, timesync_endpoint, command_id,
                                           goal_waypoint_rt_seed_ewrt_seed_tolerance):
         converter = timesync_endpoint.get_robot_time_converter()
@@ -733,29 +770,16 @@
         """
         travel_params = graph_nav_pb2.TravelParams(max_distance=max_distance, max_yaw=max_yaw)
         if velocity_limit is not None:
             travel_params.velocity_limit.CopyFrom(velocity_limit)
         return travel_params
 
     @staticmethod
-    def generate_route_params(waypoint_id_list):
-        """ Generate the API RouteGenParams for navigation requests.
-
-        Args:
-            waypoint_id_list: List of waypoint id strings in which a route should pass through.
-        Returns:
-            The API RouteGenParams protobuf message.
-        """
-        route_params = graph_nav_pb2.RouteGenParams()
-        route_params.via_waypoints.extend(waypoint_id_list)
-        return route_params
-
-    @staticmethod
     def build_route(waypoint_id_list, edge_id_list):
-        """ Generate the API RouteGenParams for navigation requests.
+        """ Generate the API Route for navigation requests.
 
         Args:
             waypoint_id_list: List of waypoint id strings in which a route should pass through.
                                 The ids should be ordered from [start waypoint --> destination waypoint].
             edge_id_list: List of the edge_id's which should be in the same ordering as the waypoint list.
         Returns:
             The API Route protobuf message.
@@ -787,18 +811,22 @@
     """The map is too large for the license on the robot."""
 
 
 class InvalidGraphError(UploadGraphError):
     """The graph is invalid topologically, e.g. missing waypoints referenced by edges."""
 
 
-class IncompatibleSensorsError(ResponseError):
+class IncompatibleSensorsError(GraphNavServiceResponseError):
     """The map was recorded with using a sensor configuration which is incompatible with the robot (for example, LIDAR configuration)."""
 
 
+class AreaCallbackMapError(GraphNavServiceResponseError):
+    """The map specified an area callback that is not registered or is faulted."""
+
+
 class RequestAbortedError(GraphNavServiceResponseError):
     """Request was aborted by the system."""
 
 
 class RequestFailedError(GraphNavServiceResponseError):
     """Request failed to complete by the system."""
 
@@ -974,15 +1002,17 @@
 _UPLOAD_GRAPH_STATUS_TO_ERROR.update({
     graph_nav_pb2.UploadGraphResponse.STATUS_OK: (None, None),
     graph_nav_pb2.UploadGraphResponse.STATUS_MAP_TOO_LARGE_LICENSE:
         error_pair(MapTooLargeLicenseError),
     graph_nav_pb2.UploadGraphResponse.STATUS_INVALID_GRAPH:
         error_pair(InvalidGraphError),
     graph_nav_pb2.UploadGraphResponse.STATUS_INCOMPATIBLE_SENSORS:
-        error_pair(IncompatibleSensorsError)
+        error_pair(IncompatibleSensorsError),
+    graph_nav_pb2.UploadGraphResponse.STATUS_AREA_CALLBACK_ERROR:
+        error_pair(AreaCallbackMapError),
 })
 
 
 @handle_common_header_errors
 @handle_lease_use_result_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _upload_graph_error(response):
@@ -1085,15 +1115,17 @@
     graph_nav_pb2.NavigateRouteResponse.STATUS_NOT_LOCALIZED_TO_MAP:
         error_pair(RobotNotLocalizedToRouteError),
     graph_nav_pb2.NavigateRouteResponse.STATUS_COULD_NOT_UPDATE_ROUTE:
         error_pair(RouteNotUpdatingError),
     graph_nav_pb2.NavigateRouteResponse.STATUS_STUCK:
         error_pair(RobotStuckError),
     graph_nav_pb2.NavigateRouteResponse.STATUS_UNRECOGNIZED_COMMAND:
-        error_pair(UnrecognizedCommandError)
+        error_pair(UnrecognizedCommandError),
+    graph_nav_pb2.NavigateRouteResponse.STATUS_AREA_CALLBACK_ERROR:
+        error_pair(AreaCallbackMapError),
 })
 
 
 @handle_common_header_errors
 @handle_lease_use_result_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _navigate_route_error(response):
@@ -1125,15 +1157,19 @@
     graph_nav_pb2.NavigateToResponse.STATUS_LOST:
         error_pair(RobotLostError),
     graph_nav_pb2.NavigateToResponse.STATUS_NOT_LOCALIZED_TO_MAP:
         error_pair(RobotNotLocalizedToRouteError),
     graph_nav_pb2.NavigateToResponse.STATUS_COULD_NOT_UPDATE_ROUTE:
         error_pair(RouteNotUpdatingError),
     graph_nav_pb2.NavigateToResponse.STATUS_STUCK:
-        error_pair(RobotStuckError)
+        error_pair(RobotStuckError),
+    graph_nav_pb2.NavigateToResponse.STATUS_UNRECOGNIZED_COMMAND:
+        error_pair(UnrecognizedCommandError),
+    graph_nav_pb2.NavigateToResponse.STATUS_AREA_CALLBACK_ERROR:
+        error_pair(AreaCallbackMapError),
 })
 
 
 @handle_common_header_errors
 @handle_lease_use_result_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _navigate_to_error(response):
@@ -1167,15 +1203,19 @@
     graph_nav_pb2.NavigateToAnchorResponse.STATUS_NOT_LOCALIZED_TO_MAP:
         error_pair(RobotNotLocalizedToRouteError),
     graph_nav_pb2.NavigateToAnchorResponse.STATUS_COULD_NOT_UPDATE_ROUTE:
         error_pair(RouteNotUpdatingError),
     graph_nav_pb2.NavigateToAnchorResponse.STATUS_STUCK:
         error_pair(RobotStuckError),
     graph_nav_pb2.NavigateToAnchorResponse.STATUS_INVALID_POSE:
-        error_pair(InvalidPoseError)
+        error_pair(InvalidPoseError),
+    graph_nav_pb2.NavigateToAnchorResponse.STATUS_UNRECOGNIZED_COMMAND:
+        error_pair(UnrecognizedCommandError),
+    graph_nav_pb2.NavigateToAnchorResponse.STATUS_AREA_CALLBACK_ERROR:
+        error_pair(AreaCallbackMapError),
 })
 
 
 @handle_common_header_errors
 @handle_lease_use_result_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _navigate_to_anchor_error(response):
@@ -1189,14 +1229,16 @@
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _navigate_feedback_error(response):
     """Return a custom exception based on navigate to response, None if no error."""
     # If the common response header is OK and the status is set, no error.
     return None
 
 
+
+
 @handle_common_header_errors
 @handle_unset_status_error(unset='STATUS_UNKNOWN')
 def _download_waypoint_snapshot_stream_errors(response):
     """Return a custom exception based on download waypoint snapshot streaming response, None if no error."""
     # Iterate through the response since the download request responds with a stream.
     for resp in response:
         # Handle error statuses from the request.
```

## bosdyn/client/gripper_camera_param.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 from bosdyn.api import gripper_camera_param_service_pb2_grpc
 from bosdyn.client.common import BaseClient, common_header_errors
```

## bosdyn/client/image.py

```diff
@@ -1,22 +1,22 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to use the image service."""
 import collections
 import os
 
 import numpy as np
 
 from bosdyn.api import image_pb2, image_service_pb2_grpc
-from bosdyn.client.common import (BaseClient, common_header_errors, error_factory, error_pair,
-                                  handle_common_header_errors)
+from bosdyn.client.common import (BaseClient, common_header_errors, custom_params_error,
+                                  error_factory, error_pair, handle_common_header_errors)
 from bosdyn.client.exceptions import ResponseError, UnsetStatusError
 
 
 class ImageResponseError(ResponseError):
     """General class of errors for Image service."""
 
 
@@ -64,18 +64,24 @@
 })
 
 
 @handle_common_header_errors
 def _error_from_response(response):
     """Return a custom exception based on the first invalid image response, None if no error."""
     for image_response in response.image_responses:
+        result = custom_params_error(image_response, total_response=response)
+        if result is not None:
+            return result
+
         result = error_factory(response, image_response.status,
                                status_to_string=image_pb2.ImageResponse.Status.Name,
                                status_to_error=_STATUS_TO_ERROR)
         if result is not None:
+            # The exception is using the image_response.  Replace it with the full response.
+            result.response = response
             return result
     return None
 
 
 class ImageClient(BaseClient):
     """Client for the image service."""
     default_service_name = 'image'
```

## bosdyn/client/image_service_helpers.py

```diff
@@ -1,28 +1,30 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
+import inspect
 import logging
 import sys
 import threading
 import time
 from abc import ABC, abstractmethod
 
 import numpy as np
 
 from bosdyn.api import (header_pb2, image_pb2, image_service_pb2, image_service_pb2_grpc,
-                        service_fault_pb2)
+                        service_customization_pb2, service_fault_pb2)
 from bosdyn.client.exceptions import RpcError
 from bosdyn.client.fault import (FaultClient, ServiceFaultAlreadyExistsError,
                                  ServiceFaultDoesNotExistError)
 from bosdyn.client.image import UnsupportedPixelFormatRequestedError
 from bosdyn.client.server_util import populate_response_header
+from bosdyn.client.service_customization_helpers import create_value_validator, validate_dict_spec
 from bosdyn.client.util import setup_logging
 from bosdyn.util import sec_to_nsec, seconds_to_duration
 
 _LOGGER = logging.getLogger(__name__)
 
 CLEAR_FAULT_RPC_TIMEOUT_SECS = 0.1
 
@@ -50,17 +52,29 @@
 class CameraInterface(ABC):
     """Abstract class interface for capturing and decoding images from a camera.
 
     This interface is used by the VisualImageSource to ensure that each image source
     has the expected capture and decoding methods with the right specification.
     """
 
+    def __init__(self):
+        self.capture_lock = threading.Lock()
+
     @abstractmethod
-    def blocking_capture(self):
-        """Communicates with the camera payload to collect the image data.
+    def blocking_capture(self, *, custom_params=None, **kwargs):
+        """Communicates with the camera payload to collect the image data. Ensure this is threadsafe as multiple
+        threads/requests may try to call blocking_capture at the same time. A Lock (self.capture_lock) is provided
+        as a convenience to help with this.
+
+        Keyword Args:
+            custom_params (service_customization_pb2.DictParam): Custom parameters defined by the image source
+                                                                 affecting the resulting capture 
+            **kwargs: Other keyword arguments including future additions to the request that affect the capture.
+                      If an implementer is looking to use kwargs, it is expected that they update their
+                      blocking_capture function signature to accept named keyword arguments such as custom_params
 
         Returns:
             A tuple with image data (in any format), and the capture timestamp in seconds (float) in the
             service computer's clock.
         """
         pass
 
@@ -98,31 +112,44 @@
         rows (int): The number of rows of pixels in the image.
         cols (int): The number of cols of pixels in the image.
         gain (float | function): The sensor's gain in dB. This can be a fixed value or a function
                                  which returns the gain as a float.
         exposure (float | function): The exposure time for an image in seconds. This can be a fixed
                                      value or a function which returns the exposure time as a float.
         pixel_formats (image_pb2.Image.PixelFormat[]): Supported pixel formats.
+        param_spec (service_customization_pb2.DictParam.Spec): A set of custom parameters passed into this
+                                                               image source
         logger (logging.Logger): Logger for debug and warning messages.
     """
 
     def __init__(self, image_name, camera_interface, rows=None, cols=None, gain=None, exposure=None,
-                 pixel_formats=[], logger=None):
+                 pixel_formats=[], logger=None, param_spec=None):
         self.image_source_name = image_name
         self.supported_pixel_formats = pixel_formats
         self.image_source_proto = self.make_image_source(image_name, rows, cols,
-                                                         self.supported_pixel_formats)
-        self.get_image_capture_params = lambda: self.make_capture_parameters(gain, exposure)
-
+                                                         self.supported_pixel_formats,
+                                                         param_spec=param_spec)
+        self.get_image_capture_params = lambda request_custom_params=None: self.make_capture_parameters(
+            gain=gain, exposure=exposure, request_custom_params=request_custom_params)
+
+        self.param_spec = param_spec
+        if param_spec:
+            #Fail fast if the spec being used is invalid, and otherwise get a function to easily validate values
+            self.value_validator = create_value_validator(param_spec)
+        else:
+            #Validate against empty parameter set
+            self.value_validator = create_value_validator(
+                service_customization_pb2.DictParam.Spec())
         # Ensure the camera_interface is a subclass of CameraInterface and has the defined capture and
         # decode methods.
         assert isinstance(camera_interface, CameraInterface)
         self.camera_interface = camera_interface
-        self.capture_function = lambda: self._do_capture_with_error_checking(self.camera_interface.
-                                                                             blocking_capture)
+
+        self.capture_function = lambda custom_params=None, **kwargs: self._do_capture_with_error_checking(
+            self.camera_interface.blocking_capture, custom_params=custom_params, **kwargs)
 
         # Optional background thread to continuously capture image data. This will help an image
         # service to respond quickly to a GetImage request, since it can use the last captured image.
         self.capture_thread = None
 
         # Fault client to report errors. Requires the image service name to
         # properly create the fault id.
@@ -148,18 +175,20 @@
         self.last_error_message = None
 
     def set_logger(self, logger):
         """Override the existing logger for the VisualImageSource class."""
         if logger is not None:
             self.logger = logger
 
-    def create_capture_thread(self):
+    def create_capture_thread(self, custom_params=None):
         """Initialize a background thread to continuously capture images.
+        
         """
-        self.capture_thread = ImageCaptureThread(self.image_source_name, self.capture_function)
+        self.capture_thread = ImageCaptureThread(self.image_source_name, self.capture_function,
+                                                 custom_params=custom_params)
         self.capture_thread.start_capturing()
 
     def initialize_faults(self, fault_client, image_service):
         """Initialize a fault client and faults for the image source (linked to the image service).
 
         The fault client can be used to throw faults for capture and decode errors. All faults
         associated with the image service name provided will be cleared.
@@ -234,55 +263,79 @@
         if show_last_error:
             # force the printout of the last error message by sending the log message at a logger level
             # high enough to not be filtered out.
             self.logger.error(self.last_error_message)
         else:
             self.logger.warning(error_message)
 
-    def _do_capture_with_error_checking(self, capture_func):
+    def _do_capture_with_error_checking(self, capture_func, custom_params=None,
+                                        **capture_func_kwargs):
         """Calls the blocking capture function and checks for any exceptions.
 
         This function will print warning messages and trigger a camera capture fault if an
         exception is thrown by the camera interface's blocking capture function.
 
         Args:
             capture_func (CameraInterface.blocking_capture): The function capturing the image
                                                               data and timestamp.
+            custom_params (service_customization_pb2.DictParam): Custom parameters passed to the blocking 
+                                                                 capture affecting the resulting capture
+            **capture_func_kwargs: Other keyword arguments for the capture_func
         """
         try:
-            img, timestamp = capture_func()
+            if custom_params or capture_func_kwargs:
+                # If supplying custom_params, try a blocking capture function that can handle them
+                try:
+                    img, timestamp = capture_func(custom_params=custom_params,
+                                                  **capture_func_kwargs)
+                except TypeError:
+                    img, timestamp = capture_func()
+            else:
+                # Supports pre-3.3 blocking_capture if no custom_params or kwargs (both introduced in 3.3) are passed
+                img, timestamp = capture_func()
             # Clear out any old error messages if the capture succeeds.
             self.last_error_message = None
             # Clear any previous camera capture faults after a successful image capture for
             # this image source.
             self.clear_fault(self.camera_capture_fault)
             return img, timestamp
         except Exception as err:
             error_message = "Failed to capture an image from %s: %s %s" % (self.image_source_name,
                                                                            type(err), err)
             self._maybe_log_error(error_message)
             self.trigger_fault(error_message, self.camera_capture_fault)
             return None, None
 
-    def get_image_and_timestamp(self):
+    def get_image_and_timestamp(self, custom_params=None, **capture_func_kwargs):
         """Retrieve the latest captured image and timestamp.
 
+        Args:
+            custom_params (service_customization_pb2.DictParam): Custom parameters passed to the object's 
+                                                                 capture_function affecting the resulting capture
+            **capture_func_kwargs: Other keyword arguments for the capture_function
+
         Returns:
             The latest captured image and the time (in seconds) associated with that image capture.
             Throws a camera capture fault and returns None if the image cannot be retrieved.
         """
         if self.capture_thread is not None:
-            image, timestamp = self.capture_thread.get_latest_captured_image()
-            if image is None or timestamp is None:
-                # Force the printout of the last error message since the capture failed.
-                self._maybe_log_error(show_last_error=True)
-            return image, timestamp
+            thread_capture_output = self.capture_thread.get_latest_captured_image(
+                custom_params=custom_params, **capture_func_kwargs)
+            valid_thread_capture, image, timestamp = thread_capture_output.is_valid, thread_capture_output.image, thread_capture_output.timestamp
+            if valid_thread_capture:
+                if image is None or timestamp is None:
+                    # Force the printout of the last error message since the capture failed.
+                    self._maybe_log_error(show_last_error=True)
+                return image, timestamp
+            else:
+                return self.capture_function(custom_params=custom_params, **capture_func_kwargs)
         else:
             # Call the capture function (which is wrapped with an error checker) to block and get the data.
-            return self.capture_function()
+            # capture_function already handles pre-3.3 blocking capture compatibility
+            return self.capture_function(custom_params=custom_params, **capture_func_kwargs)
 
     def image_decode_with_error_checking(self, image_data, image_proto, image_req):
         """Decode the image data into an Image proto based on the requested format and quality.
 
         Args:
             image_data(any format): The image data returned by the camera interface's
                                     blocking_capture function.
@@ -335,51 +388,55 @@
         """
         if self.capture_thread is not None:
             self.capture_thread.stop_capturing(timeout_secs)
 
     @staticmethod
     def make_image_source(source_name, rows=None, cols=None, pixel_formats=[],
                           image_type=image_pb2.ImageSource.IMAGE_TYPE_VISUAL,
-                          image_formats=[image_pb2.Image.FORMAT_JPEG]):
+                          image_formats=[image_pb2.Image.FORMAT_JPEG], param_spec=None):
         """Create an instance of the image_pb2.ImageSource for a given source name.
 
         Args:
             source_name (string): The name for the camera source.
             rows (int): The number of rows of pixels in the image.
             cols (int): The number of cols of pixels in the image.
             image_type (image_pb2.ImageType): The type of image (e.g. visual, depth).
             image_formats (image_pb2.Image.Format): The image formats supported (jpeg, raw)
             pixel_formats (image_pb2.Image.PixelFormat): The pixel formats supported
-
+            param_spec (service_customization_pb2.DictParam.Spec): A set of custom parameters 
+                                                                   passed into this image source
         Returns:
             An ImageSource with the cols, rows, and image type populated.
         """
         source = image_pb2.ImageSource()
         source.name = source_name
 
         if rows is not None and cols is not None:
             source.rows = rows
             source.cols = cols
 
         # Image from the ricoh theta is a JPEG, which is considered a visual image source (no depth data).
         source.image_type = image_type
         source.image_formats.extend(image_formats)
         source.pixel_formats.extend(pixel_formats)
+        if param_spec:
+            source.custom_params.CopyFrom(param_spec)
         return source
 
     @staticmethod
-    def make_capture_parameters(gain=None, exposure=None):
+    def make_capture_parameters(gain=None, exposure=None, request_custom_params=None):
         """Creates an instance of the image_pb2.CaptureParameters protobuf message.
 
         Args:
             gain (float | function): The sensor's gain in dB. This can be a fixed value or a function
                                      which returns the gain as a float.
             exposure (float | function): The exposure time for an image in seconds. This can be a fixed
                               value or a function which returns the exposure time as a float.
-
+            request_custom_params (service_customization_pb2.DictParam): Custom Params associated with the image 
+                            request. Should not be 'None', but left as an option to accomodate old callers
         Returns:
             An instance of the protobuf CaptureParameters message.
         """
         params = image_pb2.CaptureParameters()
         if gain:
             if callable(gain):
                 params.gain = gain()
@@ -388,69 +445,137 @@
         if exposure:
             if callable(exposure):
                 params.exposure_duration.CopyFrom(seconds_to_duration(exposure()))
             elif exposure == float('inf'):
                 params.exposure_duration.CopyFrom(seconds_to_duration(sys.maxsize))
             else:
                 params.exposure_duration.CopyFrom(seconds_to_duration(exposure))
+        if request_custom_params:
+            params.custom_params.CopyFrom(request_custom_params)
         return params
 
 
+class ThreadCaptureOutput:
+    """Small struct to represent the output of an ImageCaptureThread's get_latest_captured_image
+    in a future-compatible way
+    
+    Args:
+        is_valid (Boolean): Whether the latest capture uses the custom parameters and other arguments
+                            supplied in the latest request, and is therefore returned
+        image (Any | None): If the latest capture is valid, the image data in any format 
+                            (e.g. numpy, bytes, array)
+        timestamp (float): The timestamp that the latest valid capture was taken
+    """
+
+    def __init__(self, is_valid, image, timestamp):
+        self.is_valid = is_valid
+        self.image = image
+        self.timestamp = timestamp
+
+
 class ImageCaptureThread():
     """Continuously query and store the last successfully captured image and its
     associated timestamp for a single camera device.
 
     Args:
         image_source_name(string): The image source name.
         capture_func (CameraInterface.blocking_capture): The function capturing the image
                                                          data and timestamp.
         capture_period_secs (int): Amount of time (in seconds) between captures to wait
                                    before triggering the next capture. Defaults to
                                    0.05s between captures.
+        custom_params (service_customization_pb2.DictParam): Custom parameters passed to capture_func
+                                                             affecting the resulting capture
+        **capture_func_kwargs: Other keyword arguments for the capture_func
     """
 
-    def __init__(self, image_source_name, capture_func, capture_period_secs=0.05):
+    def __init__(self, image_source_name, capture_func, capture_period_secs=0.05,
+                 custom_params=None, **capture_func_kwargs):
         # Name of the image source that is being requested from.
         self.image_source_name = image_source_name
 
         # Indicate if the image capture thread is alive.
         self.stop_capturing_event = threading.Event()
 
         # Track the last image and timestamp for this image source.
         self.last_captured_image = None
         self.last_captured_time = None
 
+        # Has a capture with the latest parameters completed (not necessarily successfully)
+        self.has_updated_capture = False
+
         # Lock for the thread.
         self._thread_lock = threading.Lock()
         self._thread = None
 
         # The wait time between captures.
         self.capture_period_secs = capture_period_secs
 
+        # Custom parameters the thread is currently running with
+        self.custom_params = custom_params
+
+        #Other keyword arguments the thread is currently running with
+        self.capture_func_kwargs = capture_func_kwargs
+
+        # Original user-passed capture_func
+        self.init_capture_function = capture_func
+
         # Function that completes the capture
-        # expected function signature: blocking_capture_function(): returns (image data[numpy bytes array], time[float])
-        self.capture_function = capture_func
+        # Expected function signature: blocking_capture_function(custom_params=None): returns (image data[numpy bytes array], time[float])
+        self.capture_function = self._make_capture_func(capture_func, custom_params=None,
+                                                        **capture_func_kwargs)
 
     def start_capturing(self):
         """Start the background thread for the image captures."""
         print("Starting the thread for %s" % self.image_source_name)
         self._thread = threading.Thread(target=self._do_image_capture)
         self._thread.daemon = True
         self._thread.start()
 
+    def maybe_update_thread(self, custom_params=None, **capture_func_kwargs):
+        if custom_params != self.custom_params or capture_func_kwargs != self.capture_func_kwargs:
+            self.capture_function = self._make_capture_func(self.init_capture_function,
+                                                            custom_params, **capture_func_kwargs)
+            self.custom_params = custom_params
+            self.capture_func_kwargs = capture_func_kwargs
+            self.has_updated_capture = False
+
     def set_last_captured_image(self, image_frame, capture_time):
         """Update the last image capture and timestamp."""
         with self._thread_lock:
             self.last_captured_image = image_frame
             self.last_captured_time = capture_time
+            self.has_updated_capture = True
+
+    def get_latest_captured_image(self, custom_params=None, **capture_func_kwargs):
+        """Returns the last found image and timestamp in a ThreadCaptureOutput object if that 
+            image uses the latest params. Otherwise returns a ThreadCaptureOutput object with
+            is_valid = False and capture/timestamp as None.
+        """
 
-    def get_latest_captured_image(self):
-        """Returns the last found image and the timestamp it was acquired at."""
         with self._thread_lock:
-            return self.last_captured_image, self.last_captured_time
+            if (custom_params == self.custom_params and
+                    capture_func_kwargs == self.capture_func_kwargs and self.has_updated_capture):
+                return ThreadCaptureOutput(True, self.last_captured_image, self.last_captured_time)
+            else:
+                self.maybe_update_thread(custom_params=custom_params, **capture_func_kwargs)
+                return ThreadCaptureOutput(False, None, None)
+
+    def _make_capture_func(self, capture_func, custom_params=None, **capture_func_kwargs):
+        """Update the capture function to use custom_params and capture_func_kwargs if it can"""
+
+        # capture_func is likely provided through create_capture_thread, which already does handling for pre-3.3 blocking_capture
+        # Still, check for the custom_params argument to ensure we accomodate pre-3.3 direct implementations of ImageCaptureThreads
+        if "custom_params" in inspect.signature(capture_func).parameters.keys():
+            #If using a blocking capture function that takes in custom params or kwargs, one should supply those
+            output_capture_function = lambda: capture_func(custom_params=custom_params, **
+                                                           capture_func_kwargs)
+        else:
+            output_capture_function = capture_func
+        return output_capture_function
 
     def _do_image_capture(self):
         """Main loop for the image capture thread, which requests and saves images."""
         while not self.stop_capturing_event.isSet():
             # Get the image by calling the blocking capture function.
             start_time = time.time()
             capture, capture_time = self.capture_function()
@@ -478,18 +603,20 @@
         bosdyn_sdk_robot (Robot): The robot instance for the service to connect to.
         service_name (string): The name of the image service.
         image_sources(List[VisualImageSource]): The list of image sources (provided as a VisualImageSource).
         logger (logging.Logger): Logger for debug and warning messages.
         use_background_capture_thread (bool): If true, the image service will create a thread that continuously
             captures images so the image service can respond rapidly to the GetImage request. If false,
             the image service will call an image sources' blocking_capture_function during the GetImage request.
+        background_capture_params (service_customization_pb2.DictParam): If use_background_capture_thread is true,
+            custom image source parameters used for all of the background captures. Otherwise ignored
     """
 
     def __init__(self, bosdyn_sdk_robot, service_name, image_sources, logger=None,
-                 use_background_capture_thread=True):
+                 use_background_capture_thread=True, background_capture_params=None):
         super(CameraBaseImageServicer, self).__init__()
         if logger is None:
             # Set up the logger to remove duplicated messages and use a specific logging format.
             setup_logging(include_dedup_filter=True)
             self.logger = _LOGGER
         else:
             self.logger = logger
@@ -511,15 +638,15 @@
         for source in image_sources:
             # Set the logger for each visual image source to be the logger of the camera service class.
             source.set_logger(self.logger)
             # Set up the fault client so service faults can be created.
             source.initialize_faults(self.fault_client, self.service_name)
             # Potentially start the capture threads in the background.
             if use_background_capture_thread:
-                source.create_capture_thread()
+                source.create_capture_thread(background_capture_params)
             # Save the visual image source class associated with the image source name.
             self.image_sources_mapped[source.image_source_name] = source
 
     def ListImageSources(self, request, context):
         """Obtain the list of ImageSources for this given service.
 
         Args:
@@ -567,35 +694,50 @@
                 continue
 
             if img_req.resize_ratio < 0 or img_req.resize_ratio > 1:
                 img_resp.status = image_pb2.ImageResponse.STATUS_UNSUPPORTED_RESIZE_RATIO_REQUESTED
                 self.logger.warning("Resize ratio %f is unsupported.", img_req.resize_ratio)
                 continue
 
+            if img_req.HasField("custom_params"):
+                value_validation_error = self.image_sources_mapped[src_name].value_validator(
+                    img_req.custom_params)
+                if value_validation_error:
+                    img_resp.status = image_pb2.ImageResponse.STATUS_CUSTOM_PARAMS_ERROR
+                    img_resp.custom_param_error.CopyFrom(value_validation_error)
+                    continue
+
             # Set the image source information in the response.
             img_resp.source.CopyFrom(self.image_sources_mapped[src_name].image_source_proto)
 
             # Set the image capture parameters in the response.
             img_resp.shot.capture_params.CopyFrom(
-                self.image_sources_mapped[src_name].get_image_capture_params())
+                self.image_sources_mapped[src_name].get_image_capture_params(img_req.custom_params))
+
+            if img_req.HasField("custom_params"):
+                #If future keyword arguments are added here, they'll need to be added to this call
+                #get_image_and_timestamp already calls a 'sanitized' capture function that handles pre-3.3 blocking_captures
+                captured_image, img_time_seconds = self.image_sources_mapped[
+                    src_name].get_image_and_timestamp(custom_params=img_req.custom_params)
+            else:
+                #get_image_and_timestamp() can accomodate pre-3.3 blocking_capture calls if no custom params are supplied
+                captured_image, img_time_seconds = self.image_sources_mapped[
+                    src_name].get_image_and_timestamp()
 
-            captured_image, img_time_seconds = self.image_sources_mapped[
-                src_name].get_image_and_timestamp()
             if captured_image is None or img_time_seconds is None:
                 img_resp.status = image_pb2.ImageResponse.STATUS_IMAGE_DATA_ERROR
                 error_message = "Failed to capture an image from %s on the server." % src_name
                 response.header.error.message = error_message
                 self.logger.warning(error_message)
                 continue
 
             # Convert the image capture time from the local clock time into the robot's time. Then set it as
             # the acquisition timestamp for the image data.
             img_resp.shot.acquisition_time.CopyFrom(
-                self.bosdyn_sdk_robot.time_sync.robot_timestamp_from_local_secs(
-                    sec_to_nsec(img_time_seconds)))
+                self.bosdyn_sdk_robot.time_sync.robot_timestamp_from_local_secs(img_time_seconds))
 
             img_resp.shot.image.rows = img_resp.source.rows
             img_resp.shot.image.cols = img_resp.source.cols
 
             # Set the image data.
             img_resp.shot.image.format = img_req.image_format
             decode_status = self._set_format_and_decode(captured_image, img_resp.shot.image,
```

## bosdyn/client/ir_enable_disable.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """A client for the ir-enable-disable service."""
 from bosdyn.api import ir_enable_disable_pb2, ir_enable_disable_service_pb2_grpc
```

## bosdyn/client/lease.py

```diff
@@ -1,23 +1,21 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Lease clients"""
 
 import collections
 import enum
 import logging
 import threading
 import time
 
-import six
-
 from bosdyn.api import lease_pb2
 from bosdyn.api.lease_pb2 import AcquireLeaseRequest, AcquireLeaseResponse
 from bosdyn.api.lease_pb2 import Lease as LeaseProto
 from bosdyn.api.lease_pb2 import (LeaseUseResult, ListLeasesRequest, RetainLeaseRequest,
                                   ReturnLeaseRequest, ReturnLeaseResponse, TakeLeaseRequest,
                                   TakeLeaseResponse)
 from bosdyn.api.lease_service_pb2_grpc import LeaseServiceStub
```

## bosdyn/client/lease_resource_hierarchy.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Helper for managing hierarchy of lease resources."""
```

## bosdyn/client/lease_validator.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Lease validator tracks lease usage in intermediate services."""
```

## bosdyn/client/license.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """License client"""
```

## bosdyn/client/local_grid.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client support for the LocalGridService."""
```

## bosdyn/client/log_annotation.py

```diff
@@ -1,31 +1,30 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the log-annotation service (DEPRECATED).
 
 The log-annotation service is deprecated and will be removed in a later release.
 Instead, please use the data_buffer service going forward.
 """
-from __future__ import print_function
 
 import logging
 import random
 import string
 import struct
 import sys
 import threading
 import time
 import traceback
+from queue import Queue
 
-from deprecated import deprecated
-from six.moves.queue import Queue
+from deprecated.sphinx import deprecated
 
 import bosdyn.api.log_annotation_pb2 as log_annotation_protos
 import bosdyn.api.log_annotation_service_pb2_grpc as log_annotation_service
 from bosdyn import util as core_util
 from bosdyn.client import time_sync
 from bosdyn.client.common import BaseClient, common_header_errors
 from bosdyn.client.exceptions import Error, RpcError, ServerError
```

## bosdyn/client/manipulation_api_client.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Manipulation API service."""
```

## bosdyn/client/map_processing.py

```diff
@@ -1,15 +1,14 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients of the graph_nav map processing service."""
-from __future__ import print_function
 
 import collections
 from enum import Enum
 
 from bosdyn.api.graph_nav import map_pb2, map_processing_pb2, map_processing_service_pb2
 from bosdyn.api.graph_nav import map_processing_service_pb2_grpc as map_processing
 from bosdyn.client.common import (BaseClient, common_header_errors, error_factory,
```

## bosdyn/client/math_helpers.py

```diff
@@ -1,19 +1,18 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 import math
 import numbers
 
 import numpy
-import six
-from deprecated import deprecated
+from deprecated.sphinx import deprecated
 
 from bosdyn.api import geometry_pb2
 
 
 def recenter_value_mod(value, center, amplitude):
     new_value = (value - center) % amplitude + center
     if new_value >= (center + 0.5 * amplitude):
@@ -992,14 +991,68 @@
             s0 = math.cos(
                 theta) - dot * sin_theta / sin_theta_0  # == sin(theta_0 - theta) / sin(theta_0)
             s1 = sin_theta / sin_theta_0
 
             result = (s0 * v0) + (s1 * v1)
         return Quat(result[0], result[1], result[2], result[3])
 
+    @staticmethod
+    def from_two_vectors(u_in: Vec3, v_in: Vec3):
+        """ Returns a quaternion representing the rotation from u to v."""
+        # Normalizing by max avoids all sorts of underflow and overflow issues when we multiply
+        # terms together, including any issues in calculating the norm itself.
+        max_u = max([math.fabs(u_in[0]), math.fabs(u_in[1]), math.fabs(u_in[2])])
+        max_v = max([math.fabs(v_in[0]), math.fabs(v_in[1]), math.fabs(v_in[2])])
+        if max_u == 0 or max_v == 0:
+            # Undefined; return identity
+            return Quat(1, 0, 0, 0)
+        u = u_in * (1 / max_u)
+        v = v_in * (1 / max_v)
+
+        u_dot_v = u.dot(v)
+        u_dot_u = u.dot(u)
+        v_dot_v = v.dot(v)
+        norm_u_norm_v = math.sqrt(u_dot_u * v_dot_v)
+
+        if u_dot_v < 0:
+            #When this is the case, things get annoying because the |u||v| + u.v (see u_dot_v >= 0
+            #case below) has cancellation; this leads us to a different formula that is sensitive to
+            #the magnitude of c. If the vectors are close to antipodal, the cross product itself can
+            #be ill conditioned. Algebraically, u x (u + v) is equal to u x v, but, the result is
+            #much more likely to be orthogonal to u and v for extreme cases.
+            c = u.cross(u + v)
+            max_c = max([math.fabs(c[0]), math.fabs(c[1]), math.fabs(c[2])])
+            if max_c == 0:
+                # We pick an orthogonal axis, avoiding the smallest one
+                if abs(u[0]) > abs(u[1]):
+                    if abs(u[1]) > abs(u[2]):
+                        q = Quat(0, -u[1], u[0], 0)
+                        return q.normalize()
+                    else:
+                        q = Quat(0, u[2], 0, -u[0])
+                        return q.normalize()
+                elif abs(u[0]) > abs(u[2]):
+                    q = Quat(0, -u[1], u[0], 0)
+                    return q.normalize()
+                else:
+                    q = Quat(0, 0, -u[2], u[1])
+                    return q.normalize()
+            c_scl = (1 / max_c) * c
+            norm2_c_scl = c_scl.dot(c_scl)
+            tmp = (norm_u_norm_v - u_dot_v) * c_scl
+            q = Quat(norm2_c_scl * max_c, tmp[0], tmp[1], tmp[2])
+            return q.normalize()
+        else:
+            c = u.cross(v)
+            q = Quat(norm_u_norm_v + u_dot_v, c[0], c[1], c[2])
+            return q.normalize()
+
+    def conj(self):
+        return Quat(self.w, -self.x, -self.y, -self.z)
+
 
 def pose_to_xyz_yaw(A_tform_B):
     """Gets the x,y,z yaw of B in A from the SE3Pose protobuf message."""
     yaw = Quat.from_proto(A_tform_B.rotation).to_yaw()
     x = A_tform_B.position.x
     y = A_tform_B.position.y
     z = A_tform_B.position.z
```

## bosdyn/client/network_compute_bridge_client.py

```diff
@@ -1,22 +1,22 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the network compute bridge service."""
 
 import collections
 
 from bosdyn.api import (network_compute_bridge_pb2, network_compute_bridge_service_pb2,
                         network_compute_bridge_service_pb2_grpc)
 from bosdyn.client.common import (BaseClient, error_factory, error_pair,
-                                  handle_common_header_errors, handle_lease_use_result_errors,
-                                  handle_unset_status_error)
+                                  handle_common_header_errors, handle_custom_params_errors,
+                                  handle_lease_use_result_errors, handle_unset_status_error)
 from bosdyn.client.exceptions import Error, InternalServerError, ResponseError, UnsetStatusError
 
 
 class ExternalServiceNotFoundError(ResponseError):
     """The requested service for external computation was not found in the directory."""
 
 
@@ -116,14 +116,16 @@
     def network_compute_bridge_command_async(self, network_compute_request, **kwargs):
         """Async version of network_compute_bridge_command()."""
         return self.call_async(self._stub.NetworkCompute, network_compute_request, None,
                                _network_compute_error, **kwargs)
 
 
 @handle_common_header_errors
+@handle_custom_params_errors(
+    status_value=network_compute_bridge_pb2.NETWORK_COMPUTE_STATUS_CUSTOM_PARAMS_ERROR)
 def _network_compute_error(response):
     """Return a custom exception based on response, None if no error."""
     error_type, message = _NETWORK_COMPUTE_STATUS_TO_ERROR[response.status]
     # This status is not an error.
     if error_type is None:
         return None
 
@@ -132,19 +134,19 @@
 
 _NETWORK_COMPUTE_STATUS_TO_ERROR = collections.defaultdict(lambda: (ResponseError, None))
 _NETWORK_COMPUTE_STATUS_TO_ERROR.update({
     network_compute_bridge_pb2.NETWORK_COMPUTE_STATUS_UNKNOWN:
         error_pair(UnsetStatusError),
     network_compute_bridge_pb2.NETWORK_COMPUTE_STATUS_SUCCESS: (None, None),
     network_compute_bridge_pb2.NETWORK_COMPUTE_STATUS_EXTERNAL_SERVICE_NOT_FOUND:
-        (ExternalServiceNotFoundError, ExternalServiceNotFoundError.__doc__),
+        error_pair(ExternalServiceNotFoundError),
     network_compute_bridge_pb2.NETWORK_COMPUTE_STATUS_EXTERNAL_SERVER_ERROR:
-        (ExternalServerError, None),
+        error_pair(ExternalServerError),
     network_compute_bridge_pb2.NETWORK_COMPUTE_STATUS_ROTATION_ERROR:
-        (NetworkComputeRotationError, None),
+        error_pair(NetworkComputeRotationError),
 })
 
 
 @handle_common_header_errors
 def _list_available_models_error(response):
     """Return a custom exception based on response, None if no error."""
     error_type, message = _LIST_AVAILABLE_MODELS_STATUS_TO_ERROR[response.status]
```

## bosdyn/client/payload.py

```diff
@@ -1,20 +1,18 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the payload service.
 
 This allows client code to read from the robot payload registry.
 """
 
-from __future__ import print_function
-
 import logging
 
 import bosdyn.api.payload_pb2 as payload_protos
 import bosdyn.api.payload_pb2 as payload_service_protos
 import bosdyn.api.payload_service_pb2_grpc as payload_service
 
 from .common import BaseClient, common_header_errors
```

## bosdyn/client/payload_registration.py

```diff
@@ -1,20 +1,18 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the payload service.
 
 This allows client code to write to the robot payload registry.
 """
 
-from __future__ import print_function
-
 import collections
 import logging
 import threading
 import time
 
 import bosdyn.api.payload_registration_pb2 as payload_registration_protos
 import bosdyn.api.payload_registration_service_pb2_grpc as payload_registration_service
```

## bosdyn/client/point_cloud.py

```diff
@@ -1,20 +1,18 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client for the point cloud service.
 
 This allows client code to read from a point cloud service.
 """
 
-from __future__ import print_function
-
 import collections
 import logging
 
 import bosdyn.api.point_cloud_pb2 as point_cloud_protos
 import bosdyn.api.point_cloud_service_pb2_grpc as point_cloud_service
 from bosdyn.client.common import (common_header_errors, error_factory, error_pair,
                                   handle_common_header_errors)
```

## bosdyn/client/power.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the power command service."""
 import collections
@@ -43,14 +43,18 @@
     """Cannot power on while estopped; inspect EStopState for more info."""
 
 
 class OverriddenError(PowerResponseError):
     """The command was overridden and is no longer valid."""
 
 
+class KeepaliveMotorsOffError(PowerResponseError):
+    """Cannot power on while Keepalive requests motors off."""
+
+
 class FaultedError(PowerResponseError):
     """Cannot power on due to a fault; inspect FaultState for more info."""
 
 
 class PowerError(Error):
     """General class of errors to handle non-response non-grpc errors."""
 
@@ -199,14 +203,16 @@
     power_pb2.STATUS_BATTERY_MISSING: (BatteryMissingError, BatteryMissingError.__doc__),
     power_pb2.STATUS_COMMAND_IN_PROGRESS: (CommandInProgressError, CommandInProgressError.__doc__),
     power_pb2.STATUS_ESTOPPED: (EstoppedError, EstoppedError.__doc__),
     power_pb2.STATUS_FAULTED: (FaultedError, FaultedError.__doc__),
     power_pb2.STATUS_INTERNAL_ERROR: (InternalServerError, InternalServerError.__doc__),
     power_pb2.STATUS_LICENSE_ERROR: (LicenseError, LicenseError.__doc__),
     power_pb2.STATUS_OVERRIDDEN: (OverriddenError, OverriddenError.__doc__),
+    power_pb2.STATUS_KEEPALIVE_MOTORS_OFF:
+        (KeepaliveMotorsOffError, KeepaliveMotorsOffError.__doc__),
 })
 
 
 def _power_status_from_response(response):
     return response.status
```

## bosdyn/client/processors.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Common message processors."""
```

## bosdyn/client/ray_cast.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Client implementation of the RayCast service."""
```

## bosdyn/client/recording.py

```diff
@@ -1,15 +1,14 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to use the graph nav recording service"""
-from __future__ import print_function
 
 import collections
 from enum import Enum
 
 from bosdyn.api.graph_nav import map_pb2, nav_pb2, recording_pb2, recording_service_pb2
 from bosdyn.api.graph_nav import recording_service_pb2_grpc as recording_service
 from bosdyn.client.common import (BaseClient, common_header_errors, error_factory,
@@ -37,31 +36,50 @@
     def start_recording(self, lease=None, recording_environment=None, require_fiducials=None,
                         **kwargs):
         """Start the recording service to create/update a map.
 
         Args:
             lease: Leases to show ownership of necessary resources. Will use the client's leases by default.
             recording_environment: RecordingEnvironment protobuf to be used for the initial waypoint created at start.
+            require_fiducials: Boolean to show whether a fiducial is needed to start the recording.
         Returns:
             The status of the start recording request.
         """
         request = self._build_start_recording_request(lease, recording_environment,
                                                       require_fiducials)
         return self.call(self._stub.StartRecording, request, value_from_response=_get_status,
                          error_from_response=_start_recording_error, copy_request=False, **kwargs)
 
+    def start_recording_full(self, lease=None, recording_environment=None, require_fiducials=None,
+                             **kwargs):
+        """Same as start_recording() but returns a full response"""
+        request = self._build_start_recording_request(lease, recording_environment,
+                                                      require_fiducials)
+        return self.call(self._stub.StartRecording, request, value_from_response=_get_response,
+                         error_from_response=_start_recording_error, copy_request=False, **kwargs)
+
     def start_recording_async(self, lease=None, recording_environment=None, require_fiducials=None,
                               **kwargs):
         """Async version of start_recording()."""
         request = self._build_start_recording_request(lease, recording_environment,
                                                       require_fiducials)
         return self.call_async(self._stub.StartRecording, request, value_from_response=_get_status,
                                error_from_response=_start_recording_error, copy_request=False,
                                **kwargs)
 
+    def start_recording_full_async(self, lease=None, recording_environment=None,
+                                   require_fiducials=None, **kwargs):
+        """Async version of start_recording_full()."""
+        request = self._build_start_recording_request(lease, recording_environment,
+                                                      require_fiducials)
+        return self.call_async(self._stub.StartRecording, request,
+                               value_from_response=_get_response,
+                               error_from_response=_start_recording_error, copy_request=False,
+                               **kwargs)
+
     def stop_recording(self, lease=None, **kwargs):
         """Stop the recording service.
 
         Args:
             lease: Leases to show ownership of necessary resources. Will use the client's leases by default.
         Returns:
             The status of the start recording request.
@@ -369,21 +387,22 @@
 class FiducialPoseError(RecordingServiceResponseError):
     """The pose of one or more required fiducials could not be determined accurately."""
 
 
 class RobotImpairedError(RecordingServiceResponseError):
     """Failed to start recording because the robot is impaired."""
 
-    def __init__(self, response, message):
-        RecordingServiceResponseError.__init__(self, response, message)
+    def __init__(self, response, error_message):
+        RecordingServiceResponseError.__init__(self, response, error_message)
         self.impaired_state = response.impaired_state
 
     def __str__(self):
         base = RecordingServiceResponseError.__str__(self)
         base += "\nImpaired state: {}".format(self.impaired_state)
+        return base
 
 
 def _get_status(response):
     return response.status
 
 
 def _get_response(response):
```

## bosdyn/client/robot.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Settings common to a user's access to one robot."""
 import copy
@@ -111,14 +111,15 @@
         self.token_cache = TokenCache()
         self._token_manager = None
         self._current_user = None
         self.service_clients_by_name = {}
         self.channels_by_authority = {}
         self.authorities_by_name = {}
         self._robot_id = None
+        self._hardware_config = None
         self._has_arm = None
         self._secure_channel_port = _DEFAULT_SECURE_CHANNEL_PORT
 
 
         # Things usually updated from an Sdk object.
         self.service_client_factories_by_type = {}
         self.service_type_by_name = {}
@@ -194,15 +195,15 @@
         self.cert = copy.deepcopy(other.cert)
         self.logger = other.logger.getChild(self._name or 'Robot')
         self.max_send_message_length = other.max_send_message_length
         self.max_receive_message_length = other.max_receive_message_length
         self.client_name = other.client_name
         self.lease_wallet.set_client_name(self.client_name)
 
-    def ensure_client(self, service_name, channel=None, options=[]):
+    def ensure_client(self, service_name, channel=None, options=[], service_endpoint=None):
         """Ensure a Client for a given service.
         Note: If a new service has been registered with the directory service, this may raise
         UnregisteredServiceNameError when trying to connect to it until sync_with_directory() is
         called.
 
         Args:
             service_name: The name of the service.
@@ -229,35 +230,52 @@
         except KeyError:
             raise UnregisteredServiceTypeError(service_type)
 
         client = creation_function()
         self.logger.debug('Created client for %s', service_name)
 
         if channel is None:
-            channel = self.ensure_channel(service_name, options=options)
+            channel = self.ensure_channel(service_name, options=options,
+                                          service_endpoint=service_endpoint)
 
         client.channel = channel
         client.update_from(self)
         # Track service clients that have been created to avoid duplicate clients
         self.service_clients_by_name[service_name] = client
         return client
 
+    def shutdown(self):
+        for channel_from_auth in self.channels_by_authority.values():
+            channel_from_auth.close()
+
     def get_cached_robot_id(self):
         """Return the RobotId proto for this robot, querying it from the robot if not yet cached.
 
         Raises:
             RpcError: There as a problem communicating with the robot.
         """
         if not self._robot_id:
             robot_id_client = self.ensure_client('robot-id')
             self._robot_id = robot_id_client.get_id()
         return self._robot_id
 
+    def get_cached_hardware_hardware_configuration(self):
+        """Return the HardwareConfiguration proto for this robot, querying it from the robot if not
+        yet cached.
+        
+        Raises:
+            RpcError: There as a problem communicating with the robot.
+        """
+        if not self._hardware_config:
+            client = self.ensure_client(RobotStateClient.default_service_name)
+            self._hardware_config = client.get_robot_hardware_configuration()
+        return self._hardware_config
+
 
-    def ensure_channel(self, service_name, options=[]):
+    def ensure_channel(self, service_name, options=[], service_endpoint=None):
         """Verify the right information exists before calling the ensure_secure_channel
         method.
 
         Args:
             service_name: Name of the service in the directory.
         Returns:
             Existing channel if found, or newly created channel if not found.
```

## bosdyn/client/robot_command.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the robot command service."""
 import collections
@@ -73,14 +73,24 @@
     """The API supports this request, but the system does not support this request."""
 
 
 class CommandFailedError(Error):
     """Command indicated it failed in its feedback."""
 
 
+class CommandFailedErrorWithFeedback(CommandFailedError):
+    """Command indicated it failed in its feedback.
+    This subclass contains the feedback response causing the error.
+    """
+
+    def __init__(self, message, feedback):
+        super().__init__(message)
+        self.feedback = feedback
+
+
 class CommandTimedOutError(Error):
     """Timed out waiting for SUCCESS response from robot command."""
 
 
 class UnknownFrameError(RobotCommandResponseError):
     """Robot does not know how to handle supplied frame."""
 
@@ -118,14 +128,22 @@
         """Calls RobotTimeConverter.robot_timestamp_from_local_secs().
 
         Args:
             end_time_secs: Time in seconds to convert.
         """
         return self.obj.robot_timestamp_from_local_secs(end_time_secs)
 
+    def local_seconds_from_robot_timestamp(self, robot_timestamp):
+        """Calls RobotTimeConverter.local_seconds_from_robot_timestamp().
+
+        Args:
+          local_time_secs:  Local system time, in seconds from the unix epoch.
+        """
+        return self.obj.local_seconds_from_robot_timestamp(robot_timestamp)
+
 
 # Tree of proto-fields leading to end_time fields needing to be set from end_time_secs.
 END_TIME_EDIT_TREE = {
     'synchronized_command': {
         'mobility_command': {
             '@command': {  # 'command' is a oneof submessage
                 'se2_velocity_request': {
@@ -170,15 +188,15 @@
     'synchronized_command': {
         'mobility_command': {
             '@command': {
                 'se2_trajectory_request': {
                     'trajectory': {
                         'reference_time': None
                     }
-                }
+                },
             }
         },
         'gripper_command': {
             '@command': {
                 'claw_gripper_command': {
                     'trajectory': {
                         'reference_time': None
@@ -224,14 +242,33 @@
                     'reference_time': None
                 }
             }
         }
     }
 }
 
+# Tree of proto fields leading to Timestamp protos which need to be converted from
+#  client clock to robot clock values using timesync information from the robot.
+# Note, the "@" sign indicates a oneof field. The "None" indicates the field which
+# contains the timestamp to be updated.
+MOBILITY_PARAM_TREE_CONVERT_LOCAL_TIME_TO_ROBOT_TIME = {
+    'body_control': {
+        '@param': {
+            'base_offset_rt_footprint': {
+                'reference_time': None
+            },
+            'body_pose': {
+                'base_offset_rt_root': {
+                    'reference_time': None
+                }
+            }
+        }
+    }
+}
+
 
 def _edit_proto(proto, edit_tree, edit_fn):
     """Recursion to update specified fields of a protobuf using a specified edit-function.
 
     Args:
         proto: Protobuf to edit recursively.
         edit_tree: Part of the tree to edit.
@@ -467,14 +504,20 @@
 
         # Set fields needing to be set from end_time_secs.
         if end_time_secs:
             _edit_proto(command, END_TIME_EDIT_TREE, _set_end_time)
 
         # Convert timestamps from local time to robot time.
         _edit_proto(command, EDIT_TREE_CONVERT_LOCAL_TIME_TO_ROBOT_TIME, _to_robot_time)
+        if command.synchronized_command.mobility_command.HasField("params"):
+            params = spot_command_pb2.MobilityParams()
+            command.synchronized_command.mobility_command.params.Unpack(params)
+            _edit_proto(params, MOBILITY_PARAM_TREE_CONVERT_LOCAL_TIME_TO_ROBOT_TIME,
+                        _to_robot_time)
+            command.synchronized_command.mobility_command.params.Pack(params)
 
     @staticmethod
     def _get_robot_command_feedback_request(robot_command_id):
         """Create RobotCommandFeedbackRequest message with the given command id.
 
         Args:
             robot_command_id: Command id to specify in the request message.
@@ -697,42 +740,53 @@
         """
         full_body_command = full_body_command_pb2.FullBodyCommand.Request(
             safe_power_off_request=basic_command_pb2.SafePowerOffCommand.Request())
         command = robot_command_pb2.RobotCommand(full_body_command=full_body_command)
         return command
 
     @staticmethod
-    def constrained_manipulation_command(task_type, init_wrench_direction_in_frame_name,
-                                         force_limit, torque_limit, frame_name,
-                                         tangential_speed=None, rotational_speed=None):
+    def constrained_manipulation_command(
+        task_type, init_wrench_direction_in_frame_name, force_limit, torque_limit, frame_name,
+        tangential_speed=None, rotational_speed=None, target_linear_position=None,
+        target_angle=None,
+        control_mode=basic_command_pb2.ConstrainedManipulationCommand.Request.CONTROL_MODE_VELOCITY,
+        reset_estimator=wrappers_pb2.BoolValue(value=True)):
         """Command constrained manipulation. """
-        if (tangential_speed is not None):
-            full_body_command = full_body_command_pb2.FullBodyCommand.Request(
-                constrained_manipulation_request=basic_command_pb2.ConstrainedManipulationCommand.
-                Request(task_type=task_type,
-                        init_wrench_direction_in_frame_name=init_wrench_direction_in_frame_name,
-                        frame_name=frame_name, tangential_speed=tangential_speed))
-        elif (rotational_speed is not None):
-            full_body_command = full_body_command_pb2.FullBodyCommand.Request(
-                constrained_manipulation_request=basic_command_pb2.ConstrainedManipulationCommand.
-                Request(task_type=task_type,
-                        init_wrench_direction_in_frame_name=init_wrench_direction_in_frame_name,
-                        frame_name=frame_name, rotational_speed=rotational_speed))
-        else:
+        if (tangential_speed is None and rotational_speed is None):
             raise Exception("Need either translational or rotational speed")
+        if (target_angle and target_linear_position):
+            raise Exception("Both target_angle and target_linear_position were specified.")
+
+        in_position_control = control_mode == basic_command_pb2.ConstrainedManipulationCommand.Request.CONTROL_MODE_POSITION
+        if (in_position_control and not (target_angle or target_linear_position)):
+            raise Exception(
+                "We are in position control mode, but neither target angle nor position were specified."
+            )
+
+        full_body_command = full_body_command_pb2.FullBodyCommand.Request(
+            constrained_manipulation_request=basic_command_pb2.ConstrainedManipulationCommand.
+            Request(task_type=task_type,
+                    init_wrench_direction_in_frame_name=init_wrench_direction_in_frame_name,
+                    frame_name=frame_name, tangential_speed=tangential_speed,
+                    rotational_speed=rotational_speed, target_angle=target_angle,
+                    target_linear_position=target_linear_position, control_mode=control_mode,
+                    reset_estimator=reset_estimator))
+
         full_body_command.constrained_manipulation_request.force_limit.value = force_limit
         full_body_command.constrained_manipulation_request.torque_limit.value = torque_limit
         command = robot_command_pb2.RobotCommand(full_body_command=full_body_command)
         return command
 
     ###################################
     # Mobility commands  - DEPRECATED #
     ###################################
 
     @staticmethod
+    @deprecated(reason='Mobility commands are now sent as a part of synchronized commands. '
+                'Use synchro_se2_trajectory_command instead.', version='2.1.0', action="always")
     def trajectory_command(goal_x, goal_y, goal_heading, frame_name, params=None, body_height=0.0,
                            locomotion_hint=spot_command_pb2.HINT_AUTO):
         """
         Command robot to move to pose along a 2D plane. Pose can be specified in the world
         (kinematic odometry) frame or the robot body frame. The arguments body_height and
         locomotion_hint are ignored if params argument is passed.
 
@@ -1217,24 +1271,29 @@
             arm_command=arm_command)
         robot_command = robot_command_pb2.RobotCommand(synchronized_command=synchronized_command)
         if build_on_command:
             return RobotCommandBuilder.build_synchro_command(build_on_command, robot_command)
         return robot_command
 
     @staticmethod
-    def arm_pose_command(x, y, z, qw, qx, qy, qz, frame_name, seconds=5, build_on_command=None):
+    def arm_pose_command_from_pose(hand_pose, frame_name, seconds=5, build_on_command=None):
         """ Builds an SE3Trajectory Point to tell robot arm to move to a pose in space
         relative to the frame specified. Wraps it in SynchronizedCommand.
 
+        Args:
+            hand_pose(geometry_pb2.SE3Pose): Protobuf message specifying the desired pose of the
+                hand.
+            frame_name(string): Name of the frame relative to which `hand_pose` is expressed.
+            seconds(float): Requested duration of the arm move.
+            build_on_command(robot_command_pb2.RobotCommand): Optional RobotCommand (not
+                containing a full_body_command). A mobility_command and gripper_command from
+                `build_on_command` will be added to the RobotCommand returned by this function.
+
         Returns:
             RobotCommand, which can be issued to the robot command service."""
-        position = geometry_pb2.Vec3(x=x, y=y, z=z)
-        rotation = geometry_pb2.Quaternion(w=qw, x=qx, y=qy, z=qz)
-        hand_pose = geometry_pb2.SE3Pose(position=position, rotation=rotation)
-
         duration = seconds_to_duration(seconds)
         hand_pose_traj_point = trajectory_pb2.SE3TrajectoryPoint(pose=hand_pose,
                                                                  time_since_reference=duration)
         hand_trajectory = trajectory_pb2.SE3Trajectory(points=[hand_pose_traj_point])
 
         arm_cartesian_command = arm_command_pb2.ArmCartesianCommand.Request(
             root_frame_name=frame_name, pose_trajectory_in_task=hand_trajectory)
@@ -1244,14 +1303,28 @@
             arm_command=arm_command)
         robot_command = robot_command_pb2.RobotCommand(synchronized_command=synchronized_command)
         if build_on_command:
             return RobotCommandBuilder.build_synchro_command(build_on_command, robot_command)
         return robot_command
 
     @staticmethod
+    def arm_pose_command(x, y, z, qw, qx, qy, qz, frame_name, seconds=5, build_on_command=None):
+        """ Builds an SE3Trajectory Point to tell robot arm to move to a pose in space
+        relative to the frame specified. Wraps it in SynchronizedCommand.
+
+        Returns:
+            RobotCommand, which can be issued to the robot command service."""
+        position = geometry_pb2.Vec3(x=x, y=y, z=z)
+        rotation = geometry_pb2.Quaternion(w=qw, x=qx, y=qy, z=qz)
+        hand_pose = geometry_pb2.SE3Pose(position=position, rotation=rotation)
+        return RobotCommandBuilder.arm_pose_command_from_pose(hand_pose, frame_name,
+                                                              seconds=seconds,
+                                                              build_on_command=build_on_command)
+
+    @staticmethod
     def arm_wrench_command(force_x, force_y, force_z, torque_x, torque_y, torque_z, frame_name,
                            seconds=5, build_on_command=None):
         """ Builds a command to tell robot arm to exhibit a wrench.
             Wraps it in a SynchronizedCommand.
 
         Returns:
             RobotCommand, which can be issued to the robot command service."""
@@ -1357,16 +1430,23 @@
         sync_arm = synchronized_command_pb2.SynchronizedCommand.Request(arm_command=arm_command)
         arm_sync_robot_cmd = robot_command_pb2.RobotCommand(synchronized_command=sync_arm)
         if build_on_command:
             return RobotCommandBuilder.build_synchro_command(build_on_command, arm_sync_robot_cmd)
         return arm_sync_robot_cmd
 
     @staticmethod
-    def arm_joint_move_helper(joint_positions, times, joint_velocities=None, ref_time=None,
-                              max_acc=None, max_vel=None):
+    def arm_joint_move_helper(
+            joint_positions,
+            times,
+            joint_velocities=None,
+            ref_time=None,
+            max_acc=None,
+            max_vel=None,
+            build_on_command=None,
+    ):
         """Given a set of joint positions, times, and optional velocity, create a synchro command.
 
         Args:
             joint_positions: A list of length N with joint positions at each knot point in our
                             trajectory. Each knot joint position is represented as a list of length 6,
                             representing the 6 joint angles [sh0, sh1, el0, el1, wr0, wr1]
             times: A list of length N with the corresponding time_since_reference for each of our knots
@@ -1375,30 +1455,34 @@
                         time. Setting this is useful for getting a consistent trajectory over a long
                         period of time when many ArmJointMoveRequest commands are chained together.
             max_acc: Optional maximum allowable joint acceleration. Not setting this will lead to the
                         robot using a relatively safe low default. If the user is sure their joint
                         trajectory is safe and achievable, this can be set to a large value so it
                         doesn't get in the way.
             max_vel: Optional maximum allowable joint velocity. Same thing about defaults as max_acc
+            build_on_command: Option to input a RobotCommand (not containing a full_body_command). A
+                mobility_command and gripper_command from this incoming RobotCommand will be added
+                to the returned RobotCommand.
 
         Returns:
             robot_command_pb2.RobotCommand with an arm_joint_move_command filled out.
         """
 
+        assert joint_positions is not None, "Must pass in a list of joint positions"
+        assert times is not None, "Must pass in a list of times"
         assert len(joint_positions) == len(
             times), "Number of joint positions must match number of times"
         if joint_velocities is not None:
             assert len(joint_velocities) == len(
                 times), "Number of joint velocities must match number of times"
 
         # Create an arm joint move command, and set the trajectory
         robot_cmd = robot_command_pb2.RobotCommand()
         arm_joint_traj = (
             robot_cmd.synchronized_command.arm_command.arm_joint_move_command.trajectory)
-
         for i in range(len(times)):
             # Add a new trajectory point to our trajectory
             traj_point = arm_joint_traj.points.add()
 
             joints = joint_positions[i]
             assert len(joints) == 6, "Need 6 joint positions per knot point for this helper"
             # Note that although we're setting all 6 joint angles here, the actual
@@ -1441,14 +1525,86 @@
             # If unset, a safe default will be used
             arm_joint_traj.maximum_acceleration.value = max_acc
         if max_vel is not None:
             # Set a maximum allowable joint velocity if desired.
             # If unset, a safe default will be used
             arm_joint_traj.maximum_velocity.value = max_vel
 
+        if build_on_command:
+            return RobotCommandBuilder.build_synchro_command(build_on_command, robot_cmd)
+        return robot_cmd
+
+    @staticmethod
+    def claw_gripper_command_helper(gripper_positions, times, gripper_velocities=None,
+                                    ref_time=None, max_acc=None, max_vel=None,
+                                    disable_force_on_contact=False, build_on_command=None):
+        """Given a set of gripper positions, times, and optional velocities, create a synchro command.
+
+        Args:
+            gripper_positions: A list of length N with joint positions at each knot point in our
+                            trajectory.
+            times: A list of length N with the corresponding time_since_reference for each of our knots
+            gripper_velocities: Optional joint velocities at each knot. Same structure as gripper_positions.
+            ref_time: Optional robot reference time. If unset, we'll use the current synchronized robot
+                        time. Setting this is useful for getting a consistent trajectory over a long
+                        period of time when many ClawGripperCommandRequest commands are chained together.
+            max_acc: Optional maximum allowable gripper acceleration. Not setting this will lead to the
+                        robot using a relatively safe low default. If the user is sure their gripper
+                        trajectory is safe and achievable, this can be set to a large value so it
+                        doesn't get in the way.
+            max_vel: Optional maximum allowable gripper velocity. Same thing about defaults as max_acc.
+            disable_force_on_contact: Whether to switch the gripper to force control on contact detection.
+            build_on_command: Option to input a RobotCommand (not containing a full_body_command). An
+                arm_command and mobility_command from this incoming RobotCommand will be added
+                to the returned RobotCommand.
+
+        Returns:
+            robot_command_pb2.RobotCommand with a claw_gripper_command filled out.
+        """
+        assert gripper_positions is not None, "Must pass in a list of gripper positions"
+        assert times is not None, "Must pass in a list of times"
+        assert len(gripper_positions) == len(
+            times), "Number of gripper positions must match number of times"
+        if gripper_velocities is not None:
+            assert len(gripper_velocities) == len(
+                times), "Number of gripper velocities must match number of times"
+
+        # Create a claw gripper command, and set the trajectory
+        robot_cmd = robot_command_pb2.RobotCommand()
+        gripper_cmd = robot_cmd.synchronized_command.gripper_command.claw_gripper_command
+        gripper_traj = gripper_cmd.trajectory
+
+        for i in range(len(times)):
+            # Add a new trajectory point to our trajectory
+            traj_point = gripper_traj.points.add()
+            traj_point.point = gripper_positions[i]
+            if gripper_velocities is not None:
+                traj_point.velocity.value = gripper_velocities[i]
+
+            # Set our time_since_reference for this trajectory point
+            traj_point.time_since_reference.CopyFrom(seconds_to_duration(times[i]))
+
+        # Set our other optional arguments
+        if ref_time is not None:
+            # Set a reference time if desired. If not, we'll automatically set the reference time
+            # to be the current robot-synchronized time
+            gripper_traj.reference_time.CopyFrom(ref_time)
+        if max_acc is not None:
+            # Set a maximum allowable joint acceleration if desired.
+            # If unset, a safe default will be used
+            gripper_cmd.maximum_open_close_acceleration.value = max_acc
+        if max_vel is not None:
+            # Set a maximum allowable joint velocity if desired.
+            # If unset, a safe default will be used
+            gripper_cmd.maximum_open_close_velocity.value = max_vel
+
+        gripper_cmd.disable_force_on_contact = disable_force_on_contact
+
+        if build_on_command:
+            return RobotCommandBuilder.build_synchro_command(build_on_command, robot_cmd)
         return robot_cmd
 
     ########################
     # Spot mobility params #
     ########################
 
     @staticmethod
@@ -1483,14 +1639,29 @@
         traj = trajectory_pb2.SE3Trajectory(points=[point])
         body_control = spot_command_pb2.BodyControlParams(base_offset_rt_footprint=traj)
         return spot_command_pb2.MobilityParams(
             body_control=body_control, locomotion_hint=locomotion_hint, stair_hint=stair_hint,
             external_force_params=external_force_params, stairs_mode=stairs_mode)
 
     @staticmethod
+    def body_pose(frame_name, body_pose):
+        """Helper to create a BodyControlParams.BodyPose from a single desired `body_pose` relative to `frame_name`.
+
+        Args:
+            frame_name(string): Name of the frame relative to which `body_pose` is expressed.
+            body_pose(geometry_pb2.SE3Pose): Protobuf message specifying the desired pose of the
+                body.
+        Returns:
+            spot.BodyControlParams.BodyPose, specifies the desired body pose for a StandCommand
+        """
+        return spot_command_pb2.BodyControlParams.BodyPose(
+            root_frame_name=frame_name, base_offset_rt_root=trajectory_pb2.SE3Trajectory(
+                points=[trajectory_pb2.SE3TrajectoryPoint(pose=body_pose)]))
+
+    @staticmethod
     def build_body_external_forces(
             external_force_indicator=spot_command_pb2.BodyExternalForceParams.EXTERNAL_FORCE_NONE,
             override_external_force_vec=None):
         """Helper to create Mobility params.
 
         This function allows the user to enable an external force estimator, or set a vector of
         forces (in the body frame) which override the estimator with constant external forces.
@@ -1569,184 +1740,194 @@
             robot_command = robot_command_pb2.RobotCommand(
                 synchronized_command=synchronized_command)
         else:
             raise Exception("Nothing to build here")
         return robot_command
 
 
-def blocking_stand(command_client, timeout_sec=10, update_frequency=1.0, params=None):
-    """Helper function which uses the RobotCommandService to stand.
-
-    Blocks until robot is standing, or raises an exception if the command times out or fails.
+def blocking_command(command_client, command, check_status_fn, end_time_secs=None, timeout_sec=10,
+                     update_frequency=1.0):
+    """Helper function which uses the RobotCommandService to execute the given command.
+
+    Blocks until check_status_fn return true, or raises an exception if the command times out or fails.
+    This helper checks the main full_body/synchronized command status (RobotCommandFeedbackStatus), but
+    the caller should check the status of the specific commands (stand, stow, selfright, etc) in the callback.
 
     Args:
         command_client: RobotCommand client.
-        timeout_sec: Timeout for the command in seconds.
+        command: The robot command to issue to the robot.
+        check_status_fn: A callback that accepts RobotCommandFeedbackResponse and returns True when the
+                         correct status's are achieved for the specific requested command and throws 
+                         CommandFailedErrorWithFeedback if an error state occurs.
+        end_time_sec: The local end time of the command (will be converted to robot time)
+        timeout_sec: Timeout for the rpc in seconds.
         update_frequency: Update frequency for the command in Hz.
-        params(spot.MobilityParams): Spot specific parameters for mobility commands to optionally set say body_height
 
     Raises:
-        CommandFailedError: Command feedback from robot is not STATUS_PROCESSING.
+        CommandFailedErrorWithFeedback: Command feedback from robot is not STATUS_PROCESSING.
         bosdyn.client.robot_command.CommandTimedOutError: Command took longer than provided
             timeout.
     """
 
+    def raise_not_processing(command_id, feedback_status, response):
+        raise CommandFailedErrorWithFeedback(
+            'Command (ID {}) no longer processing ({})'.format(
+                command_id,
+                basic_command_pb2.RobotCommandFeedbackStatus.Status.Name(feedback_status)),
+            response)
+
     start_time = time.time()
     end_time = start_time + timeout_sec
     update_time = 1.0 / update_frequency
 
-    stand_command = RobotCommandBuilder.synchro_stand_command(params=params)
-    command_id = command_client.robot_command(stand_command, timeout=timeout_sec)
+    command_id = command_client.robot_command(command, timeout=timeout_sec,
+                                              end_time_secs=end_time_secs)
 
     now = time.time()
     while now < end_time:
         time_until_timeout = end_time - now
         rpc_timeout = max(time_until_timeout, 1)
         start_call_time = time.time()
         try:
             response = command_client.robot_command_feedback(command_id, timeout=rpc_timeout)
-            mob_feedback = response.feedback.synchronized_feedback.mobility_command_feedback
-            mob_status = mob_feedback.status
-            stand_status = mob_feedback.stand_feedback.status
         except TimedOutError:
             # Excuse the TimedOutError and let the while check bail us out if we're out of time.
             pass
         else:
-            if mob_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
-                raise CommandFailedError('Stand (ID {}) no longer processing (now {})'.format(
-                    command_id,
-                    basic_command_pb2.RobotCommandFeedbackStatus.Status.Name(mob_status)))
-            if stand_status == basic_command_pb2.StandCommand.Feedback.STATUS_IS_STANDING:
+            # Check the high level robot command status'
+            if response.feedback.HasField("full_body_feedback"):
+                full_body_status = response.feedback.full_body_feedback.status
+                if full_body_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
+                    raise_not_processing(command_id, full_body_status, response)
+            elif response.feedback.HasField("synchronized_feedback"):
+                synchro_fb = response.feedback.synchronized_feedback
+                # Mobility Feedback
+                if synchro_fb.HasField("mobility_command_feedback"):
+                    mob_status = synchro_fb.mobility_command_feedback.status
+                    if mob_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
+                        raise_not_processing(command_id, mob_status, response)
+                # Arm Feedback
+                if synchro_fb.HasField("arm_command_feedback"):
+                    arm_status = synchro_fb.arm_command_feedback.status
+                    if arm_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
+                        raise_not_processing(command_id, arm_status, response)
+                # Gripper Feedback
+                if synchro_fb.HasField("gripper_command_feedback"):
+                    gripper_status = synchro_fb.gripper_command_feedback.status
+                    if gripper_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
+                        raise_not_processing(command_id, gripper_status, response)
+            else:
+                raise CommandFailedErrorWithFeedback(
+                    'Command (ID {}) has neither full body nor synchronized feedback'.format(
+                        command_id), response)
+
+            # Check low level command specific status'
+            if check_status_fn(response):
                 return
+
         delta_t = time.time() - start_call_time
         time.sleep(max(min(delta_t, update_time), 0.0))
         now = time.time()
 
     raise CommandTimedOutError(
-        "Took longer than {:.1f} seconds to assure the robot stood.".format(now - start_time))
+        "Took longer than {:.1f} seconds to execute the command.".format(now - start_time))
+
+
+def blocking_stand(command_client, timeout_sec=10, update_frequency=1.0, params=None):
+    """Helper function which uses the RobotCommandService to stand.
+
+    Blocks until robot is standing, or raises an exception if the command times out or fails.
+
+    Args:
+        command_client: RobotCommand client.
+        timeout_sec: Timeout for the command in seconds.
+        update_frequency: Update frequency for the command in Hz.
+        params(spot.MobilityParams): Spot specific parameters for mobility commands to optionally set say body_height
+
+    Raises:
+        CommandFailedErrorWithFeedback: Command feedback from robot is not STATUS_PROCESSING.
+        bosdyn.client.robot_command.CommandTimedOutError: Command took longer than provided
+            timeout.
+    """
+
+    def check_stand_status(response):
+        status = response.feedback.synchronized_feedback.mobility_command_feedback.stand_feedback.status
+        return status == basic_command_pb2.StandCommand.Feedback.STATUS_IS_STANDING
+
+    stand_command = RobotCommandBuilder.synchro_stand_command(params=params)
+    blocking_command(command_client, stand_command, check_stand_status, timeout_sec=timeout_sec,
+                     update_frequency=update_frequency)
 
 
 def blocking_sit(command_client, timeout_sec=10, update_frequency=1.0):
     """Helper function which uses the RobotCommandService to sit.
 
     Blocks until robot is sitting, or raises an exception if the command times out or fails.
 
     Args:
         command_client: RobotCommand client.
         timeout_sec: Timeout for the command in seconds.
         update_frequency: Update frequency for the command in Hz.
 
     Raises:
-        CommandFailedError: Command feedback from robot is not STATUS_PROCESSING.
+        CommandFailedErrorWithFeedback: Command feedback from robot is not STATUS_PROCESSING.
         bosdyn.client.robot_command.CommandTimedOutError: Command took longer than provided
             timeout.
     """
 
-    start_time = time.time()
-    end_time = start_time + timeout_sec
-    update_time = 1.0 / update_frequency
+    def check_sit_status(response):
+        status = response.feedback.synchronized_feedback.mobility_command_feedback.sit_feedback.status
+        return status == basic_command_pb2.SitCommand.Feedback.STATUS_IS_SITTING
 
     sit_command = RobotCommandBuilder.synchro_sit_command()
-    command_id = command_client.robot_command(sit_command, timeout=timeout_sec)
-
-    now = time.time()
-    while now < end_time:
-        time_until_timeout = end_time - now
-        rpc_timeout = max(time_until_timeout, 1)
-        start_call_time = time.time()
-        try:
-            response = command_client.robot_command_feedback(command_id, timeout=rpc_timeout)
-            mob_feedback = response.feedback.synchronized_feedback.mobility_command_feedback
-            mob_status = mob_feedback.status
-            sit_status = mob_feedback.sit_feedback.status
-        except TimedOutError:
-            # Excuse the TimedOutError and let the while check bail us out if we're out of time.
-            pass
-        else:
-            if mob_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
-                raise CommandFailedError('Sit (ID {}) no longer processing (now {})'.format(
-                    command_id,
-                    basic_command_pb2.RobotCommandFeedbackStatus.Status.Name(mob_status)))
-            if sit_status == basic_command_pb2.SitCommand.Feedback.STATUS_IS_SITTING:
-                return
-        delta_t = time.time() - start_call_time
-        time.sleep(max(min(delta_t, update_time), 0.0))
-        now = time.time()
-
-    raise CommandTimedOutError(
-        "Took longer than {:.1f} seconds to assure the robot sat.".format(now - start_time))
+    blocking_command(command_client, sit_command, check_sit_status, timeout_sec=timeout_sec,
+                     update_frequency=update_frequency)
 
 
 def blocking_selfright(command_client, timeout_sec=30, update_frequency=1.0):
     """Helper function which uses the RobotCommandService to self-right.
 
     Blocks until self-right has completed, or raises an exception if the command times out or fails.
 
     Args:
         command_client: RobotCommand client.
         timeout_sec: Timeout for the command in seconds.
         update_frequency: Update frequency for the command in Hz.
 
     Raises:
-        CommandFailedError: Command feedback from robot is not STATUS_PROCESSING.
+        CommandFailedErrorWithFeedback: Command feedback from robot is not STATUS_PROCESSING.
         bosdyn.client.robot_command.CommandTimedOutError: Command took longer than provided
             timeout.
     """
 
-    start_time = time.time()
-    end_time = start_time + timeout_sec
-    update_time = 1.0 / update_frequency
+    def check_self_right_status(response):
+        status = response.feedback.full_body_feedback.selfright_feedback.status
+        return status == basic_command_pb2.SelfRightCommand.Feedback.STATUS_COMPLETED
 
     selfright_command = RobotCommandBuilder.selfright_command()
-    command_id = command_client.robot_command(selfright_command, timeout=timeout_sec)
-
-    now = time.time()
-    while now < end_time:
-        time_until_timeout = end_time - now
-        rpc_timeout = max(time_until_timeout, 1)
-        start_call_time = time.time()
-        try:
-            response = command_client.robot_command_feedback(command_id, timeout=rpc_timeout)
-            full_body_feedback = response.feedback.full_body_feedback
-            full_body_status = full_body_feedback.status
-            selfright_status = full_body_feedback.selfright_feedback.status
-        except TimedOutError:
-            # Excuse the TimedOutError and let the while check bail us out if we're out of time.
-            pass
-        else:
-            if full_body_status != basic_command_pb2.RobotCommandFeedbackStatus.STATUS_PROCESSING:
-                raise CommandFailedError('Self-right (ID {}) no longer processing (now {})'.format(
-                    command_id,
-                    basic_command_pb2.RobotCommandFeedbackStatus.Status.Name(full_body_status)))
-            if selfright_status == basic_command_pb2.SelfRightCommand.Feedback.STATUS_COMPLETED:
-                return
-        delta_t = time.time() - start_call_time
-        time.sleep(max(min(delta_t, update_time), 0.0))
-        now = time.time()
-
-    raise CommandTimedOutError(
-        "Took longer than {:.1f} seconds to assure the robot completed self-right.".format(
-            now - start_time))
+    blocking_command(command_client, selfright_command, check_self_right_status,
+                     timeout_sec=timeout_sec, update_frequency=update_frequency)
 
 
 def block_until_arm_arrives(command_client, cmd_id, timeout_sec=None):
     """Helper that blocks until the arm achieves a finishing state for the specific arm command.
 
        This helper will block and check the feedback for ArmCartesianCommand, GazeCommand,
-       ArmJointMoveCommand, and NamedArmPositionsCommand.
+       ArmJointMoveCommand, NamedArmPositionsCommand, and ArmImpedanceCommand.
 
        Args:
         command_client: robot command client, used to request feedback
         cmd_id: command ID returned by the robot when the arm movement command was sent.
         timeout_sec: optional number of seconds after which we'll return no matter what
                      the robot's state is.
 
        Return values:
         True if successfully got to the end of the trajectory, False if the arm stalled or
-        the move was canceled (the arm failed to reach the goal).
+        the move was canceled (the arm failed to reach the goal). See the proto definitions in 
+        arm_command.proto for more information about why a trajectory would succeed or fail.
     """
     if timeout_sec is not None:
         start_time = time.time()
         end_time = start_time + timeout_sec
         now = time.time()
 
     while timeout_sec is None or now < end_time:
@@ -1769,14 +1950,19 @@
             elif arm_feedback.arm_joint_move_feedback.status == arm_command_pb2.ArmJointMoveCommand.Feedback.STATUS_STALLED:
                 return False
         elif arm_feedback.HasField("named_arm_position_feedback"):
             if arm_feedback.named_arm_position_feedback.status == arm_command_pb2.NamedArmPositionsCommand.Feedback.STATUS_COMPLETE:
                 return True
             elif arm_feedback.named_arm_position_feedback.status == arm_command_pb2.NamedArmPositionsCommand.Feedback.STATUS_STALLED_HOLDING_ITEM:
                 return False
+        elif arm_feedback.HasField("arm_impedance_feedback"):
+            if arm_feedback.arm_impedance_feedback.status == arm_command_pb2.ArmImpedanceCommand.Feedback.STATUS_TRAJECTORY_COMPLETE:
+                return True
+            elif arm_feedback.arm_impedance_feedback.status == arm_command_pb2.ArmImpedanceCommand.Feedback.STATUS_TRAJECTORY_STALLED:
+                return False
 
         time.sleep(0.1)
         now = time.time()
     return False
 
 
 def block_for_trajectory_cmd(
```

## bosdyn/client/robot_id.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the robot id service.
```

## bosdyn/client/robot_state.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to use the robot state service."""
```

## bosdyn/client/sdk.py

```diff
@@ -1,15 +1,14 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Sdk is  a repository for settings typically common to a single developer and/or robot fleet."""
-from __future__ import absolute_import
 
 import datetime
 import glob
 import logging
 import os
 import platform
 from enum import Enum
@@ -33,19 +32,22 @@
 from .door import DoorClient
 from .estop import EstopClient
 from .exceptions import Error
 from .fault import FaultClient
 from .graph_nav import GraphNavClient
 from .gripper_camera_param import GripperCameraParamClient
 from .image import ImageClient
+from .inverse_kinematics import InverseKinematicsClient
 from .ir_enable_disable import IREnableDisableServiceClient
+from .keepalive import KeepaliveClient
 from .lease import LeaseClient
 from .license import LicenseClient
 from .local_grid import LocalGridClient
 from .log_annotation import LogAnnotationClient
+from .log_status import LogStatusClient
 from .manipulation_api_client import ManipulationApiClient
 from .map_processing import MapProcessingServiceClient
 from .network_compute_bridge_client import NetworkComputeBridgeClient
 from .payload import PayloadClient
 from .payload_registration import PayloadRegistrationClient
 from .point_cloud import PointCloudClient
 from .power import PowerClient
@@ -78,17 +80,18 @@
 
 BOSDYN_RESOURCE_ROOT = os.environ.get('BOSDYN_RESOURCE_ROOT',
                                       os.path.join(os.path.expanduser('~'), '.bosdyn'))
 
 
 def generate_client_name(prefix=''):
     """Returns a descriptive client name for API clients with an optional prefix."""
-    import __main__
+    import bosdyn.client.__main__
     try:
-        process_info = '{}-{}'.format(os.path.basename(__main__.__file__), os.getpid())
+        process_info = '{}-{}'.format(os.path.basename(bosdyn.client.__main__.__file__),
+                                      os.getpid())
     except AttributeError:
         process_info = '{}'.format(os.getpid())
     machine_name = platform.node()
     if not machine_name:
         import getpass
         try:
             user_name = getpass.getuser()
@@ -117,29 +120,32 @@
     FaultClient,
     GraphNavClient,
     GraphNavRecordingServiceClient,
     GripperCameraParamClient,
     ImageClient,
     IREnableDisableServiceClient,
     LeaseClient,
+    KeepaliveClient,
     LicenseClient,
     LogAnnotationClient,
+    LogStatusClient,
     LocalGridClient,
     ManipulationApiClient,
     MapProcessingServiceClient,
     NetworkComputeBridgeClient,
     PayloadClient,
     PayloadRegistrationClient,
     PointCloudClient,
     PowerClient,
     RayCastClient,
     RobotCommandClient,
     RobotIdClient,
     RobotStateClient,
     SpotCheckClient,
+    InverseKinematicsClient,
     TimeSyncClient,
     WorldObjectClient,
 ]
 
 
 def create_standard_sdk(client_name_prefix, service_clients=None, cert_resource_glob=None):
     """Return an Sdk with the most common configuration.
```

## bosdyn/client/server_util.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Helper functions and classes for creating and running a gRPC service."""
```

## bosdyn/client/spot_check.py

```diff
@@ -1,15 +1,13 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
-from __future__ import print_function
-
 import collections
 import time
 
 from urllib3 import Timeout
 
 from bosdyn.api.spot import spot_check_pb2, spot_check_service_pb2_grpc
 from bosdyn.client.common import (BaseClient, error_factory, handle_common_header_errors,
@@ -322,15 +320,15 @@
     return None
 
 
 @handle_common_header_errors
 def _calibration_feedback_error_from_response(response):
     # Special handling of lease case.
     if response.status == spot_check_pb2.CameraCalibrationFeedbackResponse.STATUS_LEASE_ERROR:
-        return LeaseUseError(response)
+        return LeaseUseError(response, None)
     return _cal_status_error_from_response(response)
 
 
 _CAL_STATUS_TO_ERROR = collections.defaultdict(lambda: (ResponseError, None))
 _CAL_STATUS_TO_ERROR.update({  # noqa
     spot_check_pb2.CameraCalibrationFeedbackResponse.STATUS_SUCCESS: (None, None),
     spot_check_pb2.CameraCalibrationFeedbackResponse.STATUS_PROCESSING: (None, None),
```

## bosdyn/client/time_sync.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """A client for the time-sync service.
```

## bosdyn/client/token_cache.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to delegate saving of tokens.
```

## bosdyn/client/token_manager.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to automate token refresh.
```

## bosdyn/client/util.py

```diff
@@ -1,49 +1,46 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """Helper functions and classes for creating client applications."""
 
-from __future__ import print_function
-
 import copy
 import getpass
 import glob
 import logging
 import os
 import signal
 import sys
 import threading
 import time
 from concurrent import futures
 
 import google.protobuf.descriptor
 import grpc
-import six
-from deprecated import deprecated
+from deprecated.sphinx import deprecated
 
 import bosdyn.client.server_util
 from bosdyn.client.auth import InvalidLoginError, InvalidTokenError
 from bosdyn.client.channel import generate_channel_options
 from bosdyn.client.exceptions import Error
 
 _LOGGER = logging.getLogger(__name__)
 
 
 def cli_login_prompt(username=None, password=None):
     """Interactive CLI for scripting conveniences."""
     if username is None:
         print('Username: ', end='', file=sys.stderr)
-        username = six.moves.input('')
+        username = input('')
     elif password is None:
         print('Username for robot [{}]: '.format(username), end='', file=sys.stderr)
-        name = six.moves.input('')
+        name = input('')
         if name:
             username = name
 
     password = getpass.getpass(prompt='[{}] Password: '.format(username), stream=sys.stderr)
     return (username, password)
```

## bosdyn/client/world_object.py

```diff
@@ -1,15 +1,14 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to use the world object service"""
-from __future__ import print_function
 
 from bosdyn.api import geometry_pb2 as geom
 from bosdyn.api import world_object_pb2, world_object_service_pb2
 from bosdyn.api import world_object_service_pb2_grpc as world_object_service
 from bosdyn.client.common import BaseClient, common_header_errors
 from bosdyn.client.frame_helpers import *
 from bosdyn.client.robot_command import NoTimeSyncError, _TimeConverter
@@ -113,14 +112,15 @@
             client_timestamp = mutation_req.mutation.object.acquisition_time
             mutation_req.mutation.object.acquisition_time.CopyFrom(
                 self._update_timestamp_filter(client_timestamp, self.timesync_endpoint))
         return self.call_async(self._stub.MutateWorldObjects, mutation_req,
                                value_from_response=_get_status,
                                error_from_response=common_header_errors, **kwargs)
 
+
     def _update_time_filter(self, timestamp, timesync_endpoint):
         """Set or convert fields of the proto that need timestamps in the robot's clock.
 
         Args:
             timestamp (float): Client time, such as from time.time().
             timesync_endpoint (TimeSyncEndpoint): A timesync endpoint associated with the robot object.
 
@@ -272,15 +272,15 @@
             print(
                 "Cannot change/delete objects detected by Spot's perception system, only client objects."
             )
     return response
 
 
 '''
-Static helper methods for constructing mutation requests for a given world object.
+Static helper methods for constructing and sending mutation requests for a given world object.
 '''
 
 
 def make_add_world_object_req(world_obj):
     """Add a world object to the scene.
 
     Args:
@@ -323,7 +323,50 @@
     Returns:
         A MutateWorldObjectRequest where the action is to "change" the object to the scene.
     """
     change_obj = world_object_pb2.MutateWorldObjectRequest.Mutation(
         action=world_object_pb2.MutateWorldObjectRequest.ACTION_CHANGE, object=world_obj)
     req = world_object_pb2.MutateWorldObjectRequest(mutation=change_obj)
     return req
+
+
+def send_add_mutation_requests(world_object_client, world_object_array):
+    """
+    Create and send an "add" mutation request for each world object in an array.  Return a matching
+    array of the object id's that are assigned when the object is created, so that each object we add
+    can be identified and removed individually (if desired) later.
+    
+    Args:
+        world_object_client (WorldObjectClient): Client for World Object service.
+        world_object_array (List): 
+    Returns:
+        A List containing the object ids associated with the objects created.
+    """
+    obj_id = [-1] * len(world_object_array)
+    for i, obj in enumerate(world_object_array):
+        add_req = make_add_world_object_req(obj)
+        add_resp = world_object_client.mutate_world_objects(mutation_req=add_req)
+        obj_id[i] = add_resp.mutated_object_id
+
+    return obj_id
+
+
+def send_delete_mutation_requests(world_object_client, delete_object_id_array):
+    """
+    Create and send a "delete" mutation request for each world object successfully identified from a
+    given list of object id's.
+        
+    Args:
+        world_object_client (WorldObjectClient): Client for World Object service.
+        delete_object_id_array (List): List of object id's to send delete requests for.
+    """
+    world_objects = world_object_client.list_world_objects().world_objects
+    for obj in world_objects:
+        this_object_id = obj.id
+        if type(delete_object_id_array) == int:
+            delete_object_id_array = [delete_object_id_array]
+        for i in range(len(delete_object_id_array)):
+            delete_id = delete_object_id_array[i]
+            if this_object_id == delete_id:
+                del_req = make_delete_world_object_req(obj)
+                del_resp = world_object_client.mutate_world_objects(mutation_req=del_req)
+                continue
```

## bosdyn/client/resources/__init__.py

```diff
@@ -1,6 +1,6 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
```

## bosdyn/client/spot_cam/__init__.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 from . import (audio, compositor, health, lighting, media_log, network, power, ptz, streamquality,
                version)
```

## bosdyn/client/spot_cam/audio.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Audio service."""
 
@@ -77,14 +77,15 @@
         """Async version of play_sound()"""
         fv = FloatValue()
         fv.value = gain
         request = audio_pb2.PlaySoundRequest(sound=sound, gain=fv)
         return self.call_async(self._stub.PlaySound, request, self._play_sound_from_response,
                                self._audio_error_from_response, copy_request=False, **kwargs)
 
+
     def delete_sound(self, sound, **kwargs):
         """Delete sound found in list_sounds()"""
         request = audio_pb2.DeleteSoundRequest(sound=sound)
         return self.call(self._stub.DeleteSound, request, self._delete_sound_from_response,
                          self._audio_error_from_response, copy_request=False, **kwargs)
 
     def delete_sound_async(self, sound, **kwargs):
@@ -197,14 +198,15 @@
     def _get_volume_from_response(response):
         return response.volume
 
     @staticmethod
     def _play_sound_from_response(response):
         pass
 
+
     @staticmethod
     def _delete_sound_from_response(response):
         pass
 
     @staticmethod
     def _load_sound_from_response(response):
         pass
```

## bosdyn/client/spot_cam/compositor.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Compositor service."""
 
@@ -104,37 +104,78 @@
 
     def get_ir_colormap_async(self, **kwargs):
         """Async version of get_ir_colormap()"""
         request = compositor_pb2.GetIrColormapRequest()
         return self.call_async(self._stub.GetIrColormap, request, self._colormap_from_response,
                                self._compositor_error_from_response, copy_request=False, **kwargs)
 
-    def set_ir_meter_overlay(self, x, y, enable, **kwargs):
+    def set_ir_meter_overlay(self, x, y, enable, unit, **kwargs):
         """Set IR reticle position to use on Spot CAM IR
 
         Args:
             x (Float): (0,1) horizontal coordinate of reticle
             y (Float): (0,1) vertical coordinate of reticle
             enable (Boolean): Enable the reticle on the display
+            unit (TempUnit): Temperature unit to display
             kwargs: extra arguments for controlling RPC details.
         """
         coords = compositor_pb2.IrMeterOverlay.NormalizedCoordinates(x=x, y=y)
-        overlay = compositor_pb2.IrMeterOverlay(enable=enable, coords=coords)
+        overlay = compositor_pb2.IrMeterOverlay(enable=enable, meter=[coords], unit=unit)
         request = compositor_pb2.SetIrMeterOverlayRequest(overlay=overlay)
         return self.call(self._stub.SetIrMeterOverlay, request, self._return_response,
                          self._compositor_error_from_response, copy_request=False, **kwargs)
 
-    def set_ir_meter_overlay_async(self, x, y, enable, **kwargs):
+    def set_ir_meter_overlay_async(self, x, y, enable, unit, **kwargs):
         """Async version of set_ir_meter_overlay()"""
         coords = compositor_pb2.IrMeterOverlay.NormalizedCoordinates(x=x, y=y)
-        overlay = compositor_pb2.IrMeterOverlay(enable=enable, coords=coords)
+        overlay = compositor_pb2.IrMeterOverlay(enable=enable, meter=[coords], unit=unit)
         request = compositor_pb2.SetIrMeterOverlayRequest(overlay=overlay)
         return self.call_async(self._stub.SetIrMeterOverlay, request, self._return_response,
                                self._compositor_error_from_response, copy_request=False, **kwargs)
 
+    def set_multi_ir_meter_overlay(self, coords, enable, unit, **kwargs):
+        """Set multiple IR reticle positions to use on Spot CAM IR
+
+        Args:
+            coords (List[Tuple(Float, Float)]): List of (x, y) reticle coordinates in range (0,1)
+                e.g. [(0.1, 0.2), (0.2, 0.4), (0.7, 0.7)]
+            enable (Boolean): Enable the reticles on the display
+            unit (TempUnit): Temperature unit to display
+            kwargs: extra arguments for controlling RPC details.
+        """
+        coords_proto = [
+            compositor_pb2.IrMeterOverlay.NormalizedCoordinates(x=x, y=y) for x, y in coords
+        ]
+        overlay = compositor_pb2.IrMeterOverlay(enable=enable, meter=coords_proto, unit=unit)
+        request = compositor_pb2.SetIrMeterOverlayRequest(overlay=overlay)
+        return self.call(self._stub.SetIrMeterOverlay, request, self._return_response,
+                         self._compositor_error_from_response, copy_request=False, **kwargs)
+
+    def set_multi_ir_meter_overlay_async(self, coords, enable, unit, **kwargs):
+        """Async version of set_multi_ir_meter_overlay()"""
+        coords_proto = [
+            compositor_pb2.IrMeterOverlay.NormalizedCoordinates(x=x, y=y) for x, y in coords
+        ]
+        overlay = compositor_pb2.IrMeterOverlay(enable=enable, meter=coords_proto, unit=unit)
+        request = compositor_pb2.SetIrMeterOverlayRequest(overlay=overlay)
+        return self.call_async(self._stub.SetIrMeterOverlay, request, self._return_response,
+                               self._compositor_error_from_response, copy_request=False, **kwargs)
+
+    def get_ir_meter_overlay(self, **kwargs):
+        """Get current IR reticle positions"""
+        request = compositor_pb2.GetIrMeterOverlayRequest()
+        return self.call(self._stub.GetIrMeterOverlay, request, self._return_response,
+                         self._compositor_error_from_response, copy_request=False, **kwargs)
+
+    def get_ir_meter_overlay_async(self, **kwargs):
+        """Async version of get_ir_meter_overlay()"""
+        request = compositor_pb2.GetIrMeterOverlayRequest()
+        return self.call_async(self._stub.GetIrMeterOverlay, request, self._return_response,
+                               self._compositor_error_from_response, copy_request=False, **kwargs)
+
     @staticmethod
     def _return_response(response):
         return response
 
     @staticmethod
     def _name_from_response(response):
         return response.name
```

## bosdyn/client/spot_cam/health.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Health service."""
```

## bosdyn/client/spot_cam/lighting.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Lighting service."""
```

## bosdyn/client/spot_cam/lights_helper.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 import logging
 import threading
```

## bosdyn/client/spot_cam/media_log.py

```diff
@@ -1,20 +1,20 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM MediaLog service."""
 
 import logging
 
 _LOGGER = logging.getLogger(__name__)
 
-from deprecated import deprecated
+from deprecated.sphinx import deprecated
 
 from bosdyn.api.spot_cam import logging_pb2, service_pb2_grpc
 from bosdyn.client.common import BaseClient, common_header_errors, handle_common_header_errors
 
 
 class MediaLogClient(BaseClient):
     """A client calling Spot CAM MediaLog service.
```

## bosdyn/client/spot_cam/network.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Network service."""
```

## bosdyn/client/spot_cam/power.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Power service."""
```

## bosdyn/client/spot_cam/ptz.py

```diff
@@ -1,20 +1,20 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Ptz service."""
 
 import logging
 
 _LOGGER = logging.getLogger(__name__)
 
-from google.protobuf.wrappers_pb2 import FloatValue
+from google.protobuf.wrappers_pb2 import FloatValue, Int32Value
 
 from bosdyn.api.spot_cam import ptz_pb2, service_pb2_grpc
 from bosdyn.client.common import BaseClient, common_header_errors, handle_common_header_errors
 from bosdyn.client.math_helpers import recenter_value_mod
 
 
 class PtzClient(BaseClient):
@@ -115,14 +115,80 @@
     def initialize_lens_async(self, **kwargs):
         """Async version of initialize_lens()"""
         request = ptz_pb2.InitializeLensRequest()
         return self.call_async(self._stub.InitializeLens, request,
                                self._initialize_lens_from_response, common_header_errors,
                                copy_request=False, **kwargs)
 
+    # Manual Focus RPCs
+
+    def get_ptz_focus_state(self, **kwargs):
+        """Retrieve focus of the mechanical ptz
+
+        Args:
+            focus_mode (PtzFocusMode): Enum indicating whether to autofocus or manually focus
+            distance (float): Approximate distance to focus on, most accurate between 1.2m and 20m,
+                only settable in PTZ_FOCUS_MANUAL mode
+            focus_position (int32): Precise lens position for the camera for repeatable operations,
+                overrides distance if specified, only settable in PTZ_FOCUS_MANUAL mode
+
+        Returns:
+            PtzFocusState containing the current focus mode and position
+        """
+        request = ptz_pb2.GetPtzFocusStateRequest()
+        return self.call(self._stub.GetPtzFocusState, request,
+                         self._get_ptz_focus_state_from_response, common_header_errors,
+                         copy_request=False, **kwargs)
+
+    def get_ptz_focus_state_async(self, **kwargs):
+        """Async version of get_ptz_focus_state()"""
+        request = ptz_pb2.GetPtzFocusStateRequest()
+        return self.call_async(self._stub.GetPtzFocusState, request,
+                               self._get_ptz_focus_state_from_response, common_header_errors,
+                               copy_request=False, **kwargs)
+
+    def set_ptz_focus_state(self, focus_mode, distance=None, focus_position=None, **kwargs):
+        """Set focus of the mechanical ptz
+
+        Args:
+            focus_mode (PtzFocusMode): Enum indicating whether to autofocus or manually focus
+            distance (float): Approximate distance to focus on, most accurate between 1.2m and 20m,
+                only settable in PTZ_FOCUS_MANUAL mode
+            focus_position (int32): Precise lens position for the camera for repeatable operations,
+                overrides distance if specified, only settable in PTZ_FOCUS_MANUAL mode
+
+        Returns:
+            SetPtzFocusStateResponse indicating whether the call was successful
+        """
+
+        request = self._make_set_ptz_focus_state_request(focus_mode, distance, focus_position)
+
+        return self.call(self._stub.SetPtzFocusState, request,
+                         self._set_ptz_focus_state_from_response, common_header_errors,
+                         copy_request=False, **kwargs)
+
+    def set_ptz_focus_state_async(self, focus_mode, distance=None, focus_position=None, **kwargs):
+        """Async version of set_ptz_focus_state()"""
+
+        request = self._make_set_ptz_focus_state_request(focus_mode, distance, focus_position)
+
+        return self.call_async(self._stub.SetPtzFocusState, request,
+                               self._set_ptz_focus_state_from_response, common_header_errors,
+                               copy_request=False, **kwargs)
+
+    @staticmethod
+    def _make_set_ptz_focus_state_request(focus_mode, distance, focus_position):
+        request = ptz_pb2.SetPtzFocusStateRequest()
+        request.focus_state.mode = focus_mode
+        if focus_position is not None:
+            request.focus_state.focus_position.value = focus_position
+        elif distance is not None:
+            request.focus_state.approx_distance.value = distance
+        return request
+
     @staticmethod
     def _list_ptz_from_response(response):
         return response.ptzs
 
     @staticmethod
     def _get_ptz_position_from_response(response):
         return response.position
@@ -141,18 +207,18 @@
 
     @staticmethod
     def _initialize_lens_from_response(response):
         return response
 
     # Focus methods
     @staticmethod
-    def _get_ptz_focus_from_response(response):
-        return response.ptz_focus
+    def _get_ptz_focus_state_from_response(response):
+        return response.focus_state
 
     @staticmethod
-    def _set_ptz_focus_from_response(response):
-        return response.ptz_focus
+    def _set_ptz_focus_state_from_response(response):
+        return response
 
 
 def shift_pan_angle(pan):
     """Shift the pan angle (degrees) so that it is in the [0,360] range."""
     return recenter_value_mod(pan, 180, 360)
```

## bosdyn/client/spot_cam/streamquality.py

```diff
@@ -1,16 +1,17 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM StreamQuality service."""
 
 import logging
+from multiprocessing.sharedctypes import Value
 
 _LOGGER = logging.getLogger(__name__)
 
 from bosdyn.api.spot_cam import service_pb2_grpc, streamquality_pb2
 from bosdyn.client.common import BaseClient, common_header_errors, handle_common_header_errors
 
 
@@ -20,27 +21,45 @@
     default_service_name = 'spot-cam-stream-quality'
     service_type = 'bosdyn.api.spot_cam.StreamQualityService'
 
     def __init__(self):
         super(StreamQualityClient, self).__init__(service_pb2_grpc.StreamQualityServiceStub)
 
     def set_stream_params(self, target_bitrate=None, refresh_interval=None, idr_interval=None,
-                          awb_mode=None, **kwargs):
-        """Change image compression and postprocessing."""
+                          awb_mode=None, auto_exposure=None, sync_auto_exposure=None,
+                          manual_exposure=None, **kwargs):
+        """Change image compression and postprocessing.
+
+        At most one of auto_exposure, sync_auto_exposure, and manual_exposure can be specified.
+        The others should be set to None if one is specified. Otherwise, they should all be None.
+
+        Args:
+            target_bitrate (int): The compression level in target BPS
+            refreshinterval (int): How often the entire feed should be refreshed (in frames)
+            idrinterval (int): How often an IDR message should get sent (in frames)
+            awb_mode (AwbModeEnum): Options for automatic white balancing mode
+            auto_exposure (AutoExposure): Runs exposure independently on each of the ring cameras
+            sync_auto_exposure (SyncAutoExposure): Runs a single autoexposure algorithm that takes
+                into account data from all ring cameras
+            manual_exposure (ManualExposure): Manual exposure sets an exposure for all ring cameras
+        """
         request = self._build_SetStreamParamsRequest(target_bitrate, refresh_interval, idr_interval,
-                                                     awb_mode)
+                                                     awb_mode, auto_exposure, sync_auto_exposure,
+                                                     manual_exposure)
 
         return self.call(self._stub.SetStreamParams, request, self._params_from_response,
                          self._streamquality_error_from_response, copy_request=False, **kwargs)
 
     def set_stream_params_async(self, target_bitrate=None, refresh_interval=None, idr_interval=None,
-                                awb_mode=None, **kwargs):
+                                awb_mode=None, auto_exposure=None, sync_auto_exposure=None,
+                                manual_exposure=None, **kwargs):
         """Async version of set_stream_params()."""
         request = self._build_SetStreamParamsRequest(target_bitrate, refresh_interval, idr_interval,
-                                                     awb_mode)
+                                                     awb_mode, auto_exposure, sync_auto_exposure,
+                                                     manual_exposure)
 
         return self.call_async(self._stub.SetStreamParams, request, self._params_from_response,
                                self._streamquality_error_from_response, copy_request=False,
                                **kwargs)
 
     def get_stream_params(self, **kwargs):
         """Get image quality and processing settings."""
@@ -65,28 +84,42 @@
         """Async version of enable_congestion_control()."""
         request = streamquality_pb2.EnableCongestionControlRequest(enable_congestion_control=enable)
         return self.call_async(self._stub.EnableCongestionControl, request, None,
                                self._streamquality_error_from_response, copy_request=False,
                                **kwargs)
 
     @staticmethod
-    def _build_SetStreamParamsRequest(target_bitrate, refresh_interval, idr_interval, awb_mode):
+    def _build_SetStreamParamsRequest(target_bitrate, refresh_interval, idr_interval, awb_mode,
+                                      auto_exposure, sync_auto_exposure, manual_exposure):
+        exposure_args = [auto_exposure, sync_auto_exposure, manual_exposure]
+        if sum([arg is not None for arg in exposure_args]) > 1:
+            raise ValueError("Only one exposure argument can be specified at a time.")
+
         request = streamquality_pb2.SetStreamParamsRequest()
         if target_bitrate:
             request.params.targetbitrate.value = target_bitrate
 
         if refresh_interval:
             request.params.refreshinterval.value = refresh_interval
 
         if idr_interval:
             request.params.idrinterval.value = idr_interval
 
         if awb_mode:
             request.params.awb.CopyFrom(streamquality_pb2.StreamParams.AwbMode(awb=awb_mode))
 
+        if auto_exposure:
+            request.params.auto_exposure.CopyFrom(auto_exposure)
+
+        if sync_auto_exposure:
+            request.params.sync_exposure.CopyFrom(sync_auto_exposure)
+
+        if manual_exposure:
+            request.params.manual_exposure.CopyFrom(manual_exposure)
+
         return request
 
     @staticmethod
     def _params_from_response(response):
         return response.params
 
     @staticmethod
```

## bosdyn/client/spot_cam/version.py

```diff
@@ -1,8 +1,8 @@
-# Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+# Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 #
 # Downloading, reproducing, distributing or otherwise using the SDK Software
 # is subject to the terms and conditions of the Boston Dynamics Software
 # Development Kit License (20191101-BDSDK-SL).
 
 """For clients to the Spot CAM Version service."""
```

## Comparing `bosdyn_client-3.2.3.dist-info/METADATA` & `bosdyn_client-3.3.0.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,32 +1,34 @@
 Metadata-Version: 2.1
 Name: bosdyn-client
-Version: 3.2.3
+Version: 3.3.0
 Summary: Boston Dynamics API client code and interfaces
 Home-page: https://dev.bostondynamics.com/
 Author: Boston Dynamics
 Author-email: support@bostondynamics.com
-License: UNKNOWN
 Project-URL: Documentation, https://dev.bostondynamics.com/
 Project-URL: Source, https://github.com/boston-dynamics/spot-sdk/
-Platform: UNKNOWN
 Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
 Classifier: License :: Other/Proprietary License
 Classifier: Operating System :: OS Independent
 Description-Content-Type: text/markdown
-Requires-Dist: bosdyn-api (==3.2.3)
-Requires-Dist: bosdyn-core (==3.2.3)
+Requires-Dist: bosdyn-api (==3.3.0)
+Requires-Dist: bosdyn-core (==3.3.0)
 Requires-Dist: grpcio
 Requires-Dist: pyjwt
 Requires-Dist: numpy
 Requires-Dist: Deprecated (~=1.2.10)
 Requires-Dist: requests (>=2.26.0)
 
 <!--
-Copyright (c) 2022 Boston Dynamics, Inc.  All rights reserved.
+Copyright (c) 2023 Boston Dynamics, Inc.  All rights reserved.
 
 Downloading, reproducing, distributing or otherwise using the SDK Software
 is subject to the terms and conditions of the Boston Dynamics Software
 Development Kit License (20191101-BDSDK-SL).
 -->
 
 # bosdyn-client
@@ -95,9 +97,7 @@
 left_depth                     (240x424)
 left_depth_in_visual_frame     (480x640)
 left_fisheye_image             (480x640)
 right_depth                    (240x424)
 right_depth_in_visual_frame    (480x640)
 right_fisheye_image            (480x640)
 ```
-
-
```

## Comparing `bosdyn_client-3.2.3.dist-info/RECORD` & `bosdyn_client-3.3.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,85 +1,90 @@
-bosdyn/__init__.py,sha256=b1r4kW1ychwGnIX1yJJwTQGUy65mcdLWgOVKLE2Fgq0,330
-bosdyn/client/__init__.py,sha256=M4BU5lGHvTdYv0RWo9N7Bd-anBYof7LvhVR7yxBhV7I,1396
-bosdyn/client/__main__.py,sha256=p3RFBpJPFYQGLYgyt5ZquBIpCQXsZeEikljiAe5wu90,466
-bosdyn/client/area_callback.py,sha256=uT5tckKr9vXCt46O_9Z7yxMrrnHKkb0L0jr4OzZzgT8,6212
-bosdyn/client/area_callback_region_handler_base.py,sha256=TSC2bLX55qeLmqtDXs0fisPRcBuYuIoqZDgp_mAinbA,14659
-bosdyn/client/area_callback_service_runner.py,sha256=r9zCopYJCsq44am20NqJc_u8kxRU1pvD80hqx6SKCSs,1869
-bosdyn/client/area_callback_service_servicer.py,sha256=ShgIeJYMQ6hRY4NApfp9qq51Yww0tL1ki26CEDBlD7k,11013
-bosdyn/client/area_callback_service_utils.py,sha256=NmvD66Lx0Npea3hcWb5NgDDRDJ3WniTmYcr1QXKu6HU,1566
-bosdyn/client/arm_surface_contact.py,sha256=-0Si1csLS42r9JHNJED6faOj7r6Yuy55UJYdmN8L2l4,3710
-bosdyn/client/async_tasks.py,sha256=9-prhMnRIRaNKlr-UFY1mKkZLfkvva6I6pg9k9EtSo4,5625
-bosdyn/client/auth.py,sha256=gj1hi9fQrZjdUlhcjlL6bXhy_pv0TDtgTtMYp0RobIY,6253
-bosdyn/client/auto_return.py,sha256=Mf0Uiyp-ziSLKsRBvaL_4SicqBL4uu1tooGZ9k3XbHQ,4486
-bosdyn/client/autowalk.py,sha256=OH93K0RFMjr_X27KfrVg39oUfDqLjGRVaCzEWc2hVvE,5682
-bosdyn/client/bddf.py,sha256=joIpn5GuIauPEPUbCNF9K9BCthIF4qP6K5kF6obNE-M,1763
-bosdyn/client/bddf_download.py,sha256=4RdXnXPgqKA8rIkSiwn8EyftSjCI7qH6Ah9CbqhpTl8,7586
-bosdyn/client/channel.py,sha256=Bd1J39xuqnG3Orwl5SHmRlQHz3enl9LgszfQI5Ayj1I,8902
-bosdyn/client/command_line.py,sha256=UjVTFh5LGfr7RmHWAcmsLPiSmPRWQlIBb6-EPLLKRLQ,78069
-bosdyn/client/common.py,sha256=acJNjKc9XnN45hSLqWF6_KlwQYjPj51qFoQoHlTA3Bo,20644
-bosdyn/client/data_acquisition.py,sha256=Jt9h90MvwJbxoGtCVNhCdIKyG5tJdSmhpPtUhYZFjX4,13075
-bosdyn/client/data_acquisition_helpers.py,sha256=MQIeHwwkxV9tmnwNKOVgFF_B8t0agUkk0ZgiFOEATPg,14882
-bosdyn/client/data_acquisition_plugin.py,sha256=DSy0il7ej6-mlQGlpxphwl2Ar9FSnJeX-fvz4FOSRjc,5025
-bosdyn/client/data_acquisition_plugin_service.py,sha256=_QO7bFB0iqsA6W5GTir7nnfNrZ9qDQPVGuEUKP7xJA4,24120
-bosdyn/client/data_acquisition_store.py,sha256=HE271Lh5WiGlOhiXjARL1ldpGOGzADyIN_72rhgX1DY,12273
-bosdyn/client/data_buffer.py,sha256=HZupSF0CJzAMo8-AGLNS_lceo6rlhkxk4A_Cu2vMiSA,25851
-bosdyn/client/data_service.py,sha256=rSosbO0HumI3lvmDn9BOLrKcLUrFGDBKFAElW-wGgRA,5240
-bosdyn/client/directory.py,sha256=m-fhwmGmHuV2BxrwGLb8dytusQJigRElX38OZCaK2Mw,4906
-bosdyn/client/directory_registration.py,sha256=pLxjbgENgVtTP8mIoBbM7na3BcWnsrlGMSIOL0-0B8M,19696
-bosdyn/client/docking.py,sha256=-Gv6yW_TcKoa5SGfg_dFwVD58hzxOgIEYQjyTrJ5vLc,17488
-bosdyn/client/door.py,sha256=WyenXrW7sGMgHrwwGWiAPiP-7xCX_gIJIWIObZdrPFA,3110
-bosdyn/client/estop.py,sha256=WAEeoW6nrrkXJdrJAbqPVPUHcUy474suTO-qT_I91F8,31826
-bosdyn/client/exceptions.py,sha256=bxNgRF9FDWM0MpOkRb-X9Rk3vOhXlv1-f2i_pggc30w,4670
-bosdyn/client/fault.py,sha256=YvwWavN0xkkXcciBhD0pVG9AAbOaWWiBzh8vqPuWNrA,6050
-bosdyn/client/frame_helpers.py,sha256=rcqwazyf-q2twUxdZHDfr_LcfLO6TC79WUIwugE5s9g,11936
-bosdyn/client/graph_nav.py,sha256=L6AkzcnksAoMM2AXbLuqBvW0NMiyWh-pKlkvCLjzpDM,61778
-bosdyn/client/gripper_camera_param.py,sha256=3_TtumxvqAMQ2ucBA8ikq6Y2apLouidgn71tlrpsBp0,2631
-bosdyn/client/image.py,sha256=RxeRTYtZ4RkJDNubARZRTv2y58EecgkaEOU-j3j3kpM,20146
-bosdyn/client/image_service_helpers.py,sha256=x7MuQIuZrTpxhCyKJkOsS0n_jMJmMAHm2GfP1Cn6SVQ,30074
-bosdyn/client/ir_enable_disable.py,sha256=n0nPULtpajhwp-ZQeYzJiE-_C-SYrUV2TxjtTN-SNQc,2153
-bosdyn/client/lease.py,sha256=i7RBV3dX0hXqB_reSrOMfLu9UXhqV_gDxp2Gz5hpZoE,45013
-bosdyn/client/lease_resource_hierarchy.py,sha256=vdyTcVZJy4TOsSpmm6ke2UTzQRjI7wgGVclm_Hd2HLg,3070
-bosdyn/client/lease_validator.py,sha256=z70aoh6l9nqeIGKibctpJQpYuzSRjAIP3sIRKBazD3M,14531
-bosdyn/client/license.py,sha256=0df5lBkmH3HhtM-2lSJXUYH95ovL9aHURSEaM3JVLdk,1736
-bosdyn/client/local_grid.py,sha256=cXLg4heC5xN6lp48MOdoR7VGP1pHrD7rcbAXqSYJvzc,3475
-bosdyn/client/log_annotation.py,sha256=4pbGMRowQiXtPJjr45leV4Ezq5NpGhPJ_21u4oOX-HU,15547
-bosdyn/client/manipulation_api_client.py,sha256=52Lj4F1Q7dGlbutYua5vnvS6IEdblmgRrCB37vM-z00,4203
-bosdyn/client/map_processing.py,sha256=bas28X7j3vqG8lOWUEhHF8AF_bwqOrudY0TnDmZkDjw,9868
-bosdyn/client/math_helpers.py,sha256=X305B53qffeXnnaPbxTOLRpkdCr75Nu3Y8ynrvmICC0,45005
-bosdyn/client/network_compute_bridge_client.py,sha256=R2t-4fdVI6M-m8maO7sUMn4WNjK9-czK0IxnsNXsLA8,7568
-bosdyn/client/payload.py,sha256=hJ8NeGIoPVL-__Iok0-zLHR5HnoGFQTGjFdIxEKQDmE,2310
-bosdyn/client/payload_registration.py,sha256=jpRfkxQ7zmp-r9TbJ_JAQ6B9WfS-dPtGk3Zj6tEB2kA,22355
-bosdyn/client/point_cloud.py,sha256=UTl3JUPVNgYIfAp5-2Tu1bclFR_QZ2MODTIxDnfaLeE,8421
-bosdyn/client/power.py,sha256=Zo946TWXxTW7pmcn7b77MZr4LhX71PnHSrTiGuQW5Fs,24711
-bosdyn/client/processors.py,sha256=2yjjx2b_wBRw2hnkwxOjIT33o8E3KVJNhRvU4cPSvv8,1275
-bosdyn/client/ray_cast.py,sha256=2sL34_mYiPVTPuwQHJhFQphP4YRBLf8-wQHSodld2PQ,4465
-bosdyn/client/recording.py,sha256=Q9XVajY_zlObR4VdeU0QEHMusCi_UDermUzottOFXcM,24729
-bosdyn/client/robot.py,sha256=2bb1Y79mRCRfe6Bd3_LWjZ5s3hO83TBDGjK4Papx_r4,29963
-bosdyn/client/robot_command.py,sha256=6Ym9dPIZq867N09LcX0jyCIgDJq8yfGAKw1OaGyL-UY,89797
-bosdyn/client/robot_id.py,sha256=Hj6yC4vqY0o_2vmoBATi3bYNUEcqRvpdfgXVh5JxuYs,2359
-bosdyn/client/robot_state.py,sha256=kQ-deeOv9PiDqxLjrA_oT9CI9UnCqFVMyFcFhpa0ukc,6215
-bosdyn/client/sdk.py,sha256=e5pP8ObiDcM2vVeiPI2kW3ZokjD8hYyvPJNrYcsVjTs,12699
-bosdyn/client/server_util.py,sha256=vPdXxHmnnwpOPusI775a3kZXUG3syros_Sm3uFPesr4,10199
-bosdyn/client/spot_check.py,sha256=xiXnxv-qe4lRGvTX31TZvqLXooFCfrBXmg9RieOjKbo,14647
-bosdyn/client/time_sync.py,sha256=jaWhRH4DyiVU5Qj0KNzjaVwYDmWHBCOiJTy8578ANac,21284
-bosdyn/client/token_cache.py,sha256=aGttc4Xu8lMdQ33h_bB92ZSokPTyR_-ptn_cDtQyw2U,3507
-bosdyn/client/token_manager.py,sha256=PuGCk7yOwe0gUlZDVCWnOfvIrPHHqN3kxUfGUGTm8b8,3144
-bosdyn/client/util.py,sha256=jzXuMdrmFTKwYsgEm2RFbloyfGIuWgbyWYbpJ_yYtbU,19106
-bosdyn/client/world_object.py,sha256=xGw5V4PDimmgpcdRLrthYMh5nQW6Lw9NJO47-G1oSMs,16843
-bosdyn/client/resources/__init__.py,sha256=U_ZJN7zwFI9vl2eQJwLR-sqHHXRJ-QR68GtXszqCtnM,265
+bosdyn/__init__.py,sha256=CMQioQKK1NlMk3kZuY49b_Aw-JyvDeOtuqOCAul1I0s,330
+bosdyn/client/__init__.py,sha256=szU23h0jL8WtyBaC6y1ahOLtaKgVjsBh7eb1PAuy5jg,1439
+bosdyn/client/__main__.py,sha256=g__h-0z_Q6yzuiXdHQQTh9AI3C2cSc3PocpvbLVwa3E,466
+bosdyn/client/area_callback.py,sha256=nQnhJR8-f0PMq9uILpKhYitVuIZHl6VViUDndN2K4u8,6270
+bosdyn/client/area_callback_region_handler_base.py,sha256=xGm5EGHst-Bsf4hqbQnK-CPRYcBQDaBkMLKvEnw-q9U,15819
+bosdyn/client/area_callback_service_runner.py,sha256=Rr30BV3TSXHQGcsUGlTa1F-noQDvgq6wv5XxQ_zTIa0,1869
+bosdyn/client/area_callback_service_servicer.py,sha256=HPzy_QAUqCMWPNxH7tefjXtAvW4ijLI9X9CF0UuxCrU,11538
+bosdyn/client/area_callback_service_utils.py,sha256=6q75KwubPezvowrrhpqehiBb0IAjnErOPTxCEyvgZ6I,6095
+bosdyn/client/arm_surface_contact.py,sha256=DRfPfsFEzfk6ufe080ViqasUefl2ZUtcvcNENgcf55k,3710
+bosdyn/client/async_tasks.py,sha256=gEPev6_jaUCe-G5PqktMiMGb7ohDy0daunxzQD5jafg,5594
+bosdyn/client/auth.py,sha256=SvIsSA-qDbGI4fHq9aACHdKBQDeL6RGvSoJMtJYJuQ8,6253
+bosdyn/client/auto_return.py,sha256=kqT1gaaneLYIPFVAFzpvTHRwa8NYYQ2OBf7wViBQudE,5598
+bosdyn/client/autowalk.py,sha256=vpTtuYRo5nMgMGFwyK6YQBulwuqTmMVFfAkDc3yM-W0,5731
+bosdyn/client/bddf.py,sha256=ok_2JcflSCQfcM25lpEgzKnkEJl0FDcJ16Bgo9Rjyzc,1763
+bosdyn/client/bddf_download.py,sha256=oDztm-aS5J_ABLb-cxomNtwNPrdlnFp8hEuOMVxVRH4,7586
+bosdyn/client/channel.py,sha256=HCr7O6VEiAX3-R3YYtQkGKyQt2H7054BQSVdDB1XWAM,8902
+bosdyn/client/command_line.py,sha256=eZKWLiJmrQDBte_kjIDwb3r5AaF8AKEzJRfrYpETnWI,87380
+bosdyn/client/common.py,sha256=tab0BAEPqEwR5B2hVfbWRIAb4_CcBCVxBeFMRtm1kQ0,22549
+bosdyn/client/data_acquisition.py,sha256=yPe43CDhuefvWQkMUfOBSTknhZ-gsBy7V-q3ak-MHUw,13123
+bosdyn/client/data_acquisition_helpers.py,sha256=ddhx9tQ5feo_qraOzkmut6ArVtZ9OySamPUIUzBKFr8,14837
+bosdyn/client/data_acquisition_plugin.py,sha256=oMcjRpzzAuWPVs0tutggEjVodZrJ-p3KzqKKce6wWbM,6166
+bosdyn/client/data_acquisition_plugin_service.py,sha256=4tqakj_7hnV1HsVKXuaypkqkl5tdXSCoL9gsTxhhDb0,25078
+bosdyn/client/data_acquisition_store.py,sha256=L5ywybtP-dIi2kdpAFhnegI4YTjPml2zp50Rma0fRLw,12272
+bosdyn/client/data_buffer.py,sha256=5YOdf7r7jsA2g_-F3ipk96AJ7q07okk0sq2lYdn5wRg,25812
+bosdyn/client/data_chunk.py,sha256=c0BYB9bE_B1KFX3_9gFpwg_U9AVQTRf-W5WBTIwfnCo,1958
+bosdyn/client/data_service.py,sha256=aKfXJCciJ2M2WZRKfdWiLS2n-UEKWSRkOgcTnArbc5o,5201
+bosdyn/client/directory.py,sha256=jWBxnPzBJSrfr4fuLf2VuZGsxOo8Q5iX5tEw6Zx2VY0,4906
+bosdyn/client/directory_registration.py,sha256=5bKXl61rOJnc2MBSoevQVzKoqiBeyALi09nDT6eP06A,19696
+bosdyn/client/docking.py,sha256=hYwZNIir3_pt-WvMFiXzMqDCwW8nA5H1BYOUD6_3-00,17596
+bosdyn/client/door.py,sha256=dbBuGcuoZL3gRhxTQoQHKDlnzcML8ELBtQxCQqomYpo,3110
+bosdyn/client/estop.py,sha256=-dy3SP6lcOryyTB_VXe0C_cFk-qK1TNJdSm9DKSz-MM,32073
+bosdyn/client/exceptions.py,sha256=oTbHhyhxiP3dhg9esi0_4Zn5xU9a0tE5FnESDfD0J3s,5418
+bosdyn/client/fault.py,sha256=ymo4M1Vy-bUasD8uOm1pxE1HnjheCds6qA9hZiJbAzY,6050
+bosdyn/client/frame_helpers.py,sha256=Xo0ypDEfhShif2JWyiQ_XmmqLpM-Y3ZhL4U21MQu2lU,12480
+bosdyn/client/graph_nav.py,sha256=jNm0A8qA1QX9QVGSZtr6yNYKSimDLAr3CtAZhEflKsA,64764
+bosdyn/client/gripper_camera_param.py,sha256=QKkHrA08c-BRhyLHrE4pDdh8AGUytoq6OABZpqsvVB0,2631
+bosdyn/client/image.py,sha256=McYzS8aBSHuuyaKGnS1rfzFAsjmFeboOrcJ24j9BJ_I,20435
+bosdyn/client/image_service_helpers.py,sha256=EXziSY8j6p5PUtPVtYGu14xJKugGcAaUH1Cu15Y9Quc,39462
+bosdyn/client/inverse_kinematics.py,sha256=KBgvGdnt-JZJvDzbdJ72Kqw8RHoOsqKq_p9rQtvwuKo,1708
+bosdyn/client/ir_enable_disable.py,sha256=6c5MAuO1Fj0RlVcjkP1vhs-qTLiOpM3RnD8F7_ik1Gw,2153
+bosdyn/client/keepalive.py,sha256=C-Vf17-sSfAHq4cbuuVIh7JQM7NLzv2pRekjHJywfdU,13214
+bosdyn/client/lease.py,sha256=cPYUW8nCHR7_hKQgA3bVSF5MNb1nXWVSrrPkTWgPFA4,45001
+bosdyn/client/lease_resource_hierarchy.py,sha256=b_YpVCeiJwVQzAy1Xh5h-1HYjpbzZvmDZAcREGCOgBc,3070
+bosdyn/client/lease_validator.py,sha256=Al7YWI9TsI6UVPdnqkHHZZhbL9CSDzgdgoRrikZ7AA8,14531
+bosdyn/client/license.py,sha256=mJRBtwo3UHUVXqAKq-3eBf35v9U_Za_P9lPRXF9q9Lk,1736
+bosdyn/client/local_grid.py,sha256=YszM_pTmeGuGIwExgRwB76PXJciO6rZqfaL2RHLxAf0,3475
+bosdyn/client/log_annotation.py,sha256=KoKSC7QfMCbRn6TDhAsSvIRVKoILjIyKvrSjjQs4wT8,15506
+bosdyn/client/log_status.py,sha256=3Jn-zkG9E3J7GX0RknO3BLcGAUWt-lbzkbKX6EOCsZw,11317
+bosdyn/client/manipulation_api_client.py,sha256=4vKaaexWb0BGwjvgaGaSBSDLJn_nEgJT_kPRTSzCUbU,4203
+bosdyn/client/map_processing.py,sha256=-Ay0fRoP7KczasvCwDAOdjnq9oQw-bgT5jaemYx9f0Y,9830
+bosdyn/client/math_helpers.py,sha256=IERJp5Cv4ZFVBEFfcHJptvfs2Vm5Xn92zftA1MJfgNY,47499
+bosdyn/client/network_compute_bridge_client.py,sha256=zFRanbJxTrTGdUR1kQHW83xjweTGKoRDoEmHGO7wSSw,7695
+bosdyn/client/payload.py,sha256=12vZirEI4-gu9KPHsDg6MH0QCmnxbolWR1j81lvgfVw,2271
+bosdyn/client/payload_registration.py,sha256=ilT-2W1iuCZImLeDlPLovPYg5HJCk7nLTHxod0Rn8nY,22316
+bosdyn/client/point_cloud.py,sha256=EZO67eqzTEX31RPHBvWXhu2GSSM82BfNNoWALFv21Xk,8382
+bosdyn/client/power.py,sha256=sxDw7I-8vvncwE9dh3fIjmzrS-D_7B494GbWhcd6CF0,24938
+bosdyn/client/processors.py,sha256=Z-Djf_I_lhfokB-f_L0PewAY8J95LThdWVju1zJ2BaE,1275
+bosdyn/client/ray_cast.py,sha256=Ca1yJo0aY6OmVAazb19fy44L-9LzcKVxr_fHt_EoQtg,4465
+bosdyn/client/recording.py,sha256=AhTChvpKmQSOldVBTuHm5LSAuMNf-AVYRYNm5YHUaO8,26016
+bosdyn/client/robot.py,sha256=YetjsdF8Q-DVTe6skd3Jl1HmdpKmSrQWlx3ad39fVOs,30775
+bosdyn/client/robot_command.py,sha256=FVh-xExi-ctvu0Zoi1leHkPcFeWw8wn_ceD5eCDAQD4,100454
+bosdyn/client/robot_id.py,sha256=ghr3TQ20_sBJkC_MjflwCeooPdI09BJS98nzrqWOhzI,2359
+bosdyn/client/robot_state.py,sha256=I_IrY6AaOWYEC4-yNoVl5-0wxyl22wlbR9uOVOGyHNY,6215
+bosdyn/client/sdk.py,sha256=7Ld3DE0kDs3Dmgv5rABHvmUFDI28uQZL0QypksLlQ6s,12932
+bosdyn/client/server_util.py,sha256=ZBdmIf8uaeqt0nsbVADY9qxIB7TtIm-cjdGvo1Imcuw,10199
+bosdyn/client/service_customization_helpers.py,sha256=lZAdmHP84Le7kUFKFnzCb_NB4U4uKhHNd6FOwuusKOQ,22568
+bosdyn/client/spot_check.py,sha256=jELZB2WjGoEz8v19ftI7Q2FLYnenos9Ny82Ia_L3Mts,14614
+bosdyn/client/time_sync.py,sha256=DNnf_vS33rLuGZHMRNuVM3wCR3IjKOk89EAzSxz7OUI,21284
+bosdyn/client/token_cache.py,sha256=Vwf9YfsR7pTyu1fLRzXrvDo9hG5GBJcen8Azlo_5_iA,3507
+bosdyn/client/token_manager.py,sha256=FvDFCXKIiGXZNkagKZM41Ut8Q0ChlYHN3O61CzrqMF8,3144
+bosdyn/client/util.py,sha256=1turXd8J-cgyOhSdtCuKfWWYGXwy2B7_0KA2BsBVqN8,19043
+bosdyn/client/world_object.py,sha256=jixEHrQ-Hx2jo_Bulj9cSov8GEHHg2_BuLRL5EgtQAI,18679
+bosdyn/client/resources/__init__.py,sha256=1qUAbnMKYlERYZvxtGz4ThjYef7Tx-ZBclLoVE_ecjU,265
 bosdyn/client/resources/robot.pem,sha256=kWAr4xK29RtTVC_EhbwW2_NblIuecYqVudR2YIdTh84,1874
-bosdyn/client/spot_cam/__init__.py,sha256=fTghGvIEkHWxbbQ4N4bqkVRd7pgC-lm3n1AjkHcpi-Y,790
-bosdyn/client/spot_cam/audio.py,sha256=POihIPnvi2fGB5DzlFDc56kQUlylZXlgKJxENYid7cM,9843
-bosdyn/client/spot_cam/compositor.py,sha256=y9DeSLhteQxYQcWlWdX73k8q-YG8dSoax8NkWGWeG-o,7889
-bosdyn/client/spot_cam/health.py,sha256=LyE4Ixum8HxXxTn10_PHaZQh1dJctYtWetiFMDFXeqU,4707
-bosdyn/client/spot_cam/lighting.py,sha256=_Ag0BppS4AJSN1eVRnb8nPuSqn4hRkW5uY1v0SUT7LE,3089
-bosdyn/client/spot_cam/lights_helper.py,sha256=ZccCMR1sh2r29J8o5Bp4PbCR910pQ9lmwqZI9Cn2uk0,3963
-bosdyn/client/spot_cam/media_log.py,sha256=WvxM7vCJRelZnV_qyYUD6luKwIQq3c7TEne_aphWjVM,10372
-bosdyn/client/spot_cam/network.py,sha256=UIEWYgGWhiUoJD_LpYajI_IlwkcleaFUdI6Ci75Z7rc,3023
-bosdyn/client/spot_cam/power.py,sha256=carB2tySQ7wF1utQkt2sDZOLZJ5ggjvWy94YkQogSbc,5181
-bosdyn/client/spot_cam/ptz.py,sha256=Pxf7wGjzgQc6cDP9pMad3ZrhB0Eh6s0qyACK-q_DXqk,6942
-bosdyn/client/spot_cam/streamquality.py,sha256=UQehLFl-l3b3BC0ljiEAmzOhrhP6RgsvX0u3YWYzmBo,4453
-bosdyn/client/spot_cam/version.py,sha256=j2If1SVham-BNyB_NCQJveikZLp1A172Loi8jUzvGBE,2856
-bosdyn_client-3.2.3.dist-info/METADATA,sha256=V4nqmKUFZ0T5lG98WPBH38nHhmgPtJyQ-GgPvF_xkTQ,3740
-bosdyn_client-3.2.3.dist-info/WHEEL,sha256=h_aVn5OB2IERUjMbi2pucmR_zzWJtk303YXvhh60NJ8,110
-bosdyn_client-3.2.3.dist-info/top_level.txt,sha256=an2OWgx1ej2jFjmBjPWNQ68ZglvUfKhmXWW-WhTtDmA,7
-bosdyn_client-3.2.3.dist-info/RECORD,,
+bosdyn/client/spot_cam/__init__.py,sha256=EZAvjRSla78A2iAENu-VJLbmwamNenTZPwQspQ5iyx8,790
+bosdyn/client/spot_cam/audio.py,sha256=8DvUOhfHVYTOXqlQEny5qUjHvvDsijvJ_njqyNJWUrs,9845
+bosdyn/client/spot_cam/compositor.py,sha256=hajJVVjf_gc93arG6T1Mu3zhMA90_TV2sIwlZr1hDZI,10294
+bosdyn/client/spot_cam/health.py,sha256=HsmLOKVb7iM6bfbZye0UapPezL2naWo4yl_7HQDNGA4,4707
+bosdyn/client/spot_cam/lighting.py,sha256=mEUK8EWs-NRTXzDTu5VSIYD6IfyiTkfMF82Y-agHZ5g,3089
+bosdyn/client/spot_cam/lights_helper.py,sha256=VWhXwcZ1a5X6OQ6Fd1CzGGPdW4BNQ5j636BCn6t9F58,3963
+bosdyn/client/spot_cam/media_log.py,sha256=CJJepePouHr1QoXuev8oJSMhA-JUYpcm6IBUq4k-Bl4,10379
+bosdyn/client/spot_cam/network.py,sha256=W7z91ERPzba3BCK23jio8byDjVr6kYnucQ9zKg9BqUA,3023
+bosdyn/client/spot_cam/power.py,sha256=HS3nJF8hXq9m1JziOIwLHGLtlNMyLgewWBgs-mRZmTM,5181
+bosdyn/client/spot_cam/ptz.py,sha256=f_SJxRger-odXnK3QkXGMkqTqYEEsl47hJexpVjx84s,10177
+bosdyn/client/spot_cam/streamquality.py,sha256=hQzVPdKnzVT91fc8E8AmNqhAPgddt0XE2tzNQD6QefQ,6411
+bosdyn/client/spot_cam/version.py,sha256=R82eyCAY9PfZqbN8D6hNzSeZatpgpsFr995dRt1Mbe0,2856
+bosdyn_client-3.3.0.dist-info/METADATA,sha256=Oe7psceroAMm7WkStoWMwsyDTSU7Sb37ORpYuk0sNic,3904
+bosdyn_client-3.3.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+bosdyn_client-3.3.0.dist-info/top_level.txt,sha256=an2OWgx1ej2jFjmBjPWNQ68ZglvUfKhmXWW-WhTtDmA,7
+bosdyn_client-3.3.0.dist-info/RECORD,,
```

