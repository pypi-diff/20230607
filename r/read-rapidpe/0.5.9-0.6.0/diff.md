# Comparing `tmp/read_rapidpe-0.5.9.tar.gz` & `tmp/read_rapidpe-0.6.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "read_rapidpe-0.5.9.tar", max compression
+gzip compressed data, was "read_rapidpe-0.6.0.tar", max compression
```

## Comparing `read_rapidpe-0.5.9.tar` & `read_rapidpe-0.6.0.tar`

### file list

```diff
@@ -1,11 +1,13 @@
--rw-r--r--   0        0        0     2399 2023-04-17 13:15:50.969962 read_rapidpe-0.5.9/README.md
--rw-r--r--   0        0        0      627 2023-06-05 00:15:43.290147 read_rapidpe-0.5.9/pyproject.toml
--rw-r--r--   0        0        0      342 2023-06-04 17:50:03.396354 read_rapidpe-0.5.9/read_rapidpe/__init__.py
--rw-r--r--   0        0        0    11295 2023-05-13 16:31:51.989559 read_rapidpe-0.5.9/read_rapidpe/grid_point.py
--rw-r--r--   0        0        0     3620 2023-06-03 15:19:21.433555 read_rapidpe-0.5.9/read_rapidpe/io.py
--rw-r--r--   0        0        0     6083 2023-04-16 13:20:01.614285 read_rapidpe-0.5.9/read_rapidpe/p_astro.py
--rw-r--r--   0        0        0     9718 2023-04-07 15:04:09.805939 read_rapidpe-0.5.9/read_rapidpe/parser.py
--rw-r--r--   0        0        0     5890 2023-06-04 20:42:24.365320 read_rapidpe-0.5.9/read_rapidpe/plot.py
--rw-r--r--   0        0        0    33548 2023-06-05 00:14:27.919501 read_rapidpe-0.5.9/read_rapidpe/result.py
--rw-r--r--   0        0        0     8855 2023-06-03 14:39:22.849276 read_rapidpe-0.5.9/read_rapidpe/transform.py
--rw-r--r--   0        0        0     3330 1970-01-01 00:00:00.000000 read_rapidpe-0.5.9/PKG-INFO
+-rw-r--r--   0        0        0     2399 2023-04-17 13:15:50.969962 read_rapidpe-0.6.0/README.md
+-rw-r--r--   0        0        0      627 2023-06-06 23:20:26.804855 read_rapidpe-0.6.0/pyproject.toml
+-rw-r--r--   0        0        0      342 2023-06-04 17:50:03.396354 read_rapidpe-0.6.0/read_rapidpe/__init__.py
+-rw-r--r--   0        0        0    11295 2023-05-13 16:31:51.989559 read_rapidpe-0.6.0/read_rapidpe/grid_point.py
+-rw-r--r--   0        0        0     3620 2023-06-03 15:19:21.433555 read_rapidpe-0.6.0/read_rapidpe/io.py
+-rw-r--r--   0        0        0     6083 2023-04-16 13:20:01.614285 read_rapidpe-0.6.0/read_rapidpe/p_astro.py
+-rw-r--r--   0        0        0     9718 2023-04-07 15:04:09.805939 read_rapidpe-0.6.0/read_rapidpe/parser.py
+-rw-r--r--   0        0        0     5890 2023-06-04 20:42:24.365320 read_rapidpe-0.6.0/read_rapidpe/plot.py
+-rw-r--r--   0        0        0        0 2023-06-06 20:59:26.587831 read_rapidpe-0.6.0/read_rapidpe/plugins/__init__.py
+-rw-r--r--   0        0        0     6291 2023-06-06 23:15:51.020171 read_rapidpe-0.6.0/read_rapidpe/plugins/em_bright.py
+-rw-r--r--   0        0        0    35379 2023-06-06 00:08:56.172702 read_rapidpe-0.6.0/read_rapidpe/result.py
+-rw-r--r--   0        0        0     8855 2023-06-03 14:39:22.849276 read_rapidpe-0.6.0/read_rapidpe/transform.py
+-rw-r--r--   0        0        0     3330 1970-01-01 00:00:00.000000 read_rapidpe-0.6.0/PKG-INFO
```

### Comparing `read_rapidpe-0.5.9/README.md` & `read_rapidpe-0.6.0/README.md`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/pyproject.toml` & `read_rapidpe-0.6.0/pyproject.toml`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "read-rapidpe"
-version = "0.5.9"
+version = "0.6.0"
 description = "Read and analyse results generated by rapidpe-rift-pipe"
 authors = ["Cory Chu <cory@gwlab.page>"]
 readme = "README.md"
 packages = [{include = "read_rapidpe"}]
 homepage = "https://github.com/c0rychu/read-rapidpe"
 repository = "https://git.ligo.org/yu-kuang.chu/read-rapidpe"
```

### Comparing `read_rapidpe-0.5.9/read_rapidpe/grid_point.py` & `read_rapidpe-0.6.0/read_rapidpe/grid_point.py`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/read_rapidpe/io.py` & `read_rapidpe-0.6.0/read_rapidpe/io.py`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/read_rapidpe/p_astro.py` & `read_rapidpe-0.6.0/read_rapidpe/p_astro.py`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/read_rapidpe/parser.py` & `read_rapidpe-0.6.0/read_rapidpe/parser.py`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/read_rapidpe/plot.py` & `read_rapidpe-0.6.0/read_rapidpe/plot.py`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/read_rapidpe/result.py` & `read_rapidpe-0.6.0/read_rapidpe/result.py`

 * *Files 3% similar despite different names*

```diff
@@ -762,15 +762,16 @@
             # m_samples = np.random.choice(m, size=N, p=prob)
             m_samples = np.random.choice(m, size=N, p=prob, replace=False)
             m1, m2 = np.array([[x["m1"], x["m2"]] for x in m_samples]).T
             self.samples = {"mass_1": m1, "mass_2": m2}
 
     def generate_posterior_samples(self,
                                    N=5000,
-                                   method="gaussian",
+                                   method="gaussian-resample",
+                                   seed=None,
                                    gaussian_sigma_to_grid_size_ratio=1.0,
                                    em_bright_compatible=True):
         """
         Generate posterior samples.
         The generated samples are saved in self.samples
 
         Parameters
@@ -788,42 +789,51 @@
             Default: 1.0
 
         em_bright_compatible: bool
             If True, generate samples compatible with EM_BRIGHT
             Default: True
 
         """
-        if method == "gaussian":
+
+        rng = np.random.default_rng(seed)
+
+        if method == "gaussian" or method == "gaussian-resample":
             grid_levels = np.unique(self.iteration)
             cov = {}
             for gl in grid_levels:
                 mask = self.iteration == gl
                 sigma_x1 = grid_separation_min(
                     self.x1[mask]) * gaussian_sigma_to_grid_size_ratio
                 sigma_x2 = grid_separation_min(
                     self.x2[mask]) * gaussian_sigma_to_grid_size_ratio
                 cov[gl] = np.diag([sigma_x1**2, sigma_x2**2])
 
             # Compute normalized relative likelihood at each grid point
             prob = np.exp(self.marg_log_likelihood
                           - logsumexp(self.marg_log_likelihood))
 
+            if method == "gaussian":
+                x = Mass_Spin.from_m1m2(self.mass_1,
+                                        self.mass_2,
+                                        grid_coordinates=self.grid_coordinates)
+                prob *= x.jacobian_m1m2_by_x1x2
+                prob /= np.sum(prob)
+
             # Compute number of samples for each grid point
-            N_multinomial = multinomial(N*20, prob)
-            N_per_grid_point = N_multinomial.rvs(1)[0]
+            N_per_grid_point = rng.multinomial(N*20, pvals=prob)
 
             # Generate samples
             samples = np.zeros([0, 2])
             for x1, x2, gl, n in zip(self.x1,
                                      self.x2,
                                      self.iteration,
                                      N_per_grid_point):
                 samples = np.concatenate([
                     samples,
-                    np.random.multivariate_normal([x1, x2], cov[gl], n)
+                    rng.multivariate_normal([x1, x2], cov[gl], n)
                     ])
             x1, x2 = samples.T
 
             # Mask out the samples outside the region of interest
             if self.grid_coordinates[0] == "chirp_mass":
                 x1_min = 0.0
             else:
@@ -851,22 +861,25 @@
             # An ad-hoc cut on the mass_1 and mass_2
             mask_m1m2 = x.mass_1 < 500
             # mask_m1m2 &= x.mass_2 > 0.1
 
             # Re-weight the samples according to the Jacobian such that
             # it has a uniform prior in m1-m2 space
             # Reference: https://dcc.ligo.org/LIGO-T2300198
-            weight = x.jacobian_m1m2_by_x1x2[mask_m1m2]
-            weight /= np.sum(weight)
+            if method == "gaussian-resample":
+                weight = x.jacobian_m1m2_by_x1x2[mask_m1m2]
+                weight /= np.sum(weight)
+            else:
+                weight = None
 
             m = {"mass_1": x.mass_1[mask_m1m2],
                  "mass_2": x.mass_2[mask_m1m2]}
 
             m = dict_of_ndarray_to_recarray(m)
-            samples = np.random.choice(m, size=N, p=weight, replace=False)
+            samples = rng.choice(m, size=N, p=weight, replace=False)
             samples = recarray_to_dict_of_ndarray(samples)
 
             if em_bright_compatible:
                 shape = samples["mass_1"].shape
                 event_spin = self.event_info["event_spin"]
                 spin_1z = np.broadcast_to(event_spin["spin_1z"], shape)
                 spin_2z = np.broadcast_to(event_spin["spin_2z"], shape)
@@ -876,24 +889,64 @@
                 samples["spin_1z"] = spin_1z
                 samples["spin_2z"] = spin_2z
 
                 self.posterior_samples = samples
             else:
                 self.posterior_samples = samples
 
-    def plot_grid(self, posterior_samples=True):
+    def plot_grid(self,
+                  posterior_samples=True,
+                  true_params=True,
+                  legend_loc=None):
+        import matplotlib.pyplot as plt
         from .plot import plot_grid
+
         plot_grid(self, posterior_samples=posterior_samples)
 
+        if true_params:
+            legend = False
+            try:
+                x_inj = Mass_Spin.from_m1m2(
+                    self.injection_info["mass_1"],
+                    self.injection_info["mass_2"],
+                    grid_coordinates=self.grid_coordinates
+                )
+                plt.scatter(x_inj.x1, x_inj.x2, marker="*", c="r", s=35,
+                            label="Injection")
+                legend = True
+            except AttributeError:
+                pass
+
+            try:
+                x_pipe = Mass_Spin.from_m1m2(
+                    self.event_info["intrinsic_param"]["mass_1"],
+                    self.event_info["intrinsic_param"]["mass_2"],
+                    grid_coordinates=self.grid_coordinates
+                )
+                plt.scatter(x_pipe.x1, x_pipe.x2, marker="o", c="b", s=15,
+                            label="Search Pipeline")
+                legend = True
+            except AttributeError:
+                pass
+
+            if legend:
+                plt.legend(loc=legend_loc, fontsize="8", fancybox=False)
+
     def plot_corner(self,
                     columns=["mass_1", "mass_2"],
+                    title=None,
                     **kwargs):
         from .plot import plot_corner
 
         samples = {}
         for col in columns:
             try:
                 samples[col] = self.posterior_samples[col]
             except KeyError:
                 pass
 
-        plot_corner(samples, **kwargs)
+        fig = plot_corner(samples, **kwargs)
+
+        if title is not None:
+            fig.suptitle(title, y=1.05)
+
+        return fig
```

### Comparing `read_rapidpe-0.5.9/read_rapidpe/transform.py` & `read_rapidpe-0.6.0/read_rapidpe/transform.py`

 * *Files identical despite different names*

### Comparing `read_rapidpe-0.5.9/PKG-INFO` & `read_rapidpe-0.6.0/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: read-rapidpe
-Version: 0.5.9
+Version: 0.6.0
 Summary: Read and analyse results generated by rapidpe-rift-pipe
 Home-page: https://github.com/c0rychu/read-rapidpe
 Author: Cory Chu
 Author-email: cory@gwlab.page
 Requires-Python: >=3.8,<4.0
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
```

