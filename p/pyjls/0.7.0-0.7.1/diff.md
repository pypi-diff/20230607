# Comparing `tmp/pyjls-0.7.0.tar.gz` & `tmp/pyjls-0.7.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyjls-0.7.0.tar", last modified: Wed May 31 12:16:00 2023, max compression
+gzip compressed data, was "pyjls-0.7.1.tar", last modified: Wed Jun  7 21:34:37 2023, max compression
```

## Comparing `pyjls-0.7.0.tar` & `pyjls-0.7.1.tar`

### file list

```diff
@@ -1,79 +1,81 @@
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.371623 pyjls-0.7.0/
--rw-rw-rw-   0        0        0     5165 2023-05-31 11:39:34.000000 pyjls-0.7.0/CHANGELOG.md
--rw-rw-rw-   0        0        0     3039 2021-03-18 16:48:36.000000 pyjls-0.7.0/CREDITS.html
--rw-rw-rw-   0        0        0    11558 2018-07-03 17:53:12.000000 pyjls-0.7.0/LICENSE
--rw-rw-rw-   0        0        0      177 2021-03-10 13:52:18.000000 pyjls-0.7.0/MANIFEST.in
--rw-rw-rw-   0        0        0    14665 2023-05-31 12:16:00.371120 pyjls-0.7.0/PKG-INFO
--rw-rw-rw-   0        0        0    13054 2022-03-07 15:46:24.000000 pyjls-0.7.0/README.md
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.232833 pyjls-0.7.0/include/
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.276142 pyjls-0.7.0/include/jls/
--rw-rw-rw-   0        0        0     2745 2023-05-16 17:33:09.000000 pyjls-0.7.0/include/jls/backend.h
--rw-rw-rw-   0        0        0     2103 2023-05-16 17:35:22.000000 pyjls-0.7.0/include/jls/cmacro.h
--rw-rw-rw-   0        0        0     1593 2023-05-16 18:43:43.000000 pyjls-0.7.0/include/jls/crc32c.h
--rw-rw-rw-   0        0        0     4080 2023-05-16 18:43:53.000000 pyjls-0.7.0/include/jls/ec.h
--rw-rw-rw-   0        0        0    24468 2023-04-26 11:42:25.000000 pyjls-0.7.0/include/jls/format.h
--rw-rw-rw-   0        0        0    12016 2023-05-30 20:46:47.000000 pyjls-0.7.0/include/jls/log.h
--rw-rw-rw-   0        0        0     6351 2022-03-05 19:14:45.000000 pyjls-0.7.0/include/jls/raw.h
--rw-rw-rw-   0        0        0    10319 2023-04-26 17:43:17.000000 pyjls-0.7.0/include/jls/reader.h
--rw-rw-rw-   0        0        0     4213 2023-05-16 18:44:44.000000 pyjls-0.7.0/include/jls/statistics.h
--rw-rw-rw-   0        0        0     2561 2022-03-05 19:14:45.000000 pyjls-0.7.0/include/jls/threaded_writer.h
--rw-rw-rw-   0        0        0    12420 2023-04-19 20:31:02.000000 pyjls-0.7.0/include/jls/time.h
--rw-rw-rw-   0        0        0     2760 2023-05-31 11:39:40.000000 pyjls-0.7.0/include/jls/version.h
--rw-rw-rw-   0        0        0     5775 2022-03-05 19:14:45.000000 pyjls-0.7.0/include/jls/writer.h
--rw-rw-rw-   0        0        0      895 2022-03-05 19:14:45.000000 pyjls-0.7.0/include/jls.h
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.217743 pyjls-0.7.0/include_prv/
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.302849 pyjls-0.7.0/include_prv/jls/
--rw-rw-rw-   0        0        0     1385 2022-03-07 15:46:24.000000 pyjls-0.7.0/include_prv/jls/bit_shift.h
--rw-rw-rw-   0        0        0     2099 2022-03-05 19:14:45.000000 pyjls-0.7.0/include_prv/jls/cdef.h
--rw-rw-rw-   0        0        0     1524 2023-05-27 15:49:14.000000 pyjls-0.7.0/include_prv/jls/datatype.h
--rw-rw-rw-   0        0        0     2951 2023-05-25 18:56:38.000000 pyjls-0.7.0/include_prv/jls/msg_ring_buffer.h
--rw-rw-rw-   0        0        0     1784 2023-04-26 18:12:34.000000 pyjls-0.7.0/include_prv/jls/rd_fsr.h
--rw-rw-rw-   0        0        0     1276 2022-03-05 19:14:45.000000 pyjls-0.7.0/include_prv/jls/util.h
--rw-rw-rw-   0        0        0     1945 2022-03-05 19:14:45.000000 pyjls-0.7.0/include_prv/jls/wr_fsr.h
--rw-rw-rw-   0        0        0     1744 2022-03-05 19:14:45.000000 pyjls-0.7.0/include_prv/jls/wr_prv.h
--rw-rw-rw-   0        0        0     3042 2022-03-05 19:14:45.000000 pyjls-0.7.0/include_prv/jls/wr_ts.h
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.308853 pyjls-0.7.0/pyjls/
--rw-rw-rw-   0        0        0     1208 2023-03-04 20:14:09.000000 pyjls-0.7.0/pyjls/__init__.py
--rw-rw-rw-   0        0        0     2557 2022-03-05 19:14:45.000000 pyjls-0.7.0/pyjls/__main__.py
--rw-rw-rw-   0        0        0  1610185 2023-05-31 12:03:55.000000 pyjls-0.7.0/pyjls/binding.c
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.318165 pyjls-0.7.0/pyjls/entry_points/
--rw-rw-rw-   0        0        0      869 2023-04-28 18:19:13.000000 pyjls-0.7.0/pyjls/entry_points/__init__.py
--rw-rw-rw-   0        0        0     2738 2022-03-05 19:14:45.000000 pyjls-0.7.0/pyjls/entry_points/annotate.py
--rw-rw-rw-   0        0        0     2561 2023-04-28 18:26:31.000000 pyjls-0.7.0/pyjls/entry_points/export.py
--rw-rw-rw-   0        0        0     2019 2023-04-28 12:29:04.000000 pyjls-0.7.0/pyjls/entry_points/info.py
--rw-rw-rw-   0        0        0     2333 2023-04-28 12:48:59.000000 pyjls-0.7.0/pyjls/structs.py
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.319165 pyjls-0.7.0/pyjls/test/
--rw-rw-rw-   0        0        0      594 2022-03-05 19:14:45.000000 pyjls-0.7.0/pyjls/test/__init__.py
--rw-rw-rw-   0        0        0    10313 2023-04-26 19:18:13.000000 pyjls-0.7.0/pyjls/test/test_binding.py
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.319165 pyjls-0.7.0/pyjls/v1/
--rw-rw-rw-   0        0        0      594 2022-03-05 19:14:45.000000 pyjls-0.7.0/pyjls/v1/__init__.py
--rw-rw-rw-   0        0        0     1059 2023-05-31 11:39:40.000000 pyjls-0.7.0/pyjls/version.py
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.317166 pyjls-0.7.0/pyjls.egg-info/
--rw-rw-rw-   0        0        0    14665 2023-05-31 12:16:00.000000 pyjls-0.7.0/pyjls.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     1339 2023-05-31 12:16:00.000000 pyjls-0.7.0/pyjls.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-05-31 12:16:00.000000 pyjls-0.7.0/pyjls.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       45 2023-05-31 12:16:00.000000 pyjls-0.7.0/pyjls.egg-info/entry_points.txt
--rw-rw-rw-   0        0        0       53 2023-05-31 12:16:00.000000 pyjls-0.7.0/pyjls.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2023-05-31 12:16:00.000000 pyjls-0.7.0/pyjls.egg-info/top_level.txt
--rw-rw-rw-   0        0        0      851 2022-11-30 13:53:49.000000 pyjls-0.7.0/pyproject.toml
--rw-rw-rw-   0        0        0       42 2023-05-31 12:16:00.371623 pyjls-0.7.0/setup.cfg
--rw-rw-rw-   0        0        0     6742 2023-04-27 15:16:07.000000 pyjls-0.7.0/setup.py
-drwxrwxrwx   0        0        0        0 2023-05-31 12:16:00.370120 pyjls-0.7.0/src/
--rw-rw-rw-   0        0        0     8684 2023-05-25 21:22:49.000000 pyjls-0.7.0/src/backend_posix.c
--rw-rw-rw-   0        0        0     9046 2023-05-25 21:36:14.000000 pyjls-0.7.0/src/backend_win.c
--rw-rw-rw-   0        0        0     1179 2022-03-07 15:46:24.000000 pyjls-0.7.0/src/bit_shift.c
--rw-rw-rw-   0        0        0     1855 2022-03-05 19:14:45.000000 pyjls-0.7.0/src/crc32c_arm_neon.c
--rw-rw-rw-   0        0        0     2433 2022-03-05 19:14:45.000000 pyjls-0.7.0/src/crc32c_intel_sse4.c
--rw-rw-rw-   0        0        0    33673 2022-03-05 19:14:45.000000 pyjls-0.7.0/src/crc32c_sw.c
--rw-rw-rw-   0        0        0     3589 2022-03-07 15:46:24.000000 pyjls-0.7.0/src/datatype.c
--rw-rw-rw-   0        0        0     1113 2022-03-05 19:14:45.000000 pyjls-0.7.0/src/ec.c
--rw-rw-rw-   0        0        0     2132 2023-05-26 20:12:15.000000 pyjls-0.7.0/src/log.c
--rw-rw-rw-   0        0        0     4190 2023-05-25 18:57:18.000000 pyjls-0.7.0/src/msg_ring_buffer.c
--rw-rw-rw-   0        0        0    17311 2023-04-19 20:32:58.000000 pyjls-0.7.0/src/raw.c
--rw-rw-rw-   0        0        0     5903 2023-04-26 19:35:45.000000 pyjls-0.7.0/src/rd_fsr.c
--rw-rw-rw-   0        0        0    55073 2023-05-30 20:41:26.000000 pyjls-0.7.0/src/reader.c
--rw-rw-rw-   0        0        0     4302 2022-03-05 19:14:45.000000 pyjls-0.7.0/src/statistics.c
--rw-rw-rw-   0        0        0    12778 2023-05-26 17:57:32.000000 pyjls-0.7.0/src/threaded_writer.c
--rw-rw-rw-   0        0        0    28085 2023-05-30 20:38:15.000000 pyjls-0.7.0/src/wr_fsr.c
--rw-rw-rw-   0        0        0     9691 2023-04-26 14:57:54.000000 pyjls-0.7.0/src/wr_ts.c
--rw-rw-rw-   0        0        0    30342 2023-04-26 12:23:06.000000 pyjls-0.7.0/src/writer.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.906780 pyjls-0.7.1/
+-rw-r--r--   0 runner    (1001) docker     (123)     5234 2023-06-07 21:34:22.000000 pyjls-0.7.1/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (123)     2965 2023-06-07 21:34:22.000000 pyjls-0.7.1/CREDITS.html
+-rw-r--r--   0 runner    (1001) docker     (123)    11357 2023-06-07 21:34:22.000000 pyjls-0.7.1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      204 2023-06-07 21:34:22.000000 pyjls-0.7.1/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)    13514 2023-06-07 21:34:37.906780 pyjls-0.7.1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    11990 2023-06-07 21:34:22.000000 pyjls-0.7.1/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.894780 pyjls-0.7.1/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.898780 pyjls-0.7.1/include/jls/
+-rw-r--r--   0 runner    (1001) docker     (123)     2661 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/backend.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2016 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/cmacro.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1527 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/crc32c.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3970 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/ec.h
+-rw-r--r--   0 runner    (1001) docker     (123)    24388 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/format.h
+-rw-r--r--   0 runner    (1001) docker     (123)    11685 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/log.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6127 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/raw.h
+-rw-r--r--   0 runner    (1001) docker     (123)    10042 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/reader.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4079 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/statistics.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5581 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/threaded_writer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12021 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/time.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2659 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/version.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5594 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls/writer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      957 2023-06-07 21:34:22.000000 pyjls-0.7.1/include/jls.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.894780 pyjls-0.7.1/include_prv/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.898780 pyjls-0.7.1/include_prv/jls/
+-rw-r--r--   0 runner    (1001) docker     (123)     1325 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/bit_shift.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2017 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/cdef.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1463 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/datatype.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2842 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/msg_ring_buffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1719 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/rd_fsr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1217 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/util.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/wr_fsr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1676 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/wr_prv.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2935 2023-06-07 21:34:22.000000 pyjls-0.7.1/include_prv/jls/wr_ts.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.902780 pyjls-0.7.1/pyjls/
+-rw-r--r--   0 runner    (1001) docker     (123)     1181 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2475 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)  1639926 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls/binding.c
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.902780 pyjls-0.7.1/pyjls/entry_points/
+-rw-r--r--   0 runner    (1001) docker     (123)      861 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/entry_points/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2672 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/entry_points/annotate.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2736 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/entry_points/export.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1958 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/entry_points/info.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3030 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/entry_points/plot.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3668 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/structs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.902780 pyjls-0.7.1/pyjls/test/
+-rw-r--r--   0 runner    (1001) docker     (123)      581 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/test/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10077 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/test/test_binding.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.902780 pyjls-0.7.1/pyjls/v1/
+-rw-r--r--   0 runner    (1001) docker     (123)      581 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/v1/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyjls/version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.902780 pyjls-0.7.1/pyjls.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)    13514 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1379 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       45 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       53 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        6 2023-06-07 21:34:37.000000 pyjls-0.7.1/pyjls.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      826 2023-06-07 21:34:22.000000 pyjls-0.7.1/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-07 21:34:37.906780 pyjls-0.7.1/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     6201 2023-06-07 21:34:22.000000 pyjls-0.7.1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-07 21:34:37.906780 pyjls-0.7.1/src/
+-rw-r--r--   0 runner    (1001) docker     (123)     8379 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/backend_posix.c
+-rw-r--r--   0 runner    (1001) docker     (123)     8751 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/backend_win.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1140 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/bit_shift.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1246 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/crc32c.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1805 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/crc32c_arm_neon.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2368 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/crc32c_intel_sse4.c
+-rw-r--r--   0 runner    (1001) docker     (123)    33131 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/crc32c_sw.c
+-rw-r--r--   0 runner    (1001) docker     (123)     3487 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/datatype.c
+-rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/ec.c
+-rw-r--r--   0 runner    (1001) docker     (123)     2048 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/log.c
+-rw-r--r--   0 runner    (1001) docker     (123)     4041 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/msg_ring_buffer.c
+-rw-r--r--   0 runner    (1001) docker     (123)    16812 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/raw.c
+-rw-r--r--   0 runner    (1001) docker     (123)     5724 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/rd_fsr.c
+-rw-r--r--   0 runner    (1001) docker     (123)    53622 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/reader.c
+-rw-r--r--   0 runner    (1001) docker     (123)     4142 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/statistics.c
+-rw-r--r--   0 runner    (1001) docker     (123)    12410 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/threaded_writer.c
+-rw-r--r--   0 runner    (1001) docker     (123)    27409 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/wr_fsr.c
+-rw-r--r--   0 runner    (1001) docker     (123)     9424 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/wr_ts.c
+-rw-r--r--   0 runner    (1001) docker     (123)    29536 2023-06-07 21:34:22.000000 pyjls-0.7.1/src/writer.c
```

### Comparing `pyjls-0.7.0/CHANGELOG.md` & `pyjls-0.7.1/CHANGELOG.md`

 * *Files 24% similar despite different names*

```diff
@@ -1,252 +1,265 @@
-
-# CHANGELOG
-
-This file contains the list of changes made to the JLS project.
-
-
-## 0.7.0
-
-2023 May 31
-
-* Fixed incorrect write timestamp stride in FSR index/summary entries.
-  Any recording over 5.77 hours was incorrect. 
-* Improved threaded writer.
-  * Removed jls_wr_flush during close due to UI performance problems.
-  * Release the GIL on some python Writer operations.
-  * Reduced buffer size from 100,000,000 B to 64 MB. 
-  * Save string null termination byte for annotations and user_data.
-  * Increased thread priority on Windows.
-  * Do not quit until all messages are processed.
-* Added jls executable to examples.
-* Improved reader logging and error handling.
-
-
-## 0.6.3
-
-2023 May 16
-
-* Added support for building a shared library.
-  Initialize build subdir with "cmake -DBUILD_SHARED_LIBS=ON .."
-
-
-## 0.6.2
-
-2023 Apr 28
-
-* Improved UTC read processing.
-* Added "--utc" option to info entry point.
-* Fixed incorrect NaNs in summary on write.
-* Added "export" pyjls entry point.
-
-
-## 0.6.1
-
-2023 Apr 27
-
-* Added FSR support for missing and duplicate data.
-* Added FSR support for unaligned u1 and u4 data.
-* Improved log messages.
-
-
-## 0.6.0
-
-2023 Apr 26
-
-* Fixed JLS to handle non-zero sample_id for first FSR data sample.
-* Added pyjls.Reader.timestamp_to_sample_id and sample_id_to_timestamp.
-
-
-## 0.5.3
-
-2023 Apr 19
-
-* Fixed build warnings for fn() declarations.
-
-
-## 0.5.2
-
-2023 Mar 30
-
-* Reduced default log level to WARNING.
-
-
-## 0.5.1
-
-2023 Mar 16
-
-* Added zero length check to jls_wr_fsr_data.
-
-
-## 0.5.0
-
-2023 Mar 9
-
-* Added support for data_type strings (not just enum integers).
-* Modified python reader bindings to release GIL.
-* Migrated to time64 representation for all API calls.
-  Use utc_to_jls and jls_to_utc to convert as needed to/from  
-  python timestamps.  
-* Added data_type_as_enum and data_type_as_str conversion functions.
-* Improved exception messages.
-
-
-## 0.4.3
-
-2022 Nov 30
-
-* Changed windows dependency from deprecated pypiwin32 to pywin32.
-* Bumped numpy dependencies.
-* Added build system requirements for pip.
-
-
-## 0.4.2
-
-2022 Mar 17
-
-* Fixed pyjls build for Raspberry Pi OS 64-bit.
-
-
-## 0.4.1
-
-2022 Mar 7
-
-* Fixed build for Linux and macOS.
-
-
-## 0.4.0
-
-2022 Mar 5
-
-* Added support for additional data types (was only f32):
-  * Signed Integer: i4, i8, i16, i24, i32, i64
-  * Unsigned Integer: u1, u4, u8, u16, u24, u32, u64
-  * Float: f64
-  * Fixed point signed & unsigned integers.
-* Renamed jls_rd_fsr_f32_statistics to jls_rd_fsr_statistics, which now
-  always returns statistics as double (f64). 
-* Improved documentation.
-
-
-## 0.3.4
-
-2021 Oct 28
-
-* Added all version fields to pyjls module.
-* Fixed writer not correctly serializing null and empty strings #6.
-
-
-## 0.3.3
-
-2021 Jul 7
-
-*   Added reader sample_id bounds checks to FSR functions.
-*   Cached jls_rd_fsr_length results.
-
-
-## 0.3.2
-
-2021 Jul 7
-
-*   Fixed incorrect statistics computation when using summaries.
-*   Added example/jls_read.c.
-*   Connected example/generate.py arguments to work correctly.
-*   Fixed documentation for jls_rd_fsr_f32_statistics().
-*   Added GitHub action.
-
-
-## 0.3.1
-
-2021 Apr 13
-
-*   Fixed y annotation argument order.
-*   Added horizontal marker annotation.
-*   Fixed Python API to automatically convert to/from UTC python timestamps.
-*   Fixed reader seek when contains multiple annotations at same timestamp.
-
-
-## 0.3.0
-
-2021 Apr 8
-
-Yanked this release, use 0.3.1
-
-*   NOT BACKWARDS COMPATIBLE with 0.2.6 and earlier.
-*   Modified annotation to contain optional y-axis position.  API change.
-*   Improved file format consistency and improved format.h.
-*   Added UTC track writer and reader for FSR signals.
-*   Added INDEX and SUMMARY writer for ANNOTATION and UTC tracks.
-*   Added reader seek to timestamp for ANNOTATION and UTC using INDEX & SUMMARY.
-
-
-## 0.2.6
-
-2021 Mar 18
-
-*   Fixed uninitialized variables in POSIX backend (thanks Valgrind!).
-*   Fixed memory leaks (thanks Valgrind!).
-
-
-## 0.2.5
-
-2021 Mar 18
-
-*   Added 32-bit ARMv7 support (Raspberry Pi OS).
-*   Added 64-bit ARM support for Apple silicon (M1).
-
-
-## 0.2.4
-
-2021 Mar 16
-
-*   Added support for aarch64 (Raspberry Pi 4).  Untested on mac M1.
-*   Fixed POSIX time.
-
-
-## 0.2.3
-
-2021 Mar 10
-
-*   Fixed sdist to include native files for pyjls cython build.
-*   Added CREDITS.html.
-*   Included credits, license & readme with pyjls source distribution.
-
-
-## 0.2.2
-
-2021 Mar 9
-
-*   Fixed build using Clang and AppleClang.
-
-
-## 0.2.1
-
-2021 Mar 8
-
-*   Fixed timeout on close when bursting data.
-*   Added annotate_stress example.
-*   Added flush.
-
-
-## 0.2.0
-
-2021 Mar 8
-
-*   Added group_id parameter to annotation.
-*   Fixed example/generate.py length argument.
-*   Updated numpy dependency to 1.20.
-*   Fixed pyjls console_script.
-*   Changed logging interface and connected native to python logging.
-
-
-## 0.1.0
-
-2021 Mar 1
-
-*   Initial public release.
-
-
-## 0.0.1
-
-2021 Feb 5
-
-*   Initial documentation.
+
+# CHANGELOG
+
+This file contains the list of changes made to the JLS project.
+
+
+## 0.7.1
+
+2023 Jun 7
+
+* Added Reader.signal_lookup.
+* Improved documentation.
+* Added Read The Docs integration.
+* Improved python "export" subcommand to specify "--signal" by name.
+* Added python subcommand "plot".
+* Improved build process, migrated to GitHub Actions.
+* Bumped minimum python version from 3.8 to 3.9.
+
+
+## 0.7.0
+
+2023 May 31
+
+* Fixed incorrect write timestamp stride in FSR index/summary entries.
+  Any recording over 5.77 hours was incorrect. 
+* Improved threaded writer.
+  * Removed jls_wr_flush during close due to UI performance problems.
+  * Release the GIL on some python Writer operations.
+  * Reduced buffer size from 100,000,000 B to 64 MB. 
+  * Save string null termination byte for annotations and user_data.
+  * Increased thread priority on Windows.
+  * Do not quit until all messages are processed.
+* Added jls executable to examples.
+* Improved reader logging and error handling.
+
+
+## 0.6.3
+
+2023 May 16
+
+* Added support for building a shared library.
+  Initialize build subdir with "cmake -DBUILD_SHARED_LIBS=ON .."
+
+
+## 0.6.2
+
+2023 Apr 28
+
+* Improved UTC read processing.
+* Added "--utc" option to info entry point.
+* Fixed incorrect NaNs in summary on write.
+* Added "export" pyjls entry point.
+
+
+## 0.6.1
+
+2023 Apr 27
+
+* Added FSR support for missing and duplicate data.
+* Added FSR support for unaligned u1 and u4 data.
+* Improved log messages.
+
+
+## 0.6.0
+
+2023 Apr 26
+
+* Fixed JLS to handle non-zero sample_id for first FSR data sample.
+* Added pyjls.Reader.timestamp_to_sample_id and sample_id_to_timestamp.
+
+
+## 0.5.3
+
+2023 Apr 19
+
+* Fixed build warnings for fn() declarations.
+
+
+## 0.5.2
+
+2023 Mar 30
+
+* Reduced default log level to WARNING.
+
+
+## 0.5.1
+
+2023 Mar 16
+
+* Added zero length check to jls_wr_fsr_data.
+
+
+## 0.5.0
+
+2023 Mar 9
+
+* Added support for data_type strings (not just enum integers).
+* Modified python reader bindings to release GIL.
+* Migrated to time64 representation for all API calls.
+  Use utc_to_jls and jls_to_utc to convert as needed to/from  
+  python timestamps.  
+* Added data_type_as_enum and data_type_as_str conversion functions.
+* Improved exception messages.
+
+
+## 0.4.3
+
+2022 Nov 30
+
+* Changed windows dependency from deprecated pypiwin32 to pywin32.
+* Bumped numpy dependencies.
+* Added build system requirements for pip.
+
+
+## 0.4.2
+
+2022 Mar 17
+
+* Fixed pyjls build for Raspberry Pi OS 64-bit.
+
+
+## 0.4.1
+
+2022 Mar 7
+
+* Fixed build for Linux and macOS.
+
+
+## 0.4.0
+
+2022 Mar 5
+
+* Added support for additional data types (was only f32):
+  * Signed Integer: i4, i8, i16, i24, i32, i64
+  * Unsigned Integer: u1, u4, u8, u16, u24, u32, u64
+  * Float: f64
+  * Fixed point signed & unsigned integers.
+* Renamed jls_rd_fsr_f32_statistics to jls_rd_fsr_statistics, which now
+  always returns statistics as double (f64). 
+* Improved documentation.
+
+
+## 0.3.4
+
+2021 Oct 28
+
+* Added all version fields to pyjls module.
+* Fixed writer not correctly serializing null and empty strings #6.
+
+
+## 0.3.3
+
+2021 Jul 7
+
+*   Added reader sample_id bounds checks to FSR functions.
+*   Cached jls_rd_fsr_length results.
+
+
+## 0.3.2
+
+2021 Jul 7
+
+*   Fixed incorrect statistics computation when using summaries.
+*   Added example/jls_read.c.
+*   Connected example/generate.py arguments to work correctly.
+*   Fixed documentation for jls_rd_fsr_f32_statistics().
+*   Added GitHub action.
+
+
+## 0.3.1
+
+2021 Apr 13
+
+*   Fixed y annotation argument order.
+*   Added horizontal marker annotation.
+*   Fixed Python API to automatically convert to/from UTC python timestamps.
+*   Fixed reader seek when contains multiple annotations at same timestamp.
+
+
+## 0.3.0
+
+2021 Apr 8
+
+Yanked this release, use 0.3.1
+
+*   NOT BACKWARDS COMPATIBLE with 0.2.6 and earlier.
+*   Modified annotation to contain optional y-axis position.  API change.
+*   Improved file format consistency and improved format.h.
+*   Added UTC track writer and reader for FSR signals.
+*   Added INDEX and SUMMARY writer for ANNOTATION and UTC tracks.
+*   Added reader seek to timestamp for ANNOTATION and UTC using INDEX & SUMMARY.
+
+
+## 0.2.6
+
+2021 Mar 18
+
+*   Fixed uninitialized variables in POSIX backend (thanks Valgrind!).
+*   Fixed memory leaks (thanks Valgrind!).
+
+
+## 0.2.5
+
+2021 Mar 18
+
+*   Added 32-bit ARMv7 support (Raspberry Pi OS).
+*   Added 64-bit ARM support for Apple silicon (M1).
+
+
+## 0.2.4
+
+2021 Mar 16
+
+*   Added support for aarch64 (Raspberry Pi 4).  Untested on mac M1.
+*   Fixed POSIX time.
+
+
+## 0.2.3
+
+2021 Mar 10
+
+*   Fixed sdist to include native files for pyjls cython build.
+*   Added CREDITS.html.
+*   Included credits, license & readme with pyjls source distribution.
+
+
+## 0.2.2
+
+2021 Mar 9
+
+*   Fixed build using Clang and AppleClang.
+
+
+## 0.2.1
+
+2021 Mar 8
+
+*   Fixed timeout on close when bursting data.
+*   Added annotate_stress example.
+*   Added flush.
+
+
+## 0.2.0
+
+2021 Mar 8
+
+*   Added group_id parameter to annotation.
+*   Fixed example/generate.py length argument.
+*   Updated numpy dependency to 1.20.
+*   Fixed pyjls console_script.
+*   Changed logging interface and connected native to python logging.
+
+
+## 0.1.0
+
+2021 Mar 1
+
+*   Initial public release.
+
+
+## 0.0.1
+
+2021 Feb 5
+
+*   Initial documentation.
```

### Comparing `pyjls-0.7.0/CREDITS.html` & `pyjls-0.7.1/CREDITS.html`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,74 +1,74 @@
-<!DOCTYPE html>
-<html lang=en>
-<head>
-  <meta charset="utf-8">
-  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
-  <title>JLS credits</title>
-</head>
-
-<body>
-  <p>JLS is 
-  Copyright © 2017-2021 Jetperch LLC and licensed under the permissive
-  <a href="https://github.com/jetperch/pyjoulescope/blob/master/LICENSE.txt">
-  Apache 2.0 License</a>.</p>
-  
-  <p>This application uses other Open Source components.  We gratefully 
-  acknowledge the countless developers who made contributions the these
-  Open Source components used by this application:</p>
-  
-  <table>
-    <tr><th>Package</th><th>License</th></tr>
-    <tr>
-      <td><a href="https://github.com/mgedmin/check-manifest">check-manifest</a></td>
-      <td><a href="https://github.com/mgedmin/check-manifest/blob/master/LICENSE.rst">MIT</a>
-          <br/>Copyright © 2013 Marius Gedminas and contributors</td>
-    </tr>
-    <tr>
-      <td><a href="https://cmocka.org/">cmocka</a></td>
-      <td><a href="https://git.cryptomilk.org/projects/cmocka.git/tree/COPYING">Apache 2.0</a>
-          <br/>Copyright 2008 Google Inc.
-          <br/>Copyright 2014-2018 Andreas Schneider
-          <br/>Copyright 2015      Jakub Hrozek</td>
-    </tr>
-    <tr>
-      <td><a href="https://github.com/htot/crc32c">crc32c</a></td>
-      <td><a href="https://github.com/htot/crc32c/blob/master/crc32c/LICENSE">BSD</a>
-          <br/>Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved
-          <br/>Copyright 2008,2009,2010 Massachusetts Institute of Technology.</td>      
-    </tr>
-    <tr>
-      <td><a href="https://github.com/nedbat/coveragepy">coverage</a></td>
-      <td><a href="https://github.com/nedbat/coveragepy/blob/master/LICENSE.txt">Apache 2.0</a>
-          <br/>Copyright 2001 Gareth Rees.  All rights reserved.
-          <br/>Copyright 2004-2019 Ned Batchelder.  All rights reserved.</td>      
-    </tr>
-    <tr>
-      <td><a href="https://cython.org/">Cython</a></td>
-      <td><a href="https://github.com/cython/cython/blob/master/LICENSE.txt">Apache 2.0</a>
-          <br/>compiler, output not a derivative work.</td>
-    </tr>
-    <tr>
-      <td><a href="https://www.numpy.org/">numpy</a></td>
-      <td><a href="https://www.numpy.org/license.html#license">BSD 3-clause</a>
-          <br/>Copyright © 2005-2021, NumPy Developers.</td>
-    </tr>
-    <tr>
-      <td><a href="https://www.python.org/">Python</a></td>
-      <td><a href="https://docs.python.org/3/license.html#psf-license-agreement-for-python-release">PSF</a>
-          <br/>Copyright © 2001-2021 Python Software Foundation</td>
-    </tr>
-    <tr>
-      <td><a href="https://github.com/pypa/wheel">wheel</a></td>
-      <td><a href="https://github.com/pypa/wheel/blob/master/LICENSE.txt">MIT</a>
-          <br/>Copyright © 2012-2014 Daniel Holth and contributors.</td>
-    </tr>
-    <tr>
-      <td><a href=""></a></td>
-      <td><a href=""></a>
-          <br/></td>
-    </tr>
-  </table>
-
-</body>
-
-</html>
+<!DOCTYPE html>
+<html lang=en>
+<head>
+  <meta charset="utf-8">
+  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
+  <title>JLS credits</title>
+</head>
+
+<body>
+  <p>JLS is 
+  Copyright © 2017-2021 Jetperch LLC and licensed under the permissive
+  <a href="https://github.com/jetperch/pyjoulescope/blob/master/LICENSE.txt">
+  Apache 2.0 License</a>.</p>
+  
+  <p>This application uses other Open Source components.  We gratefully 
+  acknowledge the countless developers who made contributions the these
+  Open Source components used by this application:</p>
+  
+  <table>
+    <tr><th>Package</th><th>License</th></tr>
+    <tr>
+      <td><a href="https://github.com/mgedmin/check-manifest">check-manifest</a></td>
+      <td><a href="https://github.com/mgedmin/check-manifest/blob/master/LICENSE.rst">MIT</a>
+          <br/>Copyright © 2013 Marius Gedminas and contributors</td>
+    </tr>
+    <tr>
+      <td><a href="https://cmocka.org/">cmocka</a></td>
+      <td><a href="https://git.cryptomilk.org/projects/cmocka.git/tree/COPYING">Apache 2.0</a>
+          <br/>Copyright 2008 Google Inc.
+          <br/>Copyright 2014-2018 Andreas Schneider
+          <br/>Copyright 2015      Jakub Hrozek</td>
+    </tr>
+    <tr>
+      <td><a href="https://github.com/htot/crc32c">crc32c</a></td>
+      <td><a href="https://github.com/htot/crc32c/blob/master/crc32c/LICENSE">BSD</a>
+          <br/>Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved
+          <br/>Copyright 2008,2009,2010 Massachusetts Institute of Technology.</td>      
+    </tr>
+    <tr>
+      <td><a href="https://github.com/nedbat/coveragepy">coverage</a></td>
+      <td><a href="https://github.com/nedbat/coveragepy/blob/master/LICENSE.txt">Apache 2.0</a>
+          <br/>Copyright 2001 Gareth Rees.  All rights reserved.
+          <br/>Copyright 2004-2019 Ned Batchelder.  All rights reserved.</td>      
+    </tr>
+    <tr>
+      <td><a href="https://cython.org/">Cython</a></td>
+      <td><a href="https://github.com/cython/cython/blob/master/LICENSE.txt">Apache 2.0</a>
+          <br/>compiler, output not a derivative work.</td>
+    </tr>
+    <tr>
+      <td><a href="https://www.numpy.org/">numpy</a></td>
+      <td><a href="https://www.numpy.org/license.html#license">BSD 3-clause</a>
+          <br/>Copyright © 2005-2021, NumPy Developers.</td>
+    </tr>
+    <tr>
+      <td><a href="https://www.python.org/">Python</a></td>
+      <td><a href="https://docs.python.org/3/license.html#psf-license-agreement-for-python-release">PSF</a>
+          <br/>Copyright © 2001-2021 Python Software Foundation</td>
+    </tr>
+    <tr>
+      <td><a href="https://github.com/pypa/wheel">wheel</a></td>
+      <td><a href="https://github.com/pypa/wheel/blob/master/LICENSE.txt">MIT</a>
+          <br/>Copyright © 2012-2014 Daniel Holth and contributors.</td>
+    </tr>
+    <tr>
+      <td><a href=""></a></td>
+      <td><a href=""></a>
+          <br/></td>
+    </tr>
+  </table>
+
+</body>
+
+</html>
```

### Comparing `pyjls-0.7.0/LICENSE` & `pyjls-0.7.1/LICENSE`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,202 +1,202 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
    limitations under the License.
```

### Comparing `pyjls-0.7.0/PKG-INFO` & `pyjls-0.7.1/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,322 +1,319 @@
-Metadata-Version: 2.1
-Name: pyjls
-Version: 0.7.0
-Summary: Joulescope™ file format
-Home-page: https://joulescope.readthedocs.io
-Author: Jetperch LLC
-Author-email: joulescope-dev@jetperch.com
-License: Apache 2.0
-Project-URL: Bug Reports, https://github.com/jetperch/jls/issues
-Project-URL: Funding, https://www.joulescope.com
-Project-URL: Twitter, https://twitter.com/joulescope
-Project-URL: Source, https://github.com/jetperch/jls/
-Keywords: JLS,Joulescope
-Classifier: Development Status :: 3 - Alpha
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: End Users/Desktop
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Operating System :: Microsoft :: Windows :: Windows 10
-Classifier: Operating System :: MacOS :: MacOS X
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Software Development :: Embedded Systems
-Classifier: Topic :: Software Development :: Testing
-Classifier: Topic :: System :: Hardware :: Hardware Drivers
-Classifier: Topic :: Utilities
-Requires-Python: ~=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE
-
-<!--
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
--->
-
-main:
-[![Windows amd64](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml)
-[![macOS amd64](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml)
-[![Ubuntu Linux amd64](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml)
-
-develop:
-[![Windows amd64](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml)
-[![macOS amd64](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml)
-[![Ubuntu Linux amd64](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml)
-
-
-# JLS
-
-Welcome to the [Joulescope®](https://www.joulescope.com) File Format project.
-The goal of this project is to provide performant data storage for huge, 
-simultaneous, one-dimensional signals. This repository contains:
-
-* The JLS file format specification
-* The implementation in C
-* Language bindings for Python
-
-> **⚠ CAUTION ⚠**  
-> We are actively developing this library.  Some features are not 
-> yet implemented.
-
-
-## License
-
-This project is Copyright © 2017-2022 Jetperch LLC and licensed under the 
-permissive [Apache 2.0](LICENSE).
-
-
-## Features
-
-* Cross-platform
-  * Microsoft Windows x64
-  * Apple macOS x64
-  * Apple macOS ARM
-  * Linux x64
-  * Linux aarch64 (ARM 64-bit).  Supports Raspberry Pi 4.
-* Support for multiple, simultaneous data sources
-* Support for multiple, simultaneous signal waveforms
-* Fixed sample rate signals (FSR)
-  * Handles missing samples gracefully (interpolate) 🔜
-  * Multiple data types including:
-    - Floating point: f32, f64
-    - Unsigned integers: u1, u4, u8, u16, u24, u32, u64 
-    - Signed integers: i4, i8, i16, i24, i32, i64
-    - Fixed-point, signed integers (same bit sizes as signed integers)
-    - Boolean (digital) 1-bit signals = u1
-* Variable sample rate (VSR) signals 🔜
-* Fast read performance
-  * Signal Summaries
-    * "Zoomed out" view with mean, min, max, standard deviation
-    * Provides fast waveform load without any additional processing steps
-  * Automatic load by summary level
-  * Fast seek, next, previous access
-* Sample ID to Wall-clock time (UTC) for FSR signals
-* Annotations
-  * Global VSR annotations
-  * Signal annotations, timestamped to sample_id for FSR and UTC time for VSR
-  * Support for text, marker, and user-defined (text, binary, JSON)
-* User data
-  * Arbitrary data included in the same file
-  * Support for text, binary, and JSON
-* Reliability
-  * Integrated integrity checks using CRC32C
-  * File data still accessible in the case of improper program termination 🔜
-  * Uncorrupted data is still accessible in presence of file corruption 🔜
-  * Write once, except for indices and the doubly-linked list pointers
-* Compression options 🔜
-  * lossless 🔜
-  * lossy 🔜
-  * lossy with downsampling below threshold 🔜
-  * Support level 0 DATA not written (only INDEX & SUMMARY) 🔜
-
-Items marked with 🔜 are under development and coming soon.
-Items marked with ⏳ are planned for future release.
-
-As of March 2022, the JLS v2 file structure is well-defined and stable.
-However, the compression storage formats are not yet defined.
-
-
-## Why JLS?
-
-The world is already full of file formats, and we would rather not create 
-another one.  However, we could not identify a solution that met these
-requirements.  [HDF5](https://www.hdfgroup.org/solutions/hdf5/) meets the
-large storage requirements, but not the reliability and rapid load requirements.
-The [Saleae binary export file format v2](https://support.saleae.com/faq/technical-faq/binary-export-format-logic-2)
-is also not suitable since it buffers stores single, contiguous blocks.
-[Sigrok v2](https://sigrok.org/wiki/File_format:Sigrok/v2) is similar.
-The [Sigrok v3](https://sigrok.org/wiki/File_format:Sigrok/v3) format
-(under development as of Feb 2022) is better in that it stores sequences of
-"packets" containing data blocks, but it still will does not allow for
-fast seek or summaries.
-
-Timeseries databases, such as [InfluxDB](https://www.influxdata.com/), are 
-powerful tools.  However, they are not well-designed for fast sample-rate
-data.
-
-Media containers are another option, especially the ISO base media file format
-used by MPEG4 and many others:
-  * [ISO/IEC 14496-14:2020 Specification](https://www.iso.org/standard/79110.html)
-  * [Overview](https://mpeg.chiariglione.org/standards/mpeg-4/iso-base-media-file-format)
-
-However, the standard does not included the ability to store the signal summaries
-and our specific signal types.  While we could add these features, these formats
-are already complicated, greatly reducing the advantage of repurposing them.
-
-
-## Why JLS v2?
-
-This file format is based upon JLS v1 designed for
-[pyjoulescope](https://github.com/jetperch/pyjoulescope) and used by the
-[Joulescope](https://www.joulescope.com/) test instrument.  We are leveraging
-the lessons learned from v1 to make v2 better, faster, and more extensible.
-
-The JLS v1 format has been great for the Joulescope ecosystem and has
-accomplished the objective of long data captures (days) with fast
-sampling rates (MHz).  However, it now has a long list of issues that are difficult
-to address without a significant restructuring.  The issues include:
-
-- Inflexible storage format (always current, voltage, power, current range, GPI0, GPI1).
-- Unable to store from multiple sources.
-- Unable to store other sources and signals.
-- No annotation support: 
-  [41](https://github.com/jetperch/pyjoulescope_ui/issues/41),
-  [93](https://github.com/jetperch/pyjoulescope_ui/issues/93).
-- Inflexible user data support.
-- Inconsistent performance across sampling rates, zoom levels, and file sizes: 
-  [48](https://github.com/jetperch/pyjoulescope_ui/issues/48),
-  [103](https://github.com/jetperch/pyjoulescope_ui/issues/103).
-- Unable to correlate sample times with UTC:
-  [55](https://github.com/jetperch/pyjoulescope_ui/issues/55).
-
-The JLS v2 file format will address all of these issues, dramatically 
-improve performance, and add new capabilities, such as signal compression.
-
-
-## How?
-
-At its lowest layer, JLS is an enhanced 
-[tag-length-value](https://en.wikipedia.org/wiki/Type-length-value) (TLV)
-format. TLV files form the foundation of many reliable image and video formats, 
-including MPEG4 and PNG.  The enhanced header contains additional fields
-to speed navigation and improve reliability.  The JLS file format calls 
-each TLV a **chunk**.  The enhanced tag-length component the **chunk header**
-or simply **header**.  The file also contains a **file header**, not to be 
-confused with the **chunk header**.  A **chunk** may have zero payload length,
-in which case the next header follows immediately.  Otherwise, a 
-**chunk** consists of a **header** followed by a **payload**. 
-
-The JLS file format defines **sources** that produce data.  The file allows
-the application to clearly define and label the source.  Each source
-can have any number of associated signals.
-
-**Signals** are 1-D sequences of values over time consisting of a single,
-fixed data type.  Each signal can have multiple **tracks** that contain
-data associated with that signal. The JLS file supports two signal types: 
-fixed sample rate (FSR) and variable sample rate (VSR).  FSR signals
-store their sample data in the FSR track using FSR_DATA and FSR_SUMMARY.
-FSR time is denoted by samples using timestamp.  FSR signals also support:
-
-* Sample time to UTC time mapping using the UTC track.
-* Annotations with the ANNOTATION track. 
-
-VSR signals store their sample data in the VSR track.  VSR signals
-specify time in UTC (wall-clock time).  VSR signals also
-support annotations with the ANNOTATION track.
-The JLS file format supports VSR signals that only use the 
-ANNOTATION track and not the VSR track.  Such signals are commonly 
-used to store UART text data where each line contains a UTC timestamp. 
-
-Signals support DATA chunks and SUMMARY chunks.
-The DATA chunks store the actual sample data.  The SUMMARY chunks
-store the reduced statistics, where each statistic entry represents
-multiple samples.  FSR tracks store the mean, min, max, 
-and standard deviation.  Although standard deviation requires the
-writer to compute the square root, standard deviation keeps the
-same units and bit depth requirements as the other fields.  Variance
-requires twice the bit size for integer types since it is squared.
-
-Before each SUMMARY chunk, the JLS file will contain the INDEX chunk
-which contains the starting time and offset for each chunk that 
-contributed to the summary.  This SUMMARY chunk enables fast O(log n)
-navigation of the file.  For FSR tracks, the starting time is 
-calculated rather than stored for each entry.
-
-The JLS file format design supports SUMMARY of SUMMARY.  It supports
-the DATA and up to 15 layers of SUMMARIES.  timestamp is given as a
-64-bit integer, which allows each summary to include only 20 samples
-and still support the full 64-bit integer timestamp space.  In practice, the
-first level summary increases a single value to 4 values, so summary
-steps are usually 50 or more.
-
-Many applications, including the Joulescope UI, prioritize read performance,
-especially visualizing the waveform quickly following open, 
-over write performance.   Waiting to scan through a 1 TB file is not a 
-valid option.  The reader opens the file and scans for sources and signals.
-The application can then quickly load the highest summary of summaries 
-for every signal of interest.  The application can very quickly display this
-data, and then start to retrieve more detailed information as requested.
-
-
-## Example file structure
-
-```
-sof
-header
-USER_DATA(0, NULL)    // Required, point to first real user_data chunk
-SOURCE_DEF(0)         // Required, internal, reserved for global annotations
-SIGNAL_DEF(0, 0.VSR)  // Required, internal, reserved for global annotations
-TRACK_DEF(0.VSR)
-TRACK_HEAD(0.VSR)
-TRACK_DEF(0.ANNO)
-TRACK_HEAD(0.ANNO)
-SOURCE_DEF(1)         // input device 1
-SIGNAL_DEF(1, 1, FSR) // our signal, like "current" or "voltage"
-TRACK_DEF(1.FSR)
-TRACK_HEAD(1.FSR)
-TRACK_DEF(1.ANNO)
-TRACK_HEAD(1.ANNO)
-TRACK_DEF(1.UTC)
-TRACK_HEAD(1.UTC)
-USER_DATA           // just because
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_INDEX(1.FSR, lvl=1)
-TRACK_SUMMARY(1.FSR, lvl=2)
-USER_DATA           // just because
-eof
-```
-
-Note that TRACK_HEAD(1.FSR) points to the first TRACK_INDEX(1.FSR, lvl=0) and
-TRACK_INDEX(1.FSR, lvl=1). 
-Each TRACK_DATA( is in a doubly-linked list with its next and previous
-neighbors.  Each TRACK_INDEX(1.FSR, lvl=0) is likewise in a separate doubly-linked
-list, and the payload of each TRACK_INDEX points to the summarized TRACK_DATA
-instances.  TRACK_INDEX(1.FSR, lvl=1) points to each TRACK_INDEX(1.FSR, lvl=0) instance.
-As more data is added, the TRACK_INDEX(1.FSR, lvl=1) will also get added to
-the INDEX chunks at the same level.
-
-
-## References
-
-* JLS v1: 
-  [lower-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/datafile.py),
-  [upper-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/data_recorder.py).
-* [Sigrok/v3](https://sigrok.org/wiki/File_format:Sigrok/v3), which shares
-  many of the same motivations.
-* Tag-length-value: [Wikipedia](https://en.wikipedia.org/wiki/Type-length-value).
-* Doubly linked list: [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list).
+Metadata-Version: 2.1
+Name: pyjls
+Version: 0.7.1
+Summary: Joulescope™ file format
+Home-page: https://joulescope.readthedocs.io
+Author: Jetperch LLC
+Author-email: joulescope-dev@jetperch.com
+License: Apache 2.0
+Project-URL: Bug Reports, https://github.com/jetperch/jls/issues
+Project-URL: Funding, https://www.joulescope.com
+Project-URL: Twitter, https://twitter.com/joulescope
+Project-URL: Source, https://github.com/jetperch/jls/
+Keywords: JLS,Joulescope
+Classifier: Development Status :: 3 - Alpha
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: End Users/Desktop
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: Microsoft :: Windows :: Windows 10
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Software Development :: Embedded Systems
+Classifier: Topic :: Software Development :: Testing
+Classifier: Topic :: System :: Hardware :: Hardware Drivers
+Classifier: Topic :: Utilities
+Requires-Python: ~=3.9
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+<!--
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+-->
+
+[![main](https://github.com/jetperch/jls/actions/workflows/packaging.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/packaging.yml)
+
+
+# JLS
+
+Welcome to the [Joulescope®](https://www.joulescope.com) File Format project.
+The goal of this project is to provide performant data storage for huge, 
+simultaneous, one-dimensional signals. This repository contains:
+
+* The JLS file format specification
+* The implementation in C
+* Language bindings for Python
+
+
+## Features
+
+* Cross-platform
+  * Microsoft Windows x64
+  * Apple macOS x64
+  * Apple macOS ARM
+  * Linux x64
+  * Linux aarch64 (ARM 64-bit).  Supports Raspberry Pi 4.
+* Support for multiple, simultaneous data sources
+* Support for multiple, simultaneous signal waveforms
+* Fixed sample rate signals (FSR)
+  * Handles missing samples gracefully (interpolate) 🔜
+  * Multiple data types including:
+    - Floating point: f32, f64
+    - Unsigned integers: u1, u4, u8, u16, u24, u32, u64 
+    - Signed integers: i4, i8, i16, i24, i32, i64
+    - Fixed-point, signed integers (same bit sizes as signed integers)
+    - Boolean (digital) 1-bit signals = u1
+* Variable sample rate (VSR) signals 🔜
+* Fast read performance
+  * Signal Summaries
+    * "Zoomed out" view with mean, min, max, standard deviation
+    * Provides fast waveform load without any additional processing steps
+  * Automatic load by summary level
+  * Fast seek, next, previous access
+* Sample ID to Wall-clock time (UTC) for FSR signals
+* Annotations
+  * Global VSR annotations
+  * Signal annotations, timestamped to sample_id for FSR and UTC time for VSR
+  * Support for text, marker, and user-defined (text, binary, JSON)
+* User data
+  * Arbitrary data included in the same file
+  * Support for text, binary, and JSON
+* Reliability
+  * Integrated integrity checks using CRC32C
+  * File data still accessible in the case of improper program termination 🔜
+  * Uncorrupted data is still accessible in presence of file corruption 🔜
+  * Write once, except for indices and the doubly-linked list pointers
+* Compression options 🔜
+  * lossless 🔜
+  * lossy 🔜
+  * lossy with downsampling below threshold 🔜
+  * Support level 0 DATA not written (only INDEX & SUMMARY) 🔜
+
+Items marked with 🔜 are under development and coming soon.
+Items marked with ⏳ are planned for future release.
+
+As of June 2023, the JLS v2 file structure is well-defined and stable.
+However, the compression storage formats are not yet defined and
+corrupted file recovery is not yet implemented.
+
+
+## Why JLS?
+
+The world is already full of file formats, and we would rather not create 
+another one.  However, we could not identify a solution that met these
+requirements.  [HDF5](https://www.hdfgroup.org/solutions/hdf5/) meets the
+large storage requirements, but not the reliability and rapid load requirements.
+The [Saleae binary export file format v2](https://support.saleae.com/faq/technical-faq/binary-export-format-logic-2)
+is also not suitable since it buffers stores single, contiguous blocks.
+[Sigrok v2](https://sigrok.org/wiki/File_format:Sigrok/v2) is similar.
+The [Sigrok v3](https://sigrok.org/wiki/File_format:Sigrok/v3) format
+(under development as of June 2023) is better in that it stores sequences of
+"packets" containing data blocks, but it still will does not allow for
+fast seek or summaries.
+
+Timeseries databases, such as [InfluxDB](https://www.influxdata.com/), are 
+powerful tools.  However, they are not well-designed for fast sample-rate
+data.
+
+Media containers are another option, especially the ISO base media file format
+used by MPEG4 and many others:
+  * [ISO/IEC 14496-14:2020 Specification](https://www.iso.org/standard/79110.html)
+  * [Overview](https://mpeg.chiariglione.org/standards/mpeg-4/iso-base-media-file-format)
+
+However, the standard does not include the ability to store the signal summaries
+and our specific signal types.  While we could add these features, these formats
+are already complicated, greatly reducing the advantage of repurposing them.
+
+
+## Why JLS v2?
+
+This file format is based upon JLS v1 designed for
+[pyjoulescope](https://github.com/jetperch/pyjoulescope) and used by the
+[Joulescope](https://www.joulescope.com/) test instrument.  We leveraged
+the lessons learned from v1 to make v2 better, faster, and more extensible.
+
+The JLS v1 format has been great for the Joulescope ecosystem and has
+accomplished the objective of long data captures (days) with fast
+sampling rates (MHz).  However, it now has a long list of issues including:
+
+- Inflexible storage format (always current, voltage, power, current range, GPI0, GPI1).
+- Unable to store from multiple sources.
+- Unable to store other sources and signals.
+- No annotation support: 
+  [41](https://github.com/jetperch/pyjoulescope_ui/issues/41),
+  [93](https://github.com/jetperch/pyjoulescope_ui/issues/93).
+- Inflexible user data support.
+- Inconsistent performance across sampling rates, zoom levels, and file sizes: 
+  [48](https://github.com/jetperch/pyjoulescope_ui/issues/48),
+  [103](https://github.com/jetperch/pyjoulescope_ui/issues/103).
+- Unable to correlate sample times with UTC:
+  [55](https://github.com/jetperch/pyjoulescope_ui/issues/55).
+
+The JLS v2 file format addressed all of these issues, dramatically 
+improved performance, and added new capabilities, such as signal compression.
+
+
+## How?
+
+At its lowest layer, JLS is an enhanced 
+[tag-length-value](https://en.wikipedia.org/wiki/Type-length-value) (TLV)
+format. TLV files form the foundation of many reliable image and video formats, 
+including MPEG4 and PNG.  The enhanced header contains additional fields
+to speed navigation and improve reliability.  The JLS file format calls 
+each TLV a **chunk**.  The enhanced tag-length component the **chunk header**
+or simply **header**.  The file also contains a **file header**, not to be 
+confused with the **chunk header**.  A **chunk** may have zero payload length,
+in which case the next header follows immediately.  Otherwise, a 
+**chunk** consists of a **header** followed by a **payload**. 
+
+The JLS file format defines **sources** that produce data.  The file allows
+the application to clearly define and label the source.  Each source
+can have any number of associated signals.
+
+**Signals** are 1-D sequences of values over time consisting of a single,
+fixed data type.  Each signal can have multiple **tracks** that contain
+data associated with that signal. The JLS file supports two signal types: 
+fixed sample rate (FSR) and variable sample rate (VSR).  FSR signals
+store their sample data in the FSR track using FSR_DATA and FSR_SUMMARY.
+FSR time is denoted by samples using timestamp.  FSR signals also support:
+
+* Sample time to UTC time mapping using the UTC track.
+* Annotations with the ANNOTATION track. 
+
+VSR signals store their sample data in the VSR track.  VSR signals
+specify time in UTC (wall-clock time).  VSR signals also
+support annotations with the ANNOTATION track.
+The JLS file format supports VSR signals that only use the 
+ANNOTATION track and not the VSR track.  Such signals are commonly 
+used to store UART text data where each line contains a UTC timestamp. 
+
+Signals support DATA chunks and SUMMARY chunks.
+The DATA chunks store the actual sample data.  The SUMMARY chunks
+store the reduced statistics, where each statistic entry represents
+multiple samples.  FSR tracks store the mean, min, max, 
+and standard deviation.  Although standard deviation requires the
+writer to compute the square root, standard deviation keeps the
+same units and bit depth requirements as the other fields.  Variance
+requires twice the bit size for integer types since it is squared.
+
+Before each SUMMARY chunk, the JLS file will contain the INDEX chunk
+which contains the starting time and offset for each chunk that 
+contributed to the summary.  This SUMMARY chunk enables fast O(log n)
+navigation of the file.  For FSR tracks, the starting time is 
+calculated rather than stored for each entry.
+
+The JLS file format design supports SUMMARY of SUMMARY.  It supports
+the DATA and up to 15 layers of SUMMARIES.  timestamp is given as a
+64-bit integer, which allows each summary to include only 20 samples
+and still support the full 64-bit integer timestamp space.  In practice, the
+first level summary increases a single value to 4 values, so summary
+steps are usually 50 or more.
+
+Many applications, including the Joulescope UI, prioritize read performance,
+especially visualizing the waveform quickly following open, 
+over write performance.   Waiting to scan through a 1 TB file is not a 
+valid option.  The reader opens the file and scans for sources and signals.
+The application can then quickly load the highest summary of summaries 
+for every signal of interest.  The application can very quickly display this
+data, and then start to retrieve more detailed information as requested.
+
+
+## Example file structure
+
+```
+sof
+header
+USER_DATA(0, NULL)    // Required, point to first real user_data chunk
+SOURCE_DEF(0)         // Required, internal, reserved for global annotations
+SIGNAL_DEF(0, 0.VSR)  // Required, internal, reserved for global annotations
+TRACK_DEF(0.VSR)
+TRACK_HEAD(0.VSR)
+TRACK_DEF(0.ANNO)
+TRACK_HEAD(0.ANNO)
+SOURCE_DEF(1)         // input device 1
+SIGNAL_DEF(1, 1, FSR) // our signal, like "current" or "voltage"
+TRACK_DEF(1.FSR)
+TRACK_HEAD(1.FSR)
+TRACK_DEF(1.ANNO)
+TRACK_HEAD(1.ANNO)
+TRACK_DEF(1.UTC)
+TRACK_HEAD(1.UTC)
+USER_DATA           // just because
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_INDEX(1.FSR, lvl=1)
+TRACK_SUMMARY(1.FSR, lvl=2)
+USER_DATA           // just because
+END
+eof
+```
+
+Note that TRACK_HEAD(1.FSR) points to the first TRACK_INDEX(1.FSR, lvl=0) and
+TRACK_INDEX(1.FSR, lvl=1). 
+Each TRACK_DATA(1.FSR) is in a doubly-linked list with its next and previous
+neighbors.  Each TRACK_INDEX(1.FSR, lvl=0) is likewise in a separate doubly-linked
+list, and the payload of each TRACK_INDEX points to the summarized TRACK_DATA
+instances.  TRACK_INDEX(1.FSR, lvl=1) points to each TRACK_INDEX(1.FSR, lvl=0) instance.
+As more data is added, the TRACK_INDEX(1.FSR, lvl=1) will also get added to
+the INDEX chunks at the same level.
+
+
+## Resources
+
+* [source code](https://github.com/jetperch/jls)
+* [documentation](https://jls.readthedocs.io/en/latest/)
+* [pypi](https://pypi.org/project/pyjls/)
+* [Joulescope](https://www.joulescope.com/) (Joulescope web store)
+* [forum](https://forum.joulescope.com/)
+
+
+## References
+
+* JLS v1: 
+  [lower-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/datafile.py),
+  [upper-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/data_recorder.py).
+* [Sigrok/v3](https://sigrok.org/wiki/File_format:Sigrok/v3), which shares
+  many of the same motivations.
+* Tag-length-value: [Wikipedia](https://en.wikipedia.org/wiki/Type-length-value).
+* Doubly linked list: [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list).
+
+
+## License
+
+This project is Copyright © 2017-2023 Jetperch LLC and licensed under the
+permissive [Apache 2.0 License](./LICENSE).
```

### Comparing `pyjls-0.7.0/README.md` & `pyjls-0.7.1/README.md`

 * *Files 12% similar despite different names*

```diff
@@ -1,285 +1,283 @@
-<!--
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
--->
-
-main:
-[![Windows amd64](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml)
-[![macOS amd64](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml)
-[![Ubuntu Linux amd64](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml)
-
-develop:
-[![Windows amd64](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml)
-[![macOS amd64](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml)
-[![Ubuntu Linux amd64](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml)
-
-
-# JLS
-
-Welcome to the [Joulescope®](https://www.joulescope.com) File Format project.
-The goal of this project is to provide performant data storage for huge, 
-simultaneous, one-dimensional signals. This repository contains:
-
-* The JLS file format specification
-* The implementation in C
-* Language bindings for Python
-
-> **⚠ CAUTION ⚠**  
-> We are actively developing this library.  Some features are not 
-> yet implemented.
-
-
-## License
-
-This project is Copyright © 2017-2022 Jetperch LLC and licensed under the 
-permissive [Apache 2.0](LICENSE).
-
-
-## Features
-
-* Cross-platform
-  * Microsoft Windows x64
-  * Apple macOS x64
-  * Apple macOS ARM
-  * Linux x64
-  * Linux aarch64 (ARM 64-bit).  Supports Raspberry Pi 4.
-* Support for multiple, simultaneous data sources
-* Support for multiple, simultaneous signal waveforms
-* Fixed sample rate signals (FSR)
-  * Handles missing samples gracefully (interpolate) 🔜
-  * Multiple data types including:
-    - Floating point: f32, f64
-    - Unsigned integers: u1, u4, u8, u16, u24, u32, u64 
-    - Signed integers: i4, i8, i16, i24, i32, i64
-    - Fixed-point, signed integers (same bit sizes as signed integers)
-    - Boolean (digital) 1-bit signals = u1
-* Variable sample rate (VSR) signals 🔜
-* Fast read performance
-  * Signal Summaries
-    * "Zoomed out" view with mean, min, max, standard deviation
-    * Provides fast waveform load without any additional processing steps
-  * Automatic load by summary level
-  * Fast seek, next, previous access
-* Sample ID to Wall-clock time (UTC) for FSR signals
-* Annotations
-  * Global VSR annotations
-  * Signal annotations, timestamped to sample_id for FSR and UTC time for VSR
-  * Support for text, marker, and user-defined (text, binary, JSON)
-* User data
-  * Arbitrary data included in the same file
-  * Support for text, binary, and JSON
-* Reliability
-  * Integrated integrity checks using CRC32C
-  * File data still accessible in the case of improper program termination 🔜
-  * Uncorrupted data is still accessible in presence of file corruption 🔜
-  * Write once, except for indices and the doubly-linked list pointers
-* Compression options 🔜
-  * lossless 🔜
-  * lossy 🔜
-  * lossy with downsampling below threshold 🔜
-  * Support level 0 DATA not written (only INDEX & SUMMARY) 🔜
-
-Items marked with 🔜 are under development and coming soon.
-Items marked with ⏳ are planned for future release.
-
-As of March 2022, the JLS v2 file structure is well-defined and stable.
-However, the compression storage formats are not yet defined.
-
-
-## Why JLS?
-
-The world is already full of file formats, and we would rather not create 
-another one.  However, we could not identify a solution that met these
-requirements.  [HDF5](https://www.hdfgroup.org/solutions/hdf5/) meets the
-large storage requirements, but not the reliability and rapid load requirements.
-The [Saleae binary export file format v2](https://support.saleae.com/faq/technical-faq/binary-export-format-logic-2)
-is also not suitable since it buffers stores single, contiguous blocks.
-[Sigrok v2](https://sigrok.org/wiki/File_format:Sigrok/v2) is similar.
-The [Sigrok v3](https://sigrok.org/wiki/File_format:Sigrok/v3) format
-(under development as of Feb 2022) is better in that it stores sequences of
-"packets" containing data blocks, but it still will does not allow for
-fast seek or summaries.
-
-Timeseries databases, such as [InfluxDB](https://www.influxdata.com/), are 
-powerful tools.  However, they are not well-designed for fast sample-rate
-data.
-
-Media containers are another option, especially the ISO base media file format
-used by MPEG4 and many others:
-  * [ISO/IEC 14496-14:2020 Specification](https://www.iso.org/standard/79110.html)
-  * [Overview](https://mpeg.chiariglione.org/standards/mpeg-4/iso-base-media-file-format)
-
-However, the standard does not included the ability to store the signal summaries
-and our specific signal types.  While we could add these features, these formats
-are already complicated, greatly reducing the advantage of repurposing them.
-
-
-## Why JLS v2?
-
-This file format is based upon JLS v1 designed for
-[pyjoulescope](https://github.com/jetperch/pyjoulescope) and used by the
-[Joulescope](https://www.joulescope.com/) test instrument.  We are leveraging
-the lessons learned from v1 to make v2 better, faster, and more extensible.
-
-The JLS v1 format has been great for the Joulescope ecosystem and has
-accomplished the objective of long data captures (days) with fast
-sampling rates (MHz).  However, it now has a long list of issues that are difficult
-to address without a significant restructuring.  The issues include:
-
-- Inflexible storage format (always current, voltage, power, current range, GPI0, GPI1).
-- Unable to store from multiple sources.
-- Unable to store other sources and signals.
-- No annotation support: 
-  [41](https://github.com/jetperch/pyjoulescope_ui/issues/41),
-  [93](https://github.com/jetperch/pyjoulescope_ui/issues/93).
-- Inflexible user data support.
-- Inconsistent performance across sampling rates, zoom levels, and file sizes: 
-  [48](https://github.com/jetperch/pyjoulescope_ui/issues/48),
-  [103](https://github.com/jetperch/pyjoulescope_ui/issues/103).
-- Unable to correlate sample times with UTC:
-  [55](https://github.com/jetperch/pyjoulescope_ui/issues/55).
-
-The JLS v2 file format will address all of these issues, dramatically 
-improve performance, and add new capabilities, such as signal compression.
-
-
-## How?
-
-At its lowest layer, JLS is an enhanced 
-[tag-length-value](https://en.wikipedia.org/wiki/Type-length-value) (TLV)
-format. TLV files form the foundation of many reliable image and video formats, 
-including MPEG4 and PNG.  The enhanced header contains additional fields
-to speed navigation and improve reliability.  The JLS file format calls 
-each TLV a **chunk**.  The enhanced tag-length component the **chunk header**
-or simply **header**.  The file also contains a **file header**, not to be 
-confused with the **chunk header**.  A **chunk** may have zero payload length,
-in which case the next header follows immediately.  Otherwise, a 
-**chunk** consists of a **header** followed by a **payload**. 
-
-The JLS file format defines **sources** that produce data.  The file allows
-the application to clearly define and label the source.  Each source
-can have any number of associated signals.
-
-**Signals** are 1-D sequences of values over time consisting of a single,
-fixed data type.  Each signal can have multiple **tracks** that contain
-data associated with that signal. The JLS file supports two signal types: 
-fixed sample rate (FSR) and variable sample rate (VSR).  FSR signals
-store their sample data in the FSR track using FSR_DATA and FSR_SUMMARY.
-FSR time is denoted by samples using timestamp.  FSR signals also support:
-
-* Sample time to UTC time mapping using the UTC track.
-* Annotations with the ANNOTATION track. 
-
-VSR signals store their sample data in the VSR track.  VSR signals
-specify time in UTC (wall-clock time).  VSR signals also
-support annotations with the ANNOTATION track.
-The JLS file format supports VSR signals that only use the 
-ANNOTATION track and not the VSR track.  Such signals are commonly 
-used to store UART text data where each line contains a UTC timestamp. 
-
-Signals support DATA chunks and SUMMARY chunks.
-The DATA chunks store the actual sample data.  The SUMMARY chunks
-store the reduced statistics, where each statistic entry represents
-multiple samples.  FSR tracks store the mean, min, max, 
-and standard deviation.  Although standard deviation requires the
-writer to compute the square root, standard deviation keeps the
-same units and bit depth requirements as the other fields.  Variance
-requires twice the bit size for integer types since it is squared.
-
-Before each SUMMARY chunk, the JLS file will contain the INDEX chunk
-which contains the starting time and offset for each chunk that 
-contributed to the summary.  This SUMMARY chunk enables fast O(log n)
-navigation of the file.  For FSR tracks, the starting time is 
-calculated rather than stored for each entry.
-
-The JLS file format design supports SUMMARY of SUMMARY.  It supports
-the DATA and up to 15 layers of SUMMARIES.  timestamp is given as a
-64-bit integer, which allows each summary to include only 20 samples
-and still support the full 64-bit integer timestamp space.  In practice, the
-first level summary increases a single value to 4 values, so summary
-steps are usually 50 or more.
-
-Many applications, including the Joulescope UI, prioritize read performance,
-especially visualizing the waveform quickly following open, 
-over write performance.   Waiting to scan through a 1 TB file is not a 
-valid option.  The reader opens the file and scans for sources and signals.
-The application can then quickly load the highest summary of summaries 
-for every signal of interest.  The application can very quickly display this
-data, and then start to retrieve more detailed information as requested.
-
-
-## Example file structure
-
-```
-sof
-header
-USER_DATA(0, NULL)    // Required, point to first real user_data chunk
-SOURCE_DEF(0)         // Required, internal, reserved for global annotations
-SIGNAL_DEF(0, 0.VSR)  // Required, internal, reserved for global annotations
-TRACK_DEF(0.VSR)
-TRACK_HEAD(0.VSR)
-TRACK_DEF(0.ANNO)
-TRACK_HEAD(0.ANNO)
-SOURCE_DEF(1)         // input device 1
-SIGNAL_DEF(1, 1, FSR) // our signal, like "current" or "voltage"
-TRACK_DEF(1.FSR)
-TRACK_HEAD(1.FSR)
-TRACK_DEF(1.ANNO)
-TRACK_HEAD(1.ANNO)
-TRACK_DEF(1.UTC)
-TRACK_HEAD(1.UTC)
-USER_DATA           // just because
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_INDEX(1.FSR, lvl=1)
-TRACK_SUMMARY(1.FSR, lvl=2)
-USER_DATA           // just because
-eof
-```
-
-Note that TRACK_HEAD(1.FSR) points to the first TRACK_INDEX(1.FSR, lvl=0) and
-TRACK_INDEX(1.FSR, lvl=1). 
-Each TRACK_DATA( is in a doubly-linked list with its next and previous
-neighbors.  Each TRACK_INDEX(1.FSR, lvl=0) is likewise in a separate doubly-linked
-list, and the payload of each TRACK_INDEX points to the summarized TRACK_DATA
-instances.  TRACK_INDEX(1.FSR, lvl=1) points to each TRACK_INDEX(1.FSR, lvl=0) instance.
-As more data is added, the TRACK_INDEX(1.FSR, lvl=1) will also get added to
-the INDEX chunks at the same level.
-
-
-## References
-
-* JLS v1: 
-  [lower-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/datafile.py),
-  [upper-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/data_recorder.py).
-* [Sigrok/v3](https://sigrok.org/wiki/File_format:Sigrok/v3), which shares
-  many of the same motivations.
-* Tag-length-value: [Wikipedia](https://en.wikipedia.org/wiki/Type-length-value).
-* Doubly linked list: [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list).
+<!--
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+-->
+
+[![main](https://github.com/jetperch/jls/actions/workflows/packaging.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/packaging.yml)
+
+
+# JLS
+
+Welcome to the [Joulescope®](https://www.joulescope.com) File Format project.
+The goal of this project is to provide performant data storage for huge, 
+simultaneous, one-dimensional signals. This repository contains:
+
+* The JLS file format specification
+* The implementation in C
+* Language bindings for Python
+
+
+## Features
+
+* Cross-platform
+  * Microsoft Windows x64
+  * Apple macOS x64
+  * Apple macOS ARM
+  * Linux x64
+  * Linux aarch64 (ARM 64-bit).  Supports Raspberry Pi 4.
+* Support for multiple, simultaneous data sources
+* Support for multiple, simultaneous signal waveforms
+* Fixed sample rate signals (FSR)
+  * Handles missing samples gracefully (interpolate) 🔜
+  * Multiple data types including:
+    - Floating point: f32, f64
+    - Unsigned integers: u1, u4, u8, u16, u24, u32, u64 
+    - Signed integers: i4, i8, i16, i24, i32, i64
+    - Fixed-point, signed integers (same bit sizes as signed integers)
+    - Boolean (digital) 1-bit signals = u1
+* Variable sample rate (VSR) signals 🔜
+* Fast read performance
+  * Signal Summaries
+    * "Zoomed out" view with mean, min, max, standard deviation
+    * Provides fast waveform load without any additional processing steps
+  * Automatic load by summary level
+  * Fast seek, next, previous access
+* Sample ID to Wall-clock time (UTC) for FSR signals
+* Annotations
+  * Global VSR annotations
+  * Signal annotations, timestamped to sample_id for FSR and UTC time for VSR
+  * Support for text, marker, and user-defined (text, binary, JSON)
+* User data
+  * Arbitrary data included in the same file
+  * Support for text, binary, and JSON
+* Reliability
+  * Integrated integrity checks using CRC32C
+  * File data still accessible in the case of improper program termination 🔜
+  * Uncorrupted data is still accessible in presence of file corruption 🔜
+  * Write once, except for indices and the doubly-linked list pointers
+* Compression options 🔜
+  * lossless 🔜
+  * lossy 🔜
+  * lossy with downsampling below threshold 🔜
+  * Support level 0 DATA not written (only INDEX & SUMMARY) 🔜
+
+Items marked with 🔜 are under development and coming soon.
+Items marked with ⏳ are planned for future release.
+
+As of June 2023, the JLS v2 file structure is well-defined and stable.
+However, the compression storage formats are not yet defined and
+corrupted file recovery is not yet implemented.
+
+
+## Why JLS?
+
+The world is already full of file formats, and we would rather not create 
+another one.  However, we could not identify a solution that met these
+requirements.  [HDF5](https://www.hdfgroup.org/solutions/hdf5/) meets the
+large storage requirements, but not the reliability and rapid load requirements.
+The [Saleae binary export file format v2](https://support.saleae.com/faq/technical-faq/binary-export-format-logic-2)
+is also not suitable since it buffers stores single, contiguous blocks.
+[Sigrok v2](https://sigrok.org/wiki/File_format:Sigrok/v2) is similar.
+The [Sigrok v3](https://sigrok.org/wiki/File_format:Sigrok/v3) format
+(under development as of June 2023) is better in that it stores sequences of
+"packets" containing data blocks, but it still will does not allow for
+fast seek or summaries.
+
+Timeseries databases, such as [InfluxDB](https://www.influxdata.com/), are 
+powerful tools.  However, they are not well-designed for fast sample-rate
+data.
+
+Media containers are another option, especially the ISO base media file format
+used by MPEG4 and many others:
+  * [ISO/IEC 14496-14:2020 Specification](https://www.iso.org/standard/79110.html)
+  * [Overview](https://mpeg.chiariglione.org/standards/mpeg-4/iso-base-media-file-format)
+
+However, the standard does not include the ability to store the signal summaries
+and our specific signal types.  While we could add these features, these formats
+are already complicated, greatly reducing the advantage of repurposing them.
+
+
+## Why JLS v2?
+
+This file format is based upon JLS v1 designed for
+[pyjoulescope](https://github.com/jetperch/pyjoulescope) and used by the
+[Joulescope](https://www.joulescope.com/) test instrument.  We leveraged
+the lessons learned from v1 to make v2 better, faster, and more extensible.
+
+The JLS v1 format has been great for the Joulescope ecosystem and has
+accomplished the objective of long data captures (days) with fast
+sampling rates (MHz).  However, it now has a long list of issues including:
+
+- Inflexible storage format (always current, voltage, power, current range, GPI0, GPI1).
+- Unable to store from multiple sources.
+- Unable to store other sources and signals.
+- No annotation support: 
+  [41](https://github.com/jetperch/pyjoulescope_ui/issues/41),
+  [93](https://github.com/jetperch/pyjoulescope_ui/issues/93).
+- Inflexible user data support.
+- Inconsistent performance across sampling rates, zoom levels, and file sizes: 
+  [48](https://github.com/jetperch/pyjoulescope_ui/issues/48),
+  [103](https://github.com/jetperch/pyjoulescope_ui/issues/103).
+- Unable to correlate sample times with UTC:
+  [55](https://github.com/jetperch/pyjoulescope_ui/issues/55).
+
+The JLS v2 file format addressed all of these issues, dramatically 
+improved performance, and added new capabilities, such as signal compression.
+
+
+## How?
+
+At its lowest layer, JLS is an enhanced 
+[tag-length-value](https://en.wikipedia.org/wiki/Type-length-value) (TLV)
+format. TLV files form the foundation of many reliable image and video formats, 
+including MPEG4 and PNG.  The enhanced header contains additional fields
+to speed navigation and improve reliability.  The JLS file format calls 
+each TLV a **chunk**.  The enhanced tag-length component the **chunk header**
+or simply **header**.  The file also contains a **file header**, not to be 
+confused with the **chunk header**.  A **chunk** may have zero payload length,
+in which case the next header follows immediately.  Otherwise, a 
+**chunk** consists of a **header** followed by a **payload**. 
+
+The JLS file format defines **sources** that produce data.  The file allows
+the application to clearly define and label the source.  Each source
+can have any number of associated signals.
+
+**Signals** are 1-D sequences of values over time consisting of a single,
+fixed data type.  Each signal can have multiple **tracks** that contain
+data associated with that signal. The JLS file supports two signal types: 
+fixed sample rate (FSR) and variable sample rate (VSR).  FSR signals
+store their sample data in the FSR track using FSR_DATA and FSR_SUMMARY.
+FSR time is denoted by samples using timestamp.  FSR signals also support:
+
+* Sample time to UTC time mapping using the UTC track.
+* Annotations with the ANNOTATION track. 
+
+VSR signals store their sample data in the VSR track.  VSR signals
+specify time in UTC (wall-clock time).  VSR signals also
+support annotations with the ANNOTATION track.
+The JLS file format supports VSR signals that only use the 
+ANNOTATION track and not the VSR track.  Such signals are commonly 
+used to store UART text data where each line contains a UTC timestamp. 
+
+Signals support DATA chunks and SUMMARY chunks.
+The DATA chunks store the actual sample data.  The SUMMARY chunks
+store the reduced statistics, where each statistic entry represents
+multiple samples.  FSR tracks store the mean, min, max, 
+and standard deviation.  Although standard deviation requires the
+writer to compute the square root, standard deviation keeps the
+same units and bit depth requirements as the other fields.  Variance
+requires twice the bit size for integer types since it is squared.
+
+Before each SUMMARY chunk, the JLS file will contain the INDEX chunk
+which contains the starting time and offset for each chunk that 
+contributed to the summary.  This SUMMARY chunk enables fast O(log n)
+navigation of the file.  For FSR tracks, the starting time is 
+calculated rather than stored for each entry.
+
+The JLS file format design supports SUMMARY of SUMMARY.  It supports
+the DATA and up to 15 layers of SUMMARIES.  timestamp is given as a
+64-bit integer, which allows each summary to include only 20 samples
+and still support the full 64-bit integer timestamp space.  In practice, the
+first level summary increases a single value to 4 values, so summary
+steps are usually 50 or more.
+
+Many applications, including the Joulescope UI, prioritize read performance,
+especially visualizing the waveform quickly following open, 
+over write performance.   Waiting to scan through a 1 TB file is not a 
+valid option.  The reader opens the file and scans for sources and signals.
+The application can then quickly load the highest summary of summaries 
+for every signal of interest.  The application can very quickly display this
+data, and then start to retrieve more detailed information as requested.
+
+
+## Example file structure
+
+```
+sof
+header
+USER_DATA(0, NULL)    // Required, point to first real user_data chunk
+SOURCE_DEF(0)         // Required, internal, reserved for global annotations
+SIGNAL_DEF(0, 0.VSR)  // Required, internal, reserved for global annotations
+TRACK_DEF(0.VSR)
+TRACK_HEAD(0.VSR)
+TRACK_DEF(0.ANNO)
+TRACK_HEAD(0.ANNO)
+SOURCE_DEF(1)         // input device 1
+SIGNAL_DEF(1, 1, FSR) // our signal, like "current" or "voltage"
+TRACK_DEF(1.FSR)
+TRACK_HEAD(1.FSR)
+TRACK_DEF(1.ANNO)
+TRACK_HEAD(1.ANNO)
+TRACK_DEF(1.UTC)
+TRACK_HEAD(1.UTC)
+USER_DATA           // just because
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_INDEX(1.FSR, lvl=1)
+TRACK_SUMMARY(1.FSR, lvl=2)
+USER_DATA           // just because
+END
+eof
+```
+
+Note that TRACK_HEAD(1.FSR) points to the first TRACK_INDEX(1.FSR, lvl=0) and
+TRACK_INDEX(1.FSR, lvl=1). 
+Each TRACK_DATA(1.FSR) is in a doubly-linked list with its next and previous
+neighbors.  Each TRACK_INDEX(1.FSR, lvl=0) is likewise in a separate doubly-linked
+list, and the payload of each TRACK_INDEX points to the summarized TRACK_DATA
+instances.  TRACK_INDEX(1.FSR, lvl=1) points to each TRACK_INDEX(1.FSR, lvl=0) instance.
+As more data is added, the TRACK_INDEX(1.FSR, lvl=1) will also get added to
+the INDEX chunks at the same level.
+
+
+## Resources
+
+* [source code](https://github.com/jetperch/jls)
+* [documentation](https://jls.readthedocs.io/en/latest/)
+* [pypi](https://pypi.org/project/pyjls/)
+* [Joulescope](https://www.joulescope.com/) (Joulescope web store)
+* [forum](https://forum.joulescope.com/)
+
+
+## References
+
+* JLS v1: 
+  [lower-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/datafile.py),
+  [upper-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/data_recorder.py).
+* [Sigrok/v3](https://sigrok.org/wiki/File_format:Sigrok/v3), which shares
+  many of the same motivations.
+* Tag-length-value: [Wikipedia](https://en.wikipedia.org/wiki/Type-length-value).
+* Doubly linked list: [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list).
+
+
+## License
+
+This project is Copyright © 2017-2023 Jetperch LLC and licensed under the
+permissive [Apache 2.0 License](./LICENSE).
```

### Comparing `pyjls-0.7.0/include/jls/backend.h` & `pyjls-0.7.1/include/jls/backend.h`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS raw backend.
- */
-
-#ifndef JLS_PRIV_RAW_BACKEND_H__
-#define JLS_PRIV_RAW_BACKEND_H__
-
-#include <stdint.h>
-#include "jls/cmacro.h"
-
-JLS_CPP_GUARD_START
-
-/**
- * @ingroup jls
- * @defgroup jls_raw_backend Raw backend
- *
- * @brief JLS raw OS-specific backend.
- *
- * @{
- */
-
-#define JLS_BK_MSG_WRITE_TIMEOUT_MS (5000)
-#define JLS_BK_MSG_LOCK_TIMEOUT_MS (5000)
-#define JLS_BK_PROCESS_LOCK_TIMEOUT_MS (2500)
-#define JLS_BK_FLUSH_TIMEOUT_MS (20000)
-#define JLS_BK_CLOSE_TIMEOUT_MS (1000)
-
-/**
- * @brief The backend instance.
- */
-struct jls_bkf_s {
-    int64_t fpos;    ///< the current file position, to reduce ftell calls.
-    int64_t fend;    ///< the file end offset.
-    int fd;          ///< The file descriptor.
-};
-
-int32_t jls_bk_fopen(struct jls_bkf_s * self, const char * filename, const char * mode);
-int32_t jls_bk_fclose(struct jls_bkf_s * self);
-int32_t jls_bk_fwrite(struct jls_bkf_s * self, const void * buffer, unsigned int count);
-int32_t jls_bk_fread(struct jls_bkf_s * self, void * const buffer, unsigned const buffer_size);
-int32_t jls_bk_fseek(struct jls_bkf_s * self, int64_t offset, int origin);
-int64_t jls_bk_ftell(struct jls_bkf_s * self);
-int32_t jls_bk_fflush(struct jls_bkf_s * self);
-
-// forward declaration for "threaded_writer.h"
-struct jls_twr_s;
-struct jls_bkt_s * jls_bkt_initialize(struct jls_twr_s * wr);
-void jls_bkt_finalize(struct jls_bkt_s * self);
-int jls_bkt_msg_lock(struct jls_bkt_s * self);          // 0 on success or error code
-int jls_bkt_msg_unlock(struct jls_bkt_s * self);        // 0 on success or error code
-int jls_bkt_process_lock(struct jls_bkt_s * self);      // 0 on success or error code
-int jls_bkt_process_unlock(struct jls_bkt_s * self);    // 0 on success or error code
-void jls_bkt_msg_wait(struct jls_bkt_s * self);
-void jls_bkt_msg_signal(struct jls_bkt_s * self);
-void jls_bkt_sleep_ms(uint32_t duration_ms);
-
-
-JLS_API int64_t jls_now(void);
-JLS_API struct jls_time_counter_s jls_time_counter(void);
-
-/** @} */
-
-JLS_CPP_GUARD_END
-
-#endif  /* JLS_PRIV_RAW_BACKEND_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS raw backend.
+ */
+
+#ifndef JLS_PRIV_RAW_BACKEND_H__
+#define JLS_PRIV_RAW_BACKEND_H__
+
+#include <stdint.h>
+#include "jls/cmacro.h"
+
+JLS_CPP_GUARD_START
+
+/**
+ * @ingroup jls
+ * @defgroup jls_raw_backend Raw backend
+ *
+ * @brief JLS raw OS-specific backend.
+ *
+ * @{
+ */
+
+#define JLS_BK_MSG_WRITE_TIMEOUT_MS (5000)
+#define JLS_BK_MSG_LOCK_TIMEOUT_MS (5000)
+#define JLS_BK_PROCESS_LOCK_TIMEOUT_MS (2500)
+#define JLS_BK_FLUSH_TIMEOUT_MS (20000)
+#define JLS_BK_CLOSE_TIMEOUT_MS (1000)
+
+/**
+ * @brief The backend instance.
+ */
+struct jls_bkf_s {
+    int64_t fpos;    ///< the current file position, to reduce ftell calls.
+    int64_t fend;    ///< the file end offset.
+    int fd;          ///< The file descriptor.
+};
+
+int32_t jls_bk_fopen(struct jls_bkf_s * self, const char * filename, const char * mode);
+int32_t jls_bk_fclose(struct jls_bkf_s * self);
+int32_t jls_bk_fwrite(struct jls_bkf_s * self, const void * buffer, unsigned int count);
+int32_t jls_bk_fread(struct jls_bkf_s * self, void * const buffer, unsigned const buffer_size);
+int32_t jls_bk_fseek(struct jls_bkf_s * self, int64_t offset, int origin);
+int64_t jls_bk_ftell(struct jls_bkf_s * self);
+int32_t jls_bk_fflush(struct jls_bkf_s * self);
+
+// forward declaration for "threaded_writer.h"
+struct jls_twr_s;
+struct jls_bkt_s * jls_bkt_initialize(struct jls_twr_s * wr);
+void jls_bkt_finalize(struct jls_bkt_s * self);
+int jls_bkt_msg_lock(struct jls_bkt_s * self);          // 0 on success or error code
+int jls_bkt_msg_unlock(struct jls_bkt_s * self);        // 0 on success or error code
+int jls_bkt_process_lock(struct jls_bkt_s * self);      // 0 on success or error code
+int jls_bkt_process_unlock(struct jls_bkt_s * self);    // 0 on success or error code
+void jls_bkt_msg_wait(struct jls_bkt_s * self);
+void jls_bkt_msg_signal(struct jls_bkt_s * self);
+void jls_bkt_sleep_ms(uint32_t duration_ms);
+
+
+JLS_API int64_t jls_now(void);
+JLS_API struct jls_time_counter_s jls_time_counter(void);
+
+/** @} */
+
+JLS_CPP_GUARD_END
+
+#endif  /* JLS_PRIV_RAW_BACKEND_H__ */
```

### Comparing `pyjls-0.7.0/include/jls/cmacro.h` & `pyjls-0.7.1/include/jls/cmacro.h`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,87 +1,87 @@
-/*
- * Copyright 2014-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file
- *
- * @brief Commonly used C macros for JLS.
- */
-
-#ifndef JLS_CMACRO_INC_H__
-#define JLS_CMACRO_INC_H__
-
-/**
- * @ingroup jls
- * @defgroup jls_cmacro_inc C Macros
- *
- * @brief Commonly used C macros for JLS.
- *
- * @{
- */
-
-/**
- * @def JLS_CPP_GUARD_START
- * @brief Make a C header file safe for a C++ compiler.
- *
- * This guard should be placed at near the top of the header file after
- * the \#if and imports.
- */
-
-/**
- * @def JLS_CPP_GUARD_END
- * @brief Make a C header file safe for a C++ compiler.
- *
- * This guard should be placed at the bottom of the header file just before
- * the \#endif.
- */
-
-#if defined(__cplusplus) && !defined(__CDT_PARSER__)
-#define JLS_CPP_GUARD_START extern "C" {
-#define JLS_CPP_GUARD_END };
-#else
-#define JLS_CPP_GUARD_START
-#define JLS_CPP_GUARD_END
-#endif
-
-/**
- * @brief All functions that are available from the library are marked with
- *      JLS_API.  This platform-specific definition allows DLLs to be
- *      created properly on Windows.
- */
-#if defined(WIN32) && defined(JLS_EXPORT)
-#define JLS_API __declspec(dllexport)
-#elif defined(WIN32) && defined(JLS_IMPORT)
-#define JLS_API __declspec(dllimport)
-#else
-#define JLS_API
-#endif
-
-
-#define JLS_STRUCT_PACKED __attribute__((packed))
-
-
-#ifdef __GNUC__
-#define JLS_USED __attribute__((used))
-#define JLS_FORMAT __attribute__((format))
-#else
-#define JLS_USED
-#endif
-
-
-/** @} */
-
-#endif /* JLS_CMACRO_INC_H__ */
-
+/*
+ * Copyright 2014-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ *
+ * @brief Commonly used C macros for JLS.
+ */
+
+#ifndef JLS_CMACRO_INC_H__
+#define JLS_CMACRO_INC_H__
+
+/**
+ * @ingroup jls
+ * @defgroup jls_cmacro_inc C Macros
+ *
+ * @brief Commonly used C macros for JLS.
+ *
+ * @{
+ */
+
+/**
+ * @def JLS_CPP_GUARD_START
+ * @brief Make a C header file safe for a C++ compiler.
+ *
+ * This guard should be placed at near the top of the header file after
+ * the \#if and imports.
+ */
+
+/**
+ * @def JLS_CPP_GUARD_END
+ * @brief Make a C header file safe for a C++ compiler.
+ *
+ * This guard should be placed at the bottom of the header file just before
+ * the \#endif.
+ */
+
+#if defined(__cplusplus) && !defined(__CDT_PARSER__)
+#define JLS_CPP_GUARD_START extern "C" {
+#define JLS_CPP_GUARD_END };
+#else
+#define JLS_CPP_GUARD_START
+#define JLS_CPP_GUARD_END
+#endif
+
+/**
+ * @brief All functions that are available from the library are marked with
+ *      JLS_API.  This platform-specific definition allows DLLs to be
+ *      created properly on Windows.
+ */
+#if defined(WIN32) && defined(JLS_EXPORT)
+#define JLS_API __declspec(dllexport)
+#elif defined(WIN32) && defined(JLS_IMPORT)
+#define JLS_API __declspec(dllimport)
+#else
+#define JLS_API
+#endif
+
+
+#define JLS_STRUCT_PACKED __attribute__((packed))
+
+
+#ifdef __GNUC__
+#define JLS_USED __attribute__((used))
+#define JLS_FORMAT __attribute__((format))
+#else
+#define JLS_USED
+#endif
+
+
+/** @} */
+
+#endif /* JLS_CMACRO_INC_H__ */
+
```

### Comparing `pyjls-0.7.0/include/jls/ec.h` & `pyjls-0.7.1/include/jls/ec.h`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,110 +1,110 @@
-/*
- * Copyright 2014-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file
- *
- * @brief Standard jls status and error codes.
- */
-
-#ifndef JLS_EC_H_
-#define JLS_EC_H_
-
-#include "jls/cmacro.h"
-
-/**
- * @ingroup jls
- * @defgroup jls_ec Error codes
- *
- * @brief Standardize error code definitions.
- *
- * See <a href="http://www.cplusplus.com/reference/system_error/errc/">errc</a>
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-/**
- * @brief The list of error codes for use by X macros.
- *
- * @see https://en.wikipedia.org/wiki/X_Macro
- * @see http://www.drdobbs.com/cpp/the-x-macro/228700289
- */
-#define JLS_ERROR_CODES(X) \
-    X(SUCCESS,                  "Success (no error)") \
-    X(UNSPECIFIED,              "Unspecified error") \
-    X(NOT_ENOUGH_MEMORY,        "Insufficient memory to complete the operation") \
-    X(NOT_SUPPORTED,            "Operation is not supported") \
-    X(IO,                       "Input/output error") \
-    X(PARAMETER_INVALID,        "The parameter value is invalid") \
-    X(INVALID_RETURN_CONDITION, "The function return condition is invalid") \
-    X(INVALID_CONTEXT,          "The context is invalid") \
-    X(INVALID_MESSAGE_LENGTH,   "The message length in invalid") \
-    X(MESSAGE_INTEGRITY,        "The message integrity check failed") \
-    X(SYNTAX_ERROR,             "A syntax error was detected") \
-    X(TIMED_OUT,                "The operation did not complete in time") \
-    X(FULL,                     "The target of the operation is full") \
-    X(EMPTY,                    "The target of the operation is empty") \
-    X(TOO_SMALL,                "The target of the operation is too small") \
-    X(TOO_BIG,                  "The target of the operation is too big") \
-    X(NOT_FOUND,                "The requested resource was not found") \
-    X(ALREADY_EXISTS,           "The requested resource already exists") \
-    X(PERMISSIONS,              "Insufficient permissions to perform the operation.") \
-    X(BUSY,                     "The requested resource is currently busy.") \
-    X(UNAVAILABLE,              "The requested resource is currently unavailable.") \
-    X(IN_USE,                   "The requested resource is currently in use.") \
-    X(CLOSED,                   "The requested resource is currently closed.") \
-    X(SEQUENCE,                 "The requested operation was out of sequence.") \
-    X(ABORTED,                  "The requested operation was previously aborted.") \
-    X(SYNCHRONIZATION,          "The target is not synchronized with the originator.")\
-    X(UNSUPPORTED_FILE,         "The target file is not supported.")
-
-/// The macro used to define the error code enum.
-#define JLS_ERROR_ENUM(NAME, TEXT) JLS_ERROR_ ## NAME,
-
-/**
- * @brief The list of error codes.
- */
-enum jls_error_code_e {
-    JLS_ERROR_CODES(JLS_ERROR_ENUM)
-    JLS_ERROR_CODE_COUNT
-};
-
-/// A shorter, less confusing alias for success.
-#define JLS_SUCCESS JLS_ERROR_SUCCESS
-
-/**
- * @brief Convert an error code into its short name.
- *
- * @param[in] ec The error code (jls_error_code_e).
- * @return The short string name for the error code.
- */
-JLS_API const char * jls_error_code_name(int ec);
-
-/**
- * @brief Convert an error code into its description.
- *
- * @param[in] ec The error code (jls_error_code_e).
- * @return The user-meaningful description of the error.
- */
-JLS_API const char * jls_error_code_description(int ec);
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif /* JLS_EC_H_ */
+/*
+ * Copyright 2014-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ *
+ * @brief Standard jls status and error codes.
+ */
+
+#ifndef JLS_EC_H_
+#define JLS_EC_H_
+
+#include "jls/cmacro.h"
+
+/**
+ * @ingroup jls
+ * @defgroup jls_ec Error codes
+ *
+ * @brief Standardize error code definitions.
+ *
+ * See <a href="http://www.cplusplus.com/reference/system_error/errc/">errc</a>
+ *
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+/**
+ * @brief The list of error codes for use by X macros.
+ *
+ * @see https://en.wikipedia.org/wiki/X_Macro
+ * @see http://www.drdobbs.com/cpp/the-x-macro/228700289
+ */
+#define JLS_ERROR_CODES(X) \
+    X(SUCCESS,                  "Success (no error)") \
+    X(UNSPECIFIED,              "Unspecified error") \
+    X(NOT_ENOUGH_MEMORY,        "Insufficient memory to complete the operation") \
+    X(NOT_SUPPORTED,            "Operation is not supported") \
+    X(IO,                       "Input/output error") \
+    X(PARAMETER_INVALID,        "The parameter value is invalid") \
+    X(INVALID_RETURN_CONDITION, "The function return condition is invalid") \
+    X(INVALID_CONTEXT,          "The context is invalid") \
+    X(INVALID_MESSAGE_LENGTH,   "The message length in invalid") \
+    X(MESSAGE_INTEGRITY,        "The message integrity check failed") \
+    X(SYNTAX_ERROR,             "A syntax error was detected") \
+    X(TIMED_OUT,                "The operation did not complete in time") \
+    X(FULL,                     "The target of the operation is full") \
+    X(EMPTY,                    "The target of the operation is empty") \
+    X(TOO_SMALL,                "The target of the operation is too small") \
+    X(TOO_BIG,                  "The target of the operation is too big") \
+    X(NOT_FOUND,                "The requested resource was not found") \
+    X(ALREADY_EXISTS,           "The requested resource already exists") \
+    X(PERMISSIONS,              "Insufficient permissions to perform the operation.") \
+    X(BUSY,                     "The requested resource is currently busy.") \
+    X(UNAVAILABLE,              "The requested resource is currently unavailable.") \
+    X(IN_USE,                   "The requested resource is currently in use.") \
+    X(CLOSED,                   "The requested resource is currently closed.") \
+    X(SEQUENCE,                 "The requested operation was out of sequence.") \
+    X(ABORTED,                  "The requested operation was previously aborted.") \
+    X(SYNCHRONIZATION,          "The target is not synchronized with the originator.")\
+    X(UNSUPPORTED_FILE,         "The target file is not supported.")
+
+/// The macro used to define the error code enum.
+#define JLS_ERROR_ENUM(NAME, TEXT) JLS_ERROR_ ## NAME,
+
+/**
+ * @brief The list of error codes.
+ */
+enum jls_error_code_e {
+    JLS_ERROR_CODES(JLS_ERROR_ENUM)
+    JLS_ERROR_CODE_COUNT
+};
+
+/// A shorter, less confusing alias for success.
+#define JLS_SUCCESS JLS_ERROR_SUCCESS
+
+/**
+ * @brief Convert an error code into its short name.
+ *
+ * @param[in] ec The error code (jls_error_code_e).
+ * @return The short string name for the error code.
+ */
+JLS_API const char * jls_error_code_name(int ec);
+
+/**
+ * @brief Convert an error code into its description.
+ *
+ * @param[in] ec The error code (jls_error_code_e).
+ * @return The user-meaningful description of the error.
+ */
+JLS_API const char * jls_error_code_description(int ec);
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif /* JLS_EC_H_ */
```

### Comparing `pyjls-0.7.0/include/jls/format.h` & `pyjls-0.7.1/include/jls/format.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,723 +1,733 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS file format.
- */
-
-#ifndef JLS_FORMAT_H__
-#define JLS_FORMAT_H__
-
-#include "jls/cmacro.h"
-#include <stdint.h>
-
-/**
- * @ingroup jls
- * @defgroup jls_format File format
- *
- * @brief JLS file format.
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-#define JLS_FORMAT_VERSION_MAJOR  (1)
-#define JLS_FORMAT_VERSION_MINOR  (0)
-#define JLS_FORMAT_VERSION_PATCH  (0)
-#define JLS_FORMAT_VERSION_U32     ((uint32_t) ( \
-    ((JLS_FORMAT_VERSION_MAJOR & 0xff) << 24) | \
-    ((JLS_FORMAT_VERSION_MINOR & 0xff) << 16) | \
-    (JLS_FORMAT_VERSION_PATCH & 0xffff) ))
-
-/**
- * @brief The file identification bytes at the start of the file.
- *
- * These bytes are not arbitrary.  We carefully selected them to provide:
- * - Identification: Help the application determine that
- *   this file is in the correct format with minimal uncertainty.
- * - Correct endianness:  Little endian has won, so this entire format is
- *   stored in little endian format.
- * - Proper binary processing:  The different line ending combinations
- *   ensure that the reader is not "fixing" the line endings, since this
- *   is a binary file format.
- * - Display: Include "substitute" and "file separator" so that text
- *   printers to not show the rest of the file.
- *
- * The following table describes maps each byte to its purpose:
- * | Value (hex)       | Purpose                                             |
- * | ----------------- | --------------------------------------------------- |
- * | 6A 6C 73 66 6d 74 | ASCII "jlsfmt", when viewed in text editor.         |
- * | 0D 0A             | DOS line ending to ensure binary correctness.       |
- * | 20                | ASCII space.                                        |
- * | 0A                | UNIX line ending to ensure binary correctness.      |
- * | 20                | ASCII space.                                        |
- * | 1A                | Substitute character (stops listing under Windows). |
- * | 20 20             | ASCII spaces.                                       |
- * | B2                | Ensure that system supports 8-bit data              |
- * | 1C                | File separator.                                     |
- */
-#define JLS_HEADER_IDENTIFICATION \
-    {0x6a, 0x6c, 0x73, 0x66, 0x6d, 0x74, 0x0d, 0x0a, \
-     0x20, 0x0a, 0x20, 0x1a, 0x20, 0x20, 0xb2, 0x1c}
-
-/**
- * @brief The maximum allowed number of sources.
- */
-#define JLS_SOURCE_COUNT (256)
-
-/**
- * @brief The maximum allowed number of signals.
- */
-#define JLS_SIGNAL_COUNT (256)
-
-/**
- * @brief The number of summary levels.
- */
-#define JLS_SUMMARY_LEVEL_COUNT (16)
-
-/**
- * @brief The signal type definition.
- */
-enum jls_signal_type_e {
-    /// Fixed sampling rate
-    JLS_SIGNAL_TYPE_FSR = 0,
-    /// Variable sampling rate
-    JLS_SIGNAL_TYPE_VSR = 1,
-};
-
-/**
- * @brief The available track types that store data over time.
- */
-enum jls_track_type_e {
-    /**
-     * @brief Block tracks contain fixed sample-rate (FSR) data.
-     *
-     * The JLS_TAG_SIGNAL_DEF defines the sampling rate.
-     */
-    JLS_TRACK_TYPE_FSR = 0,
-
-    /**
-     * @brief Fixed-type, variable-sample-rate (VSR) time series data.
-     *
-     * Each data entry consists of time in UTC and the data.
-     */
-    JLS_TRACK_TYPE_VSR = 1,
-
-    /**
-     * @brief Annotations contain infrequent, variable-typed data.
-     *
-     * @see jls_annotation_type_e for the annotation types.
-     *
-     * Each annotation data entry consists of time and associated
-     * annotation data.
-     * For FSR, time must be samples_id.
-     * For VSR, time must be UTC.
-     */
-    JLS_TRACK_TYPE_ANNOTATION = 2,
-
-    /**
-     * @brief The UTC track associates sample_id with UTC.
-     *
-     * Each utc data entry consists of sample_id, UTC timestamp pairs.
-     * This track is only used for FSR signals.
-     */
-    JLS_TRACK_TYPE_UTC = 3,
-
-    /// The total number of track types
-    JLS_TRACK_TYPE_COUNT = 4,
-};
-
-/**
- * @brief The data storage type.
- *
- * The data storage type applies to directly user-accessible data including
- * annotations and user_data.
- */
-enum jls_storage_type_e {
-    /// Invalid (unknown) storage type.
-    JLS_STORAGE_TYPE_INVALID = 0,
-    /// Raw binary data.
-    JLS_STORAGE_TYPE_BINARY = 1,
-    /// Null-terminated C-style string with UTF-8 encoding.
-    JLS_STORAGE_TYPE_STRING = 2,
-    /// JSON serialized data structure with NULL terminator and UTF-8 encoding.
-    JLS_STORAGE_TYPE_JSON = 3,
-};
-
-/**
- * @brief The available annotation types.
- */
-enum jls_annotation_type_e {
-    /**
-     * @brief Arbitrary user data.
-     *
-     * Application-dependent data with no standardized form or purpose.
-     */
-    JLS_ANNOTATION_TYPE_USER = 0,
-
-    /**
-     * @brief UTF-8 formatted text.
-     *
-     * Viewers should display this text at the appropriate location.
-     * The jls_storage_type_e must be STRING.
-     */
-    JLS_ANNOTATION_TYPE_TEXT = 1,
-
-    /**
-     * @brief A vertical marker at a given time.
-     *
-     * Marker names can be arbitrary, but the convention is:
-     * - Number strings, like "1", represent a single marker.
-     * - Alpha + number string, like "A1" and "A2", represent
-     *   a marker pair (dual markers).
-     * The jls_storage_type_e must be STRING.
-     */
-    JLS_ANNOTATION_TYPE_VERTICAL_MARKER = 2,
-
-    /**
-     * @brief A horizontal marker at a given y-axis value.
-     *
-     * Marker names can be arbitrary, but the convention is:
-     * - Number strings, like "1", represent a single marker.
-     * - Alpha + number string, like "A1" and "A2", represent
-     *   a marker pair (dual markers).
-     * The jls_storage_type_e must be STRING.
-     */
-    JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER = 3,
-
-    /// consider sample_loss: start, stop
-};
-
-/**
- * @brief The chunks used to store the track information.
- */
-enum jls_track_chunk_e {
-    /**
-     * @brief Track definition chunk.
-     *
-     * This chunk contains a zero-length (empty) payload.
-     */
-    JLS_TRACK_CHUNK_DEF = 0,
-
-    /**
-     * @brief Track offsets for the first chunk at each level.
-     *
-     * @see jls_track_head_s for all track types.
-     *
-     * This chunk provides fast seek access to the first chunk at
-     * each summary level for this track.  The payload is jls_track_head_s
-     * which contains the offset to the first INDEX chunk.
-     */
-    JLS_TRACK_CHUNK_HEAD = 1,
-
-    /**
-     * @brief The data chunk.
-     *
-     * @see jls_fsr_f32_data_s for FSR float32.
-     * @see jls_annotation_s for ANNOTATION.
-     * @see jls_utc_data_s for UTC.
-     *
-     * The payload varies by track type and data format.  All DATA
-     * payloads start with jls_payload_header_s.
-     */
-    JLS_TRACK_CHUNK_DATA = 2,
-
-    /**
-     * @brief Provides the timestamp and offset for each contributing data chunk.
-     *
-     * @see jls_fsr_index_s for FSR track types.
-     * @see jls_index_s for all other track types.
-     *
-     * This chunk MUST be immediately follow by a SUMMARY chunk.
-     * All INDEX payloads start with jls_payload_header_s.
-     */
-    JLS_TRACK_CHUNK_INDEX = 3,
-
-    /**
-     * @brief The summary chunk.
-     *
-     * @see jls_fsr_f32_summary_s for FSR float32.
-     * @see jls_annotation_summary_s for ANNOTATION.
-     * @see jls_utc_summary_s for UTC.
-     *
-     * The payload format is defined by the track type.
-     * All CHUNK payloads start with jls_payload_header_s.
-     */
-    JLS_TRACK_CHUNK_SUMMARY = 4,
-};
-
-/**
- * @brief Pack the chunk tag.
- *
- * @param track_type The jls_track_type_e
- * @param track_chunk The jls_track_chunk_e
- * @return The tag value.
- */
-#define JLS_TRACK_TAG_PACK(track_type, track_chunk) \
-    (0x20 | (((track_type) & 0x03) << 3) | ((track_chunk) & 0x07))
-
-#define JLS_TRACK_TAG_PACKER(track_type, track_chunk) \
-    JLS_TRACK_TAG_PACK(JLS_TRACK_TYPE_##track_type, JLS_TRACK_CHUNK_##track_chunk)
-
-/**
- * @brief The tag definitions.
- */
-enum jls_tag_e {
-    // CAUTION: update jls_tag_to_name on any changes
-    JLS_TAG_INVALID                     = 0x00,
-
-    // file definition tags
-    JLS_TAG_SOURCE_DEF                  = 0x01,   // own doubly-linked list
-    JLS_TAG_SIGNAL_DEF                  = 0x02,   // SIGNAL_DEF, TRACK_*_DEF, and TRACK_*_HEAD for doubly-linked list
-
-    // track tags
-    JLS_TAG_TRACK_FSR_DEF               = JLS_TRACK_TAG_PACKER(FSR, DEF),
-    JLS_TAG_TRACK_FSR_HEAD              = JLS_TRACK_TAG_PACKER(FSR, HEAD),
-    JLS_TAG_TRACK_FSR_DATA              = JLS_TRACK_TAG_PACKER(FSR, DATA),
-    JLS_TAG_TRACK_FSR_INDEX             = JLS_TRACK_TAG_PACKER(FSR, INDEX),
-    JLS_TAG_TRACK_FSR_SUMMARY           = JLS_TRACK_TAG_PACKER(FSR, SUMMARY),
-
-    JLS_TAG_TRACK_VSR_DEF               = JLS_TRACK_TAG_PACKER(VSR, DEF),
-    JLS_TAG_TRACK_VSR_HEAD              = JLS_TRACK_TAG_PACKER(VSR, HEAD),
-    JLS_TAG_TRACK_VSR_DATA              = JLS_TRACK_TAG_PACKER(VSR, DATA),
-    JLS_TAG_TRACK_VSR_INDEX             = JLS_TRACK_TAG_PACKER(VSR, INDEX),
-    JLS_TAG_TRACK_VSR_SUMMARY           = JLS_TRACK_TAG_PACKER(VSR, SUMMARY),
-
-    JLS_TAG_TRACK_ANNOTATION_DEF        = JLS_TRACK_TAG_PACKER(ANNOTATION, DEF),
-    JLS_TAG_TRACK_ANNOTATION_HEAD       = JLS_TRACK_TAG_PACKER(ANNOTATION, HEAD),
-    JLS_TAG_TRACK_ANNOTATION_DATA       = JLS_TRACK_TAG_PACKER(ANNOTATION, DATA),
-    JLS_TAG_TRACK_ANNOTATION_INDEX      = JLS_TRACK_TAG_PACKER(ANNOTATION, INDEX),
-    JLS_TAG_TRACK_ANNOTATION_SUMMARY    = JLS_TRACK_TAG_PACKER(ANNOTATION, SUMMARY),
-
-    JLS_TAG_TRACK_UTC_DEF               = JLS_TRACK_TAG_PACKER(UTC, DEF),
-    JLS_TAG_TRACK_UTC_HEAD              = JLS_TRACK_TAG_PACKER(UTC, HEAD),
-    JLS_TAG_TRACK_UTC_DATA              = JLS_TRACK_TAG_PACKER(UTC, DATA),
-    JLS_TAG_TRACK_UTC_INDEX             = JLS_TRACK_TAG_PACKER(UTC, INDEX),
-    JLS_TAG_TRACK_UTC_SUMMARY           = JLS_TRACK_TAG_PACKER(UTC, SUMMARY),
-
-    // other tags
-    JLS_TAG_USER_DATA                   = 0x40, // own doubly-linked list
-    JLS_TAG_END                         = 0xFF, // present if file closed properly
-};
-
-#define JLS_DATATYPE_BASETYPE_INT        (0x01)
-#define JLS_DATATYPE_BASETYPE_UNSIGNED   (0x02)
-#define JLS_DATATYPE_BASETYPE_UINT       (JLS_DATATYPE_BASETYPE_INT | JLS_DATATYPE_BASETYPE_UNSIGNED)
-#define JLS_DATATYPE_BASETYPE_FLOAT      (0x04)
-
-/**
- * @brief Construct a JLS datatype.
- *
- * @param basetype The datatype base type, one of [INT, UINT, FLOAT, BOOL]
- * @param size The size in bits.  Only the following options are supported:
- *      - INT: 4, 8, 16, 24, 32, 64
- *      - UINT: 1, 4, 8, 16, 24, 32, 64
- *      - FLOAT: 32, 64
- *      - BOOL = UINT 1
- * @param q The signed fixed-point location, only valid for INT and UINT.
- *      Set to 0 for normal, whole numbers.
- *      Set to 0 for FLOAT and BOOL.
- *      The fixed point is between bits q and q-1.  The value is scaled
- *      by 2 ** -q.
- */
-#define JLS_DATATYPE_DEF(basetype, size, q)     \
-    (((JLS_DATATYPE_BASETYPE_##basetype) & 0x0f) |        \
-     (((uint32_t) ((size) & 0xff)) << 8) |   \
-     (((uint32_t) ((q) & 0xff)) << 16))
-
-static inline uint8_t jls_datatype_parse_basetype(uint32_t dt) {
-    return (uint8_t) (dt & 0x0f);
-}
-
-static inline uint8_t jls_datatype_parse_size(uint32_t dt) {
-    return (uint8_t) ((dt >> 8) & 0xff);
-}
-
-static inline uint8_t jls_datatype_parse_q(uint32_t dt) {
-    return (uint8_t) ((dt >> 16) & 0xff);
-}
-
-#define JLS_DATATYPE_I4  JLS_DATATYPE_DEF(INT, 4, 0)
-#define JLS_DATATYPE_I8  JLS_DATATYPE_DEF(INT, 8, 0)
-#define JLS_DATATYPE_I16 JLS_DATATYPE_DEF(INT, 16, 0)
-#define JLS_DATATYPE_I24 JLS_DATATYPE_DEF(INT, 24, 0)
-#define JLS_DATATYPE_I32 JLS_DATATYPE_DEF(INT, 32, 0)
-#define JLS_DATATYPE_I64 JLS_DATATYPE_DEF(INT, 64, 0)
-
-#define JLS_DATATYPE_U1  JLS_DATATYPE_DEF(UINT, 1, 0)
-#define JLS_DATATYPE_U4  JLS_DATATYPE_DEF(UINT, 4, 0)
-#define JLS_DATATYPE_U8  JLS_DATATYPE_DEF(UINT, 8, 0)
-#define JLS_DATATYPE_U16 JLS_DATATYPE_DEF(UINT, 16, 0)
-#define JLS_DATATYPE_U24 JLS_DATATYPE_DEF(UINT, 24, 0)
-#define JLS_DATATYPE_U32 JLS_DATATYPE_DEF(UINT, 32, 0)
-#define JLS_DATATYPE_U64 JLS_DATATYPE_DEF(UINT, 64, 0)
-#define JLS_DATATYPE_BOOL JLS_DATATYPE_U1
-
-#define JLS_DATATYPE_F32 JLS_DATATYPE_DEF(FLOAT, 32, 0)
-#define JLS_DATATYPE_F64 JLS_DATATYPE_DEF(FLOAT, 64, 0)
-
-/**
- * @brief The source definition.
- */
-struct jls_source_def_s {
-    // store unique source_id in chunk_meta
-    uint16_t source_id;          // 0 reserved for global annotations, must be unique per instance
-    // on disk: reserve 64 bytes as 0 for future use
-    const char * name;
-    const char * vendor;
-    const char * model;
-    const char * version;
-    const char * serial_number;
-};
-
-/**
- * @brief The signal definition.
- */
-struct jls_signal_def_s {       // 0 reserved for VSR annotations
-    // store unique signal_id in chunk_meta
-    uint16_t signal_id;                 // 0 to JLS_SIGNAL_COUNT - 1, must be unique per instance
-    uint16_t source_id;                 // must match a source_def
-    uint8_t signal_type;                // jls_signal_type_e
-    uint16_t rsv16_0;                   // JLS_DATATYPE_*
-    uint32_t data_type;                 //
-    uint32_t sample_rate;               // 0 for VSR
-    uint32_t samples_per_data;          // suggestion, will be rounded
-    uint32_t sample_decimate_factor;    // definite
-    uint32_t entries_per_summary;       // suggestion, will be rounded
-    uint32_t summary_decimate_factor;   // definite
-    uint32_t annotation_decimate_factor;
-    uint32_t utc_decimate_factor;
-    int64_t sample_id_offset;           // FSR read-only, dynamically loaded from first data chunk.
-    // on disk: reserve 64 bytes as 0 for future use
-    const char * name;                  // The signal name
-    const char * units;                 // The units string, normally as SI with no scale prefix.
-};
-
-//  struct jls_track_def_s  // empty, only need chunk_meta for now
-
-/**
- * @brief The track head payload for JLS_TRACK_CHUNK_HEAD.
- */
-struct jls_track_head_s {
-    uint64_t offset[16];  // 0 = data, 1 = first summary, ...
-};
-
-/// The summary storage order for each entry
-enum jls_summary_fsr_e {
-    JLS_SUMMARY_FSR_MEAN = 0,
-    JLS_SUMMARY_FSR_STD = 1,
-    JLS_SUMMARY_FSR_MIN = 2,
-    JLS_SUMMARY_FSR_MAX = 3,
-    JLS_SUMMARY_FSR_COUNT = 4,   // must be last
-};
-
-/**
- * @brief Union structure for parsing 32-bit versions.
- */
-union jls_version_u {
-    uint32_t u32;
-    struct {
-        uint16_t patch;
-        uint8_t minor;
-        uint8_t major;
-    } s;
-};
-
-/**
- * @brief The JLS file header structure.
- */
-struct jls_file_header_s {
-    /**
-     * @brief The semi-unique file identification header.
-     *
-     * @see JLS_HEADER_IDENTIFICATION
-     */
-    uint8_t identification[16];
-    
-    /**
-     * @brief The file length in bytes.
-     *
-     * This is the last field updated on file close.  If the file was not
-     * closed gracefully, the value will be 0.
-     */
-    uint64_t length;
-    
-    /**
-     * @brief The JLS file format version number.
-     *
-     * @see JLS_FORMAT_VERSION_U32
-     */
-    union jls_version_u version;
-    
-    /**
-     * @brief The CRC32 from the start of the file through version.
-     */
-    uint32_t crc32;
-};
-
-/**
- * @brief The JLS chunk header structure.
- *
- * Every chunk starts with this header.  This header identifies the chunk's
- * payload, and enables the chunk to participate in one doubly-linked list.
- * 
- * If the length is zero, then the next chuck header immediately follows
- * this chunk header.  If the length is not zero, then the chunk consists of:
- * - A chunk header
- * - payload of length bytes
- * - Zero padding of 0-7 bytes, so that the entire chunk will end on a mulitple
- *   of 8 bytes.  This field ends on: 8 * k - 4
- * - crc32 over the payload.
- */
-struct jls_chunk_header_s {
-    /**
-     * @brief The next item.
-     *
-     * The chunk header enables each chunk to participate in a
-     * single, doubly-linked list.
-     * This field indicates the location for the next item in the list.
-     * The value is relative to start of the file.
-     * 0 indicates end of list.
-     *
-     * This field allows simple, linear traversal of data, but the
-     * next chunk is not known when the chunk is first created.
-     * Therefore, this field requires that chunk headers are updated
-     * when the software writes the next item to the file.
-     */
-    uint64_t item_next;
-
-    /**
-     * @brief The previous item.
-     *
-     * The chunk header enables each chunk to participate in a
-     * single, doubly-linked list.
-     * This field indicates the location for the previous item in the list.
-     * The value is relative to start of the file.
-     * 0 indicates start of list.
-     */
-    uint64_t item_prev;
-
-    /**
-     * @brief The tag.
-     *
-     * The jls_tag_e value that identifies the contents of this chunk.
-     */
-    uint8_t tag;
-    
-    /// Reserved for future use.  (compression?)
-    uint8_t rsv0_u8;
-
-    /**
-     * @brief The metadata associated with this chunk.
-     *
-     * Each tag is free to define the purpose of this field.
-     * 
-     * However, all data tags use this definition:
-     * - chunk_meta[7:0] is the signal/time series identifier from 0 to 255.
-     * - chunk_meta[11:8] is reserved.
-     * - chunk_meta[15:12] contains the depth for this chunk from 0 to 15.
-     *   - 0 = block (sample level)
-     *   - 1 = First-level summary of block samples
-     *   - 2 = Second-level summary of first-level summaries.
-     *
-     * User-data reserves chunk_meta[15:12] to store the storage_type and
-     * another internal indications.  chunk_meta[11:0] may be assigned
-     * by the specific application.
-     */
-    uint16_t chunk_meta;
-    
-    /**
-     * @brief The length of the payload in bytes.  Can be 0.
-     *
-     * In addition to defining the payload size, this value is
-     * also used for forward chunk traversal.
-     */
-    uint32_t payload_length;
-    
-    /**
-     * @brief The length of the previous payload in bytes.
-     *
-     * Used for reverse chunk traversal.
-     */
-    uint32_t payload_prev_length;
-    
-    /// The CRC32 over the header, excluding this field.
-    uint32_t crc32;
-};
-
-/**
- * @brief The payload header for DATA, INDEX, and SUMMARY chunks.
- */
-struct jls_payload_header_s {
-    int64_t timestamp;          ///< The sample_id for the first entry.
-    uint32_t entry_count;       ///< The total number of entries.
-    uint16_t entry_size_bits;   ///< The size of each entry, in bits.
-    uint16_t rsv16;             ///< Reserved.
-};
-
-/// The FSR data chunk format.
-struct jls_fsr_data_s {
-    struct jls_payload_header_s header;  ///< The payload header.
-
-    /**
-     * @brief The summary data.
-     *
-     * Although data's type is float, the actual data type depends upon
-     * the signal definition.
-     */
-    float data[];
-};
-
-/**
- * @brief The payload for JLS_TAG_TRACK_FSR_INDEX chunks.
- *
- * @see jls_index_s for all other INDEX chunk types.
- *
- * Since FSR has a fixed sample rate, the header contains enough information
- * to fully identify the timestamp for each offset.  Therefore, no additional
- * time information is required per entry.
- */
-struct jls_fsr_index_s {
-    struct jls_payload_header_s header;
-    uint64_t offsets[];         ///< The chunk file offsets, spaced by fixed time intervals.
-};
-
-/**
- * @brief The FSR summary chunk format with f32 values.
- *
- * This summary format is used by all types except u32, u64, i32, i64, f64.
- */
-struct jls_fsr_f32_summary_s {
-    struct jls_payload_header_s header;  ///< The payload
-    float data[][JLS_SUMMARY_FSR_COUNT]; ///< The summary data, each entry is 4 x f32: mean, std, min, max.
-};
-
-/**
- * @brief The FSR summary chunk format with f64 values.
- *
- * This summary format is used by u64, i64, f64.
- */
-struct jls_fsr_f64_summary_s {
-    struct jls_payload_header_s header;   ///< The payload
-    double data[][JLS_SUMMARY_FSR_COUNT]; ///< The summary data, each entry is 4 x f64: mean, std, min, max.
-};
-
-/**
- * @brief The entry format for JLS_TRACK_CHUNK_INDEX payloads.
- * @see jls_index_s
- */
-struct jls_index_entry_s {
-    int64_t timestamp;      ///< The timestamp for this entry.  sample_id for FSR, UTC for VSR.
-    uint64_t offset;        ///< The chunk file offset.
-};
-
-/**
- * @brief The payload for JLS_TRACK_CHUNK_INDEX chunks.
- *
- * @see jls_fsr_index_s for JLS_TAG_TRACK_FSR_INDEX.
- *
- * The INDEX payload maps timestamps to offsets to allow fast seek.
- * However, the JLS_TAG_TRACK_FSR_INDEX uses the jls_fsr_index_s since
- * the timestamp provides unnecessary, duplicative information for FSR tracks.
- */
-struct jls_index_s {
-    struct jls_payload_header_s header;
-    struct jls_index_entry_s entries[];
-};
-
-/**
- * @brief Hold a single annotation record.
- *
- * This structure is used by both the API and JLS_TAG_TRACK_ANNOTATION_DATA.
- */
-struct jls_annotation_s {
-    int64_t timestamp;          ///< The timestamp for this annotation.  sample_id for FSR, UTC for VSR.
-    uint64_t rsv64_1;           ///< Reserved, write to 0.
-    uint8_t annotation_type;    ///< The jls_annotation_type_e.
-    uint8_t storage_type;       ///< The jls_storage_type_e.
-    uint8_t group_id;           ///< The optional group identifier.  If unused, write to 0.
-    uint8_t rsv8_1;             ///< Reserved, write to 0.
-    float y;                    ///< The y-axis value or NAN to automatically position.
-    uint32_t data_size;         ///< The size of data in bytes.
-    uint8_t data[];             ///< The annotation data.
-};
-
-/**
- * @brief The entry format for JLS_TAG_TRACK_ANNOTATION_SUMMARY.
- * @see jls_annotation_summary_s
- */
-struct jls_annotation_summary_entry_s {
-    int64_t timestamp;          ///< The timestamp (duplicates INDEX).
-    uint8_t annotation_type;    ///< The jls_annotation_s.annotation_type
-    uint8_t group_id;           ///< The jls_annotation_s.group_id
-    uint8_t rsv8_1;             ///< Reserved, write to 0.
-    uint8_t rsv8_2;             ///< Reserved, write to 0.
-    float y;                    ///< The jls_annotation_s.y
-};
-
-/**
- * @brief The payload format for JLS_TAG_TRACK_ANNOTATION_SUMMARY chunks.
- */
-struct jls_annotation_summary_s {
-    struct jls_payload_header_s header;
-    struct jls_annotation_summary_entry_s entries[];
-};
-
-/**
- * @brief The entry format for JLS_TAG_TRACK_UTC_DATA.
- *
- * @see jls_utc_summary_s
- *
- * This same format is reused for summary entries.
- * UTC.DATA only exists to provide recovery in the event that the
- * file is not properly closed.
- */
-struct jls_utc_data_s {
-    struct jls_payload_header_s header;
-    int64_t timestamp;         ///< The timestamp in UTC.
-};
-
-/**
- * @brief The entry format for JLS_TAG_TRACK_UTC_SUMMARY.
- *
- * @see jls_utc_summary_s
- *
- * This same format is reused for summary entries.
- * UTC.DATA only exists to provide recovery in the event that the
- * file is not properly closed.
- */
-struct jls_utc_summary_entry_s {
-    int64_t sample_id;         ///< The timestamp in sample ids (duplicates INDEX).
-    int64_t timestamp;         ///< The timestamp in UTC.
-};
-
-/**
- * @brief The payload format for JLS_TAG_TRACK_UTC_SUMMARY chunks.
- */
-struct jls_utc_summary_s {
-    struct jls_payload_header_s header;
-    struct jls_utc_summary_entry_s entries[];
-};
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif  /* JLS_FORMAT_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS file format.
+ */
+
+#ifndef JLS_FORMAT_H__
+#define JLS_FORMAT_H__
+
+#include "jls/cmacro.h"
+#include <stdint.h>
+
+/**
+ * @ingroup jls
+ * @defgroup jls_format File format
+ *
+ * @brief JLS file format.
+ *
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+#define JLS_FORMAT_VERSION_MAJOR  (1)
+#define JLS_FORMAT_VERSION_MINOR  (0)
+#define JLS_FORMAT_VERSION_PATCH  (0)
+#define JLS_FORMAT_VERSION_U32     ((uint32_t) ( \
+    ((JLS_FORMAT_VERSION_MAJOR & 0xff) << 24) | \
+    ((JLS_FORMAT_VERSION_MINOR & 0xff) << 16) | \
+    (JLS_FORMAT_VERSION_PATCH & 0xffff) ))
+
+/**
+ * @brief The file identification bytes at the start of the file.
+ *
+ * These bytes are not arbitrary.  We carefully selected them to provide:
+ * - Identification: Help the application determine that
+ *   this file is in the correct format with minimal uncertainty.
+ * - Correct endianness:  Little endian has won, so this entire format is
+ *   stored in little endian format.
+ * - Proper binary processing:  The different line ending combinations
+ *   ensure that the reader is not "fixing" the line endings, since this
+ *   is a binary file format.
+ * - Display: Include "substitute" and "file separator" so that text
+ *   printers to not show the rest of the file.
+ *
+ * The following table describes maps each byte to its purpose:
+ * | Value (hex)       | Purpose                                             |
+ * | ----------------- | --------------------------------------------------- |
+ * | 6A 6C 73 66 6d 74 | ASCII "jlsfmt", when viewed in text editor.         |
+ * | 0D 0A             | DOS line ending to ensure binary correctness.       |
+ * | 20                | ASCII space.                                        |
+ * | 0A                | UNIX line ending to ensure binary correctness.      |
+ * | 20                | ASCII space.                                        |
+ * | 1A                | Substitute character (stops listing under Windows). |
+ * | 20 20             | ASCII spaces.                                       |
+ * | B2                | Ensure that system supports 8-bit data              |
+ * | 1C                | File separator.                                     |
+ */
+#define JLS_HEADER_IDENTIFICATION \
+    {0x6a, 0x6c, 0x73, 0x66, 0x6d, 0x74, 0x0d, 0x0a, \
+     0x20, 0x0a, 0x20, 0x1a, 0x20, 0x20, 0xb2, 0x1c}
+
+/**
+ * @brief The maximum allowed number of sources.
+ */
+#define JLS_SOURCE_COUNT (256)
+
+/**
+ * @brief The maximum allowed number of signals.
+ */
+#define JLS_SIGNAL_COUNT (256)
+
+/**
+ * @brief The number of summary levels.
+ */
+#define JLS_SUMMARY_LEVEL_COUNT (16)
+
+/**
+ * @brief The signal type definition.
+ */
+enum jls_signal_type_e {
+    /// Fixed sampling rate
+    JLS_SIGNAL_TYPE_FSR = 0,
+    /// Variable sampling rate
+    JLS_SIGNAL_TYPE_VSR = 1,
+};
+
+/**
+ * @brief The available track types that store data over time.
+ */
+enum jls_track_type_e {
+    /**
+     * @brief Block tracks contain fixed sample-rate (FSR) data.
+     *
+     * The JLS_TAG_SIGNAL_DEF defines the sampling rate.
+     */
+    JLS_TRACK_TYPE_FSR = 0,
+
+    /**
+     * @brief Fixed-type, variable-sample-rate (VSR) time series data.
+     *
+     * Each data entry consists of time in UTC and the data.
+     */
+    JLS_TRACK_TYPE_VSR = 1,
+
+    /**
+     * @brief Annotations contain infrequent, variable-typed data.
+     *
+     * @see jls_annotation_type_e for the annotation types.
+     *
+     * Each annotation data entry consists of time and associated
+     * annotation data.
+     * For FSR, time must be samples_id.
+     * For VSR, time must be UTC.
+     */
+    JLS_TRACK_TYPE_ANNOTATION = 2,
+
+    /**
+     * @brief The UTC track associates sample_id with UTC.
+     *
+     * Each utc data entry consists of sample_id, UTC timestamp pairs.
+     * This track is only used for FSR signals.
+     */
+    JLS_TRACK_TYPE_UTC = 3,
+
+    /// The total number of track types
+    JLS_TRACK_TYPE_COUNT = 4,
+};
+
+/**
+ * @brief The data storage type.
+ *
+ * The data storage type applies to directly user-accessible data including
+ * annotations and user_data.
+ */
+enum jls_storage_type_e {
+    /// Invalid (unknown) storage type.
+    JLS_STORAGE_TYPE_INVALID = 0,
+    /// Raw binary data.
+    JLS_STORAGE_TYPE_BINARY = 1,
+    /// Null-terminated C-style string with UTF-8 encoding.
+    JLS_STORAGE_TYPE_STRING = 2,
+    /// JSON serialized data structure with NULL terminator and UTF-8 encoding.
+    JLS_STORAGE_TYPE_JSON = 3,
+};
+
+/**
+ * @brief The available annotation types.
+ */
+enum jls_annotation_type_e {
+    /**
+     * @brief Arbitrary user data.
+     *
+     * Application-dependent data with no standardized form or purpose.
+     */
+    JLS_ANNOTATION_TYPE_USER = 0,
+
+    /**
+     * @brief UTF-8 formatted text.
+     *
+     * Viewers should display this text at the appropriate location.
+     * The jls_storage_type_e must be STRING.
+     */
+    JLS_ANNOTATION_TYPE_TEXT = 1,
+
+    /**
+     * @brief A vertical marker at a given time.
+     *
+     * Marker names can be arbitrary, but the convention is:
+     * - Number strings, like "1", represent a single marker.
+     * - Alpha + number string, like "A1" and "A2", represent
+     *   a marker pair (dual markers).
+     * The jls_storage_type_e must be STRING.
+     */
+    JLS_ANNOTATION_TYPE_VERTICAL_MARKER = 2,
+
+    /**
+     * @brief A horizontal marker at a given y-axis value.
+     *
+     * Marker names can be arbitrary, but the convention is:
+     * - Number strings, like "1", represent a single marker.
+     * - Alpha + number string, like "A1" and "A2", represent
+     *   a marker pair (dual markers).
+     * The jls_storage_type_e must be STRING.
+     */
+    JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER = 3,
+
+    /// consider sample_loss: start, stop
+};
+
+/**
+ * @brief The chunks used to store the track information.
+ */
+enum jls_track_chunk_e {
+    /**
+     * @brief Track definition chunk.
+     *
+     * This chunk contains a zero-length (empty) payload.
+     */
+    JLS_TRACK_CHUNK_DEF = 0,
+
+    /**
+     * @brief Track offsets for the first chunk at each level.
+     *
+     * @see jls_track_head_s for all track types.
+     *
+     * This chunk provides fast seek access to the first chunk at
+     * each summary level for this track.  The payload is jls_track_head_s
+     * which contains the offset to the first INDEX chunk.
+     */
+    JLS_TRACK_CHUNK_HEAD = 1,
+
+    /**
+     * @brief The data chunk.
+     *
+     * @see jls_fsr_f32_data_s for FSR float32.
+     * @see jls_annotation_s for ANNOTATION.
+     * @see jls_utc_data_s for UTC.
+     *
+     * The payload varies by track type and data format.  All DATA
+     * payloads start with jls_payload_header_s.
+     */
+    JLS_TRACK_CHUNK_DATA = 2,
+
+    /**
+     * @brief Provides the timestamp and offset for each contributing data chunk.
+     *
+     * @see jls_fsr_index_s for FSR track types.
+     * @see jls_index_s for all other track types.
+     *
+     * This chunk MUST be immediately follow by a SUMMARY chunk.
+     * All INDEX payloads start with jls_payload_header_s.
+     */
+    JLS_TRACK_CHUNK_INDEX = 3,
+
+    /**
+     * @brief The summary chunk.
+     *
+     * @see jls_fsr_f32_summary_s for FSR float32.
+     * @see jls_annotation_summary_s for ANNOTATION.
+     * @see jls_utc_summary_s for UTC.
+     *
+     * The payload format is defined by the track type.
+     * All CHUNK payloads start with jls_payload_header_s.
+     */
+    JLS_TRACK_CHUNK_SUMMARY = 4,
+};
+
+/**
+ * @brief Pack the chunk tag.
+ *
+ * @param track_type The jls_track_type_e
+ * @param track_chunk The jls_track_chunk_e
+ * @return The tag value.
+ */
+#define JLS_TRACK_TAG_PACK(track_type, track_chunk) \
+    (0x20 | (((track_type) & 0x03) << 3) | ((track_chunk) & 0x07))
+
+#define JLS_TRACK_TAG_PACKER(track_type, track_chunk) \
+    JLS_TRACK_TAG_PACK(JLS_TRACK_TYPE_##track_type, JLS_TRACK_CHUNK_##track_chunk)
+
+/**
+ * @brief The tag definitions.
+ */
+enum jls_tag_e {
+    // CAUTION: update jls_tag_to_name on any changes
+    JLS_TAG_INVALID                     = 0x00,
+
+    // file definition tags
+    JLS_TAG_SOURCE_DEF                  = 0x01,   // own doubly-linked list
+    JLS_TAG_SIGNAL_DEF                  = 0x02,   // SIGNAL_DEF, TRACK_*_DEF, and TRACK_*_HEAD for doubly-linked list
+
+    // track tags
+    JLS_TAG_TRACK_FSR_DEF               = JLS_TRACK_TAG_PACKER(FSR, DEF),
+    JLS_TAG_TRACK_FSR_HEAD              = JLS_TRACK_TAG_PACKER(FSR, HEAD),
+    JLS_TAG_TRACK_FSR_DATA              = JLS_TRACK_TAG_PACKER(FSR, DATA),
+    JLS_TAG_TRACK_FSR_INDEX             = JLS_TRACK_TAG_PACKER(FSR, INDEX),
+    JLS_TAG_TRACK_FSR_SUMMARY           = JLS_TRACK_TAG_PACKER(FSR, SUMMARY),
+
+    JLS_TAG_TRACK_VSR_DEF               = JLS_TRACK_TAG_PACKER(VSR, DEF),
+    JLS_TAG_TRACK_VSR_HEAD              = JLS_TRACK_TAG_PACKER(VSR, HEAD),
+    JLS_TAG_TRACK_VSR_DATA              = JLS_TRACK_TAG_PACKER(VSR, DATA),
+    JLS_TAG_TRACK_VSR_INDEX             = JLS_TRACK_TAG_PACKER(VSR, INDEX),
+    JLS_TAG_TRACK_VSR_SUMMARY           = JLS_TRACK_TAG_PACKER(VSR, SUMMARY),
+
+    JLS_TAG_TRACK_ANNOTATION_DEF        = JLS_TRACK_TAG_PACKER(ANNOTATION, DEF),
+    JLS_TAG_TRACK_ANNOTATION_HEAD       = JLS_TRACK_TAG_PACKER(ANNOTATION, HEAD),
+    JLS_TAG_TRACK_ANNOTATION_DATA       = JLS_TRACK_TAG_PACKER(ANNOTATION, DATA),
+    JLS_TAG_TRACK_ANNOTATION_INDEX      = JLS_TRACK_TAG_PACKER(ANNOTATION, INDEX),
+    JLS_TAG_TRACK_ANNOTATION_SUMMARY    = JLS_TRACK_TAG_PACKER(ANNOTATION, SUMMARY),
+
+    JLS_TAG_TRACK_UTC_DEF               = JLS_TRACK_TAG_PACKER(UTC, DEF),
+    JLS_TAG_TRACK_UTC_HEAD              = JLS_TRACK_TAG_PACKER(UTC, HEAD),
+    JLS_TAG_TRACK_UTC_DATA              = JLS_TRACK_TAG_PACKER(UTC, DATA),
+    JLS_TAG_TRACK_UTC_INDEX             = JLS_TRACK_TAG_PACKER(UTC, INDEX),
+    JLS_TAG_TRACK_UTC_SUMMARY           = JLS_TRACK_TAG_PACKER(UTC, SUMMARY),
+
+    // other tags
+    JLS_TAG_USER_DATA                   = 0x40, // own doubly-linked list
+    JLS_TAG_END                         = 0xFF, // present if file closed properly
+};
+
+#define JLS_DATATYPE_BASETYPE_INT        (0x01)
+#define JLS_DATATYPE_BASETYPE_UNSIGNED   (0x02)
+#define JLS_DATATYPE_BASETYPE_UINT       (JLS_DATATYPE_BASETYPE_INT | JLS_DATATYPE_BASETYPE_UNSIGNED)
+#define JLS_DATATYPE_BASETYPE_FLOAT      (0x04)
+
+/**
+ * @brief Construct a JLS datatype.
+ *
+ * @param basetype The datatype base type, one of [INT, UINT, FLOAT, BOOL]
+ * @param size The size in bits.  Only the following options are supported:
+ *      - INT: 4, 8, 16, 24, 32, 64
+ *      - UINT: 1, 4, 8, 16, 24, 32, 64
+ *      - FLOAT: 32, 64
+ *      - BOOL = UINT 1
+ * @param q The signed fixed-point location, only valid for INT and UINT.
+ *      Set to 0 for normal, whole numbers.
+ *      Set to 0 for FLOAT and BOOL.
+ *      The fixed point is between bits q and q-1.  The value is scaled
+ *      by 2 ** -q.
+ */
+#define JLS_DATATYPE_DEF(basetype, size, q)     \
+    (((JLS_DATATYPE_BASETYPE_##basetype) & 0x0f) |        \
+     (((uint32_t) ((size) & 0xff)) << 8) |   \
+     (((uint32_t) ((q) & 0xff)) << 16))
+
+static inline uint8_t jls_datatype_parse_basetype(uint32_t dt) {
+    return (uint8_t) (dt & 0x0f);
+}
+
+static inline uint8_t jls_datatype_parse_size(uint32_t dt) {
+    return (uint8_t) ((dt >> 8) & 0xff);
+}
+
+static inline uint8_t jls_datatype_parse_q(uint32_t dt) {
+    return (uint8_t) ((dt >> 16) & 0xff);
+}
+
+#define JLS_DATATYPE_I4  JLS_DATATYPE_DEF(INT, 4, 0)
+#define JLS_DATATYPE_I8  JLS_DATATYPE_DEF(INT, 8, 0)
+#define JLS_DATATYPE_I16 JLS_DATATYPE_DEF(INT, 16, 0)
+#define JLS_DATATYPE_I24 JLS_DATATYPE_DEF(INT, 24, 0)
+#define JLS_DATATYPE_I32 JLS_DATATYPE_DEF(INT, 32, 0)
+#define JLS_DATATYPE_I64 JLS_DATATYPE_DEF(INT, 64, 0)
+
+#define JLS_DATATYPE_U1  JLS_DATATYPE_DEF(UINT, 1, 0)
+#define JLS_DATATYPE_U4  JLS_DATATYPE_DEF(UINT, 4, 0)
+#define JLS_DATATYPE_U8  JLS_DATATYPE_DEF(UINT, 8, 0)
+#define JLS_DATATYPE_U16 JLS_DATATYPE_DEF(UINT, 16, 0)
+#define JLS_DATATYPE_U24 JLS_DATATYPE_DEF(UINT, 24, 0)
+#define JLS_DATATYPE_U32 JLS_DATATYPE_DEF(UINT, 32, 0)
+#define JLS_DATATYPE_U64 JLS_DATATYPE_DEF(UINT, 64, 0)
+#define JLS_DATATYPE_BOOL JLS_DATATYPE_U1
+
+#define JLS_DATATYPE_F32 JLS_DATATYPE_DEF(FLOAT, 32, 0)
+#define JLS_DATATYPE_F64 JLS_DATATYPE_DEF(FLOAT, 64, 0)
+
+/**
+ * @brief The source definition.
+ */
+struct jls_source_def_s {
+    // store unique source_id in chunk_meta
+    /**
+     * @brief The source identifier.
+     *
+     * 0 reserved for global annotations, must be unique per instance
+     */
+    uint16_t source_id;
+    // on disk: reserve 64 bytes as 0 for future use
+    const char * name;          ///< The source name string.
+    const char * vendor;        ///< The vendor name string.
+    const char * model;         ///< The model string.
+    const char * version;       ///< The version string.
+    const char * serial_number; ///< The serial number string.
+};
+
+/**
+ * @brief The signal definition.
+ */
+struct jls_signal_def_s {       // 0 reserved for VSR annotations
+    // store unique signal_id in chunk_meta
+    /**
+     * @brief The signal identifier.
+     *
+     * 0 to JLS_SIGNAL_COUNT - 1, must be unique per instance
+     */
+    uint16_t signal_id;
+    uint16_t source_id;                 ///< The source identifier, must match a source_def.
+    uint8_t signal_type;                ///< The jls_signal_type_e signal type.
+    uint16_t rsv16_0;                   //
+    uint32_t data_type;                 ///< The JLS_DATATYPE_* data type for this signal.
+    uint32_t sample_rate;               ///< TThe sample rate per second (Hz).  0 for VSR.
+    uint32_t samples_per_data;          ///< The number of samples per data chunk.  (write suggestion)
+    uint32_t sample_decimate_factor;    ///< The number of samples per summary level 1 entry.
+    uint32_t entries_per_summary;       ///< The number of entries per summary chunk.  (write suggestion)
+    uint32_t summary_decimate_factor;   ///< The number of summaries per summary, level >= 2.
+    uint32_t annotation_decimate_factor;  ///< The annotation decimate factor for summaries.
+    uint32_t utc_decimate_factor;       ///< The UTC decimate factor for summaries.
+    int64_t sample_id_offset;           ///< The sample id offset for the first sample.  (FSR only)
+    // on disk: reserve 64 bytes as 0 for future use
+    const char * name;                  ///< The signal name
+    const char * units;                 ///< The units string, normally as SI with no scale prefix.
+};
+
+//  struct jls_track_def_s  // empty, only need chunk_meta for now
+
+/**
+ * @brief The track head payload for JLS_TRACK_CHUNK_HEAD.
+ */
+struct jls_track_head_s {
+    uint64_t offset[16];  // 0 = data, 1 = first summary, ...
+};
+
+/// The summary storage order for each entry
+enum jls_summary_fsr_e {
+    JLS_SUMMARY_FSR_MEAN = 0,
+    JLS_SUMMARY_FSR_STD = 1,
+    JLS_SUMMARY_FSR_MIN = 2,
+    JLS_SUMMARY_FSR_MAX = 3,
+    JLS_SUMMARY_FSR_COUNT = 4,   // must be last
+};
+
+/**
+ * @brief Union structure for parsing 32-bit versions.
+ */
+union jls_version_u {
+    uint32_t u32;
+    struct {
+        uint16_t patch;
+        uint8_t minor;
+        uint8_t major;
+    } s;
+};
+
+/**
+ * @brief The JLS file header structure.
+ */
+struct jls_file_header_s {
+    /**
+     * @brief The semi-unique file identification header.
+     *
+     * @see JLS_HEADER_IDENTIFICATION
+     */
+    uint8_t identification[16];
+    
+    /**
+     * @brief The file length in bytes.
+     *
+     * This is the last field updated on file close.  If the file was not
+     * closed gracefully, the value will be 0.
+     */
+    uint64_t length;
+    
+    /**
+     * @brief The JLS file format version number.
+     *
+     * @see JLS_FORMAT_VERSION_U32
+     */
+    union jls_version_u version;
+    
+    /**
+     * @brief The CRC32 from the start of the file through version.
+     */
+    uint32_t crc32;
+};
+
+/**
+ * @brief The JLS chunk header structure.
+ *
+ * Every chunk starts with this header.  This header identifies the chunk's
+ * payload, and enables the chunk to participate in one doubly-linked list.
+ * 
+ * If the length is zero, then the next chuck header immediately follows
+ * this chunk header.  If the length is not zero, then the chunk consists of:
+ * - A chunk header
+ * - payload of length bytes
+ * - Zero padding of 0-7 bytes, so that the entire chunk will end on a mulitple
+ *   of 8 bytes.  This field ends on: 8 * k - 4
+ * - crc32 over the payload.
+ */
+struct jls_chunk_header_s {
+    /**
+     * @brief The next item.
+     *
+     * The chunk header enables each chunk to participate in a
+     * single, doubly-linked list.
+     * This field indicates the location for the next item in the list.
+     * The value is relative to start of the file.
+     * 0 indicates end of list.
+     *
+     * This field allows simple, linear traversal of data, but the
+     * next chunk is not known when the chunk is first created.
+     * Therefore, this field requires that chunk headers are updated
+     * when the software writes the next item to the file.
+     */
+    uint64_t item_next;
+
+    /**
+     * @brief The previous item.
+     *
+     * The chunk header enables each chunk to participate in a
+     * single, doubly-linked list.
+     * This field indicates the location for the previous item in the list.
+     * The value is relative to start of the file.
+     * 0 indicates start of list.
+     */
+    uint64_t item_prev;
+
+    /**
+     * @brief The tag.
+     *
+     * The jls_tag_e value that identifies the contents of this chunk.
+     */
+    uint8_t tag;
+    
+    /// Reserved for future use.  (compression?)
+    uint8_t rsv0_u8;
+
+    /**
+     * @brief The metadata associated with this chunk.
+     *
+     * Each tag is free to define the purpose of this field.
+     * 
+     * However, all data tags use this definition:
+     * - chunk_meta[7:0] is the signal/time series identifier from 0 to 255.
+     * - chunk_meta[11:8] is reserved.
+     * - chunk_meta[15:12] contains the depth for this chunk from 0 to 15.
+     *   - 0 = block (sample level)
+     *   - 1 = First-level summary of block samples
+     *   - 2 = Second-level summary of first-level summaries.
+     *
+     * User-data reserves chunk_meta[15:12] to store the storage_type and
+     * another internal indications.  chunk_meta[11:0] may be assigned
+     * by the specific application.
+     */
+    uint16_t chunk_meta;
+    
+    /**
+     * @brief The length of the payload in bytes.  Can be 0.
+     *
+     * In addition to defining the payload size, this value is
+     * also used for forward chunk traversal.
+     */
+    uint32_t payload_length;
+    
+    /**
+     * @brief The length of the previous payload in bytes.
+     *
+     * Used for reverse chunk traversal.
+     */
+    uint32_t payload_prev_length;
+    
+    /// The CRC32 over the header, excluding this field.
+    uint32_t crc32;
+};
+
+/**
+ * @brief The payload header for DATA, INDEX, and SUMMARY chunks.
+ */
+struct jls_payload_header_s {
+    int64_t timestamp;          ///< The sample_id for the first entry.
+    uint32_t entry_count;       ///< The total number of entries.
+    uint16_t entry_size_bits;   ///< The size of each entry, in bits.
+    uint16_t rsv16;             ///< Reserved.
+};
+
+/// The FSR data chunk format.
+struct jls_fsr_data_s {
+    struct jls_payload_header_s header;  ///< The payload header.
+
+    /**
+     * @brief The summary data.
+     *
+     * Although data's type is float, the actual data type depends upon
+     * the signal definition.
+     */
+    float data[];
+};
+
+/**
+ * @brief The payload for JLS_TAG_TRACK_FSR_INDEX chunks.
+ *
+ * @see jls_index_s for all other INDEX chunk types.
+ *
+ * Since FSR has a fixed sample rate, the header contains enough information
+ * to fully identify the timestamp for each offset.  Therefore, no additional
+ * time information is required per entry.
+ */
+struct jls_fsr_index_s {
+    struct jls_payload_header_s header;
+    uint64_t offsets[];         ///< The chunk file offsets, spaced by fixed time intervals.
+};
+
+/**
+ * @brief The FSR summary chunk format with f32 values.
+ *
+ * This summary format is used by all types except u32, u64, i32, i64, f64.
+ */
+struct jls_fsr_f32_summary_s {
+    struct jls_payload_header_s header;  ///< The payload
+    float data[][JLS_SUMMARY_FSR_COUNT]; ///< The summary data, each entry is 4 x f32: mean, std, min, max.
+};
+
+/**
+ * @brief The FSR summary chunk format with f64 values.
+ *
+ * This summary format is used by u64, i64, f64.
+ */
+struct jls_fsr_f64_summary_s {
+    struct jls_payload_header_s header;   ///< The payload
+    double data[][JLS_SUMMARY_FSR_COUNT]; ///< The summary data, each entry is 4 x f64: mean, std, min, max.
+};
+
+/**
+ * @brief The entry format for JLS_TRACK_CHUNK_INDEX payloads.
+ * @see jls_index_s
+ */
+struct jls_index_entry_s {
+    int64_t timestamp;      ///< The timestamp for this entry.  sample_id for FSR, UTC for VSR.
+    uint64_t offset;        ///< The chunk file offset.
+};
+
+/**
+ * @brief The payload for JLS_TRACK_CHUNK_INDEX chunks.
+ *
+ * @see jls_fsr_index_s for JLS_TAG_TRACK_FSR_INDEX.
+ *
+ * The INDEX payload maps timestamps to offsets to allow fast seek.
+ * However, the JLS_TAG_TRACK_FSR_INDEX uses the jls_fsr_index_s since
+ * the timestamp provides unnecessary, duplicative information for FSR tracks.
+ */
+struct jls_index_s {
+    struct jls_payload_header_s header;
+    struct jls_index_entry_s entries[];
+};
+
+/**
+ * @brief Hold a single annotation record.
+ *
+ * This structure is used by both the API and JLS_TAG_TRACK_ANNOTATION_DATA.
+ */
+struct jls_annotation_s {
+    int64_t timestamp;          ///< The timestamp for this annotation.  sample_id for FSR, UTC for VSR.
+    uint64_t rsv64_1;           ///< Reserved, write to 0.
+    uint8_t annotation_type;    ///< The jls_annotation_type_e.
+    uint8_t storage_type;       ///< The jls_storage_type_e.
+    uint8_t group_id;           ///< The optional group identifier.  If unused, write to 0.
+    uint8_t rsv8_1;             ///< Reserved, write to 0.
+    float y;                    ///< The y-axis value or NAN to automatically position.
+    uint32_t data_size;         ///< The size of data in bytes.
+    uint8_t data[];             ///< The annotation data.
+};
+
+/**
+ * @brief The entry format for JLS_TAG_TRACK_ANNOTATION_SUMMARY.
+ * @see jls_annotation_summary_s
+ */
+struct jls_annotation_summary_entry_s {
+    int64_t timestamp;          ///< The timestamp (duplicates INDEX).
+    uint8_t annotation_type;    ///< The jls_annotation_s.annotation_type
+    uint8_t group_id;           ///< The jls_annotation_s.group_id
+    uint8_t rsv8_1;             ///< Reserved, write to 0.
+    uint8_t rsv8_2;             ///< Reserved, write to 0.
+    float y;                    ///< The jls_annotation_s.y
+};
+
+/**
+ * @brief The payload format for JLS_TAG_TRACK_ANNOTATION_SUMMARY chunks.
+ */
+struct jls_annotation_summary_s {
+    struct jls_payload_header_s header;
+    struct jls_annotation_summary_entry_s entries[];
+};
+
+/**
+ * @brief The entry format for JLS_TAG_TRACK_UTC_DATA.
+ *
+ * @see jls_utc_summary_s
+ *
+ * This same format is reused for summary entries.
+ * UTC.DATA only exists to provide recovery in the event that the
+ * file is not properly closed.
+ */
+struct jls_utc_data_s {
+    struct jls_payload_header_s header;
+    int64_t timestamp;         ///< The timestamp in UTC.
+};
+
+/**
+ * @brief The entry format for JLS_TAG_TRACK_UTC_SUMMARY.
+ *
+ * @see jls_utc_summary_s
+ *
+ * This same format is reused for summary entries.
+ * UTC.DATA only exists to provide recovery in the event that the
+ * file is not properly closed.
+ */
+struct jls_utc_summary_entry_s {
+    int64_t sample_id;         ///< The timestamp in sample ids (duplicates INDEX).
+    int64_t timestamp;         ///< The timestamp in UTC.
+};
+
+/**
+ * @brief The payload format for JLS_TAG_TRACK_UTC_SUMMARY chunks.
+ */
+struct jls_utc_summary_s {
+    struct jls_payload_header_s header;
+    struct jls_utc_summary_entry_s entries[];
+};
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif  /* JLS_FORMAT_H__ */
```

### Comparing `pyjls-0.7.0/include/jls/log.h` & `pyjls-0.7.1/include/jls/log.h`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,331 +1,331 @@
-/*
- * Copyright 2014-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/*!
- * \file
- *
- * \brief Trivial logging support.
- */
-
-#ifndef JLS_LOG_H_
-#define JLS_LOG_H_
-
-#include "jls/cmacro.h"
-#include <stdint.h>
-
-/**
- * @ingroup jls
- * @defgroup jls_log Console logging
- *
- * @brief Generic console logging with compile-time levels.
- *
- * To use this module, call jls_log_initialize() with the appropriate
- * handler for your application.
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-/**
- * @def JLS_LOG_GLOBAL_LEVEL
- *
- * @brief The global logging level.
- *
- * The maximum level to compile regardless of the individual module level.
- * This value should be defined in the project CMake (makefile).
- */
-#ifndef JLS_LOG_GLOBAL_LEVEL
-#define JLS_LOG_GLOBAL_LEVEL JLS_LOG_LEVEL_ALL
-#endif
-
-/**
- * @def JLS_LOG_LEVEL
- *
- * @brief The module logging level.
- *
- * Typical usage 1:  (not MISRA C compliant, but safe)
- *
- *      #define JLS_LOG_LEVEL JLS_LOG_LEVEL_WARNING
- *      #include "log.h"
- */
-#ifndef JLS_LOG_LEVEL
-#define JLS_LOG_LEVEL JLS_LOG_LEVEL_WARNING
-#endif
-
-/**
- * @def \_\_FILENAME\_\_
- *
- * @brief The filename to display for logging.
- *
- * When compiling C and C++ code, the __FILE__ define may contain a long path
- * that just confuses the log output.  The build tools, such as make and cmake,
- * can define __FILENAME__ to produce more meaningful results.
- *
- * A good Makefile usage includes:
- *
- */
-#ifndef __FILENAME__
-#define __FILENAME__ __FILE__
-#endif
-
-#if defined(__GNUC__) && !defined(_WIN32)
-/* https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html */
-#define JLS_LOG_PRINTF_FORMAT __attribute__((format (printf, 1, 2)))
-#else
-#define JLS_LOG_PRINTF_FORMAT
-#endif
-
-/**
- * @brief The printf-style function call for each log message.
- *
- * @param format The print-style formatting string.
- *     The remaining parameters are arguments for the formatting string.
- * @return The number of characters printed.
- *
- * For PC-based applications, a common implementation is::
- *
- *     #include <stdarg.h>
- *     #include <stdio.h>
- *
- *     void jls_log_printf(const char * format, ...) {
- *         va_list arg;
- *         va_start(arg, format);
- *         vprintf(format, arg);
- *         va_end(arg);
- *     }
- *
- * If your application calls the LOG* macros from multiple threads, then
- * the jls_log_printf implementation must be thread-safe and reentrant.
- *
- * This function is exposed to allow for unit testing.
- */
-JLS_API void jls_log_printf(const char * format, ...) JLS_LOG_PRINTF_FORMAT;
-
-/**
- * @brief The callback for log messages.
- *
- * @param msg The log message.
- */
-typedef void (*jls_log_cbk)(const char * msg);
-
-/**
- * @brief Register a logging handler
- *
- * @param handler The log handler.  Pass NULL or call jls_log_unregister() to
- *      restore the default log handler.
- *
- * @return 0 or error code.
- *
- * The library initializes with a default null log handler so that logging
- * which occurs before jls_log_register will not cause a fault.  This function
- * may be safely called at any time, even without finalize.
- */
-JLS_API void jls_log_register(jls_log_cbk handler);
-
-/**
- * @brief Finalize the logging feature.
- *
- * This is equivalent to calling jls_log_initialize(0).
- */
-JLS_API void jls_log_unregister(void);
-
-/**
- * @def JLS_LOG_PRINTF
- * @brief The printf function including log formatting.
- *
- * @param level The level for this log message
- * @param format The formatting string
- * @param ... The arguments for the formatting string
- */
-#ifndef JLS_LOG_PRINTF
-#define JLS_LOG_PRINTF(level, format, ...) \
-    jls_log_printf("%c %s:%d: " format "\n", jls_log_level_char[level], __FILENAME__, __LINE__, __VA_ARGS__);
-#endif
-
-/**
- * @brief The available logging levels.
- */
-enum jls_log_level_e {
-    /** Logging functionality is disabled. */
-    JLS_LOG_LEVEL_OFF         = -1,
-    /** A "panic" condition that may result in significant harm. */
-    JLS_LOG_LEVEL_EMERGENCY   = 0,
-    /** A condition requiring immediate action. */
-    JLS_LOG_LEVEL_ALERT       = 1,
-    /** A critical error which prevents further functions. */
-    JLS_LOG_LEVEL_CRITICAL    = 2,
-    /** An error which prevents the current operation from completing or
-     *  will adversely effect future functionality. */
-    JLS_LOG_LEVEL_ERROR       = 3,
-    /** A warning which may adversely affect the current operation or future
-     *  operations. */
-    JLS_LOG_LEVEL_WARNING     = 4,
-    /** A notification for interesting events. */
-    JLS_LOG_LEVEL_NOTICE      = 5,
-    /** An informative message. */
-    JLS_LOG_LEVEL_INFO        = 6,
-    /** Detailed messages for the software developer. */
-    JLS_LOG_LEVEL_DEBUG1      = 7,
-    /** Very detailed messages for the software developer. */
-    JLS_LOG_LEVEL_DEBUG2      = 8,
-    /** Insanely detailed messages for the software developer. */
-    JLS_LOG_LEVEL_DEBUG3      = 9,
-    /** All logging functionality is enabled. */
-    JLS_LOG_LEVEL_ALL         = 10,
-};
-
-/** Detailed messages for the software developer. */
-#define JLS_LOG_LEVEL_DEBUG JLS_LOG_LEVEL_DEBUG1
-
-/**
- * @brief Map log level to a string name.
- */
-extern char const * const jls_log_level_str[JLS_LOG_LEVEL_ALL + 1];
-
-/**
- * @brief Map log level to a single character.
- */
-extern char const jls_log_level_char[JLS_LOG_LEVEL_ALL + 1];
-
-/**
- * @brief Convert a log level to a user-meaningful string description.
- *
- * @param level The log level.
- * @return The string description.
- */
-JLS_API const char * jsdrv_log_level_to_str(int8_t level);
-
-/**
- * @brief Convert a log level to a user-meaningful character.
- *
- * @param level The log level.
- * @return The character representing the log level.
- */
-JLS_API char jsdrv_log_level_to_char(int8_t level);
-
-/**
- * @brief Check the current level against the static logging configuration.
- *
- * @param level The level to query.
- * @return True if logging at level is permitted.
- */
-#define JLS_LOG_CHECK_STATIC(level) ((level <= JLS_LOG_GLOBAL_LEVEL) && (level <= JLS_LOG_LEVEL) && (level >= 0))
-
-/**
- * @brief Check a log level against a configured level.
- *
- * @param level The level to query.
- * @param cfg_level The configured logging level.
- * @return True if level is permitted given cfg_level.
- */
-#define JLS_LOG_LEVEL_CHECK(level, cfg_level) (level <= cfg_level)
-
-/*!
- * \brief Macro to log a printf-compatible formatted string.
- *
- * \param level The jls_log_level_e.
- * \param format The printf-compatible formatting string.
- * \param ... The arguments to the formatting string.
- */
-#define JLS_LOG(level, format, ...) \
-    do { \
-        if (JLS_LOG_CHECK_STATIC(level)) { \
-            JLS_LOG_PRINTF(level, format, __VA_ARGS__); \
-        } \
-    } while (0)
-
-
-#ifdef _MSC_VER
-/* Microsoft Visual Studio compiler support */
-/** Log a emergency using printf-style arguments. */
-#define JLS_LOG_EMERGENCY(format, ...)  JLS_LOG(JLS_LOG_LEVEL_EMERGENCY, format, __VA_ARGS__)
-/** Log a alert using printf-style arguments. */
-#define JLS_LOG_ALERT(format, ...)  JLS_LOG(JLS_LOG_LEVEL_ALERT, format, __VA_ARGS__)
-/** Log a critical failure using printf-style arguments. */
-#define JLS_LOG_CRITICAL(format, ...)  JLS_LOG(JLS_LOG_LEVEL_CRITICAL, format, __VA_ARGS__)
-/** Log an error using printf-style arguments. */
-#define JLS_LOG_ERROR(format, ...)     JLS_LOG(JLS_LOG_LEVEL_ERROR, format, __VA_ARGS__)
-/** Log a warning using printf-style arguments. */
-#define JLS_LOG_WARNING(format, ...)      JLS_LOG(JLS_LOG_LEVEL_WARNING, format, __VA_ARGS__)
-/** Log a notice using printf-style arguments. */
-#define JLS_LOG_NOTICE(format, ...)    JLS_LOG(JLS_LOG_LEVEL_NOTICE,   format, __VA_ARGS__)
-/** Log an informative message using printf-style arguments. */
-#define JLS_LOG_INFO(format, ...)      JLS_LOG(JLS_LOG_LEVEL_INFO,     format, __VA_ARGS__)
-/** Log a detailed debug message using printf-style arguments. */
-#define JLS_LOG_DEBUG1(format, ...)    JLS_LOG(JLS_LOG_LEVEL_DEBUG1,    format, __VA_ARGS__)
-/** Log a very detailed debug message using printf-style arguments. */
-#define JLS_LOG_DEBUG2(format, ...)    JLS_LOG(JLS_LOG_LEVEL_DEBUG2,  format, __VA_ARGS__)
-/** Log an insanely detailed debug message using printf-style arguments. */
-#define JLS_LOG_DEBUG3(format, ...)    JLS_LOG(JLS_LOG_LEVEL_DEBUG3,  format, __VA_ARGS__)
-
-#else
-/* GCC compiler support */
-// zero length variadic arguments are not allowed for macros
-// this hack ensures that LOG(message) and LOG(format, args...) are both supported.
-// https://stackoverflow.com/questions/5588855/standard-alternative-to-gccs-va-args-trick
-#define _JLS_LOG_SELECT(PREFIX, _11, _10, _9, _8, _7, _6, _5, _4, _3, _2, _1, SUFFIX, ...) PREFIX ## _ ## SUFFIX
-#define _JLS_LOG_1(level, message) JLS_LOG(level, "%s", message)
-#define _JLS_LOG_N(level, format, ...) JLS_LOG(level, format, __VA_ARGS__)
-#define _JLS_LOG_DISPATCH(level, ...)  _JLS_LOG_SELECT(_JLS_LOG, __VA_ARGS__, N, N, N, N, N, N, N, N, N, N, 1, 0)(level, __VA_ARGS__)
-
-/** Log a emergency using printf-style arguments. */
-#define JLS_LOG_EMERGENCY(...)  _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_EMERGENCY, __VA_ARGS__)
-/** Log a alert using printf-style arguments. */
-#define JLS_LOG_ALERT(...)  _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_ALERT, __VA_ARGS__)
-/** Log a critical failure using printf-style arguments. */
-#define JLS_LOG_CRITICAL(...)  _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_CRITICAL, __VA_ARGS__)
-/** Log an error using printf-style arguments. */
-#define JLS_LOG_ERROR(...)     _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_ERROR, __VA_ARGS__)
-/** Log a warning using printf-style arguments. */
-#define JLS_LOG_WARNING(...)      _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_WARNING, __VA_ARGS__)
-/** Log a notice using printf-style arguments. */
-#define JLS_LOG_NOTICE(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_NOTICE,   __VA_ARGS__)
-/** Log an informative message using printf-style arguments. */
-#define JLS_LOG_INFO(...)      _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_INFO,     __VA_ARGS__)
-/** Log a detailed debug message using printf-style arguments. */
-#define JLS_LOG_DEBUG1(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_DEBUG1,    __VA_ARGS__)
-/** Log a very detailed debug message using printf-style arguments. */
-#define JLS_LOG_DEBUG2(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_DEBUG2,  __VA_ARGS__)
-/** Log an insanely detailed debug message using printf-style arguments. */
-#define JLS_LOG_DEBUG3(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_DEBUG3,  __VA_ARGS__)
-
-#endif
-
-
-/** Log an error using printf-style arguments.  Alias for JLS_LOG_ERROR. */
-#define JLS_LOG_ERR JLS_LOG_ERROR
-/** Log a warning using printf-style arguments.  Alias for JLS_LOG_WARNING. */
-#define JLS_LOG_WARN JLS_LOG_WARNING
-/** Log a detailed debug message using printf-style arguments.  Alias for JLS_LOG_DEBUG1. */
-#define JLS_LOG_DEBUG JLS_LOG_DEBUG1
-/** Log a detailed debug message using printf-style arguments.  Alias for JLS_LOG_DEBUG1. */
-#define JLS_LOG_DBG JLS_LOG_DEBUG1
-
-#define JLS_LOGE JLS_LOG_ERROR
-#define JLS_LOGW JLS_LOG_WARNING
-#define JLS_LOGN JLS_LOG_NOTICE
-#define JLS_LOGI JLS_LOG_INFO
-#define JLS_LOGD JLS_LOG_DEBUG1
-#define JLS_LOGD1 JLS_LOG_DEBUG1
-#define JLS_LOGD2 JLS_LOG_DEBUG2
-#define JLS_LOGD3 JLS_LOG_DEBUG3
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif /* JLS_LOG_H_ */
+/*
+ * Copyright 2014-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*!
+ * \file
+ *
+ * \brief Trivial logging support.
+ */
+
+#ifndef JLS_LOG_H_
+#define JLS_LOG_H_
+
+#include "jls/cmacro.h"
+#include <stdint.h>
+
+/**
+ * @ingroup jls
+ * @defgroup jls_log Console logging
+ *
+ * @brief Generic console logging with compile-time levels.
+ *
+ * To use this module, call jls_log_initialize() with the appropriate
+ * handler for your application.
+ *
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+/**
+ * @def JLS_LOG_GLOBAL_LEVEL
+ *
+ * @brief The global logging level.
+ *
+ * The maximum level to compile regardless of the individual module level.
+ * This value should be defined in the project CMake (makefile).
+ */
+#ifndef JLS_LOG_GLOBAL_LEVEL
+#define JLS_LOG_GLOBAL_LEVEL JLS_LOG_LEVEL_ALL
+#endif
+
+/**
+ * @def JLS_LOG_LEVEL
+ *
+ * @brief The module logging level.
+ *
+ * Typical usage 1:  (not MISRA C compliant, but safe)
+ *
+ *      #define JLS_LOG_LEVEL JLS_LOG_LEVEL_WARNING
+ *      #include "log.h"
+ */
+#ifndef JLS_LOG_LEVEL
+#define JLS_LOG_LEVEL JLS_LOG_LEVEL_WARNING
+#endif
+
+/**
+ * @def \_\_FILENAME\_\_
+ *
+ * @brief The filename to display for logging.
+ *
+ * When compiling C and C++ code, the __FILE__ define may contain a long path
+ * that just confuses the log output.  The build tools, such as make and cmake,
+ * can define __FILENAME__ to produce more meaningful results.
+ *
+ * A good Makefile usage includes:
+ *
+ */
+#ifndef __FILENAME__
+#define __FILENAME__ __FILE__
+#endif
+
+#if defined(__GNUC__) && !defined(_WIN32)
+/* https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html */
+#define JLS_LOG_PRINTF_FORMAT __attribute__((format (printf, 1, 2)))
+#else
+#define JLS_LOG_PRINTF_FORMAT
+#endif
+
+/**
+ * @brief The printf-style function call for each log message.
+ *
+ * @param format The print-style formatting string.
+ *     The remaining parameters are arguments for the formatting string.
+ * @return The number of characters printed.
+ *
+ * For PC-based applications, a common implementation is::
+ *
+ *     #include <stdarg.h>
+ *     #include <stdio.h>
+ *
+ *     void jls_log_printf(const char * format, ...) {
+ *         va_list arg;
+ *         va_start(arg, format);
+ *         vprintf(format, arg);
+ *         va_end(arg);
+ *     }
+ *
+ * If your application calls the LOG* macros from multiple threads, then
+ * the jls_log_printf implementation must be thread-safe and reentrant.
+ *
+ * This function is exposed to allow for unit testing.
+ */
+JLS_API void jls_log_printf(const char * format, ...) JLS_LOG_PRINTF_FORMAT;
+
+/**
+ * @brief The callback for log messages.
+ *
+ * @param msg The log message.
+ */
+typedef void (*jls_log_cbk)(const char * msg);
+
+/**
+ * @brief Register a logging handler
+ *
+ * @param handler The log handler.  Pass NULL or call jls_log_unregister() to
+ *      restore the default log handler.
+ *
+ * @return 0 or error code.
+ *
+ * The library initializes with a default null log handler so that logging
+ * which occurs before jls_log_register will not cause a fault.  This function
+ * may be safely called at any time, even without finalize.
+ */
+JLS_API void jls_log_register(jls_log_cbk handler);
+
+/**
+ * @brief Finalize the logging feature.
+ *
+ * This is equivalent to calling jls_log_initialize(0).
+ */
+JLS_API void jls_log_unregister(void);
+
+/**
+ * @def JLS_LOG_PRINTF
+ * @brief The printf function including log formatting.
+ *
+ * @param level The level for this log message
+ * @param format The formatting string
+ * @param ... The arguments for the formatting string
+ */
+#ifndef JLS_LOG_PRINTF
+#define JLS_LOG_PRINTF(level, format, ...) \
+    jls_log_printf("%c %s:%d: " format "\n", jls_log_level_char[level], __FILENAME__, __LINE__, __VA_ARGS__);
+#endif
+
+/**
+ * @brief The available logging levels.
+ */
+enum jls_log_level_e {
+    /** Logging functionality is disabled. */
+    JLS_LOG_LEVEL_OFF         = -1,
+    /** A "panic" condition that may result in significant harm. */
+    JLS_LOG_LEVEL_EMERGENCY   = 0,
+    /** A condition requiring immediate action. */
+    JLS_LOG_LEVEL_ALERT       = 1,
+    /** A critical error which prevents further functions. */
+    JLS_LOG_LEVEL_CRITICAL    = 2,
+    /** An error which prevents the current operation from completing or
+     *  will adversely effect future functionality. */
+    JLS_LOG_LEVEL_ERROR       = 3,
+    /** A warning which may adversely affect the current operation or future
+     *  operations. */
+    JLS_LOG_LEVEL_WARNING     = 4,
+    /** A notification for interesting events. */
+    JLS_LOG_LEVEL_NOTICE      = 5,
+    /** An informative message. */
+    JLS_LOG_LEVEL_INFO        = 6,
+    /** Detailed messages for the software developer. */
+    JLS_LOG_LEVEL_DEBUG1      = 7,
+    /** Very detailed messages for the software developer. */
+    JLS_LOG_LEVEL_DEBUG2      = 8,
+    /** Insanely detailed messages for the software developer. */
+    JLS_LOG_LEVEL_DEBUG3      = 9,
+    /** All logging functionality is enabled. */
+    JLS_LOG_LEVEL_ALL         = 10,
+};
+
+/** Detailed messages for the software developer. */
+#define JLS_LOG_LEVEL_DEBUG JLS_LOG_LEVEL_DEBUG1
+
+/**
+ * @brief Map log level to a string name.
+ */
+extern char const * const jls_log_level_str[JLS_LOG_LEVEL_ALL + 1];
+
+/**
+ * @brief Map log level to a single character.
+ */
+extern char const jls_log_level_char[JLS_LOG_LEVEL_ALL + 1];
+
+/**
+ * @brief Convert a log level to a user-meaningful string description.
+ *
+ * @param level The log level.
+ * @return The string description.
+ */
+JLS_API const char * jsdrv_log_level_to_str(int8_t level);
+
+/**
+ * @brief Convert a log level to a user-meaningful character.
+ *
+ * @param level The log level.
+ * @return The character representing the log level.
+ */
+JLS_API char jsdrv_log_level_to_char(int8_t level);
+
+/**
+ * @brief Check the current level against the static logging configuration.
+ *
+ * @param level The level to query.
+ * @return True if logging at level is permitted.
+ */
+#define JLS_LOG_CHECK_STATIC(level) ((level <= JLS_LOG_GLOBAL_LEVEL) && (level <= JLS_LOG_LEVEL) && (level >= 0))
+
+/**
+ * @brief Check a log level against a configured level.
+ *
+ * @param level The level to query.
+ * @param cfg_level The configured logging level.
+ * @return True if level is permitted given cfg_level.
+ */
+#define JLS_LOG_LEVEL_CHECK(level, cfg_level) (level <= cfg_level)
+
+/*!
+ * \brief Macro to log a printf-compatible formatted string.
+ *
+ * \param level The jls_log_level_e.
+ * \param format The printf-compatible formatting string.
+ * \param ... The arguments to the formatting string.
+ */
+#define JLS_LOG(level, format, ...) \
+    do { \
+        if (JLS_LOG_CHECK_STATIC(level)) { \
+            JLS_LOG_PRINTF(level, format, __VA_ARGS__); \
+        } \
+    } while (0)
+
+
+#ifdef _MSC_VER
+/* Microsoft Visual Studio compiler support */
+/** Log a emergency using printf-style arguments. */
+#define JLS_LOG_EMERGENCY(format, ...)  JLS_LOG(JLS_LOG_LEVEL_EMERGENCY, format, __VA_ARGS__)
+/** Log a alert using printf-style arguments. */
+#define JLS_LOG_ALERT(format, ...)  JLS_LOG(JLS_LOG_LEVEL_ALERT, format, __VA_ARGS__)
+/** Log a critical failure using printf-style arguments. */
+#define JLS_LOG_CRITICAL(format, ...)  JLS_LOG(JLS_LOG_LEVEL_CRITICAL, format, __VA_ARGS__)
+/** Log an error using printf-style arguments. */
+#define JLS_LOG_ERROR(format, ...)     JLS_LOG(JLS_LOG_LEVEL_ERROR, format, __VA_ARGS__)
+/** Log a warning using printf-style arguments. */
+#define JLS_LOG_WARNING(format, ...)      JLS_LOG(JLS_LOG_LEVEL_WARNING, format, __VA_ARGS__)
+/** Log a notice using printf-style arguments. */
+#define JLS_LOG_NOTICE(format, ...)    JLS_LOG(JLS_LOG_LEVEL_NOTICE,   format, __VA_ARGS__)
+/** Log an informative message using printf-style arguments. */
+#define JLS_LOG_INFO(format, ...)      JLS_LOG(JLS_LOG_LEVEL_INFO,     format, __VA_ARGS__)
+/** Log a detailed debug message using printf-style arguments. */
+#define JLS_LOG_DEBUG1(format, ...)    JLS_LOG(JLS_LOG_LEVEL_DEBUG1,    format, __VA_ARGS__)
+/** Log a very detailed debug message using printf-style arguments. */
+#define JLS_LOG_DEBUG2(format, ...)    JLS_LOG(JLS_LOG_LEVEL_DEBUG2,  format, __VA_ARGS__)
+/** Log an insanely detailed debug message using printf-style arguments. */
+#define JLS_LOG_DEBUG3(format, ...)    JLS_LOG(JLS_LOG_LEVEL_DEBUG3,  format, __VA_ARGS__)
+
+#else
+/* GCC compiler support */
+// zero length variadic arguments are not allowed for macros
+// this hack ensures that LOG(message) and LOG(format, args...) are both supported.
+// https://stackoverflow.com/questions/5588855/standard-alternative-to-gccs-va-args-trick
+#define _JLS_LOG_SELECT(PREFIX, _11, _10, _9, _8, _7, _6, _5, _4, _3, _2, _1, SUFFIX, ...) PREFIX ## _ ## SUFFIX
+#define _JLS_LOG_1(level, message) JLS_LOG(level, "%s", message)
+#define _JLS_LOG_N(level, format, ...) JLS_LOG(level, format, __VA_ARGS__)
+#define _JLS_LOG_DISPATCH(level, ...)  _JLS_LOG_SELECT(_JLS_LOG, __VA_ARGS__, N, N, N, N, N, N, N, N, N, N, 1, 0)(level, __VA_ARGS__)
+
+/** Log a emergency using printf-style arguments. */
+#define JLS_LOG_EMERGENCY(...)  _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_EMERGENCY, __VA_ARGS__)
+/** Log a alert using printf-style arguments. */
+#define JLS_LOG_ALERT(...)  _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_ALERT, __VA_ARGS__)
+/** Log a critical failure using printf-style arguments. */
+#define JLS_LOG_CRITICAL(...)  _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_CRITICAL, __VA_ARGS__)
+/** Log an error using printf-style arguments. */
+#define JLS_LOG_ERROR(...)     _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_ERROR, __VA_ARGS__)
+/** Log a warning using printf-style arguments. */
+#define JLS_LOG_WARNING(...)      _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_WARNING, __VA_ARGS__)
+/** Log a notice using printf-style arguments. */
+#define JLS_LOG_NOTICE(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_NOTICE,   __VA_ARGS__)
+/** Log an informative message using printf-style arguments. */
+#define JLS_LOG_INFO(...)      _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_INFO,     __VA_ARGS__)
+/** Log a detailed debug message using printf-style arguments. */
+#define JLS_LOG_DEBUG1(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_DEBUG1,    __VA_ARGS__)
+/** Log a very detailed debug message using printf-style arguments. */
+#define JLS_LOG_DEBUG2(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_DEBUG2,  __VA_ARGS__)
+/** Log an insanely detailed debug message using printf-style arguments. */
+#define JLS_LOG_DEBUG3(...)    _JLS_LOG_DISPATCH(JLS_LOG_LEVEL_DEBUG3,  __VA_ARGS__)
+
+#endif
+
+
+/** Log an error using printf-style arguments.  Alias for JLS_LOG_ERROR. */
+#define JLS_LOG_ERR JLS_LOG_ERROR
+/** Log a warning using printf-style arguments.  Alias for JLS_LOG_WARNING. */
+#define JLS_LOG_WARN JLS_LOG_WARNING
+/** Log a detailed debug message using printf-style arguments.  Alias for JLS_LOG_DEBUG1. */
+#define JLS_LOG_DEBUG JLS_LOG_DEBUG1
+/** Log a detailed debug message using printf-style arguments.  Alias for JLS_LOG_DEBUG1. */
+#define JLS_LOG_DBG JLS_LOG_DEBUG1
+
+#define JLS_LOGE JLS_LOG_ERROR
+#define JLS_LOGW JLS_LOG_WARNING
+#define JLS_LOGN JLS_LOG_NOTICE
+#define JLS_LOGI JLS_LOG_INFO
+#define JLS_LOGD JLS_LOG_DEBUG1
+#define JLS_LOGD1 JLS_LOG_DEBUG1
+#define JLS_LOGD2 JLS_LOG_DEBUG2
+#define JLS_LOGD3 JLS_LOG_DEBUG3
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif /* JLS_LOG_H_ */
```

### Comparing `pyjls-0.7.0/include/jls/reader.h` & `pyjls-0.7.1/include/jls/reader.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,277 +1,277 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS reader.
- */
-
-#ifndef JLS_READER_H__
-#define JLS_READER_H__
-
-#include <stdint.h>
-#include "jls/cmacro.h"
-#include "jls/format.h"
-
-/**
- * @ingroup jls
- * @defgroup jls_reader Reader
- *
- * @brief JLS reader.
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-/// The opaque JLS reader object.
-struct jls_rd_s;
-
-/**
- * @brief Open a JLS file to read contents.
- *
- * @param[out] instance The new JLS read instance.
- * @param path The JLS file path.
- * @return 0 or error code.
- *
- * Call jls_rd_close() when done.
- */
-JLS_API int32_t jls_rd_open(struct jls_rd_s ** instance, const char * path);
-
-/**
- * @brief Close a JLS file opened with jls_rd_open().
- * @param self The JLS read instance.
- */
-JLS_API void jls_rd_close(struct jls_rd_s * self);
-
-/**
- * @brief Get the array of sources in the file.
- *
- * @param self The reader instance.
- * @param[out] sources The array of sources.
- * @param[out] count The number of items in sources.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_sources(struct jls_rd_s * self, struct jls_source_def_s ** sources, uint16_t * count);
-
-/**
- * @brief Get the array of signals in the file.
- *
- * @param self The reader instance.
- * @param[out] signals The array of signals.
- * @param[out] count The number of items in signals.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_signals(struct jls_rd_s * self, struct jls_signal_def_s ** signals, uint16_t * count);
-
-/**
- * @brief Get the signal by signal_id.
- *
- * @param self The reader instance.
- * @param signal_id The signal id to get.
- * @param[out] signal The signal definition.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_signal(struct jls_rd_s * self, uint16_t signal_id, struct jls_signal_def_s * signal);
-
-/**
- * @brief Get the number of samples in an FSR signal.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.
- * @param[out] samples The number of samples in the signal.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_fsr_length(struct jls_rd_s * self, uint16_t signal_id, int64_t * samples);
-
-/**
- * @brief Read fixed sample rate (FSR) data.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.  The first
- *      recorded sample is always 0.  To get the first recorded sample_id,
- *      see jls_signal_def_s.sample_id_offset.
- * @param start_sample_id The starting sample id to read.
- * @param[out] data The samples read.
- * @param data_length The number of samples to read.
- *      data is at least this many samples.
- *      For data types less than 8 bits long, you need to provide an
- *      extra byte to allow for data shifting.  Therefore
- *      data is at least 1 + (data_length * entry_size_bits) / 8 bytes.
- * @return 0 or error code
- */
-JLS_API int32_t jls_rd_fsr(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
-                           void * data, int64_t data_length);
-
-/**
- * @brief Read fixed sample rate (FSR) float32 data.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.  The first
- *      recorded sample is always 0.  To get the first recorded sample_id,
- *      see jls_signal_def_s.sample_id_offset.
- * @param start_sample_id The starting sample id to read.
- * @param[out] data The samples read.
- * @param data_length The number of samples to read.  data is
- *      also at least this many entries (4 * data_length bytes).
- * @return 0 or error code
- */
-JLS_API int32_t jls_rd_fsr_f32(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
-                               float * data, int64_t data_length);
-
-/**
- * @brief Read the statistics data for a fixed sampling rate signal.
- *
- * @param self The reader instance.
- * @param signal_id The FSR signal.
- * @param start_sample_id The starting sample id to read.  The first
- *      recorded sample is always 0.  To get the first recorded sample_id,
- *      see jls_signal_def_s.sample_id_offset.
- * @param increment The number of samples that form a single output summary.
- * @param[out] data The statistics information, in the shape of
- *      data[data_length][JLS_SUMMARY_FSR_COUNT].  The elements are
- *      mean, standard_deviation, min, max.
- *      Use JLS_SUMMARY_FSR_MEAN, JLS_SUMMARY_FSR_STD,
- *      JLS_SUMMARY_FSR_MIN, and JLS_SUMMARY_FSR_MAX to index the values.
- * @param data_length The number of statistics points to populate.  data
- *      is at least JLS_SUMMARY_FSR_COUNT * data_length elements, each
- *      of float64 type (8 bytes).
- *      This argument allows efficient computation over many consecutive
- *      windows, as is common for displaying waveforms.
- * @return 0 or error code.
- *
- * For data_length 1, the statistics are sample-accurate.  For
- * larger data_lengths, the external boundaries for start and end
- * are computed exactly.  The internal boundaries are approximated,
- * perfect for waveform display, but perhaps not suitable for other use
- * cases.  If you need sample accurate statistics over multiple
- * increments, call this function repeatedly with data_length 1.
- */
-JLS_API int32_t jls_rd_fsr_statistics(struct jls_rd_s * self, uint16_t signal_id,
-                                      int64_t start_sample_id, int64_t increment,
-                                      double * data, int64_t data_length);
-
-/**
- * @brief The function called for each annotation.
- *
- * @param user_data The arbitrary user data.
- * @param annotation The annotation which only remains valid for the duration
- *      of the call.
- * @return 0 to continue iteration or any other value to stop.
- * @see jls_rd_annotations
- */
-typedef int32_t (*jls_rd_annotation_cbk_fn)(void * user_data, const struct jls_annotation_s * annotation);
-
-/**
- * @brief Iterate over the annotations for a signal.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.
- * @param timestamp The starting timestamp.  Skip all prior annotations.
- * @param cbk_fn The callback function that jls_rd_annotations() will
- *      call once for each matching annotation.  Return 0 to continue
- *      to the next annotation or a non-zero value to stop iteration.
- * @param cbk_user_data The arbitrary data provided to cbk_fn.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_annotations(struct jls_rd_s * self, uint16_t signal_id, int64_t timestamp,
-                                   jls_rd_annotation_cbk_fn cbk_fn, void * cbk_user_data);
-
-/**
- * @brief The function called for each user data entry.
- *
- * @param user_data The arbitrary user data.
- * @param chunk_meta The chunk meta value.
- * @param storage_type The data storage type.
- * @param data The data.
- * @param data_size The size of data in bytes.
- * @return 0 to continue iteration or any other value to stop.
- * @see jls_rd_user_data
- */
-typedef int32_t (*jls_rd_user_data_cbk_fn)(void * user_data,
-        uint16_t chunk_meta, enum jls_storage_type_e storage_type,
-        uint8_t * data, uint32_t data_size);
-
-/**
- * @brief Iterate over user data entries.
- *
- * @param self The reader instance.
- * @param cbk_fn The callback function that jls_rd_user_data() will
- *      call once for each user data entry.  Return 0 to continue
- *      to the next user data entry or a non-zero value to stop iteration.
- * @param cbk_user_data The arbitrary data provided to cbk_fn.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_user_data(struct jls_rd_s * self, jls_rd_user_data_cbk_fn cbk_fn, void * cbk_user_data);
-
-/**
- * @brief The function called for each UTC entry.
- *
- * @param user_data The arbitrary user data.
- * @param utc The array of utc entries, which are sample_id / timestamp pairs.
- * @param size The number of utc entries for this callback.
- * @return 0 to continue iteration or any other value to stop.
- * @see jls_rd_annotations
- */
-typedef int32_t (*jls_rd_utc_cbk_fn)(void * user_data,
-        const struct jls_utc_summary_entry_s * utc, uint32_t size);
-
-/**
- * @brief Iterate over the UTC timestamps for a FSR signal.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.
- * @param sample_id The starting sample_id.  Skip all prior sample ids.
- * @param cbk_fn The callback function that jls_rd_utc() will
- *      call once for UTC entries.  Return 0 to continue
- *      to the next UTC entries or a non-zero value to stop iteration.
- * @param cbk_user_data The arbitrary data provided to cbk_fn.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_utc(struct jls_rd_s * self, uint16_t signal_id, int64_t sample_id,
-                           jls_rd_utc_cbk_fn cbk_fn, void * cbk_user_data);
-
-/**
- * @brief Convert from sample_id to timestamp for FSR signals.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.
- * @param sample_id The sample id to convert.
- * @param timestamp[out] The JLS timestamp for the sample_id.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_sample_id_to_timestamp(struct jls_rd_s * self, uint16_t signal_id,
-        int64_t sample_id, int64_t * timestamp);
-
-/**
- * @brief Convert from timestamp to sample_id for FSR signals.
- *
- * @param self The reader instance.
- * @param signal_id The signal id.
- * @param timestamp The JLS timestamp to convert.
- * @param sample_id[out] The sample_id for timestamp.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_rd_timestamp_to_sample_id(struct jls_rd_s * self, uint16_t signal_id,
-        int64_t timestamp, int64_t * sample_id);
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif  /* JLS_READER_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS reader.
+ */
+
+#ifndef JLS_READER_H__
+#define JLS_READER_H__
+
+#include <stdint.h>
+#include "jls/cmacro.h"
+#include "jls/format.h"
+
+/**
+ * @ingroup jls
+ * @defgroup jls_reader Reader
+ *
+ * @brief JLS reader.
+ *
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+/// The opaque JLS reader object.
+struct jls_rd_s;
+
+/**
+ * @brief Open a JLS file to read contents.
+ *
+ * @param[out] instance The new JLS read instance.
+ * @param path The JLS file path.
+ * @return 0 or error code.
+ *
+ * Call jls_rd_close() when done.
+ */
+JLS_API int32_t jls_rd_open(struct jls_rd_s ** instance, const char * path);
+
+/**
+ * @brief Close a JLS file opened with jls_rd_open().
+ * @param self The JLS read instance.
+ */
+JLS_API void jls_rd_close(struct jls_rd_s * self);
+
+/**
+ * @brief Get the array of sources in the file.
+ *
+ * @param self The reader instance.
+ * @param[out] sources The array of sources.
+ * @param[out] count The number of items in sources.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_sources(struct jls_rd_s * self, struct jls_source_def_s ** sources, uint16_t * count);
+
+/**
+ * @brief Get the array of signals in the file.
+ *
+ * @param self The reader instance.
+ * @param[out] signals The array of signals.
+ * @param[out] count The number of items in signals.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_signals(struct jls_rd_s * self, struct jls_signal_def_s ** signals, uint16_t * count);
+
+/**
+ * @brief Get the signal by signal_id.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id to get.
+ * @param[out] signal The signal definition.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_signal(struct jls_rd_s * self, uint16_t signal_id, struct jls_signal_def_s * signal);
+
+/**
+ * @brief Get the number of samples in an FSR signal.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.
+ * @param[out] samples The number of samples in the signal.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_fsr_length(struct jls_rd_s * self, uint16_t signal_id, int64_t * samples);
+
+/**
+ * @brief Read fixed sample rate (FSR) data.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.  The first
+ *      recorded sample is always 0.  To get the first recorded sample_id,
+ *      see jls_signal_def_s.sample_id_offset.
+ * @param start_sample_id The starting sample id to read.
+ * @param[out] data The samples read.
+ * @param data_length The number of samples to read.
+ *      data is at least this many samples.
+ *      For data types less than 8 bits long, you need to provide an
+ *      extra byte to allow for data shifting.  Therefore
+ *      data is at least 1 + (data_length * entry_size_bits) / 8 bytes.
+ * @return 0 or error code
+ */
+JLS_API int32_t jls_rd_fsr(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
+                           void * data, int64_t data_length);
+
+/**
+ * @brief Read fixed sample rate (FSR) float32 data.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.  The first
+ *      recorded sample is always 0.  To get the first recorded sample_id,
+ *      see jls_signal_def_s.sample_id_offset.
+ * @param start_sample_id The starting sample id to read.
+ * @param[out] data The samples read.
+ * @param data_length The number of samples to read.  data is
+ *      also at least this many entries (4 * data_length bytes).
+ * @return 0 or error code
+ */
+JLS_API int32_t jls_rd_fsr_f32(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
+                               float * data, int64_t data_length);
+
+/**
+ * @brief Read the statistics data for a fixed sampling rate signal.
+ *
+ * @param self The reader instance.
+ * @param signal_id The FSR signal.
+ * @param start_sample_id The starting sample id to read.  The first
+ *      recorded sample is always 0.  To get the first recorded sample_id,
+ *      see jls_signal_def_s.sample_id_offset.
+ * @param increment The number of samples that form a single output summary.
+ * @param[out] data The statistics information, in the shape of
+ *      data[data_length][JLS_SUMMARY_FSR_COUNT].  The elements are
+ *      mean, standard_deviation, min, max.
+ *      Use JLS_SUMMARY_FSR_MEAN, JLS_SUMMARY_FSR_STD,
+ *      JLS_SUMMARY_FSR_MIN, and JLS_SUMMARY_FSR_MAX to index the values.
+ * @param data_length The number of statistics points to populate.  data
+ *      is at least JLS_SUMMARY_FSR_COUNT * data_length elements, each
+ *      of float64 type (8 bytes).
+ *      This argument allows efficient computation over many consecutive
+ *      windows, as is common for displaying waveforms.
+ * @return 0 or error code.
+ *
+ * For data_length 1, the statistics are sample-accurate.  For
+ * larger data_lengths, the external boundaries for start and end
+ * are computed exactly.  The internal boundaries are approximated,
+ * perfect for waveform display, but perhaps not suitable for other use
+ * cases.  If you need sample accurate statistics over multiple
+ * increments, call this function repeatedly with data_length 1.
+ */
+JLS_API int32_t jls_rd_fsr_statistics(struct jls_rd_s * self, uint16_t signal_id,
+                                      int64_t start_sample_id, int64_t increment,
+                                      double * data, int64_t data_length);
+
+/**
+ * @brief The function called for each annotation.
+ *
+ * @param user_data The arbitrary user data.
+ * @param annotation The annotation which only remains valid for the duration
+ *      of the call.
+ * @return 0 to continue iteration or any other value to stop.
+ * @see jls_rd_annotations
+ */
+typedef int32_t (*jls_rd_annotation_cbk_fn)(void * user_data, const struct jls_annotation_s * annotation);
+
+/**
+ * @brief Iterate over the annotations for a signal.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.
+ * @param timestamp The starting timestamp.  Skip all prior annotations.
+ * @param cbk_fn The callback function that jls_rd_annotations() will
+ *      call once for each matching annotation.  Return 0 to continue
+ *      to the next annotation or a non-zero value to stop iteration.
+ * @param cbk_user_data The arbitrary data provided to cbk_fn.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_annotations(struct jls_rd_s * self, uint16_t signal_id, int64_t timestamp,
+                                   jls_rd_annotation_cbk_fn cbk_fn, void * cbk_user_data);
+
+/**
+ * @brief The function called for each user data entry.
+ *
+ * @param user_data The arbitrary user data.
+ * @param chunk_meta The chunk meta value.
+ * @param storage_type The data storage type.
+ * @param data The data.
+ * @param data_size The size of data in bytes.
+ * @return 0 to continue iteration or any other value to stop.
+ * @see jls_rd_user_data
+ */
+typedef int32_t (*jls_rd_user_data_cbk_fn)(void * user_data,
+        uint16_t chunk_meta, enum jls_storage_type_e storage_type,
+        uint8_t * data, uint32_t data_size);
+
+/**
+ * @brief Iterate over user data entries.
+ *
+ * @param self The reader instance.
+ * @param cbk_fn The callback function that jls_rd_user_data() will
+ *      call once for each user data entry.  Return 0 to continue
+ *      to the next user data entry or a non-zero value to stop iteration.
+ * @param cbk_user_data The arbitrary data provided to cbk_fn.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_user_data(struct jls_rd_s * self, jls_rd_user_data_cbk_fn cbk_fn, void * cbk_user_data);
+
+/**
+ * @brief The function called for each UTC entry.
+ *
+ * @param user_data The arbitrary user data.
+ * @param utc The array of utc entries, which are sample_id / timestamp pairs.
+ * @param size The number of utc entries for this callback.
+ * @return 0 to continue iteration or any other value to stop.
+ * @see jls_rd_annotations
+ */
+typedef int32_t (*jls_rd_utc_cbk_fn)(void * user_data,
+        const struct jls_utc_summary_entry_s * utc, uint32_t size);
+
+/**
+ * @brief Iterate over the UTC timestamps for a FSR signal.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.
+ * @param sample_id The starting sample_id.  Skip all prior sample ids.
+ * @param cbk_fn The callback function that jls_rd_utc() will
+ *      call once for UTC entries.  Return 0 to continue
+ *      to the next UTC entries or a non-zero value to stop iteration.
+ * @param cbk_user_data The arbitrary data provided to cbk_fn.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_utc(struct jls_rd_s * self, uint16_t signal_id, int64_t sample_id,
+                           jls_rd_utc_cbk_fn cbk_fn, void * cbk_user_data);
+
+/**
+ * @brief Convert from sample_id to timestamp for FSR signals.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.
+ * @param sample_id The sample id to convert.
+ * @param[out] timestamp The JLS timestamp for the sample_id.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_sample_id_to_timestamp(struct jls_rd_s * self, uint16_t signal_id,
+        int64_t sample_id, int64_t * timestamp);
+
+/**
+ * @brief Convert from timestamp to sample_id for FSR signals.
+ *
+ * @param self The reader instance.
+ * @param signal_id The signal id.
+ * @param timestamp The JLS timestamp to convert.
+ * @param[out] sample_id The sample_id for timestamp.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_rd_timestamp_to_sample_id(struct jls_rd_s * self, uint16_t signal_id,
+        int64_t timestamp, int64_t * sample_id);
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif  /* JLS_READER_H__ */
```

### Comparing `pyjls-0.7.0/include/jls/statistics.h` & `pyjls-0.7.1/include/jls/statistics.h`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,134 +1,134 @@
-/*
- * Copyright 2020-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef JLS_STATISTICS_H
-#define JLS_STATISTICS_H
-
-#include "jls/cmacro.h"
-#include <stdint.h>
-
-/**
- * @ingroup jls
- * @defgroup jls_statistics Statistics
- *
- * @brief JLS statistics.
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-/**
- * @brief The statistics instance for a single variable.
- *
- * This structure and associated "methods" compute mean, sample variance, 
- * minimum and maximum over samples.  The statistics are computed in a single 
- * pass and are available at any time with minimal additional computation.
- *
- * @see https://en.wikipedia.org/wiki/Variance
- * @see https://en.wikipedia.org/wiki/Unbiased_estimation_of_standard_deviation
- * @see https://www.johndcook.com/blog/standard_deviation/
- * @see https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
- */
-struct jls_statistics_s {
-    uint64_t k;    ///< Number of samples.
-    double mean;   ///< mean (average value).
-    double s;      ///< Scaled running variance.
-    double min;    ///< Minimum value.
-    double max;    ///< Maximum value.
-};
-
-/**
- * @brief Reset the statistics to 0 samples.
- *
- * @param s The statistics instance.
- */
-JLS_API void jls_statistics_reset(struct jls_statistics_s * s);
-
-/**
- * @brief Mark the statistics as invalid.
- *
- * @param s The statistics instance which will have all statistics marked
- *      as NaN.
- */
-JLS_API void jls_statistics_invalid(struct jls_statistics_s * s);
-
-/**
- * @brief Compute the statistics over an array.
- *
- * @param s The statistics instance.
- * @param x The value array.
- * @param length The number of elements in x.
- *
- * Use the "traditional" two pass method.  Compute mean in first pass,
- * then variance in second pass.
- */
-JLS_API void jls_statistics_compute_f32(struct jls_statistics_s * s, const float * x, uint64_t length);
-
-/**
- * @brief Compute the statistics over an array.
- *
- * @param s The statistics instance.
- * @param x The value array.
- * @param length The number of elements in x.
- */
-JLS_API void jls_statistics_compute_f64(struct jls_statistics_s * s, const double * x, uint64_t length);
-
-/**
- * @brief Add a new sample into the statistics.
- *
- * @param s The statistics instance.
- * @param x The new value.
- */
-JLS_API void jls_statistics_add(struct jls_statistics_s * s, double x);
-
-/**
- * @brief Get the sample variance.
- *
- * @param s The statistics instance.
- * @return The sample variance
- *
- * Sample variance uses k-1 denominator, also called the Bessel correction,
- * which is what you want for estimating variance from samples.
- * "Standard" population variance uses k as the denominator which tends to
- * underestimate true variance.
- */
-JLS_API double jls_statistics_var(struct jls_statistics_s * s);
-
-/**
- * @brief Copy one statistics instance to another.
- *
- * @param tgt The target statistics instance.
- * @param src The source statistics instance.
- */
-JLS_API void jls_statistics_copy(struct jls_statistics_s * tgt, struct jls_statistics_s const * src);
-
-/**
- * @brief Compute the combined statistics over two statistics instances.
- *
- * @param tgt The target statistics instance.  It is safe to use a or b for tgt.
- * @param a The first statistics instance to combine.
- * @param b The first statistics instance to combine.
- */
-JLS_API void jls_statistics_combine(struct jls_statistics_s * tgt,
-                                    struct jls_statistics_s const * a,
-                                    struct jls_statistics_s const * b);
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif  // JLS_STATISTICS_H
+/*
+ * Copyright 2020-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JLS_STATISTICS_H
+#define JLS_STATISTICS_H
+
+#include "jls/cmacro.h"
+#include <stdint.h>
+
+/**
+ * @ingroup jls
+ * @defgroup jls_statistics Statistics
+ *
+ * @brief JLS statistics.
+ *
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+/**
+ * @brief The statistics instance for a single variable.
+ *
+ * This structure and associated "methods" compute mean, sample variance, 
+ * minimum and maximum over samples.  The statistics are computed in a single 
+ * pass and are available at any time with minimal additional computation.
+ *
+ * @see https://en.wikipedia.org/wiki/Variance
+ * @see https://en.wikipedia.org/wiki/Unbiased_estimation_of_standard_deviation
+ * @see https://www.johndcook.com/blog/standard_deviation/
+ * @see https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
+ */
+struct jls_statistics_s {
+    uint64_t k;    ///< Number of samples.
+    double mean;   ///< mean (average value).
+    double s;      ///< Scaled running variance.
+    double min;    ///< Minimum value.
+    double max;    ///< Maximum value.
+};
+
+/**
+ * @brief Reset the statistics to 0 samples.
+ *
+ * @param s The statistics instance.
+ */
+JLS_API void jls_statistics_reset(struct jls_statistics_s * s);
+
+/**
+ * @brief Mark the statistics as invalid.
+ *
+ * @param s The statistics instance which will have all statistics marked
+ *      as NaN.
+ */
+JLS_API void jls_statistics_invalid(struct jls_statistics_s * s);
+
+/**
+ * @brief Compute the statistics over an array.
+ *
+ * @param s The statistics instance.
+ * @param x The value array.
+ * @param length The number of elements in x.
+ *
+ * Use the "traditional" two pass method.  Compute mean in first pass,
+ * then variance in second pass.
+ */
+JLS_API void jls_statistics_compute_f32(struct jls_statistics_s * s, const float * x, uint64_t length);
+
+/**
+ * @brief Compute the statistics over an array.
+ *
+ * @param s The statistics instance.
+ * @param x The value array.
+ * @param length The number of elements in x.
+ */
+JLS_API void jls_statistics_compute_f64(struct jls_statistics_s * s, const double * x, uint64_t length);
+
+/**
+ * @brief Add a new sample into the statistics.
+ *
+ * @param s The statistics instance.
+ * @param x The new value.
+ */
+JLS_API void jls_statistics_add(struct jls_statistics_s * s, double x);
+
+/**
+ * @brief Get the sample variance.
+ *
+ * @param s The statistics instance.
+ * @return The sample variance
+ *
+ * Sample variance uses k-1 denominator, also called the Bessel correction,
+ * which is what you want for estimating variance from samples.
+ * "Standard" population variance uses k as the denominator which tends to
+ * underestimate true variance.
+ */
+JLS_API double jls_statistics_var(struct jls_statistics_s * s);
+
+/**
+ * @brief Copy one statistics instance to another.
+ *
+ * @param tgt The target statistics instance.
+ * @param src The source statistics instance.
+ */
+JLS_API void jls_statistics_copy(struct jls_statistics_s * tgt, struct jls_statistics_s const * src);
+
+/**
+ * @brief Compute the combined statistics over two statistics instances.
+ *
+ * @param tgt The target statistics instance.  It is safe to use a or b for tgt.
+ * @param a The first statistics instance to combine.
+ * @param b The first statistics instance to combine.
+ */
+JLS_API void jls_statistics_combine(struct jls_statistics_s * tgt,
+                                    struct jls_statistics_s const * a,
+                                    struct jls_statistics_s const * b);
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif  // JLS_STATISTICS_H
```

### Comparing `pyjls-0.7.0/include/jls/time.h` & `pyjls-0.7.1/include/jls/time.h`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,399 +1,399 @@
-/*
- * Copyright 2014-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file
- *
- * @brief JLS time representation.
- */
-
-#ifndef JLS_TIME_H__
-#define JLS_TIME_H__
-
-#include "jls/cmacro.h"
-#include <stdint.h>
-
-/**
- * @ingroup jls
- * @defgroup jls_time Time representation
- *
- * @brief JLS time representation.
- *
- * The C standard library includes time.h which is very inconvenient for any
- * precision application.  This module defines a much simpler 64-bit fixed point
- * integer for representing time.  The value is 34Q30 with the upper 34 bits
- * to represent whole seconds and the lower 30 bits to represent fractional
- * seconds.  A value of 2**30 (1 << 30) represents 1 second.  This
- * representation gives a resolution of 2 ** -30 (approximately 1 nanosecond)
- * and a range of +/- 2 ** 33 (approximately 272 years).  The value is
- * signed to allow for simple arithmetic on the time either as a fixed value
- * or as deltas.
- *
- * Certain elements may elect to use floating point time given in seconds.
- * The macros JLS_TIME_TO_F64() and JLS_F64_TO_TIME() facilitate
- * converting between the domains.  Note that double precision floating
- * point is not able to maintain the same resolution over the time range
- * as the 64-bit representation.  JLS_TIME_TO_F32() and JLS_F32_TO_TIME()
- * allow conversion to single precision floating point which has significantly
- * reduce resolution compared to the 34Q30 value.
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-/**
- * @brief The number of fractional bits in the 64-bit time representation.
- */
-#define JLS_TIME_Q 30
-
-/**
- * @brief The maximum (positive) time representation
- */
-#define JLS_TIME_MAX ((int64_t) 0x7fffffffffffffffU)
-
-/**
- * @brief The minimum (negative) time representation.
- */
-#define JLS_TIME_MIN ((int64_t) 0x8000000000000000U)
-
-/**
- * @brief The offset from the standard UNIX (POSIX) epoch.
- *
- * This offset allows translation between jls time and the 
- * standard UNIX (POSIX) epoch of Jan 1, 1970.
- *
- * The value was computed using python3:
- *
- *     import dateutil.parser
- *     dateutil.parser.parse('2018-01-01T00:00:00Z').timestamp()
- *
- * JLS chooses a different epoch to advance "zero" by 48 years!
- */
-#define JLS_TIME_EPOCH_UNIX_OFFSET_SECONDS 1514764800
-
-/**
- * @brief The fixed-point representation for 1 second.
- */
-#define JLS_TIME_SECOND (((int64_t) 1) << JLS_TIME_Q)
-
-/// The mask for the fractional bits
-#define JLS_FRACT_MASK (JLS_TIME_SECOND - 1)
-
-/**
- * @brief The approximate fixed-point representation for 1 millisecond.
- */
-#define JLS_TIME_MILLISECOND ((JLS_TIME_SECOND + 500) / 1000)
-
-/**
- * @brief The approximate fixed-point representation for 1 microsecond.
- *
- * CAUTION: this value is 0.024% accurate (240 ppm)
- */
-#define JLS_TIME_MICROSECOND ((JLS_TIME_SECOND + 500000) / 1000000)
-
-/**
- * @brief The approximate fixed-point representation for 1 nanosecond.
- *
- * WARNING: this value is only 6.7% accurate!
- */
-#define JLS_TIME_NANOSECOND ((int64_t) 1)
-
-/**
- * @brief The fixed-point representation for 1 minute.
- */
-#define JLS_TIME_MINUTE (JLS_TIME_SECOND * 60)
-
-/**
- * @brief The fixed-point representation for 1 hour.
- */
-#define JLS_TIME_HOUR (JLS_TIME_MINUTE * 60)
-
-/**
- * @brief The fixed-point representation for 1 day.
- */
-#define JLS_TIME_DAY (JLS_TIME_HOUR * 24)
-
-/**
- * @brief The fixed-point representation for 1 week.
- */
-#define JLS_TIME_WEEK (JLS_TIME_DAY * 7)
-
-/**
- * @brief The average fixed-point representation for 1 month (365 day year).
- */
-#define JLS_TIME_MONTH (JLS_TIME_YEAR / 12)
-
-/**
- * @brief The approximate fixed-point representation for 1 year (365 days).
- */
-#define JLS_TIME_YEAR (JLS_TIME_DAY * 365)
-
-/**
- * @brief Convert the 64-bit fixed point time to a double.
- *
- * @param x The 64-bit signed fixed point time.
- * @return The time as a double p.  Note that IEEE 747 doubles only have
- *      52 bits of precision, so the result will be truncated for very
- *      small deltas.
- */
-#define JLS_TIME_TO_F64(x) (((double) (x)) / ((double) JLS_TIME_SECOND))
-
-/**
- * @brief Convert the double precision time to 64-bit fixed point time.
- *
- * @param x The double-precision floating point time in seconds.
- * @return The time as a 34Q30.
- */
-static inline int64_t JLS_F64_TO_TIME(double x) {
-    if (x < 0) {
-        return -JLS_F64_TO_TIME(-x);
-    }
-    return (int64_t) ((x * (double) JLS_TIME_SECOND) + 0.5);
-}
-
-/**
- * @brief Convert the 64-bit fixed point time to single precision float.
- *
- * @param x The 64-bit signed fixed point time.
- * @return The time as a float p in seconds.  Note that IEEE 747 singles only
- *      have 23 bits of precision, so the result will likely be truncated.
- */
-#define JLS_TIME_TO_F32(x) (((float) (x)) / ((float) JLS_TIME_SECOND))
-
-/**
- * @brief Convert the single precision float time to 64-bit fixed point time.
- *
- * @param x The single-precision floating point time in seconds.
- * @return The time as a 34Q30.
- */
-static inline int64_t JLS_F32_TO_TIME(float x) {
-    if (x < 0.0f) {
-        return -JLS_F32_TO_TIME(-x);
-    }
-    return (int64_t) ((x * (float) JLS_TIME_SECOND) + 0.5f);
-}
-
-/**
- * @brief Convert to counter ticks, rounded to nearest.
- *
- * @param x The 64-bit signed fixed point time.
- * @param z The counter frequency in Hz.
- * @return The 64-bit time in counter ticks.
- */
-static inline int64_t JLS_TIME_TO_COUNTER(int64_t x, uint64_t z) {
-    if (x < 0) {
-        return -JLS_TIME_TO_COUNTER(-x, z);
-    }
-    // return (int64_t) ((((x * z) >> (JLS_TIME_Q - 1)) + 1) >> 1);
-    uint64_t c = (((x & ~JLS_FRACT_MASK) >> (JLS_TIME_Q - 1)) * z);
-    uint64_t fract = (x & JLS_FRACT_MASK) << 1;
-    c += ((fract * z) >> JLS_TIME_Q) + 1;
-    return (int64_t) (c >> 1);
-}
-
-/**
- * @brief Convert to counter ticks, rounded towards zero
- *
- * @param x The 64-bit signed fixed point time.
- * @param z The counter frequency in Hz.
- * @return The 64-bit time in counter ticks.
- */
-static inline int64_t JLS_TIME_TO_COUNTER_RZERO(int64_t x, uint64_t z) {
-    if (x < 0) {
-        return -JLS_TIME_TO_COUNTER_RZERO(-x, z);
-    }
-    uint64_t c = (x >> JLS_TIME_Q) * z;
-    c += ((x & JLS_FRACT_MASK) * z) >> JLS_TIME_Q;
-    return (int64_t) c;
-}
-
-/**
- * @brief Convert to counter ticks, rounded towards infinity.
- *
- * @param x The 64-bit signed fixed point time.
- * @param z The counter frequency in Hz.
- * @return The 64-bit time in counter ticks.
- */
-static inline int64_t JLS_TIME_TO_COUNTER_RINF(int64_t x, uint64_t z) {
-    if (x < 0) {
-        return -JLS_TIME_TO_COUNTER_RINF(-x, z);
-    }
-    x += JLS_TIME_SECOND - 1;
-    uint64_t c = (x >> JLS_TIME_Q) * z;
-    c += ((x & JLS_FRACT_MASK) * z) >> JLS_TIME_Q;
-    return (int64_t) c;
-}
-
-/**
- * @brief Convert to 32-bit unsigned seconds.
- *
- * @param x The 64-bit signed fixed point time.
- * @return The 64-bit unsigned time in seconds, rounded to nearest.
- */
-#define JLS_TIME_TO_SECONDS(x) JLS_TIME_TO_COUNTER(x, 1)
-
-/**
- * @brief Convert to milliseconds.
- *
- * @param x The 64-bit signed fixed point time.
- * @return The 64-bit signed time in milliseconds, rounded to nearest.
- */
-#define JLS_TIME_TO_MILLISECONDS(x) JLS_TIME_TO_COUNTER(x, 1000)
-
-/**
- * @brief Convert to microseconds.
- *
- * @param x The 64-bit signed fixed point time.
- * @return The 64-bit signed time in microseconds, rounded to nearest.
- */
-#define JLS_TIME_TO_MICROSECONDS(x) JLS_TIME_TO_COUNTER(x, 1000000)
-
-/**
- * @brief Convert to nanoseconds.
- *
- * @param x The 64-bit signed fixed point time.
- * @return The 64-bit signed time in nanoseconds, rounded to nearest.
- */
-#define JLS_TIME_TO_NANOSECONDS(x) JLS_TIME_TO_COUNTER(x, 1000000000ll)
-
-/**
- * @brief Convert a counter to 64-bit signed fixed point time.
- *
- * @param x The counter value in ticks.
- * @param z The counter frequency in Hz.
- * @return The 64-bit signed fixed point time.
- */
-static inline int64_t JLS_COUNTER_TO_TIME(uint64_t x, uint64_t z) {
-    // compute (x << JLS_TIME_Q) / z, but without unnecessary saturation
-    uint64_t seconds = x / z;
-    uint64_t remainder = x - (seconds * z);
-    uint64_t fract = (remainder << JLS_TIME_Q) / z;
-    uint64_t t = (int64_t) ((seconds << JLS_TIME_Q) + fract);
-    return t;
-}
-
-/**
- * @brief Convert to 64-bit signed fixed point time.
- *
- * @param x he 32-bit unsigned time in seconds.
- * @return The 64-bit signed fixed point time.
- */
-#define JLS_SECONDS_TO_TIME(x) (((int64_t) (x)) << JLS_TIME_Q)
-
-/**
- * @brief Convert to 64-bit signed fixed point time.
- *
- * @param x The 32-bit unsigned time in milliseconds.
- * @return The 64-bit signed fixed point time.
- */
-#define JLS_MILLISECONDS_TO_TIME(x) JLS_COUNTER_TO_TIME(x, 1000)
-
-/**
- * @brief Convert to 64-bit signed fixed point time.
- *
- * @param x The 32-bit unsigned time in microseconds.
- * @return The 64-bit signed fixed point time.
- */
-#define JLS_MICROSECONDS_TO_TIME(x) JLS_COUNTER_TO_TIME(x, 1000000)
-
-/**
- * @brief Convert to 64-bit signed fixed point time.
- *
- * @param x The 32-bit unsigned time in microseconds.
- * @return The 64-bit signed fixed point time.
- */
-#define JLS_NANOSECONDS_TO_TIME(x) JLS_COUNTER_TO_TIME(x, 1000000000ll)
-
-/**
- * @brief Compute the absolute value of a time.
- *
- * @param t The time.
- * @return The absolute value of t.
- */
-static inline int64_t JLS_TIME_ABS(int64_t t) {
-    return ( (t) < 0 ? -(t) : (t) );
-}
-
-/**
- * @brief Get the UTC time as a 34Q30 fixed point number.
- *
- * @return The current time.  This value is not guaranteed to be monotonic.
- *      The device may synchronize to external clocks which can cause
- *      discontinuous jumps, both backwards and forwards.
- *
- *      At power-on, the time will start from 0 unless the system has
- *      a real-time clock.  When the current time first synchronizes to
- *      an external host, it may have a large skip.
- *
- * Be sure to verify your time for each platform using python:
- *
- *      python
- *      import datetime
- *      import dateutil.parser
- *      epoch = dateutil.parser.parse('2018-01-01T00:00:00Z').timestamp()
- *      datetime.datetime.fromtimestamp((my_time >> 30) + epoch)
- */
-JLS_API int64_t jls_now(void);
-
-/**
- * @brief The platform counter structure.
- */
-struct jls_time_counter_s {
-    /// The counter value.
-    uint64_t value;
-    /// The approximate counter frequency.
-    uint64_t frequency;
-};
-
-/**
- * @brief Get the monotonic platform counter.
- *
- * @return The monotonic platform counter.
- *
- * The platform implementation may select an appropriate source and
- * frequency.  The JLS library assumes a nominal frequency of
- * at least 1000 Hz, but we frequencies in the 1 MHz to 100 MHz
- * range to enable profiling.  The frequency should not exceed 10 GHz
- * to prevent rollover.
- *
- * The counter must be monotonic.  If the underlying hardware is less
- * than the full 64 bits, then the platform must unwrap and extend
- * the hardware value to 64-bit.
- *
- * The JLS authors recommend this counter starts at 0 when the
- * system powers up.
- */
-JLS_API struct jls_time_counter_s jls_time_counter(void);
-
-/**
- * @brief Get the monotonic platform time as a 34Q30 fixed point number.
- *
- * @return The monotonic platform time based upon the jls_time_counter().
- *      The platform time has no guaranteed relationship with
- *      UTC or wall-clock calendar time.  This time has both
- *      offset and scale errors relative to UTC.
- */
-static inline int64_t jls_time_rel(void) {
-    struct jls_time_counter_s counter = jls_time_counter();
-    return JLS_COUNTER_TO_TIME(counter.value, counter.frequency);
-}
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif /* JLS_TIME_H__ */
+/*
+ * Copyright 2014-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @file
+ *
+ * @brief JLS time representation.
+ */
+
+#ifndef JLS_TIME_H__
+#define JLS_TIME_H__
+
+#include "jls/cmacro.h"
+#include <stdint.h>
+
+/**
+ * @ingroup jls
+ * @defgroup jls_time Time representation
+ *
+ * @brief JLS time representation.
+ *
+ * The C standard library includes time.h which is very inconvenient for any
+ * precision application.  This module defines a much simpler 64-bit fixed point
+ * integer for representing time.  The value is 34Q30 with the upper 34 bits
+ * to represent whole seconds and the lower 30 bits to represent fractional
+ * seconds.  A value of 2**30 (1 << 30) represents 1 second.  This
+ * representation gives a resolution of 2 ** -30 (approximately 1 nanosecond)
+ * and a range of +/- 2 ** 33 (approximately 272 years).  The value is
+ * signed to allow for simple arithmetic on the time either as a fixed value
+ * or as deltas.
+ *
+ * Certain elements may elect to use floating point time given in seconds.
+ * The macros JLS_TIME_TO_F64() and JLS_F64_TO_TIME() facilitate
+ * converting between the domains.  Note that double precision floating
+ * point is not able to maintain the same resolution over the time range
+ * as the 64-bit representation.  JLS_TIME_TO_F32() and JLS_F32_TO_TIME()
+ * allow conversion to single precision floating point which has significantly
+ * reduce resolution compared to the 34Q30 value.
+ *
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+/**
+ * @brief The number of fractional bits in the 64-bit time representation.
+ */
+#define JLS_TIME_Q 30
+
+/**
+ * @brief The maximum (positive) time representation
+ */
+#define JLS_TIME_MAX ((int64_t) 0x7fffffffffffffffU)
+
+/**
+ * @brief The minimum (negative) time representation.
+ */
+#define JLS_TIME_MIN ((int64_t) 0x8000000000000000U)
+
+/**
+ * @brief The offset from the standard UNIX (POSIX) epoch.
+ *
+ * This offset allows translation between jls time and the 
+ * standard UNIX (POSIX) epoch of Jan 1, 1970.
+ *
+ * The value was computed using python3:
+ *
+ *     import dateutil.parser
+ *     dateutil.parser.parse('2018-01-01T00:00:00Z').timestamp()
+ *
+ * JLS chooses a different epoch to advance "zero" by 48 years!
+ */
+#define JLS_TIME_EPOCH_UNIX_OFFSET_SECONDS 1514764800
+
+/**
+ * @brief The fixed-point representation for 1 second.
+ */
+#define JLS_TIME_SECOND (((int64_t) 1) << JLS_TIME_Q)
+
+/// The mask for the fractional bits
+#define JLS_FRACT_MASK (JLS_TIME_SECOND - 1)
+
+/**
+ * @brief The approximate fixed-point representation for 1 millisecond.
+ */
+#define JLS_TIME_MILLISECOND ((JLS_TIME_SECOND + 500) / 1000)
+
+/**
+ * @brief The approximate fixed-point representation for 1 microsecond.
+ *
+ * CAUTION: this value is 0.024% accurate (240 ppm)
+ */
+#define JLS_TIME_MICROSECOND ((JLS_TIME_SECOND + 500000) / 1000000)
+
+/**
+ * @brief The approximate fixed-point representation for 1 nanosecond.
+ *
+ * WARNING: this value is only 6.7% accurate!
+ */
+#define JLS_TIME_NANOSECOND ((int64_t) 1)
+
+/**
+ * @brief The fixed-point representation for 1 minute.
+ */
+#define JLS_TIME_MINUTE (JLS_TIME_SECOND * 60)
+
+/**
+ * @brief The fixed-point representation for 1 hour.
+ */
+#define JLS_TIME_HOUR (JLS_TIME_MINUTE * 60)
+
+/**
+ * @brief The fixed-point representation for 1 day.
+ */
+#define JLS_TIME_DAY (JLS_TIME_HOUR * 24)
+
+/**
+ * @brief The fixed-point representation for 1 week.
+ */
+#define JLS_TIME_WEEK (JLS_TIME_DAY * 7)
+
+/**
+ * @brief The average fixed-point representation for 1 month (365 day year).
+ */
+#define JLS_TIME_MONTH (JLS_TIME_YEAR / 12)
+
+/**
+ * @brief The approximate fixed-point representation for 1 year (365 days).
+ */
+#define JLS_TIME_YEAR (JLS_TIME_DAY * 365)
+
+/**
+ * @brief Convert the 64-bit fixed point time to a double.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @return The time as a double p.  Note that IEEE 747 doubles only have
+ *      52 bits of precision, so the result will be truncated for very
+ *      small deltas.
+ */
+#define JLS_TIME_TO_F64(x) (((double) (x)) / ((double) JLS_TIME_SECOND))
+
+/**
+ * @brief Convert the double precision time to 64-bit fixed point time.
+ *
+ * @param x The double-precision floating point time in seconds.
+ * @return The time as a 34Q30.
+ */
+static inline int64_t JLS_F64_TO_TIME(double x) {
+    if (x < 0) {
+        return -JLS_F64_TO_TIME(-x);
+    }
+    return (int64_t) ((x * (double) JLS_TIME_SECOND) + 0.5);
+}
+
+/**
+ * @brief Convert the 64-bit fixed point time to single precision float.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @return The time as a float p in seconds.  Note that IEEE 747 singles only
+ *      have 23 bits of precision, so the result will likely be truncated.
+ */
+#define JLS_TIME_TO_F32(x) (((float) (x)) / ((float) JLS_TIME_SECOND))
+
+/**
+ * @brief Convert the single precision float time to 64-bit fixed point time.
+ *
+ * @param x The single-precision floating point time in seconds.
+ * @return The time as a 34Q30.
+ */
+static inline int64_t JLS_F32_TO_TIME(float x) {
+    if (x < 0.0f) {
+        return -JLS_F32_TO_TIME(-x);
+    }
+    return (int64_t) ((x * (float) JLS_TIME_SECOND) + 0.5f);
+}
+
+/**
+ * @brief Convert to counter ticks, rounded to nearest.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @param z The counter frequency in Hz.
+ * @return The 64-bit time in counter ticks.
+ */
+static inline int64_t JLS_TIME_TO_COUNTER(int64_t x, uint64_t z) {
+    if (x < 0) {
+        return -JLS_TIME_TO_COUNTER(-x, z);
+    }
+    // return (int64_t) ((((x * z) >> (JLS_TIME_Q - 1)) + 1) >> 1);
+    uint64_t c = (((x & ~JLS_FRACT_MASK) >> (JLS_TIME_Q - 1)) * z);
+    uint64_t fract = (x & JLS_FRACT_MASK) << 1;
+    c += ((fract * z) >> JLS_TIME_Q) + 1;
+    return (int64_t) (c >> 1);
+}
+
+/**
+ * @brief Convert to counter ticks, rounded towards zero
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @param z The counter frequency in Hz.
+ * @return The 64-bit time in counter ticks.
+ */
+static inline int64_t JLS_TIME_TO_COUNTER_RZERO(int64_t x, uint64_t z) {
+    if (x < 0) {
+        return -JLS_TIME_TO_COUNTER_RZERO(-x, z);
+    }
+    uint64_t c = (x >> JLS_TIME_Q) * z;
+    c += ((x & JLS_FRACT_MASK) * z) >> JLS_TIME_Q;
+    return (int64_t) c;
+}
+
+/**
+ * @brief Convert to counter ticks, rounded towards infinity.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @param z The counter frequency in Hz.
+ * @return The 64-bit time in counter ticks.
+ */
+static inline int64_t JLS_TIME_TO_COUNTER_RINF(int64_t x, uint64_t z) {
+    if (x < 0) {
+        return -JLS_TIME_TO_COUNTER_RINF(-x, z);
+    }
+    x += JLS_TIME_SECOND - 1;
+    uint64_t c = (x >> JLS_TIME_Q) * z;
+    c += ((x & JLS_FRACT_MASK) * z) >> JLS_TIME_Q;
+    return (int64_t) c;
+}
+
+/**
+ * @brief Convert to 32-bit unsigned seconds.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @return The 64-bit unsigned time in seconds, rounded to nearest.
+ */
+#define JLS_TIME_TO_SECONDS(x) JLS_TIME_TO_COUNTER(x, 1)
+
+/**
+ * @brief Convert to milliseconds.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @return The 64-bit signed time in milliseconds, rounded to nearest.
+ */
+#define JLS_TIME_TO_MILLISECONDS(x) JLS_TIME_TO_COUNTER(x, 1000)
+
+/**
+ * @brief Convert to microseconds.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @return The 64-bit signed time in microseconds, rounded to nearest.
+ */
+#define JLS_TIME_TO_MICROSECONDS(x) JLS_TIME_TO_COUNTER(x, 1000000)
+
+/**
+ * @brief Convert to nanoseconds.
+ *
+ * @param x The 64-bit signed fixed point time.
+ * @return The 64-bit signed time in nanoseconds, rounded to nearest.
+ */
+#define JLS_TIME_TO_NANOSECONDS(x) JLS_TIME_TO_COUNTER(x, 1000000000ll)
+
+/**
+ * @brief Convert a counter to 64-bit signed fixed point time.
+ *
+ * @param x The counter value in ticks.
+ * @param z The counter frequency in Hz.
+ * @return The 64-bit signed fixed point time.
+ */
+static inline int64_t JLS_COUNTER_TO_TIME(uint64_t x, uint64_t z) {
+    // compute (x << JLS_TIME_Q) / z, but without unnecessary saturation
+    uint64_t seconds = x / z;
+    uint64_t remainder = x - (seconds * z);
+    uint64_t fract = (remainder << JLS_TIME_Q) / z;
+    uint64_t t = (int64_t) ((seconds << JLS_TIME_Q) + fract);
+    return t;
+}
+
+/**
+ * @brief Convert to 64-bit signed fixed point time.
+ *
+ * @param x he 32-bit unsigned time in seconds.
+ * @return The 64-bit signed fixed point time.
+ */
+#define JLS_SECONDS_TO_TIME(x) (((int64_t) (x)) << JLS_TIME_Q)
+
+/**
+ * @brief Convert to 64-bit signed fixed point time.
+ *
+ * @param x The 32-bit unsigned time in milliseconds.
+ * @return The 64-bit signed fixed point time.
+ */
+#define JLS_MILLISECONDS_TO_TIME(x) JLS_COUNTER_TO_TIME(x, 1000)
+
+/**
+ * @brief Convert to 64-bit signed fixed point time.
+ *
+ * @param x The 32-bit unsigned time in microseconds.
+ * @return The 64-bit signed fixed point time.
+ */
+#define JLS_MICROSECONDS_TO_TIME(x) JLS_COUNTER_TO_TIME(x, 1000000)
+
+/**
+ * @brief Convert to 64-bit signed fixed point time.
+ *
+ * @param x The 32-bit unsigned time in microseconds.
+ * @return The 64-bit signed fixed point time.
+ */
+#define JLS_NANOSECONDS_TO_TIME(x) JLS_COUNTER_TO_TIME(x, 1000000000ll)
+
+/**
+ * @brief Compute the absolute value of a time.
+ *
+ * @param t The time.
+ * @return The absolute value of t.
+ */
+static inline int64_t JLS_TIME_ABS(int64_t t) {
+    return ( (t) < 0 ? -(t) : (t) );
+}
+
+/**
+ * @brief Get the UTC time as a 34Q30 fixed point number.
+ *
+ * @return The current time.  This value is not guaranteed to be monotonic.
+ *      The device may synchronize to external clocks which can cause
+ *      discontinuous jumps, both backwards and forwards.
+ *
+ *      At power-on, the time will start from 0 unless the system has
+ *      a real-time clock.  When the current time first synchronizes to
+ *      an external host, it may have a large skip.
+ *
+ * Be sure to verify your time for each platform using python:
+ *
+ *      python
+ *      import datetime
+ *      import dateutil.parser
+ *      epoch = dateutil.parser.parse('2018-01-01T00:00:00Z').timestamp()
+ *      datetime.datetime.fromtimestamp((my_time >> 30) + epoch)
+ */
+JLS_API int64_t jls_now(void);
+
+/**
+ * @brief The platform counter structure.
+ */
+struct jls_time_counter_s {
+    /// The counter value.
+    uint64_t value;
+    /// The approximate counter frequency.
+    uint64_t frequency;
+};
+
+/**
+ * @brief Get the monotonic platform counter.
+ *
+ * @return The monotonic platform counter.
+ *
+ * The platform implementation may select an appropriate source and
+ * frequency.  The JLS library assumes a nominal frequency of
+ * at least 1000 Hz, but we frequencies in the 1 MHz to 100 MHz
+ * range to enable profiling.  The frequency should not exceed 10 GHz
+ * to prevent rollover.
+ *
+ * The counter must be monotonic.  If the underlying hardware is less
+ * than the full 64 bits, then the platform must unwrap and extend
+ * the hardware value to 64-bit.
+ *
+ * The JLS authors recommend this counter starts at 0 when the
+ * system powers up.
+ */
+JLS_API struct jls_time_counter_s jls_time_counter(void);
+
+/**
+ * @brief Get the monotonic platform time as a 34Q30 fixed point number.
+ *
+ * @return The monotonic platform time based upon the jls_time_counter().
+ *      The platform time has no guaranteed relationship with
+ *      UTC or wall-clock calendar time.  This time has both
+ *      offset and scale errors relative to UTC.
+ */
+static inline int64_t jls_time_rel(void) {
+    struct jls_time_counter_s counter = jls_time_counter();
+    return JLS_COUNTER_TO_TIME(counter.value, counter.frequency);
+}
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif /* JLS_TIME_H__ */
```

### Comparing `pyjls-0.7.0/include/jls/writer.h` & `pyjls-0.7.1/include/jls/threaded_writer.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,180 +1,179 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS writer.
- */
-
-#ifndef JLS_WRITER_H__
-#define JLS_WRITER_H__
-
-#include <stdint.h>
-#include "jls/statistics.h"
-#include "jls/format.h"
-
-/**
- * @ingroup jls
- * @defgroup jls_writer Writer
- *
- * @brief JLS writer.
- *
- * @{
- */
-
-JLS_CPP_GUARD_START
-
-/// Opaque JLS writer object.
-struct jls_wr_s;
-
-/**
- * @brief Open a JLS file for writing.
- *
- * @param[out] instance The JLS writer instance.
- * @param path The JLS file path.
- * @return 0 or error code.
- *
- * Call jls_wr_close() when done.
- */
-JLS_API int32_t jls_wr_open(struct jls_wr_s ** instance, const char * path);
-
-/**
- * @brief Close a JLS file.
- *
- * @param self The JLS writer instance from jls_wr_open().
- * @return 0 or error code.
- */
-JLS_API int32_t jls_wr_close(struct jls_wr_s * self);
-
-/**
- * @brief Flush a JLS file to disk.
- *
- * @param self The JLS writer instance from jls_wr_open().
- * @return 0 or error code.
- */
-JLS_API int32_t jls_wr_flush(struct jls_wr_s * self);
-
-/**
- * @brief Define a new source.
- *
- * @param self The JLS writer instance.
- * @param source The source definition.
- * @return 0 or error code.
- *
- * This JLS file format supports multiple sources, which are usually different
- * instruments.  Each source can provide multiple signals.
- */
-JLS_API int32_t jls_wr_source_def(struct jls_wr_s * self, const struct jls_source_def_s * source);
-
-/**
- * @brief Define a new signal.
- *
- * @param self The JLS writer instance.
- * @param signal The signal definition.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_wr_signal_def(struct jls_wr_s * self, const struct jls_signal_def_s * signal);
-
-/**
- * @brief Add arbitrary user data.
- *
- * @param self The writer instance.
- * @param chunk_meta The arbitrary data.  Bits 15:12 are reserved, but
- *      bits 11:0 may be assigned by the application.
- * @param storage_type The storage type for data.
- * @param data The user data to store.
- * @param data_size The size of data for JLS_STORAGE_TYPE_BINARY.  Ignored
- *      for all other storage types.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_wr_user_data(struct jls_wr_s * self, uint16_t chunk_meta,
-        enum jls_storage_type_e storage_type, const uint8_t * data, uint32_t data_size);
-
-
-/**
- * @brief Write fixed-rate sample data to a signal.
- *
- * @param self The JLS writer instance.
- * @param signal_id The signal id.
- * @param sample_id The sample id for data[0].
- * @param data The sample data array.  Data must be packed with no spacing
- *      between samples.  u1 stores 8 samples per byte, and u4 stores 2 samples
- *      per byte.
- * @param data_length The length of data in samples.
- * @return 0 or error code
- */
-JLS_API int32_t jls_wr_fsr(struct jls_wr_s * self, uint16_t signal_id,
-                           int64_t sample_id, const void * data, uint32_t data_length);
-
-/**
- * @brief Write sample data to a float32 FSR signal.
- *
- * @param self The JLS writer instance.
- * @param signal_id The signal id.
- * @param sample_id The sample id for data[0].
- * @param data The sample data array.
- * @param data_length The length of data in floats (bytes / 4).
- * @return 0 or error code
- */
-JLS_API int32_t jls_wr_fsr_f32(struct jls_wr_s * self, uint16_t signal_id,
-        int64_t sample_id, const float * data, uint32_t data_length);
-
-/**
- * @brief Add an annotation to a signal.
- *
- * @param self The writer instance.
- * @param signal_id The signal id.
- * @param timestamp The x-axis timestamp in sample_id for FSR and UTC for VSR.
- * @param y The y-axis value or NAN to automatically position.
- * @param annotation_type The annotation type.
- * @param group_id The optional group identifier.  If unused, set to 0.
- * @param storage_type The storage type.
- * @param data The data for the annotation.
- * @param data_size The length of data for JLS_STORAGE_TYPE_BINARY storage_type.
- *      Set to 0 for all other storage types.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_wr_annotation(struct jls_wr_s * self,
-                                  uint16_t signal_id,
-                                  int64_t timestamp,
-                                  float y,
-                                  enum jls_annotation_type_e annotation_type,
-                                  uint8_t group_id,
-                                  enum jls_storage_type_e storage_type,
-                                  const uint8_t * data,
-                                  uint32_t data_size);
-
-/**
- * @brief Add a mapping from sample_id to UTC timestamp for an FSR signal.
- *
- * @param self The writer instance.
- * @param signal_id The signal id.
- * @param sample_id The sample_id for FSR.
- * @param utc The UTC timestamp.
- * @return 0 or error code.
- */
-JLS_API int32_t jls_wr_utc(struct jls_wr_s * self, uint16_t signal_id, int64_t sample_id, int64_t utc);
-
-// todo jls_wr_vsr_f32
-// JLS_API int32_t jls_wr_vsr_f32(struct jls_wr_s * self, uint16_t ts_id, int64_t timestamp, uint32_t data, uint32_t size);
-
-JLS_CPP_GUARD_END
-
-/** @} */
-
-#endif  /* JLS_WRITER_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS threaded writer.
+ */
+
+#ifndef JLS_THREADED_WRITER_H__
+#define JLS_THREADED_WRITER_H__
+
+#include <stdint.h>
+#include "jls/cmacro.h"
+#include "jls/format.h"
+
+/**
+ * @ingroup jls
+ * @defgroup jls_threaded_writer Threaded writer
+ *
+ * @brief JLS threaded writer.
+ *
+ * This module wraps writer.  For normal operation while recording signals,
+ * prefer this threaded writer over writer.
+ * 
+ * @{
+ */
+
+JLS_CPP_GUARD_START
+
+/// Opaque JLS threaded writer object.
+struct jls_twr_s;
+
+/**
+ * @brief Open a JLS file for writing.
+ *
+ * @param[out] instance The JLS writer instance.
+ * @param path The JLS file path.
+ * @return 0 or error code.
+ *
+ * Call jls_twr_close() when done.
+ */
+JLS_API int32_t jls_twr_open(struct jls_twr_s ** instance, const char * path);
+
+/**
+ * @brief Close a JLS file.
+ *
+ * @param self The JLS writer instance from jls_twr_open().
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_twr_close(struct jls_twr_s * self);
+
+/**
+ * @brief Flush a JLS file to disk.
+ *
+ * @param self The JLS writer instance from jls_twr_open().
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_twr_flush(struct jls_twr_s * self);
+
+/**
+ * @brief Define a new source.
+ *
+ * @param self The JLS writer instance.
+ * @param source The source definition.
+ * @return 0 or error code.
+ *
+ * This JLS file format supports multiple sources, which are usually different
+ * instruments.  Each source can provide multiple signals.
+ */
+JLS_API int32_t jls_twr_source_def(struct jls_twr_s * self, const struct jls_source_def_s * source);
+
+/**
+ * @brief Define a new signal.
+ *
+ * @param self The JLS writer instance.
+ * @param signal The signal definition.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_twr_signal_def(struct jls_twr_s * self, const struct jls_signal_def_s * signal);
+
+/**
+ * @brief Add arbitrary user data.
+ *
+ * @param self The writer instance.
+ * @param chunk_meta The arbitrary data.  Bits 15:12 are reserved, but
+ *      bits 11:0 may be assigned by the application.
+ * @param storage_type The storage type for data.
+ * @param data The user data to store.
+ * @param data_size The size of data for JLS_STORAGE_TYPE_BINARY.  Ignored
+ *      for all other storage types.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_twr_user_data(struct jls_twr_s * self, uint16_t chunk_meta,
+        enum jls_storage_type_e storage_type, const uint8_t * data, uint32_t data_size);
+
+/**
+ * @brief Write fixed-rate sample data to a signal.
+ *
+ * @param self The JLS writer instance.
+ * @param signal_id The signal id.
+ * @param sample_id The sample id for data[0].
+ * @param data The sample data array.  Data must be packed with no spacing
+ *      between samples.  u1 stores 8 samples per byte, and u4 stores 2 samples
+ *      per byte.
+ * @param data_length The length of data in samples.
+ * @return 0 or error code
+ */
+JLS_API int32_t jls_twr_fsr(struct jls_twr_s * self, uint16_t signal_id,
+                            int64_t sample_id, const void * data, uint32_t data_length);
+
+/**
+ * @brief Write sample data to a float32 FSR signal.
+ *
+ * @param self The JLS writer instance.
+ * @param signal_id The signal id.
+ * @param sample_id The sample id for data[0].
+ * @param data The sample data array.
+ * @param data_length The length of data in floats (bytes / 4).
+ * @return 0 or error code
+ */
+JLS_API int32_t jls_twr_fsr_f32(struct jls_twr_s * self, uint16_t signal_id,
+        int64_t sample_id, const float * data, uint32_t data_length);
+
+/**
+ * @brief Add an annotation to a signal.
+ *
+ * @param self The writer instance.
+ * @param signal_id The signal id.
+ * @param timestamp The x-axis timestamp in sample_id for FSR and UTC for VSR.
+ * @param y The y-axis value or NAN to automatically position.
+ * @param annotation_type The annotation type.
+ * @param group_id The optional group identifier.  If unused, set to 0.
+ * @param storage_type The storage type.
+ * @param data The data for the annotation.
+ * @param data_size The length of data for JLS_STORAGE_TYPE_BINARY storage_type.
+ *      Set to 0 for all other storage types.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_twr_annotation(struct jls_twr_s * self, uint16_t signal_id, int64_t timestamp,
+        float y,
+        enum jls_annotation_type_e annotation_type,
+        uint8_t group_id,
+        enum jls_storage_type_e storage_type,
+        const uint8_t * data, uint32_t data_size);
+
+/**
+ * @brief Add a mapping from sample_id to UTC timestamp for an FSR signal.
+ *
+ * @param self The writer instance.
+ * @param signal_id The signal id.
+ * @param sample_id The sample_id for FSR.
+ * @param utc The UTC timestamp.
+ * @return 0 or error code.
+ */
+JLS_API int32_t jls_twr_utc(struct jls_twr_s * self, uint16_t signal_id, int64_t sample_id, int64_t utc);
+
+// todo jls_twr_vsr_f32
+//JLS_API int32_t jls_twr_vsr_f32(struct jls_twr_s * self, uint16_t ts_id, int64_t timestamp, uint32_t data, uint32_t size);
+
+JLS_CPP_GUARD_END
+
+/** @} */
+
+#endif  /* JLS_THREADED_WRITER_H__ */
```

### Comparing `pyjls-0.7.0/include_prv/jls/bit_shift.h` & `pyjls-0.7.1/include_prv/jls/bit_shift.h`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-/*
- * Copyright 2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS shift.
- */
-
-#ifndef JLS_PRIV_SHIFT_H__
-#define JLS_PRIV_SHIFT_H__
-
-#include <stdint.h>
-#include <stddef.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @ingroup jls
- * @defgroup jls_bit_shift Bit shift
- *
- * @brief JLS bit shifting utilities.
- *
- * @{
- */
-
-/**
- * @brief Right shift all bits in an array.
- *
- * @param bits The number of bits to shift which is between 0 and 8, inclusive.
- * @param[inout] data The data array to shift, modified in place.
- * @param size The size of data in bytes.
- * @return 0 or JLS_ERROR_PARAMETER_INVALID
- */
-int32_t jls_bit_shift_array_right(uint8_t bits, void * data, size_t size);
-
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* JLS_PRIV_SHIFT_H__ */
+/*
+ * Copyright 2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS shift.
+ */
+
+#ifndef JLS_PRIV_SHIFT_H__
+#define JLS_PRIV_SHIFT_H__
+
+#include <stdint.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup jls
+ * @defgroup jls_bit_shift Bit shift
+ *
+ * @brief JLS bit shifting utilities.
+ *
+ * @{
+ */
+
+/**
+ * @brief Right shift all bits in an array.
+ *
+ * @param bits The number of bits to shift which is between 0 and 8, inclusive.
+ * @param[inout] data The data array to shift, modified in place.
+ * @param size The size of data in bytes.
+ * @return 0 or JLS_ERROR_PARAMETER_INVALID
+ */
+int32_t jls_bit_shift_array_right(uint8_t bits, void * data, size_t size);
+
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* JLS_PRIV_SHIFT_H__ */
```

### Comparing `pyjls-0.7.0/include_prv/jls/datatype.h` & `pyjls-0.7.1/include_prv/jls/datatype.h`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-/*
- * Copyright 2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS data type conversions.
- */
-
-#ifndef JLS_PRIV_DATATYPE_H__
-#define JLS_PRIV_DATATYPE_H__
-
-#include <stdint.h>
-#include <stddef.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @ingroup jls
- * @defgroup jls_dt Data type conversions
- *
- * @brief JLS data type handling and conversions.
- *
- * @{
- */
-
-/**
- * @brief Convert a buffer into doubles.
- * @param src The source buffer pointer
- * @param src_datatype The source buffer datatype, see JLS_DATATYPE_*.
- * @param[out] dst The output f64 buffer.
- * @param samples The number of samples to convert.  Both src and dst must
- *      be able to hold at least this many samples.
- * @return 0 or error code.
- */
-int32_t jls_dt_buffer_to_f64(const void * src, uint32_t src_datatype, double * dst, size_t samples);
-
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* JLS_PRIV_DATATYPE_H__ */
+/*
+ * Copyright 2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS data type conversions.
+ */
+
+#ifndef JLS_PRIV_DATATYPE_H__
+#define JLS_PRIV_DATATYPE_H__
+
+#include <stdint.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup jls
+ * @defgroup jls_dt Data type conversions
+ *
+ * @brief JLS data type handling and conversions.
+ *
+ * @{
+ */
+
+/**
+ * @brief Convert a buffer into doubles.
+ * @param src The source buffer pointer
+ * @param src_datatype The source buffer datatype, see JLS_DATATYPE_*.
+ * @param[out] dst The output f64 buffer.
+ * @param samples The number of samples to convert.  Both src and dst must
+ *      be able to hold at least this many samples.
+ * @return 0 or error code.
+ */
+int32_t jls_dt_buffer_to_f64(const void * src, uint32_t src_datatype, double * dst, size_t samples);
+
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* JLS_PRIV_DATATYPE_H__ */
```

### Comparing `pyjls-0.7.0/include_prv/jls/rd_fsr.h` & `pyjls-0.7.1/include_prv/jls/rd_fsr.h`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-/*
- * Copyright 2023 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS timestamp <-> sample_id mapping for FSR channels.
- */
-
-#ifndef JLS_PRIV_RD_FSR_H__
-#define JLS_PRIV_RD_FSR_H__
-
-#include <stdint.h>
-#include <stddef.h>
-#include "jls/format.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @ingroup jls
- * @defgroup jls_rd_fsr FSR sample_id & JLS timestamp conversions.
- *
- * @brief Convert between sample_id and JLS timestamps for the
- *      JLS reader for FSR signals with UTC channels.
- *
- * @{
- */
-
-
-/// The opaque instance.
-struct jls_rd_fsr_s;
-
-struct jls_rd_fsr_s * jls_rd_fsr_alloc(double sample_rate);
-void jls_rd_fsr_free(struct jls_rd_fsr_s * self);
-
-int32_t jls_rd_fsr_add_cbk(void * user_data, const struct jls_utc_summary_entry_s * utc, uint32_t size);
-int32_t jls_rd_fsr_add(struct jls_rd_fsr_s * self, int64_t sample_id, int64_t timestamp);
-int32_t jls_rd_fsr_sample_id_to_timestamp(struct jls_rd_fsr_s * self, int64_t sample_id, int64_t * timestamp);
-int32_t jls_rd_fsr_timestamp_to_sample_id(struct jls_rd_fsr_s * self, int64_t timestamp, int64_t * sample_id);
-
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* JLS_PRIV_RD_FSR_H__ */
+/*
+ * Copyright 2023 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS timestamp <-> sample_id mapping for FSR channels.
+ */
+
+#ifndef JLS_PRIV_RD_FSR_H__
+#define JLS_PRIV_RD_FSR_H__
+
+#include <stdint.h>
+#include <stddef.h>
+#include "jls/format.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup jls
+ * @defgroup jls_rd_fsr FSR sample_id & JLS timestamp conversions.
+ *
+ * @brief Convert between sample_id and JLS timestamps for the
+ *      JLS reader for FSR signals with UTC channels.
+ *
+ * @{
+ */
+
+
+/// The opaque instance.
+struct jls_rd_fsr_s;
+
+struct jls_rd_fsr_s * jls_rd_fsr_alloc(double sample_rate);
+void jls_rd_fsr_free(struct jls_rd_fsr_s * self);
+
+int32_t jls_rd_fsr_add_cbk(void * user_data, const struct jls_utc_summary_entry_s * utc, uint32_t size);
+int32_t jls_rd_fsr_add(struct jls_rd_fsr_s * self, int64_t sample_id, int64_t timestamp);
+int32_t jls_rd_fsr_sample_id_to_timestamp(struct jls_rd_fsr_s * self, int64_t sample_id, int64_t * timestamp);
+int32_t jls_rd_fsr_timestamp_to_sample_id(struct jls_rd_fsr_s * self, int64_t timestamp, int64_t * sample_id);
+
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* JLS_PRIV_RD_FSR_H__ */
```

### Comparing `pyjls-0.7.0/include_prv/jls/util.h` & `pyjls-0.7.1/include_prv/jls/util.h`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS utilities.
- */
-
-#ifndef JLS_UTIL_H__
-#define JLS_UTIL_H__
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @ingroup jls
- * @defgroup jls_util Utilities
- *
- * @brief Common JLS utilities.
- *
- * @{
- */
-
-/**
- * @brief Pack the chunk tag.
- *
- * @param track_type The jls_track_type_e
- * @param track_chunk The jls_track_chunk_e
- * @return The tag value.
- */
-static inline uint8_t jls_track_tag_pack(uint8_t track_type, uint8_t track_chunk) {
-    return JLS_TRACK_TAG_PACK(track_type, track_chunk);
-}
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* JLS_UTIL_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS utilities.
+ */
+
+#ifndef JLS_UTIL_H__
+#define JLS_UTIL_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup jls
+ * @defgroup jls_util Utilities
+ *
+ * @brief Common JLS utilities.
+ *
+ * @{
+ */
+
+/**
+ * @brief Pack the chunk tag.
+ *
+ * @param track_type The jls_track_type_e
+ * @param track_chunk The jls_track_chunk_e
+ * @return The tag value.
+ */
+static inline uint8_t jls_track_tag_pack(uint8_t track_type, uint8_t track_chunk) {
+    return JLS_TRACK_TAG_PACK(track_type, track_chunk);
+}
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* JLS_UTIL_H__ */
```

### Comparing `pyjls-0.7.0/include_prv/jls/wr_fsr.h` & `pyjls-0.7.1/include_prv/jls/wr_fsr.h`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS fixed-sampling rate signal writer.
- */
-
-#ifndef JLS_WRITE_FSR_H__
-#define JLS_WRITE_FSR_H__
-
-#include <stdint.h>
-#include "jls/format.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @ingroup jls
- * @defgroup jls_wr_fsr FSR signal writer.
- *
- * @brief JLS FSR signal writer.
- *
- * @{
- */
-
-struct jls_wr_s; // opaque, see "jls/writer.h"
-struct jls_wr_fsr_s;  // opaque, defined by wr_fsr.c
-
-/**
- * @brief Validate and align the signal definition.
- *
- * @param def[inout] The signal definition.
- * @return 0 or error code.
- */
-int32_t jls_wr_fsr_validate(struct jls_signal_def_s * def);
-
-int32_t jls_wr_fsr_open(struct jls_wr_fsr_s ** instance, struct jls_wr_s * wr, const struct jls_signal_def_s * def);
-int32_t jls_wr_fsr_close(struct jls_wr_fsr_s * self);
-
-/**
- * @brief Write fixed sample rate data.
- *
- * @param self The instance.
- * @param sample_id The starting sample id for this data.
- * @param data The packed data appropriate for the format.
- * @param data_length The length of data in samples (NOT BYTES).
- * @return 0 or error code.
- */
-int32_t jls_wr_fsr_data(struct jls_wr_fsr_s * self, int64_t sample_id, const void * data, uint32_t data_length);
-
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* JLS_WRITE_FSR_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS fixed-sampling rate signal writer.
+ */
+
+#ifndef JLS_WRITE_FSR_H__
+#define JLS_WRITE_FSR_H__
+
+#include <stdint.h>
+#include "jls/format.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup jls
+ * @defgroup jls_wr_fsr FSR signal writer.
+ *
+ * @brief JLS FSR signal writer.
+ *
+ * @{
+ */
+
+struct jls_wr_s; // opaque, see "jls/writer.h"
+struct jls_wr_fsr_s;  // opaque, defined by wr_fsr.c
+
+/**
+ * @brief Validate and align the signal definition.
+ *
+ * @param def[inout] The signal definition.
+ * @return 0 or error code.
+ */
+int32_t jls_wr_fsr_validate(struct jls_signal_def_s * def);
+
+int32_t jls_wr_fsr_open(struct jls_wr_fsr_s ** instance, struct jls_wr_s * wr, const struct jls_signal_def_s * def);
+int32_t jls_wr_fsr_close(struct jls_wr_fsr_s * self);
+
+/**
+ * @brief Write fixed sample rate data.
+ *
+ * @param self The instance.
+ * @param sample_id The starting sample id for this data.
+ * @param data The packed data appropriate for the format.
+ * @param data_length The length of data in samples (NOT BYTES).
+ * @return 0 or error code.
+ */
+int32_t jls_wr_fsr_data(struct jls_wr_fsr_s * self, int64_t sample_id, const void * data, uint32_t data_length);
+
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* JLS_WRITE_FSR_H__ */
```

### Comparing `pyjls-0.7.0/include_prv/jls/wr_ts.h` & `pyjls-0.7.1/include_prv/jls/wr_ts.h`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,107 +1,107 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-/**
- * @file
- *
- * @brief JLS time series writer.
- */
-
-#ifndef JLS_WRITE_TS_H__
-#define JLS_WRITE_TS_H__
-
-#include <stdint.h>
-#include "jls/format.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @ingroup jls
- * @defgroup jls_wf_ts Timeseries writer.
- *
- * @brief JLS timeseries writer.
- *
- * @{
- */
-
-struct jls_wr_s; // opaque, see writer.h
-struct jls_wr_ts_s;  // opaque, see wr_ts.c
-
-/**
- * @brief Open a new timeseries for index writing.
- *
- * @param instance[out] The new instance
- * @param wr The JLS file writer.
- * @param signal_id The signal_id for this timeseries.
- * @param track_type The track type (ANNOTATION, UTC) for this timeseries.
- * @param decimate_factor The decimation factor for each index level.
- * @return 0 or error code.
- */
-int32_t jls_wr_ts_open(
-        struct jls_wr_ts_s ** instance,
-        struct jls_wr_s * wr,
-        uint16_t signal_id,
-        enum jls_track_type_e track_type,
-        uint32_t decimate_factor);
-
-/**
- * @brief Close the timeseries and write summary information to disk.
- *
- * @param self The timeseries instance.
- * @return 0 or error code.
- */
-int32_t jls_wr_ts_close(struct jls_wr_ts_s * self);
-
-/**
- * @brief Add a timeseries annotation entry.
- *
- * @param self The timeseries instance.
- * @param timestamp The timestamp (sample_id for FSR or utc for VSR).
- * @param offset The file offset for the referenced chunk.
- * @param annotation_type The annotation type.
- * @param group_id The group_id.
- * @param y The y-axis value.
- * @return 0 or error code.
- * @note The annotation data chunk must be written by the caller.
- */
-int32_t jls_wr_ts_anno(struct jls_wr_ts_s * self, int64_t timestamp, int64_t offset,
-                       enum jls_annotation_type_e annotation_type, uint8_t group_id,
-                       float y);
-
-/**
- * @brief Add a UTC entry.
- *
- * @param self The timeseries instance.
- * @param sample_id The sample id.
- * @param offset The file offset for the referenced chunk.
- * @param utc The utc timestamp.
- * @return 0 or error code.
- * @note The utc data chunk must be written by the caller, if desired.
- *     Alternatively, provide offset=0 to omit level 0 data chunks.
- */
-int32_t jls_wr_ts_utc(struct jls_wr_ts_s * self, int64_t sample_id, int64_t offset, int64_t utc);
-
-
-/** @} */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* JLS_WRITE_TS_H__ */
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/**
+ * @file
+ *
+ * @brief JLS time series writer.
+ */
+
+#ifndef JLS_WRITE_TS_H__
+#define JLS_WRITE_TS_H__
+
+#include <stdint.h>
+#include "jls/format.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @ingroup jls
+ * @defgroup jls_wf_ts Timeseries writer.
+ *
+ * @brief JLS timeseries writer.
+ *
+ * @{
+ */
+
+struct jls_wr_s; // opaque, see writer.h
+struct jls_wr_ts_s;  // opaque, see wr_ts.c
+
+/**
+ * @brief Open a new timeseries for index writing.
+ *
+ * @param instance[out] The new instance
+ * @param wr The JLS file writer.
+ * @param signal_id The signal_id for this timeseries.
+ * @param track_type The track type (ANNOTATION, UTC) for this timeseries.
+ * @param decimate_factor The decimation factor for each index level.
+ * @return 0 or error code.
+ */
+int32_t jls_wr_ts_open(
+        struct jls_wr_ts_s ** instance,
+        struct jls_wr_s * wr,
+        uint16_t signal_id,
+        enum jls_track_type_e track_type,
+        uint32_t decimate_factor);
+
+/**
+ * @brief Close the timeseries and write summary information to disk.
+ *
+ * @param self The timeseries instance.
+ * @return 0 or error code.
+ */
+int32_t jls_wr_ts_close(struct jls_wr_ts_s * self);
+
+/**
+ * @brief Add a timeseries annotation entry.
+ *
+ * @param self The timeseries instance.
+ * @param timestamp The timestamp (sample_id for FSR or utc for VSR).
+ * @param offset The file offset for the referenced chunk.
+ * @param annotation_type The annotation type.
+ * @param group_id The group_id.
+ * @param y The y-axis value.
+ * @return 0 or error code.
+ * @note The annotation data chunk must be written by the caller.
+ */
+int32_t jls_wr_ts_anno(struct jls_wr_ts_s * self, int64_t timestamp, int64_t offset,
+                       enum jls_annotation_type_e annotation_type, uint8_t group_id,
+                       float y);
+
+/**
+ * @brief Add a UTC entry.
+ *
+ * @param self The timeseries instance.
+ * @param sample_id The sample id.
+ * @param offset The file offset for the referenced chunk.
+ * @param utc The utc timestamp.
+ * @return 0 or error code.
+ * @note The utc data chunk must be written by the caller, if desired.
+ *     Alternatively, provide offset=0 to omit level 0 data chunks.
+ */
+int32_t jls_wr_ts_utc(struct jls_wr_ts_s * self, int64_t sample_id, int64_t offset, int64_t utc);
+
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* JLS_WRITE_TS_H__ */
```

### Comparing `pyjls-0.7.0/pyjls/__init__.py` & `pyjls-0.7.1/pyjls/version.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,27 +1,28 @@
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from .binding import DataType, AnnotationType, SignalType, Writer, Reader, SummaryFSR, \
-    data_type_as_enum, data_type_as_str, \
-    utc_to_jls, jls_to_utc
-from .structs import SourceDef, SignalDef
-from .version import *
-
-__all__ = ['Writer', 'Reader', 'DataType', 'AnnotationType',
-           'SignalType', 'SourceDef', 'SignalDef', 'SummaryFSR',
-           'data_type_as_enum', 'data_type_as_str',
-           'utc_to_jls', 'jls_to_utc',
-           '__version__', '__title__', '__description__', '__url__',
-           '__author__', '__author_email__', '__license__',
-           '__copyright__']
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+__version__ = "0.7.1"
+
+__title__ = "pyjls"
+__description__ = 'Joulescope™ file format'
+__url__ = 'https://joulescope.readthedocs.io'
+__author__ = 'Jetperch LLC'
+__author_email__ = 'joulescope-dev@jetperch.com'
+__license__ = 'Apache 2.0'
+__copyright__ = 'Copyright 2021-2022 Jetperch LLC'
+
+__all__ = ['__version__', '__title__', '__description__', '__url__',
+           '__author__', '__author_email__', '__license__',
+           '__copyright__']
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `pyjls-0.7.0/pyjls/__main__.py` & `pyjls-0.7.1/pyjls/__main__.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,82 +1,82 @@
-#!/usr/bin/env python3
-# Copyright 2018-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-"""jls command-line utility."""
-
-
-import os
-import sys
-import argparse
-import logging
-import traceback
-from . import entry_points
-
-
-_LOG_LEVELS = {
-    'OFF': 100,
-    'CRITICAL': logging.CRITICAL,
-    'ERROR': logging.ERROR,
-    'WARNING': logging.WARNING,
-    'INFO': logging.INFO,
-    'DEBUG': logging.DEBUG,
-    'ALL': 0,
-}
-
-_EPILOG = f"""\
-Set the PYJLS_LOG_LEVEL environment variable to change the logging level.
-Options are [{', '.join(_LOG_LEVELS.keys())}].
-The default is WARNING.
-"""
-
-
-def get_parser():
-    parser = argparse.ArgumentParser(
-        description='jls command line tools.',
-        epilog=_EPILOG,
-    )
-    subparsers = parser.add_subparsers(
-        dest='subparser_name',
-        help='The command to execute')
-
-    for entry_point in entry_points.__all__:
-        default_name = entry_point.__name__.split('.')[-1]
-        name = getattr(entry_point, 'NAME', default_name)
-        cfg_fn = entry_point.parser_config
-        p = subparsers.add_parser(name, help=cfg_fn.__doc__)
-        cmd_fn = cfg_fn(p)
-        if not callable(cmd_fn):
-            raise ValueError(f'Invalid command function for {name}')
-        p.set_defaults(func=cmd_fn)
-
-    subparsers.add_parser('help', help='Display the command help. Use [command] --help to display help for a specific command.')
-
-    return parser
-
-
-def run():
-    log_level = os.environ.get('PYJLS_LOG_LEVEL', 'WARNING').upper()
-    log_level = _LOG_LEVELS.get(log_level, logging.WARNING)
-    logging.basicConfig(level=log_level,
-                        format="%(levelname)s:%(asctime)s:%(filename)s:%(lineno)d:%(name)s:%(message)s")
-    parser = get_parser()
-    args = parser.parse_args()
-    if args.subparser_name is None or args.subparser_name.lower() in ['help']:
-        parser.print_help()
-        parser.exit()
-    return args.func(args)
-
-
-if __name__ == "__main__":
-    sys.exit(run())
+#!/usr/bin/env python3
+# Copyright 2018-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""jls command-line utility."""
+
+
+import os
+import sys
+import argparse
+import logging
+import traceback
+from . import entry_points
+
+
+_LOG_LEVELS = {
+    'OFF': 100,
+    'CRITICAL': logging.CRITICAL,
+    'ERROR': logging.ERROR,
+    'WARNING': logging.WARNING,
+    'INFO': logging.INFO,
+    'DEBUG': logging.DEBUG,
+    'ALL': 0,
+}
+
+_EPILOG = f"""\
+Set the PYJLS_LOG_LEVEL environment variable to change the logging level.
+Options are [{', '.join(_LOG_LEVELS.keys())}].
+The default is WARNING.
+"""
+
+
+def get_parser():
+    parser = argparse.ArgumentParser(
+        description='jls command line tools.',
+        epilog=_EPILOG,
+    )
+    subparsers = parser.add_subparsers(
+        dest='subparser_name',
+        help='The command to execute')
+
+    for entry_point in entry_points.__all__:
+        default_name = entry_point.__name__.split('.')[-1]
+        name = getattr(entry_point, 'NAME', default_name)
+        cfg_fn = entry_point.parser_config
+        p = subparsers.add_parser(name, help=cfg_fn.__doc__)
+        cmd_fn = cfg_fn(p)
+        if not callable(cmd_fn):
+            raise ValueError(f'Invalid command function for {name}')
+        p.set_defaults(func=cmd_fn)
+
+    subparsers.add_parser('help', help='Display the command help. Use [command] --help to display help for a specific command.')
+
+    return parser
+
+
+def run():
+    log_level = os.environ.get('PYJLS_LOG_LEVEL', 'WARNING').upper()
+    log_level = _LOG_LEVELS.get(log_level, logging.WARNING)
+    logging.basicConfig(level=log_level,
+                        format="%(levelname)s:%(asctime)s:%(filename)s:%(lineno)d:%(name)s:%(message)s")
+    parser = get_parser()
+    args = parser.parse_args()
+    if args.subparser_name is None or args.subparser_name.lower() in ['help']:
+        parser.print_help()
+        parser.exit()
+    return args.func(args)
+
+
+if __name__ == "__main__":
+    sys.exit(run())
```

### Comparing `pyjls-0.7.0/pyjls/binding.c` & `pyjls-0.7.1/pyjls/binding.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,42 +1,49 @@
 /* Generated by Cython 0.29.35 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
-            "C:\\bin\\Python3_8_10\\lib\\site-packages\\numpy\\core\\include\\numpy\\arrayobject.h",
-            "C:\\bin\\Python3_8_10\\lib\\site-packages\\numpy\\core\\include\\numpy\\arrayscalars.h",
-            "C:\\bin\\Python3_8_10\\lib\\site-packages\\numpy\\core\\include\\numpy\\ndarrayobject.h",
-            "C:\\bin\\Python3_8_10\\lib\\site-packages\\numpy\\core\\include\\numpy\\ndarraytypes.h",
-            "C:\\bin\\Python3_8_10\\lib\\site-packages\\numpy\\core\\include\\numpy\\ufuncobject.h"
+            "/tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/core/include/numpy/arrayobject.h",
+            "/tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/core/include/numpy/arrayscalars.h",
+            "/tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/core/include/numpy/ndarrayobject.h",
+            "/tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/core/include/numpy/ndarraytypes.h",
+            "/tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/core/include/numpy/ufuncobject.h"
+        ],
+        "extra_compile_args": [
+            "-msse4.2"
         ],
         "include_dirs": [
             "include",
             "include_prv",
-            "C:\\bin\\Python3_8_10\\lib\\site-packages\\numpy\\core\\include"
+            "/tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/core/include"
+        ],
+        "libraries": [
+            "pthread",
+            "m"
         ],
         "name": "pyjls.binding",
         "sources": [
             "pyjls/binding.pyx",
             "src/bit_shift.c",
+            "src/crc32c.c",
             "src/datatype.c",
             "src/ec.c",
             "src/log.c",
             "src/msg_ring_buffer.c",
             "src/raw.c",
             "src/rd_fsr.c",
             "src/reader.c",
             "src/statistics.c",
             "src/threaded_writer.c",
             "src/wr_fsr.c",
             "src/wr_ts.c",
             "src/writer.c",
-            "src/backend_win.c",
-            "src/crc32c_intel_sse4.c"
+            "src/backend_posix.c"
         ]
     },
     "module_name": "pyjls.binding"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
@@ -1033,15 +1040,15 @@
 #if CYTHON_CCOMPLEX && !defined(__cplusplus) && defined(__sun__) && defined(__GNUC__)
   #undef _Complex_I
   #define _Complex_I 1.0fj
 #endif
 
 
 static const char *__pyx_f[] = {
-  "pyjls\\binding.pyx",
+  "pyjls/binding.pyx",
   "stringsource",
   "__init__.pxd",
   "type.pxd",
 };
 /* ForceInitThreads.proto */
 #ifndef __PYX_FORCE_INIT_THREADS
   #define __PYX_FORCE_INIT_THREADS 0
@@ -1143,195 +1150,195 @@
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":689
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":689
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":690
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":690
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":691
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":691
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":692
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":692
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":696
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":696
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":697
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":697
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":698
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":698
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":699
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":699
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":703
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":703
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":704
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":704
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":713
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":713
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":714
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":714
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":715
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":715
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":717
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":717
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":718
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":718
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":719
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":719
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":721
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":721
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":722
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":722
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":724
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":724
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":725
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":725
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":726
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":726
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
@@ -1365,84 +1372,84 @@
 struct __pyx_obj_5pyjls_7binding_AnnotationCallback;
 struct __pyx_obj_5pyjls_7binding_Reader;
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":728
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":728
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":729
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":729
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":730
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":730
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":732
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":732
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
 
-/* "pyjls/binding.pyx":254
+/* "pyjls/binding.pyx":271
  * 
  * 
  * cdef class Writer:             # <<<<<<<<<<<<<<
- *     cdef c_jls.jls_twr_s * _wr
- *     cdef c_jls.jls_signal_def_s _signals[_JLS_SIGNAL_COUNT]
+ *     """Create a new JLS writer.
+ * 
  */
 struct __pyx_obj_5pyjls_7binding_Writer {
   PyObject_HEAD
   struct jls_twr_s *_wr;
   struct jls_signal_def_s _signals[0x100];
 };
 
 
-/* "pyjls/binding.pyx":440
+/* "pyjls/binding.pyx":501
  * 
  * 
  * cdef class AnnotationCallback:             # <<<<<<<<<<<<<<
  *     cdef uint8_t is_fsr
  *     cdef object cbk_fn
  */
 struct __pyx_obj_5pyjls_7binding_AnnotationCallback {
   PyObject_HEAD
   uint8_t is_fsr;
   PyObject *cbk_fn;
 };
 
 
-/* "pyjls/binding.pyx":449
+/* "pyjls/binding.pyx":510
  * 
  * 
  * cdef class Reader:             # <<<<<<<<<<<<<<
- *     cdef c_jls.jls_rd_s * _rd
- *     cdef object _sources
+ *     """Open a JLS v2 file for reading.
+ * 
  */
 struct __pyx_obj_5pyjls_7binding_Reader {
   PyObject_HEAD
   struct jls_rd_s *_rd;
   PyObject *_sources;
   PyObject *_signals;
 };
@@ -1989,36 +1996,14 @@
 #define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
 static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
 #else
 #define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
 #define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
 #endif
 
-/* PyIntBinop.proto */
-#if !CYTHON_COMPILING_IN_PYPY
-static PyObject* __Pyx_PyInt_FloorDivideObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
-#else
-#define __Pyx_PyInt_FloorDivideObjC(op1, op2, intval, inplace, zerodivision_check)\
-    (inplace ? PyNumber_InPlaceFloorDivide(op1, op2) : PyNumber_FloorDivide(op1, op2))
-#endif
-
-/* PyIntBinop.proto */
-#if !CYTHON_COMPILING_IN_PYPY
-static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
-#else
-#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace, zerodivision_check)\
-    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
-#endif
-
-/* DivInt[long].proto */
-static CYTHON_INLINE long __Pyx_div_long(long, long);
-
-/* ExtTypeTest.proto */
-static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
-
 /* GetTopmostException.proto */
 #if CYTHON_USE_EXC_INFO_STACK
 static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
 #endif
 
 /* SaveResetException.proto */
 #if CYTHON_FAST_THREAD_STATE
@@ -2035,14 +2020,66 @@
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
 static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
 #endif
 
+/* PyObjectGetMethod.proto */
+static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);
+
+/* PyObjectCallMethod0.proto */
+static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);
+
+/* RaiseNoneIterError.proto */
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
+
+/* UnpackTupleError.proto */
+static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);
+
+/* UnpackTuple2.proto */
+#define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
+    (likely(is_tuple || PyTuple_Check(tuple)) ?\
+        (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
+            __Pyx_unpack_tuple2_exact(tuple, value1, value2, decref_tuple) :\
+            (__Pyx_UnpackTupleError(tuple, 2), -1)) :\
+        __Pyx_unpack_tuple2_generic(tuple, value1, value2, has_known_size, decref_tuple))
+static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
+    PyObject* tuple, PyObject** value1, PyObject** value2, int decref_tuple);
+static int __Pyx_unpack_tuple2_generic(
+    PyObject* tuple, PyObject** value1, PyObject** value2, int has_known_size, int decref_tuple);
+
+/* dict_iter.proto */
+static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
+                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
+static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
+                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);
+
+/* PyIntBinop.proto */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_FloorDivideObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
+#else
+#define __Pyx_PyInt_FloorDivideObjC(op1, op2, intval, inplace, zerodivision_check)\
+    (inplace ? PyNumber_InPlaceFloorDivide(op1, op2) : PyNumber_FloorDivide(op1, op2))
+#endif
+
+/* PyIntBinop.proto */
+#if !CYTHON_COMPILING_IN_PYPY
+static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
+#else
+#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace, zerodivision_check)\
+    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
+#endif
+
+/* DivInt[long].proto */
+static CYTHON_INLINE long __Pyx_div_long(long, long);
+
+/* ExtTypeTest.proto */
+static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);
+
 /* PySequenceContains.proto */
 static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
     int result = PySequence_Contains(seq, item);
     return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
 }
 
 /* Import.proto */
@@ -2072,17 +2109,14 @@
 
 /* UnaryNegOverflows.proto */
 #define UNARY_NEG_WOULD_OVERFLOW(x)\
         (((x) < 0) & ((unsigned long)(x) == 0-(unsigned long)(x)))
 
 static CYTHON_UNUSED int __pyx_array_getbuffer(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
 static PyObject *__pyx_array_get_memview(struct __pyx_array_obj *); /*proto*/
-/* RaiseNoneIterError.proto */
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);
-
 /* SwapException.proto */
 #if CYTHON_FAST_THREAD_STATE
 #define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
 #else
 static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
 #endif
@@ -2759,14 +2793,15 @@
 static const char __pyx_k_string[] = "string";
 static const char __pyx_k_struct[] = "struct";
 static const char __pyx_k_uint16[] = "uint16";
 static const char __pyx_k_uint32[] = "uint32";
 static const char __pyx_k_uint64[] = "uint64";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
+static const char __pyx_k_values[] = "values";
 static const char __pyx_k_vendor[] = "vendor";
 static const char __pyx_k_HMARKER[] = "HMARKER";
 static const char __pyx_k_Mapping[] = "Mapping";
 static const char __pyx_k_VMARKER[] = "VMARKER";
 static const char __pyx_k_WARNING[] = "WARNING";
 static const char __pyx_k_float32[] = "float32";
 static const char __pyx_k_float64[] = "float64";
@@ -2866,15 +2901,15 @@
 static const char __pyx_k_start_sample_id[] = "start_sample_id";
 static const char __pyx_k_vertical_marker[] = "vertical_marker";
 static const char __pyx_k_data_type_as_str[] = "_data_type_as_str";
 static const char __pyx_k_sample_id_offset[] = "sample_id_offset";
 static const char __pyx_k_samples_per_data[] = "samples_per_data";
 static const char __pyx_k_data_type_as_enum[] = "_data_type_as_enum";
 static const char __pyx_k_horizontal_marker[] = "horizontal_marker";
-static const char __pyx_k_pyjls_binding_pyx[] = "pyjls\\binding.pyx";
+static const char __pyx_k_pyjls_binding_pyx[] = "pyjls/binding.pyx";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
 static const char __pyx_k_rd_fsr_statistics[] = "rd_fsr_statistics";
 static const char __pyx_k_AnnotationCallback[] = "AnnotationCallback";
 static const char __pyx_k_Data_type_mismatch[] = "Data type mismatch ";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_data_type_as_str_2[] = "data_type_as_str";
 static const char __pyx_k_populate_data_type[] = "_populate_data_type";
@@ -2889,33 +2924,38 @@
 static const char __pyx_k_sample_decimate_factor[] = "sample_decimate_factor";
 static const char __pyx_k_sample_id_to_timestamp[] = "sample_id_to_timestamp";
 static const char __pyx_k_timestamp_to_sample_id[] = "timestamp_to_sample_id";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
 static const char __pyx_k_summary_decimate_factor[] = "summary_decimate_factor";
 static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
+static const char __pyx_k_signal_lookup_failed_for[] = "signal_lookup failed for ";
 static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
+static const char __pyx_k_The_FSR_column_enumeration[] = "The FSR column enumeration.";
 static const char __pyx_k_annotation_decimate_factor[] = "annotation_decimate_factor";
+static const char __pyx_k_The_signal_type_enumeration[] = "The signal type enumeration.";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_pyx_unpickle_AnnotationCallbac[] = "__pyx_unpickle_AnnotationCallback";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
 static const char __pyx_k_Python_binding_for_the_native_J[] = "\nPython binding for the native JLS implementation.\n";
+static const char __pyx_k_The_annotation_type_enumeration[] = "The annotation type enumeration.";
 static const char __pyx_k_numpy_core_multiarray_failed_to[] = "numpy.core.multiarray failed to import";
 static const char __pyx_k_self__rd_cannot_be_converted_to[] = "self._rd cannot be converted to a Python object for pickling";
 static const char __pyx_k_self__wr_cannot_be_converted_to[] = "self._wr cannot be converted to a Python object for pickling";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0x03191f0, 0xbf06ca6, 0x802df30) = (cbk_fn, is_fsr))";
 static const char __pyx_k_Indirect_dimensions_not_supporte[] = "Indirect dimensions not supported";
 static const char __pyx_k_Invalid_mode_expected_c_or_fortr[] = "Invalid mode, expected 'c' or 'fortran', got %s";
 static const char __pyx_k_Out_of_bounds_on_buffer_access_a[] = "Out of bounds on buffer access (axis %d)";
+static const char __pyx_k_The_signal_data_type_enumeration[] = "The signal data type enumeration.\n\n    unsigned integers: U1, U4, U8, U16, U32, U64\n    signed integer: I4, I8, I16, I32, I64\n    floating point: F32, F64\n    ";
 static const char __pyx_k_Unable_to_convert_item_to_object[] = "Unable to convert item to object";
 static const char __pyx_k_got_differing_extents_in_dimensi[] = "got differing extents in dimension %d (got %d and %d)";
 static const char __pyx_k_no_default___reduce___due_to_non[] = "no default __reduce__ due to non-trivial __cinit__";
 static const char __pyx_k_numpy_core_umath_failed_to_impor[] = "numpy.core.umath failed to import";
 static const char __pyx_k_unable_to_allocate_shape_and_str[] = "unable to allocate shape and strides.";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0_2[] = "Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))";
 static PyObject *__pyx_kp_u_;
@@ -2984,14 +3024,18 @@
 static PyObject *__pyx_n_s_SignalType;
 static PyObject *__pyx_n_u_SignalType;
 static PyObject *__pyx_n_s_SourceDef;
 static PyObject *__pyx_n_u_SourceDef;
 static PyObject *__pyx_n_s_SummaryFSR;
 static PyObject *__pyx_n_u_SummaryFSR;
 static PyObject *__pyx_n_s_TEXT;
+static PyObject *__pyx_kp_s_The_FSR_column_enumeration;
+static PyObject *__pyx_kp_s_The_annotation_type_enumeration;
+static PyObject *__pyx_kp_s_The_signal_data_type_enumeration;
+static PyObject *__pyx_kp_s_The_signal_type_enumeration;
 static PyObject *__pyx_n_s_TypeError;
 static PyObject *__pyx_n_s_U1;
 static PyObject *__pyx_n_s_U16;
 static PyObject *__pyx_n_s_U32;
 static PyObject *__pyx_n_s_U4;
 static PyObject *__pyx_n_s_U64;
 static PyObject *__pyx_n_s_U8;
@@ -3176,14 +3220,15 @@
 static PyObject *__pyx_n_s_serial_number;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shape;
 static PyObject *__pyx_n_s_signal_def;
 static PyObject *__pyx_n_u_signal_def;
 static PyObject *__pyx_n_s_signal_id;
+static PyObject *__pyx_kp_u_signal_lookup_failed_for;
 static PyObject *__pyx_n_s_signal_type;
 static PyObject *__pyx_n_s_size;
 static PyObject *__pyx_n_s_source_def;
 static PyObject *__pyx_n_u_source_def;
 static PyObject *__pyx_n_s_source_id;
 static PyObject *__pyx_n_s_split;
 static PyObject *__pyx_n_s_start;
@@ -3231,14 +3276,15 @@
 static PyObject *__pyx_n_u_utc;
 static PyObject *__pyx_n_s_utc_decimate_factor;
 static PyObject *__pyx_n_s_utc_i64;
 static PyObject *__pyx_n_s_utc_timestamp;
 static PyObject *__pyx_n_s_utc_to_jls;
 static PyObject *__pyx_kp_u_utf_8;
 static PyObject *__pyx_n_s_value;
+static PyObject *__pyx_n_s_values;
 static PyObject *__pyx_n_s_vendor;
 static PyObject *__pyx_n_s_version;
 static PyObject *__pyx_n_u_vertical_marker;
 static PyObject *__pyx_n_s_view;
 static PyObject *__pyx_n_u_vmarker;
 static PyObject *__pyx_n_s_y;
 static PyObject *__pyx_pf_5pyjls_7binding__data_type_def(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_basetype, PyObject *__pyx_v_size, PyObject *__pyx_v_q); /* proto */
@@ -3272,23 +3318,24 @@
 static PyObject *__pyx_pf_5pyjls_7binding_18AnnotationCallback_4__setstate_cython__(struct __pyx_obj_5pyjls_7binding_AnnotationCallback *__pyx_v_self, PyObject *__pyx_v___pyx_state); /* proto */
 static int __pyx_pf_5pyjls_7binding_6Reader___init__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_path); /* proto */
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_2__enter__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_4__exit__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_type, CYTHON_UNUSED PyObject *__pyx_v_value, CYTHON_UNUSED PyObject *__pyx_v_traceback); /* proto */
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_6close(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_7sources___get__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_7signals___get__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_8fsr(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_length); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_10fsr_statistics(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_increment, PyObject *__pyx_v_length); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_12annotations(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_timestamp, PyObject *__pyx_v_cbk_fn); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_14user_data(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_cbk_fn); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_16utc(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id, PyObject *__pyx_v_cbk_fn); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_18sample_id_to_timestamp(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_20timestamp_to_sample_id(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_utc_timestamp); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_22__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self); /* proto */
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_24__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_8signal_lookup(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_spec); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_10fsr(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_length); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_12fsr_statistics(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_increment, PyObject *__pyx_v_length); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_14annotations(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_timestamp, PyObject *__pyx_v_cbk_fn); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_16user_data(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_cbk_fn); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_18utc(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id, PyObject *__pyx_v_cbk_fn); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_20sample_id_to_timestamp(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_22timestamp_to_sample_id(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_utc_timestamp); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_24__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self); /* proto */
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_26__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state); /* proto */
 static PyObject *__pyx_pf_5pyjls_7binding_20__pyx_unpickle_AnnotationCallback(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_array___pyx_pf_15View_dot_MemoryView_5array_8__getattr__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_attr); /* proto */
@@ -3558,15 +3605,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":120
+/* "pyjls/binding.pyx":126
  * 
  * 
  * def _populate_data_type():             # <<<<<<<<<<<<<<
  *     for key, value in list(_data_type_as_enum.items()):
  *         _data_type_as_enum[value] = value
  */
 
@@ -3597,152 +3644,152 @@
   PyObject *__pyx_t_6 = NULL;
   PyObject *(*__pyx_t_7)(PyObject *);
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_populate_data_type", 0);
 
-  /* "pyjls/binding.pyx":121
+  /* "pyjls/binding.pyx":127
  * 
  * def _populate_data_type():
  *     for key, value in list(_data_type_as_enum.items()):             # <<<<<<<<<<<<<<
  *         _data_type_as_enum[value] = value
  *         _data_type_as_str[value] = key
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 121, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 127, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_items); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 121, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_items); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 127, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_t_2 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_2)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 121, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 127, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 121, __pyx_L1_error)
+  __pyx_t_3 = PySequence_List(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 127, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = __pyx_t_3; __Pyx_INCREF(__pyx_t_1); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   for (;;) {
     if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_1)) break;
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
-    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 121, __pyx_L1_error)
+    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 127, __pyx_L1_error)
     #else
-    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 121, __pyx_L1_error)
+    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 127, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     #endif
     if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
       PyObject* sequence = __pyx_t_3;
       Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
       if (unlikely(size != 2)) {
         if (size > 2) __Pyx_RaiseTooManyValuesError(2);
         else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-        __PYX_ERR(0, 121, __pyx_L1_error)
+        __PYX_ERR(0, 127, __pyx_L1_error)
       }
       #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
       if (likely(PyTuple_CheckExact(sequence))) {
         __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       } else {
         __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
         __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       }
       __Pyx_INCREF(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_5);
       #else
-      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 121, __pyx_L1_error)
+      __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 127, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_2);
-      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 121, __pyx_L1_error)
+      __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 127, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
       #endif
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     } else {
       Py_ssize_t index = -1;
-      __pyx_t_6 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 121, __pyx_L1_error)
+      __pyx_t_6 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 127, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
       index = 0; __pyx_t_2 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_2)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_2);
       index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L5_unpacking_failed;
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 121, __pyx_L1_error)
+      if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 127, __pyx_L1_error)
       __pyx_t_7 = NULL;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       goto __pyx_L6_unpacking_done;
       __pyx_L5_unpacking_failed:;
       __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
       __pyx_t_7 = NULL;
       if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-      __PYX_ERR(0, 121, __pyx_L1_error)
+      __PYX_ERR(0, 127, __pyx_L1_error)
       __pyx_L6_unpacking_done:;
     }
     __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_2);
     __pyx_t_2 = 0;
     __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":122
+    /* "pyjls/binding.pyx":128
  * def _populate_data_type():
  *     for key, value in list(_data_type_as_enum.items()):
  *         _data_type_as_enum[value] = value             # <<<<<<<<<<<<<<
  *         _data_type_as_str[value] = key
  *         _data_type_as_str[key] = key
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 122, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 128, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_value, __pyx_v_value) < 0)) __PYX_ERR(0, 122, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_value, __pyx_v_value) < 0)) __PYX_ERR(0, 128, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "pyjls/binding.pyx":123
+    /* "pyjls/binding.pyx":129
  *     for key, value in list(_data_type_as_enum.items()):
  *         _data_type_as_enum[value] = value
  *         _data_type_as_str[value] = key             # <<<<<<<<<<<<<<
  *         _data_type_as_str[key] = key
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_data_type_as_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 123, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_data_type_as_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 129, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_value, __pyx_v_key) < 0)) __PYX_ERR(0, 123, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_value, __pyx_v_key) < 0)) __PYX_ERR(0, 129, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "pyjls/binding.pyx":124
+    /* "pyjls/binding.pyx":130
  *         _data_type_as_enum[value] = value
  *         _data_type_as_str[value] = key
  *         _data_type_as_str[key] = key             # <<<<<<<<<<<<<<
  * 
  * 
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_data_type_as_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 124, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_data_type_as_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 130, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_key, __pyx_v_key) < 0)) __PYX_ERR(0, 124, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_t_3, __pyx_v_key, __pyx_v_key) < 0)) __PYX_ERR(0, 130, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-    /* "pyjls/binding.pyx":121
+    /* "pyjls/binding.pyx":127
  * 
  * def _populate_data_type():
  *     for key, value in list(_data_type_as_enum.items()):             # <<<<<<<<<<<<<<
  *         _data_type_as_enum[value] = value
  *         _data_type_as_str[value] = key
  */
   }
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":120
+  /* "pyjls/binding.pyx":126
  * 
  * 
  * def _populate_data_type():             # <<<<<<<<<<<<<<
  *     for key, value in list(_data_type_as_enum.items()):
  *         _data_type_as_enum[value] = value
  */
 
@@ -3761,15 +3808,15 @@
   __Pyx_XDECREF(__pyx_v_key);
   __Pyx_XDECREF(__pyx_v_value);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":130
+/* "pyjls/binding.pyx":136
  * 
  * 
  * def data_type_as_enum(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_enum[data_type]
  * 
  */
 
@@ -3793,32 +3840,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("data_type_as_enum", 0);
 
-  /* "pyjls/binding.pyx":131
+  /* "pyjls/binding.pyx":137
  * 
  * def data_type_as_enum(data_type):
  *     return _data_type_as_enum[data_type]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 131, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 137, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_data_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_data_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":130
+  /* "pyjls/binding.pyx":136
  * 
  * 
  * def data_type_as_enum(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_enum[data_type]
  * 
  */
 
@@ -3830,15 +3877,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":134
+/* "pyjls/binding.pyx":140
  * 
  * 
  * def data_type_as_str(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_str[data_type]
  * 
  */
 
@@ -3862,32 +3909,32 @@
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("data_type_as_str", 0);
 
-  /* "pyjls/binding.pyx":135
+  /* "pyjls/binding.pyx":141
  * 
  * def data_type_as_str(data_type):
  *     return _data_type_as_str[data_type]             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_data_type_as_str); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_data_type_as_str); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 141, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_data_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_data_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":134
+  /* "pyjls/binding.pyx":140
  * 
  * 
  * def data_type_as_str(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_str[data_type]
  * 
  */
 
@@ -3899,15 +3946,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":186
+/* "pyjls/binding.pyx":195
  * 
  * 
  * cdef void _log_cbk(const char * msg) nogil:             # <<<<<<<<<<<<<<
  *     with gil:
  *         m = msg.decode('utf-8').strip()
  */
 
@@ -3934,77 +3981,77 @@
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   #ifdef WITH_THREAD
   PyGILState_STATE __pyx_gilstate_save;
   #endif
   __Pyx_RefNannySetupContext("_log_cbk", 1);
 
-  /* "pyjls/binding.pyx":187
+  /* "pyjls/binding.pyx":196
  * 
  * cdef void _log_cbk(const char * msg) nogil:
  *     with gil:             # <<<<<<<<<<<<<<
  *         m = msg.decode('utf-8').strip()
  *         level, location, s = m.split(' ', 2)
  */
   /*try:*/ {
     {
         #ifdef WITH_THREAD
         PyGILState_STATE __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
         #endif
         /*try:*/ {
 
-          /* "pyjls/binding.pyx":188
+          /* "pyjls/binding.pyx":197
  * cdef void _log_cbk(const char * msg) nogil:
  *     with gil:
  *         m = msg.decode('utf-8').strip()             # <<<<<<<<<<<<<<
  *         level, location, s = m.split(' ', 2)
  *         lvl = _log_level_map.get(level, logging.DEBUG)
  */
-          __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 188, __pyx_L7_error)
+          __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_msg, 0, strlen(__pyx_v_msg), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 197, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_2);
-          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_strip); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 188, __pyx_L7_error)
+          __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_strip); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 197, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
           __pyx_t_2 = NULL;
           if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
             __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
             if (likely(__pyx_t_2)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
               __Pyx_INCREF(__pyx_t_2);
               __Pyx_INCREF(function);
               __Pyx_DECREF_SET(__pyx_t_3, function);
             }
           }
           __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
           __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
-          if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L7_error)
+          if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_1);
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           __pyx_v_m = __pyx_t_1;
           __pyx_t_1 = 0;
 
-          /* "pyjls/binding.pyx":189
+          /* "pyjls/binding.pyx":198
  *     with gil:
  *         m = msg.decode('utf-8').strip()
  *         level, location, s = m.split(' ', 2)             # <<<<<<<<<<<<<<
  *         lvl = _log_level_map.get(level, logging.DEBUG)
  *         filename, line, _ = location.split(':')
  */
-          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_m, __pyx_n_s_split); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L7_error)
+          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_m, __pyx_n_s_split); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 189, __pyx_L7_error)
+          __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 198, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
           if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
             PyObject* sequence = __pyx_t_3;
             Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
             if (unlikely(size != 3)) {
               if (size > 3) __Pyx_RaiseTooManyValuesError(3);
               else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-              __PYX_ERR(0, 189, __pyx_L7_error)
+              __PYX_ERR(0, 198, __pyx_L7_error)
             }
             #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
             if (likely(PyTuple_CheckExact(sequence))) {
               __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
               __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
               __pyx_t_4 = PyTuple_GET_ITEM(sequence, 2); 
             } else {
@@ -4012,67 +4059,67 @@
               __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
               __pyx_t_4 = PyList_GET_ITEM(sequence, 2); 
             }
             __Pyx_INCREF(__pyx_t_1);
             __Pyx_INCREF(__pyx_t_2);
             __Pyx_INCREF(__pyx_t_4);
             #else
-            __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 189, __pyx_L7_error)
+            __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 198, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_1);
-            __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 189, __pyx_L7_error)
+            __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 198, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_2);
-            __pyx_t_4 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 189, __pyx_L7_error)
+            __pyx_t_4 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 198, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_4);
             #endif
             __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           } else {
             Py_ssize_t index = -1;
-            __pyx_t_5 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 189, __pyx_L7_error)
+            __pyx_t_5 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 198, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_5);
             __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
             __pyx_t_6 = Py_TYPE(__pyx_t_5)->tp_iternext;
             index = 0; __pyx_t_1 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_1)) goto __pyx_L9_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_1);
             index = 1; __pyx_t_2 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_2)) goto __pyx_L9_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_2);
             index = 2; __pyx_t_4 = __pyx_t_6(__pyx_t_5); if (unlikely(!__pyx_t_4)) goto __pyx_L9_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_4);
-            if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 3) < 0) __PYX_ERR(0, 189, __pyx_L7_error)
+            if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_5), 3) < 0) __PYX_ERR(0, 198, __pyx_L7_error)
             __pyx_t_6 = NULL;
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
             goto __pyx_L10_unpacking_done;
             __pyx_L9_unpacking_failed:;
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
             __pyx_t_6 = NULL;
             if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-            __PYX_ERR(0, 189, __pyx_L7_error)
+            __PYX_ERR(0, 198, __pyx_L7_error)
             __pyx_L10_unpacking_done:;
           }
           __pyx_v_level = __pyx_t_1;
           __pyx_t_1 = 0;
           __pyx_v_location = __pyx_t_2;
           __pyx_t_2 = 0;
           __pyx_v_s = __pyx_t_4;
           __pyx_t_4 = 0;
 
-          /* "pyjls/binding.pyx":190
+          /* "pyjls/binding.pyx":199
  *         m = msg.decode('utf-8').strip()
  *         level, location, s = m.split(' ', 2)
  *         lvl = _log_level_map.get(level, logging.DEBUG)             # <<<<<<<<<<<<<<
  *         filename, line, _ = location.split(':')
  *         record = logging.LogRecord(_log_c_name, lvl, filename, int(line), s, None, None)
  */
-          __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_log_level_map); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 190, __pyx_L7_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_log_level_map); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 199, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_4);
-          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 190, __pyx_L7_error)
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_get); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 199, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_2);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-          __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_logging); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 190, __pyx_L7_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_logging); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 199, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_4);
-          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 190, __pyx_L7_error)
+          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 199, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_1);
           __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
           __pyx_t_4 = NULL;
           __pyx_t_7 = 0;
           if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
             __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
             if (likely(__pyx_t_4)) {
@@ -4082,80 +4129,80 @@
               __Pyx_DECREF_SET(__pyx_t_2, function);
               __pyx_t_7 = 1;
             }
           }
           #if CYTHON_FAST_PYCALL
           if (PyFunction_Check(__pyx_t_2)) {
             PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_level, __pyx_t_1};
-            __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L7_error)
+            __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L7_error)
             __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
           } else
           #endif
           #if CYTHON_FAST_PYCCALL
           if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
             PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_level, __pyx_t_1};
-            __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L7_error)
+            __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L7_error)
             __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
           } else
           #endif
           {
-            __pyx_t_5 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 190, __pyx_L7_error)
+            __pyx_t_5 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 199, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_5);
             if (__pyx_t_4) {
               __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
             }
             __Pyx_INCREF(__pyx_v_level);
             __Pyx_GIVEREF(__pyx_v_level);
             PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_7, __pyx_v_level);
             __Pyx_GIVEREF(__pyx_t_1);
             PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_7, __pyx_t_1);
             __pyx_t_1 = 0;
-            __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 190, __pyx_L7_error)
+            __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 199, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           }
           __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
           __pyx_v_lvl = __pyx_t_3;
           __pyx_t_3 = 0;
 
-          /* "pyjls/binding.pyx":191
+          /* "pyjls/binding.pyx":200
  *         level, location, s = m.split(' ', 2)
  *         lvl = _log_level_map.get(level, logging.DEBUG)
  *         filename, line, _ = location.split(':')             # <<<<<<<<<<<<<<
  *         record = logging.LogRecord(_log_c_name, lvl, filename, int(line), s, None, None)
  *         _log_c.handle(record)
  */
-          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_location, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 191, __pyx_L7_error)
+          __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_location, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 200, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_2);
           __pyx_t_5 = NULL;
           if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
             __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
             if (likely(__pyx_t_5)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
               __Pyx_INCREF(__pyx_t_5);
               __Pyx_INCREF(function);
               __Pyx_DECREF_SET(__pyx_t_2, function);
             }
           }
           __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_kp_u__3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_u__3);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 191, __pyx_L7_error)
+          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 200, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
           if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
             PyObject* sequence = __pyx_t_3;
             Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
             if (unlikely(size != 3)) {
               if (size > 3) __Pyx_RaiseTooManyValuesError(3);
               else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-              __PYX_ERR(0, 191, __pyx_L7_error)
+              __PYX_ERR(0, 200, __pyx_L7_error)
             }
             #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
             if (likely(PyTuple_CheckExact(sequence))) {
               __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
               __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
               __pyx_t_1 = PyTuple_GET_ITEM(sequence, 2); 
             } else {
@@ -4163,67 +4210,67 @@
               __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
               __pyx_t_1 = PyList_GET_ITEM(sequence, 2); 
             }
             __Pyx_INCREF(__pyx_t_2);
             __Pyx_INCREF(__pyx_t_5);
             __Pyx_INCREF(__pyx_t_1);
             #else
-            __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 191, __pyx_L7_error)
+            __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 200, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_2);
-            __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 191, __pyx_L7_error)
+            __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 200, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_5);
-            __pyx_t_1 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 191, __pyx_L7_error)
+            __pyx_t_1 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 200, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_1);
             #endif
             __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
           } else {
             Py_ssize_t index = -1;
-            __pyx_t_4 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 191, __pyx_L7_error)
+            __pyx_t_4 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 200, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_4);
             __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
             __pyx_t_6 = Py_TYPE(__pyx_t_4)->tp_iternext;
             index = 0; __pyx_t_2 = __pyx_t_6(__pyx_t_4); if (unlikely(!__pyx_t_2)) goto __pyx_L11_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_2);
             index = 1; __pyx_t_5 = __pyx_t_6(__pyx_t_4); if (unlikely(!__pyx_t_5)) goto __pyx_L11_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_5);
             index = 2; __pyx_t_1 = __pyx_t_6(__pyx_t_4); if (unlikely(!__pyx_t_1)) goto __pyx_L11_unpacking_failed;
             __Pyx_GOTREF(__pyx_t_1);
-            if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_4), 3) < 0) __PYX_ERR(0, 191, __pyx_L7_error)
+            if (__Pyx_IternextUnpackEndCheck(__pyx_t_6(__pyx_t_4), 3) < 0) __PYX_ERR(0, 200, __pyx_L7_error)
             __pyx_t_6 = NULL;
             __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
             goto __pyx_L12_unpacking_done;
             __pyx_L11_unpacking_failed:;
             __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
             __pyx_t_6 = NULL;
             if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-            __PYX_ERR(0, 191, __pyx_L7_error)
+            __PYX_ERR(0, 200, __pyx_L7_error)
             __pyx_L12_unpacking_done:;
           }
           __pyx_v_filename = __pyx_t_2;
           __pyx_t_2 = 0;
           __pyx_v_line = __pyx_t_5;
           __pyx_t_5 = 0;
           __pyx_v__ = __pyx_t_1;
           __pyx_t_1 = 0;
 
-          /* "pyjls/binding.pyx":192
+          /* "pyjls/binding.pyx":201
  *         lvl = _log_level_map.get(level, logging.DEBUG)
  *         filename, line, _ = location.split(':')
  *         record = logging.LogRecord(_log_c_name, lvl, filename, int(line), s, None, None)             # <<<<<<<<<<<<<<
  *         _log_c.handle(record)
  * 
  */
-          __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_logging); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L7_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_logging); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 201, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_LogRecord); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 192, __pyx_L7_error)
+          __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_LogRecord); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 201, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_5);
           __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-          __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_log_c_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 192, __pyx_L7_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_log_c_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 201, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_1);
-          __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_v_line); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 192, __pyx_L7_error)
+          __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_v_line); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 201, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_2);
           __pyx_t_4 = NULL;
           __pyx_t_7 = 0;
           if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
             __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
             if (likely(__pyx_t_4)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -4232,33 +4279,33 @@
               __Pyx_DECREF_SET(__pyx_t_5, function);
               __pyx_t_7 = 1;
             }
           }
           #if CYTHON_FAST_PYCALL
           if (PyFunction_Check(__pyx_t_5)) {
             PyObject *__pyx_temp[8] = {__pyx_t_4, __pyx_t_1, __pyx_v_lvl, __pyx_v_filename, __pyx_t_2, __pyx_v_s, Py_None, Py_None};
-            __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 7+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L7_error)
+            __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 7+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 201, __pyx_L7_error)
             __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
             __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
           } else
           #endif
           #if CYTHON_FAST_PYCCALL
           if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
             PyObject *__pyx_temp[8] = {__pyx_t_4, __pyx_t_1, __pyx_v_lvl, __pyx_v_filename, __pyx_t_2, __pyx_v_s, Py_None, Py_None};
-            __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 7+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L7_error)
+            __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_7, 7+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 201, __pyx_L7_error)
             __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
             __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
           } else
           #endif
           {
-            __pyx_t_8 = PyTuple_New(7+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 192, __pyx_L7_error)
+            __pyx_t_8 = PyTuple_New(7+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 201, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_8);
             if (__pyx_t_4) {
               __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4); __pyx_t_4 = NULL;
             }
             __Pyx_GIVEREF(__pyx_t_1);
             PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_1);
             __Pyx_INCREF(__pyx_v_lvl);
@@ -4276,53 +4323,53 @@
             __Pyx_GIVEREF(Py_None);
             PyTuple_SET_ITEM(__pyx_t_8, 5+__pyx_t_7, Py_None);
             __Pyx_INCREF(Py_None);
             __Pyx_GIVEREF(Py_None);
             PyTuple_SET_ITEM(__pyx_t_8, 6+__pyx_t_7, Py_None);
             __pyx_t_1 = 0;
             __pyx_t_2 = 0;
-            __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 192, __pyx_L7_error)
+            __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 201, __pyx_L7_error)
             __Pyx_GOTREF(__pyx_t_3);
             __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
           }
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __pyx_v_record = __pyx_t_3;
           __pyx_t_3 = 0;
 
-          /* "pyjls/binding.pyx":193
+          /* "pyjls/binding.pyx":202
  *         filename, line, _ = location.split(':')
  *         record = logging.LogRecord(_log_c_name, lvl, filename, int(line), s, None, None)
  *         _log_c.handle(record)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-          __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_log_c); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 193, __pyx_L7_error)
+          __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_log_c); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 202, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_5);
-          __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_handle); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 193, __pyx_L7_error)
+          __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_handle); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 202, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_8);
           __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
           __pyx_t_5 = NULL;
           if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
             __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_8);
             if (likely(__pyx_t_5)) {
               PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
               __Pyx_INCREF(__pyx_t_5);
               __Pyx_INCREF(function);
               __Pyx_DECREF_SET(__pyx_t_8, function);
             }
           }
           __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_5, __pyx_v_record) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_record);
           __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 193, __pyx_L7_error)
+          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 202, __pyx_L7_error)
           __Pyx_GOTREF(__pyx_t_3);
           __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
           __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
         }
 
-        /* "pyjls/binding.pyx":187
+        /* "pyjls/binding.pyx":196
  * 
  * cdef void _log_cbk(const char * msg) nogil:
  *     with gil:             # <<<<<<<<<<<<<<
  *         m = msg.decode('utf-8').strip()
  *         level, location, s = m.split(' ', 2)
  */
         /*finally:*/ {
@@ -4354,15 +4401,15 @@
       __pyx_gilstate_save = __Pyx_PyGILState_Ensure();
       #endif
       goto __pyx_L1_error;
     }
     __pyx_L5:;
   }
 
-  /* "pyjls/binding.pyx":186
+  /* "pyjls/binding.pyx":195
  * 
  * 
  * cdef void _log_cbk(const char * msg) nogil:             # <<<<<<<<<<<<<<
  *     with gil:
  *         m = msg.decode('utf-8').strip()
  */
 
@@ -4387,15 +4434,15 @@
   __Pyx_XDECREF(__pyx_v__);
   __Pyx_XDECREF(__pyx_v_record);
   #ifdef WITH_THREAD
   __Pyx_PyGILState_Release(__pyx_gilstate_save);
   #endif
 }
 
-/* "pyjls/binding.pyx":199
+/* "pyjls/binding.pyx":208
  * 
  * 
  * def jls_inject_log(level, filename, line, msg):             # <<<<<<<<<<<<<<
  *     cdef char * c_msg
  *     location = ':'.join([filename, str(line), ''])
  */
 
@@ -4436,31 +4483,31 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_level)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_filename)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, 1); __PYX_ERR(0, 199, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, 1); __PYX_ERR(0, 208, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_line)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, 2); __PYX_ERR(0, 199, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, 2); __PYX_ERR(0, 208, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_msg)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, 3); __PYX_ERR(0, 199, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, 3); __PYX_ERR(0, 208, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "jls_inject_log") < 0)) __PYX_ERR(0, 199, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "jls_inject_log") < 0)) __PYX_ERR(0, 208, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -4469,15 +4516,15 @@
     __pyx_v_level = values[0];
     __pyx_v_filename = values[1];
     __pyx_v_line = values[2];
     __pyx_v_msg = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 199, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("jls_inject_log", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 208, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.jls_inject_log", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_8jls_inject_log(__pyx_self, __pyx_v_level, __pyx_v_filename, __pyx_v_line, __pyx_v_msg);
 
@@ -4497,88 +4544,88 @@
   char const *__pyx_t_4;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("jls_inject_log", 0);
   __Pyx_INCREF(__pyx_v_msg);
 
-  /* "pyjls/binding.pyx":201
+  /* "pyjls/binding.pyx":210
  * def jls_inject_log(level, filename, line, msg):
  *     cdef char * c_msg
  *     location = ':'.join([filename, str(line), ''])             # <<<<<<<<<<<<<<
  *     msg = ' '.join([level, location, msg]).encode('utf-8')
  *     c_msg = msg
  */
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_line); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 201, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_line); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 210, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 201, __pyx_L1_error)
+  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 210, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_filename);
   __Pyx_GIVEREF(__pyx_v_filename);
   PyList_SET_ITEM(__pyx_t_2, 0, __pyx_v_filename);
   __Pyx_GIVEREF(__pyx_t_1);
   PyList_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
   __Pyx_INCREF(__pyx_kp_u__4);
   __Pyx_GIVEREF(__pyx_kp_u__4);
   PyList_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u__4);
   __pyx_t_1 = 0;
-  __pyx_t_1 = PyUnicode_Join(__pyx_kp_u__3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 201, __pyx_L1_error)
+  __pyx_t_1 = PyUnicode_Join(__pyx_kp_u__3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 210, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_location = ((PyObject*)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":202
+  /* "pyjls/binding.pyx":211
  *     cdef char * c_msg
  *     location = ':'.join([filename, str(line), ''])
  *     msg = ' '.join([level, location, msg]).encode('utf-8')             # <<<<<<<<<<<<<<
  *     c_msg = msg
  *     c_jls.jls_log_printf('%s\n'.encode('utf-8'), c_msg)
  */
-  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_v_level);
   __Pyx_GIVEREF(__pyx_v_level);
   PyList_SET_ITEM(__pyx_t_1, 0, __pyx_v_level);
   __Pyx_INCREF(__pyx_v_location);
   __Pyx_GIVEREF(__pyx_v_location);
   PyList_SET_ITEM(__pyx_t_1, 1, __pyx_v_location);
   __Pyx_INCREF(__pyx_v_msg);
   __Pyx_GIVEREF(__pyx_v_msg);
   PyList_SET_ITEM(__pyx_t_1, 2, __pyx_v_msg);
-  __pyx_t_2 = PyUnicode_Join(__pyx_kp_u_, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_t_2 = PyUnicode_Join(__pyx_kp_u_, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = PyUnicode_AsUTF8String(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 202, __pyx_L1_error)
+  __pyx_t_1 = PyUnicode_AsUTF8String(((PyObject*)__pyx_t_2)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 211, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF_SET(__pyx_v_msg, __pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":203
+  /* "pyjls/binding.pyx":212
  *     location = ':'.join([filename, str(line), ''])
  *     msg = ' '.join([level, location, msg]).encode('utf-8')
  *     c_msg = msg             # <<<<<<<<<<<<<<
  *     c_jls.jls_log_printf('%s\n'.encode('utf-8'), c_msg)
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_AsWritableString(__pyx_v_msg); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 203, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_AsWritableString(__pyx_v_msg); if (unlikely((!__pyx_t_3) && PyErr_Occurred())) __PYX_ERR(0, 212, __pyx_L1_error)
   __pyx_v_c_msg = __pyx_t_3;
 
-  /* "pyjls/binding.pyx":204
+  /* "pyjls/binding.pyx":213
  *     msg = ' '.join([level, location, msg]).encode('utf-8')
  *     c_msg = msg
  *     c_jls.jls_log_printf('%s\n'.encode('utf-8'), c_msg)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_4 = __Pyx_PyBytes_AsString(__pyx_kp_b_s); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 204, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyBytes_AsString(__pyx_kp_b_s); if (unlikely((!__pyx_t_4) && PyErr_Occurred())) __PYX_ERR(0, 213, __pyx_L1_error)
   jls_log_printf(__pyx_t_4, __pyx_v_c_msg);
 
-  /* "pyjls/binding.pyx":199
+  /* "pyjls/binding.pyx":208
  * 
  * 
  * def jls_inject_log(level, filename, line, msg):             # <<<<<<<<<<<<<<
  *     cdef char * c_msg
  *     location = ':'.join([filename, str(line), ''])
  */
 
@@ -4594,15 +4641,15 @@
   __Pyx_XDECREF(__pyx_v_location);
   __Pyx_XDECREF(__pyx_v_msg);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":207
+/* "pyjls/binding.pyx":216
  * 
  * 
  * def _encode_str(s):             # <<<<<<<<<<<<<<
  *     if s is None:
  *         s = ''
  */
 
@@ -4630,77 +4677,77 @@
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_encode_str", 0);
   __Pyx_INCREF(__pyx_v_s);
 
-  /* "pyjls/binding.pyx":208
+  /* "pyjls/binding.pyx":217
  * 
  * def _encode_str(s):
  *     if s is None:             # <<<<<<<<<<<<<<
  *         s = ''
  *     return s.encode('utf-8') + b'\x00'
  */
   __pyx_t_1 = (__pyx_v_s == Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "pyjls/binding.pyx":209
+    /* "pyjls/binding.pyx":218
  * def _encode_str(s):
  *     if s is None:
  *         s = ''             # <<<<<<<<<<<<<<
  *     return s.encode('utf-8') + b'\x00'
  * 
  */
     __Pyx_INCREF(__pyx_kp_u__4);
     __Pyx_DECREF_SET(__pyx_v_s, __pyx_kp_u__4);
 
-    /* "pyjls/binding.pyx":208
+    /* "pyjls/binding.pyx":217
  * 
  * def _encode_str(s):
  *     if s is None:             # <<<<<<<<<<<<<<
  *         s = ''
  *     return s.encode('utf-8') + b'\x00'
  */
   }
 
-  /* "pyjls/binding.pyx":210
+  /* "pyjls/binding.pyx":219
  *     if s is None:
  *         s = ''
  *     return s.encode('utf-8') + b'\x00'             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 210, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_encode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 219, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_u_utf_8);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 210, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 219, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_4 = PyNumber_Add(__pyx_t_3, __pyx_kp_b__5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 210, __pyx_L1_error)
+  __pyx_t_4 = PyNumber_Add(__pyx_t_3, __pyx_kp_b__5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 219, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":207
+  /* "pyjls/binding.pyx":216
  * 
  * 
  * def _encode_str(s):             # <<<<<<<<<<<<<<
  *     if s is None:
  *         s = ''
  */
 
@@ -4714,15 +4761,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_s);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":213
+/* "pyjls/binding.pyx":222
  * 
  * 
  * def _storage_pack(data):             # <<<<<<<<<<<<<<
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  */
 
@@ -4753,210 +4800,210 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_storage_pack", 0);
 
-  /* "pyjls/binding.pyx":214
+  /* "pyjls/binding.pyx":223
  * 
  * def _storage_pack(data):
  *     if data is None:             # <<<<<<<<<<<<<<
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  *     elif isinstance(data, str):
  */
   __pyx_t_1 = (__pyx_v_data == Py_None);
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "pyjls/binding.pyx":215
+    /* "pyjls/binding.pyx":224
  * def _storage_pack(data):
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0             # <<<<<<<<<<<<<<
  *     elif isinstance(data, str):
  *         s = _encode_str(data)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_BINARY); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_BINARY); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 224, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 215, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 224, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
     __Pyx_INCREF(__pyx_kp_b__4);
     __Pyx_GIVEREF(__pyx_kp_b__4);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_kp_b__4);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_int_0);
     __pyx_t_3 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
 
-    /* "pyjls/binding.pyx":214
+    /* "pyjls/binding.pyx":223
  * 
  * def _storage_pack(data):
  *     if data is None:             # <<<<<<<<<<<<<<
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  *     elif isinstance(data, str):
  */
   }
 
-  /* "pyjls/binding.pyx":216
+  /* "pyjls/binding.pyx":225
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  *     elif isinstance(data, str):             # <<<<<<<<<<<<<<
  *         s = _encode_str(data)
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)
  */
   __pyx_t_2 = PyUnicode_Check(__pyx_v_data); 
   __pyx_t_1 = (__pyx_t_2 != 0);
   if (__pyx_t_1) {
 
-    /* "pyjls/binding.pyx":217
+    /* "pyjls/binding.pyx":226
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  *     elif isinstance(data, str):
  *         s = _encode_str(data)             # <<<<<<<<<<<<<<
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)
  *     elif isinstance(data, bytes):
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 217, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 226, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_t_5 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_5)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_5);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_data);
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 217, __pyx_L1_error)
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 226, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_s = __pyx_t_4;
     __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":218
+    /* "pyjls/binding.pyx":227
  *     elif isinstance(data, str):
  *         s = _encode_str(data)
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)             # <<<<<<<<<<<<<<
  *     elif isinstance(data, bytes):
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, data, len(data)
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_STRING); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 218, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_STRING); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 227, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PyObject_Length(__pyx_v_s); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 218, __pyx_L1_error)
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 218, __pyx_L1_error)
+    __pyx_t_6 = PyObject_Length(__pyx_v_s); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 227, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 227, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 218, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 227, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __Pyx_INCREF(__pyx_v_s);
     __Pyx_GIVEREF(__pyx_v_s);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_s);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_3);
     __pyx_t_4 = 0;
     __pyx_t_3 = 0;
     __pyx_r = __pyx_t_5;
     __pyx_t_5 = 0;
     goto __pyx_L0;
 
-    /* "pyjls/binding.pyx":216
+    /* "pyjls/binding.pyx":225
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  *     elif isinstance(data, str):             # <<<<<<<<<<<<<<
  *         s = _encode_str(data)
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)
  */
   }
 
-  /* "pyjls/binding.pyx":219
+  /* "pyjls/binding.pyx":228
  *         s = _encode_str(data)
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)
  *     elif isinstance(data, bytes):             # <<<<<<<<<<<<<<
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, data, len(data)
  *     else:
  */
   __pyx_t_1 = PyBytes_Check(__pyx_v_data); 
   __pyx_t_2 = (__pyx_t_1 != 0);
   if (__pyx_t_2) {
 
-    /* "pyjls/binding.pyx":220
+    /* "pyjls/binding.pyx":229
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)
  *     elif isinstance(data, bytes):
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, data, len(data)             # <<<<<<<<<<<<<<
  *     else:
  *         s = _encode_str(json.dumps(data))
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_5 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_BINARY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 220, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_BINARY); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 229, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 220, __pyx_L1_error)
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 220, __pyx_L1_error)
+    __pyx_t_6 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 229, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 229, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 220, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 229, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_v_data);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
     __pyx_t_5 = 0;
     __pyx_t_3 = 0;
     __pyx_r = __pyx_t_4;
     __pyx_t_4 = 0;
     goto __pyx_L0;
 
-    /* "pyjls/binding.pyx":219
+    /* "pyjls/binding.pyx":228
  *         s = _encode_str(data)
  *         return c_jls.JLS_STORAGE_TYPE_STRING, s, len(s)
  *     elif isinstance(data, bytes):             # <<<<<<<<<<<<<<
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, data, len(data)
  *     else:
  */
   }
 
-  /* "pyjls/binding.pyx":222
+  /* "pyjls/binding.pyx":231
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, data, len(data)
  *     else:
  *         s = _encode_str(json.dumps(data))             # <<<<<<<<<<<<<<
  *         return c_jls.JLS_STORAGE_TYPE_JSON, s, len(s)
  * 
  */
   /*else*/ {
-    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 222, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 231, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_json); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 222, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_json); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 231, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_dumps); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 222, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_dumps); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 231, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __pyx_t_7 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
       __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_8);
       if (likely(__pyx_t_7)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
         __Pyx_INCREF(__pyx_t_7);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_8, function);
       }
     }
     __pyx_t_5 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_7, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_data);
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
-    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 222, __pyx_L1_error)
+    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 231, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __pyx_t_8 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_8)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -4964,34 +5011,34 @@
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_4 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_8, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5);
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 222, __pyx_L1_error)
+    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 231, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_s = __pyx_t_4;
     __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":223
+    /* "pyjls/binding.pyx":232
  *     else:
  *         s = _encode_str(json.dumps(data))
  *         return c_jls.JLS_STORAGE_TYPE_JSON, s, len(s)             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_4 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_JSON); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 223, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_enum__jls_storage_type_e(JLS_STORAGE_TYPE_JSON); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_6 = PyObject_Length(__pyx_v_s); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 223, __pyx_L1_error)
-    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 223, __pyx_L1_error)
+    __pyx_t_6 = PyObject_Length(__pyx_v_s); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 232, __pyx_L1_error)
+    __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 223, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 232, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
     __Pyx_INCREF(__pyx_v_s);
     __Pyx_GIVEREF(__pyx_v_s);
     PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_s);
     __Pyx_GIVEREF(__pyx_t_3);
@@ -4999,15 +5046,15 @@
     __pyx_t_4 = 0;
     __pyx_t_3 = 0;
     __pyx_r = __pyx_t_5;
     __pyx_t_5 = 0;
     goto __pyx_L0;
   }
 
-  /* "pyjls/binding.pyx":213
+  /* "pyjls/binding.pyx":222
  * 
  * 
  * def _storage_pack(data):             # <<<<<<<<<<<<<<
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  */
 
@@ -5023,15 +5070,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_s);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":226
+/* "pyjls/binding.pyx":235
  * 
  * 
  * cdef _storage_unpack(uint8_t storage_type, const uint8_t * data, uint32_t data_size):             # <<<<<<<<<<<<<<
  *     cdef const char * str = <const char *> data
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:
  */
 
@@ -5044,119 +5091,119 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_storage_unpack", 0);
 
-  /* "pyjls/binding.pyx":227
+  /* "pyjls/binding.pyx":236
  * 
  * cdef _storage_unpack(uint8_t storage_type, const uint8_t * data, uint32_t data_size):
  *     cdef const char * str = <const char *> data             # <<<<<<<<<<<<<<
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:
  *         return str[:data_size - 1].decode('utf-8')
  */
   __pyx_v_str = ((char const *)__pyx_v_data);
 
-  /* "pyjls/binding.pyx":228
+  /* "pyjls/binding.pyx":237
  * cdef _storage_unpack(uint8_t storage_type, const uint8_t * data, uint32_t data_size):
  *     cdef const char * str = <const char *> data
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:             # <<<<<<<<<<<<<<
  *         return str[:data_size - 1].decode('utf-8')
  *     elif storage_type == c_jls.JLS_STORAGE_TYPE_BINARY:
  */
   switch (__pyx_v_storage_type) {
     case JLS_STORAGE_TYPE_STRING:
 
-    /* "pyjls/binding.pyx":229
+    /* "pyjls/binding.pyx":238
  *     cdef const char * str = <const char *> data
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:
  *         return str[:data_size - 1].decode('utf-8')             # <<<<<<<<<<<<<<
  *     elif storage_type == c_jls.JLS_STORAGE_TYPE_BINARY:
  *         return data[:data_size]
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_decode_c_string(__pyx_v_str, 0, (__pyx_v_data_size - 1), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 229, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_decode_c_string(__pyx_v_str, 0, (__pyx_v_data_size - 1), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "pyjls/binding.pyx":228
+    /* "pyjls/binding.pyx":237
  * cdef _storage_unpack(uint8_t storage_type, const uint8_t * data, uint32_t data_size):
  *     cdef const char * str = <const char *> data
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:             # <<<<<<<<<<<<<<
  *         return str[:data_size - 1].decode('utf-8')
  *     elif storage_type == c_jls.JLS_STORAGE_TYPE_BINARY:
  */
     break;
     case JLS_STORAGE_TYPE_BINARY:
 
-    /* "pyjls/binding.pyx":231
+    /* "pyjls/binding.pyx":240
  *         return str[:data_size - 1].decode('utf-8')
  *     elif storage_type == c_jls.JLS_STORAGE_TYPE_BINARY:
  *         return data[:data_size]             # <<<<<<<<<<<<<<
  *     else:
  *         return json.loads(str[:data_size - 1].decode('utf-8'))
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data) + 0, __pyx_v_data_size - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 231, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(((const char*)__pyx_v_data) + 0, __pyx_v_data_size - 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
 
-    /* "pyjls/binding.pyx":230
+    /* "pyjls/binding.pyx":239
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:
  *         return str[:data_size - 1].decode('utf-8')
  *     elif storage_type == c_jls.JLS_STORAGE_TYPE_BINARY:             # <<<<<<<<<<<<<<
  *         return data[:data_size]
  *     else:
  */
     break;
     default:
 
-    /* "pyjls/binding.pyx":233
+    /* "pyjls/binding.pyx":242
  *         return data[:data_size]
  *     else:
  *         return json.loads(str[:data_size - 1].decode('utf-8'))             # <<<<<<<<<<<<<<
  * 
  * 
  */
     __Pyx_XDECREF(__pyx_r);
-    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_json); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 233, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_json); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 242, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
-    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_loads); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 233, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_loads); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 242, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_str, 0, (__pyx_v_data_size - 1), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 233, __pyx_L1_error)
+    __pyx_t_2 = __Pyx_decode_c_string(__pyx_v_str, 0, (__pyx_v_data_size - 1), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 242, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_2);
     __pyx_t_4 = NULL;
     if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
       __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
       if (likely(__pyx_t_4)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
         __Pyx_INCREF(__pyx_t_4);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_3, function);
       }
     }
     __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2);
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 233, __pyx_L1_error)
+    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 242, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_r = __pyx_t_1;
     __pyx_t_1 = 0;
     goto __pyx_L0;
     break;
   }
 
-  /* "pyjls/binding.pyx":226
+  /* "pyjls/binding.pyx":235
  * 
  * 
  * cdef _storage_unpack(uint8_t storage_type, const uint8_t * data, uint32_t data_size):             # <<<<<<<<<<<<<<
  *     cdef const char * str = <const char *> data
  *     if storage_type == c_jls.JLS_STORAGE_TYPE_STRING:
  */
 
@@ -5170,15 +5217,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":236
+/* "pyjls/binding.pyx":245
  * 
  * 
  * def utc_to_jls(utc):             # <<<<<<<<<<<<<<
  *     """Convert from python UTC timestamp to jls timestamp."""
  *     return int((utc - _UTC_OFFSET) * SECOND)
  */
 
@@ -5204,41 +5251,41 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("utc_to_jls", 0);
 
-  /* "pyjls/binding.pyx":238
+  /* "pyjls/binding.pyx":247
  * def utc_to_jls(utc):
  *     """Convert from python UTC timestamp to jls timestamp."""
  *     return int((utc - _UTC_OFFSET) * SECOND)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_UTC_OFFSET); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_UTC_OFFSET); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = PyNumber_Subtract(__pyx_v_utc, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_t_2 = PyNumber_Subtract(__pyx_v_utc, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 247, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_SECOND); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_SECOND); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyNumber_Multiply(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Multiply(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 247, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 238, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyNumber_Int(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":236
+  /* "pyjls/binding.pyx":245
  * 
  * 
  * def utc_to_jls(utc):             # <<<<<<<<<<<<<<
  *     """Convert from python UTC timestamp to jls timestamp."""
  *     return int((utc - _UTC_OFFSET) * SECOND)
  */
 
@@ -5251,25 +5298,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":241
+/* "pyjls/binding.pyx":250
  * 
  * 
  * def jls_to_utc(timestamp):             # <<<<<<<<<<<<<<
- *     """Convert from jls timestamp to python UTC timestamp."""
- *     return (timestamp / SECOND) + _UTC_OFFSET
+ *     """Convert from jls timestamp to python UTC timestamp.
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_17jls_to_utc(PyObject *__pyx_self, PyObject *__pyx_v_timestamp); /*proto*/
-static char __pyx_doc_5pyjls_7binding_16jls_to_utc[] = "Convert from jls timestamp to python UTC timestamp.";
+static char __pyx_doc_5pyjls_7binding_16jls_to_utc[] = "Convert from jls timestamp to python UTC timestamp.\n\n    :param timestamp: The JLS timestamp.\n    :return: The python UTC timestamp.\n\n    Note that python timestamps usually have lower resolution than\n    the JLS timestamps.  When full resolution is required,\n    use relative JLS timestamp offsets to maintain precision.\n    ";
 static PyMethodDef __pyx_mdef_5pyjls_7binding_17jls_to_utc = {"jls_to_utc", (PyCFunction)__pyx_pw_5pyjls_7binding_17jls_to_utc, METH_O, __pyx_doc_5pyjls_7binding_16jls_to_utc};
 static PyObject *__pyx_pw_5pyjls_7binding_17jls_to_utc(PyObject *__pyx_self, PyObject *__pyx_v_timestamp) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("jls_to_utc (wrapper)", 0);
   __pyx_r = __pyx_pf_5pyjls_7binding_16jls_to_utc(__pyx_self, ((PyObject *)__pyx_v_timestamp));
 
@@ -5285,43 +5332,43 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("jls_to_utc", 0);
 
-  /* "pyjls/binding.pyx":243
- * def jls_to_utc(timestamp):
- *     """Convert from jls timestamp to python UTC timestamp."""
+  /* "pyjls/binding.pyx":260
+ *     use relative JLS timestamp offsets to maintain precision.
+ *     """
  *     return (timestamp / SECOND) + _UTC_OFFSET             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_SECOND); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_SECOND); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyNumber_Divide(__pyx_v_timestamp, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyNumber_Divide(__pyx_v_timestamp, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 260, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_UTC_OFFSET); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_UTC_OFFSET); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 260, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 243, __pyx_L1_error)
+  __pyx_t_3 = PyNumber_Add(__pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 260, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":241
+  /* "pyjls/binding.pyx":250
  * 
  * 
  * def jls_to_utc(timestamp):             # <<<<<<<<<<<<<<
- *     """Convert from jls timestamp to python UTC timestamp."""
- *     return (timestamp / SECOND) + _UTC_OFFSET
+ *     """Convert from jls timestamp to python UTC timestamp.
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -5329,15 +5376,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":246
+/* "pyjls/binding.pyx":263
  * 
  * 
  * def _handle_rc(name, rc):             # <<<<<<<<<<<<<<
  *     if rc == 0:
  *         return
  */
 
@@ -5372,32 +5419,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_rc)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("_handle_rc", 1, 2, 2, 1); __PYX_ERR(0, 246, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("_handle_rc", 1, 2, 2, 1); __PYX_ERR(0, 263, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_handle_rc") < 0)) __PYX_ERR(0, 246, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_handle_rc") < 0)) __PYX_ERR(0, 263, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_name = values[0];
     __pyx_v_rc = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("_handle_rc", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 246, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("_handle_rc", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 263, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding._handle_rc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_18_handle_rc(__pyx_self, __pyx_v_name, __pyx_v_rc);
 
@@ -5420,139 +5467,139 @@
   Py_UCS4 __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_handle_rc", 0);
 
-  /* "pyjls/binding.pyx":247
+  /* "pyjls/binding.pyx":264
  * 
  * def _handle_rc(name, rc):
  *     if rc == 0:             # <<<<<<<<<<<<<<
  *         return
  *     rc_name = c_jls.jls_error_code_name(rc).decode('utf-8')
  */
-  __pyx_t_1 = __Pyx_PyInt_EqObjC(__pyx_v_rc, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 247, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_EqObjC(__pyx_v_rc, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 264, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 247, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 264, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   if (__pyx_t_2) {
 
-    /* "pyjls/binding.pyx":248
+    /* "pyjls/binding.pyx":265
  * def _handle_rc(name, rc):
  *     if rc == 0:
  *         return             # <<<<<<<<<<<<<<
  *     rc_name = c_jls.jls_error_code_name(rc).decode('utf-8')
  *     rc_descr = c_jls.jls_error_code_description(rc).decode('utf-8')
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "pyjls/binding.pyx":247
+    /* "pyjls/binding.pyx":264
  * 
  * def _handle_rc(name, rc):
  *     if rc == 0:             # <<<<<<<<<<<<<<
  *         return
  *     rc_name = c_jls.jls_error_code_name(rc).decode('utf-8')
  */
   }
 
-  /* "pyjls/binding.pyx":249
+  /* "pyjls/binding.pyx":266
  *     if rc == 0:
  *         return
  *     rc_name = c_jls.jls_error_code_name(rc).decode('utf-8')             # <<<<<<<<<<<<<<
  *     rc_descr = c_jls.jls_error_code_description(rc).decode('utf-8')
  *     raise RuntimeError(f'{name} {rc_name}[{rc}]: {rc_descr}')
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_rc); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_rc); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 266, __pyx_L1_error)
   __pyx_t_4 = jls_error_code_name(__pyx_t_3);
-  __pyx_t_1 = __Pyx_decode_c_string(__pyx_t_4, 0, strlen(__pyx_t_4), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 249, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_decode_c_string(__pyx_t_4, 0, strlen(__pyx_t_4), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 266, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_rc_name = __pyx_t_1;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":250
+  /* "pyjls/binding.pyx":267
  *         return
  *     rc_name = c_jls.jls_error_code_name(rc).decode('utf-8')
  *     rc_descr = c_jls.jls_error_code_description(rc).decode('utf-8')             # <<<<<<<<<<<<<<
  *     raise RuntimeError(f'{name} {rc_name}[{rc}]: {rc_descr}')
  * 
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_rc); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 250, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int(__pyx_v_rc); if (unlikely((__pyx_t_3 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 267, __pyx_L1_error)
   __pyx_t_5 = jls_error_code_description(__pyx_t_3);
-  __pyx_t_1 = __Pyx_decode_c_string(__pyx_t_5, 0, strlen(__pyx_t_5), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 250, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_decode_c_string(__pyx_t_5, 0, strlen(__pyx_t_5), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_rc_descr = __pyx_t_1;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":251
+  /* "pyjls/binding.pyx":268
  *     rc_name = c_jls.jls_error_code_name(rc).decode('utf-8')
  *     rc_descr = c_jls.jls_error_code_description(rc).decode('utf-8')
  *     raise RuntimeError(f'{name} {rc_name}[{rc}]: {rc_descr}')             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_6 = 0;
   __pyx_t_7 = 127;
-  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_7;
   __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
   __Pyx_GIVEREF(__pyx_t_8);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_8);
   __pyx_t_8 = 0;
   __Pyx_INCREF(__pyx_kp_u_);
   __pyx_t_6 += 1;
   __Pyx_GIVEREF(__pyx_kp_u_);
   PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u_);
-  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_rc_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_rc_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_7;
   __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
   __Pyx_GIVEREF(__pyx_t_8);
   PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_8);
   __pyx_t_8 = 0;
   __Pyx_INCREF(__pyx_kp_u__6);
   __pyx_t_6 += 1;
   __Pyx_GIVEREF(__pyx_kp_u__6);
   PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_kp_u__6);
-  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_rc, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_rc, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_7;
   __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
   __Pyx_GIVEREF(__pyx_t_8);
   PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_t_8);
   __pyx_t_8 = 0;
   __Pyx_INCREF(__pyx_kp_u__7);
   __pyx_t_6 += 3;
   __Pyx_GIVEREF(__pyx_kp_u__7);
   PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_kp_u__7);
-  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_rc_descr, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_v_rc_descr, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_7;
   __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
   __Pyx_GIVEREF(__pyx_t_8);
   PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_t_8);
   __pyx_t_8 = 0;
-  __pyx_t_8 = __Pyx_PyUnicode_Join(__pyx_t_1, 7, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyUnicode_Join(__pyx_t_1, 7, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_RuntimeError, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 251, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_RuntimeError, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 268, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_Raise(__pyx_t_1, 0, 0, 0);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __PYX_ERR(0, 251, __pyx_L1_error)
+  __PYX_ERR(0, 268, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":246
+  /* "pyjls/binding.pyx":263
  * 
  * 
  * def _handle_rc(name, rc):             # <<<<<<<<<<<<<<
  *     if rc == 0:
  *         return
  */
 
@@ -5566,15 +5613,15 @@
   __Pyx_XDECREF(__pyx_v_rc_name);
   __Pyx_XDECREF(__pyx_v_rc_descr);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":258
+/* "pyjls/binding.pyx":279
  *     cdef c_jls.jls_signal_def_s _signals[_JLS_SIGNAL_COUNT]
  * 
  *     def __init__(self, path: str):             # <<<<<<<<<<<<<<
  *         cdef c_jls.jls_twr_s ** wr_ptr = &self._wr
  *         cdef int32_t rc
  */
 
@@ -5603,32 +5650,32 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 258, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 279, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_path = ((PyObject*)values[0]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 258, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 279, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_path), (&PyUnicode_Type), 1, "path", 1))) __PYX_ERR(0, 258, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_path), (&PyUnicode_Type), 1, "path", 1))) __PYX_ERR(0, 279, __pyx_L1_error)
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer___init__(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_path);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
@@ -5652,96 +5699,96 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "pyjls/binding.pyx":259
+  /* "pyjls/binding.pyx":280
  * 
  *     def __init__(self, path: str):
  *         cdef c_jls.jls_twr_s ** wr_ptr = &self._wr             # <<<<<<<<<<<<<<
  *         cdef int32_t rc
  *         cdef const uint8_t[:] path_u8
  */
   __pyx_v_wr_ptr = (&__pyx_v_self->_wr);
 
-  /* "pyjls/binding.pyx":262
+  /* "pyjls/binding.pyx":283
  *         cdef int32_t rc
  *         cdef const uint8_t[:] path_u8
  *         path_bytes = path.encode('utf-8')             # <<<<<<<<<<<<<<
  *         path_u8 = path_bytes
  *         self._signals[0].signal_type = c_jls.JLS_SIGNAL_TYPE_VSR
  */
   if (unlikely(__pyx_v_path == Py_None)) {
     PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "encode");
-    __PYX_ERR(0, 262, __pyx_L1_error)
+    __PYX_ERR(0, 283, __pyx_L1_error)
   }
-  __pyx_t_1 = PyUnicode_AsUTF8String(__pyx_v_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 262, __pyx_L1_error)
+  __pyx_t_1 = PyUnicode_AsUTF8String(__pyx_v_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 283, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_path_bytes = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":263
+  /* "pyjls/binding.pyx":284
  *         cdef const uint8_t[:] path_u8
  *         path_bytes = path.encode('utf-8')
  *         path_u8 = path_bytes             # <<<<<<<<<<<<<<
  *         self._signals[0].signal_type = c_jls.JLS_SIGNAL_TYPE_VSR
  *         with nogil:
  */
-  __pyx_t_2 = __Pyx_PyObject_to_MemoryviewSlice_ds_nn_uint8_t__const__(__pyx_v_path_bytes, 0); if (unlikely(!__pyx_t_2.memview)) __PYX_ERR(0, 263, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_to_MemoryviewSlice_ds_nn_uint8_t__const__(__pyx_v_path_bytes, 0); if (unlikely(!__pyx_t_2.memview)) __PYX_ERR(0, 284, __pyx_L1_error)
   __pyx_v_path_u8 = __pyx_t_2;
   __pyx_t_2.memview = NULL;
   __pyx_t_2.data = NULL;
 
-  /* "pyjls/binding.pyx":264
+  /* "pyjls/binding.pyx":285
  *         path_bytes = path.encode('utf-8')
  *         path_u8 = path_bytes
  *         self._signals[0].signal_type = c_jls.JLS_SIGNAL_TYPE_VSR             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rc = c_jls.jls_twr_open(wr_ptr, <char *> &path_u8[0])
  */
   (__pyx_v_self->_signals[0]).signal_type = JLS_SIGNAL_TYPE_VSR;
 
-  /* "pyjls/binding.pyx":265
+  /* "pyjls/binding.pyx":286
  *         path_u8 = path_bytes
  *         self._signals[0].signal_type = c_jls.JLS_SIGNAL_TYPE_VSR
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_open(wr_ptr, <char *> &path_u8[0])
  *         _handle_rc('open', rc)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":266
+        /* "pyjls/binding.pyx":287
  *         self._signals[0].signal_type = c_jls.JLS_SIGNAL_TYPE_VSR
  *         with nogil:
  *             rc = c_jls.jls_twr_open(wr_ptr, <char *> &path_u8[0])             # <<<<<<<<<<<<<<
  *         _handle_rc('open', rc)
  * 
  */
         __pyx_t_3 = 0;
         __pyx_t_4 = -1;
         if (__pyx_t_3 < 0) {
           __pyx_t_3 += __pyx_v_path_u8.shape[0];
           if (unlikely(__pyx_t_3 < 0)) __pyx_t_4 = 0;
         } else if (unlikely(__pyx_t_3 >= __pyx_v_path_u8.shape[0])) __pyx_t_4 = 0;
         if (unlikely(__pyx_t_4 != -1)) {
           __Pyx_RaiseBufferIndexErrorNogil(__pyx_t_4);
-          __PYX_ERR(0, 266, __pyx_L4_error)
+          __PYX_ERR(0, 287, __pyx_L4_error)
         }
         __pyx_v_rc = jls_twr_open(__pyx_v_wr_ptr, ((char *)(&(*((uint8_t const  *) ( /* dim=0 */ (__pyx_v_path_u8.data + __pyx_t_3 * __pyx_v_path_u8.strides[0]) ))))));
       }
 
-      /* "pyjls/binding.pyx":265
+      /* "pyjls/binding.pyx":286
  *         path_u8 = path_bytes
  *         self._signals[0].signal_type = c_jls.JLS_SIGNAL_TYPE_VSR
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_open(wr_ptr, <char *> &path_u8[0])
  *         _handle_rc('open', rc)
  */
       /*finally:*/ {
@@ -5759,24 +5806,24 @@
           #endif
           goto __pyx_L1_error;
         }
         __pyx_L5:;
       }
   }
 
-  /* "pyjls/binding.pyx":267
+  /* "pyjls/binding.pyx":288
  *         with nogil:
  *             rc = c_jls.jls_twr_open(wr_ptr, <char *> &path_u8[0])
  *         _handle_rc('open', rc)             # <<<<<<<<<<<<<<
  * 
  *     def __enter__(self):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 267, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 267, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_t_7 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_7)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -5785,49 +5832,49 @@
       __Pyx_DECREF_SET(__pyx_t_5, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_u_open, __pyx_t_6};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 288, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_u_open, __pyx_t_6};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_4, 2+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 288, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else
   #endif
   {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 267, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 288, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_open);
     __Pyx_GIVEREF(__pyx_n_u_open);
     PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_4, __pyx_n_u_open);
     __Pyx_GIVEREF(__pyx_t_6);
     PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_4, __pyx_t_6);
     __pyx_t_6 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 267, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 288, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":258
+  /* "pyjls/binding.pyx":279
  *     cdef c_jls.jls_signal_def_s _signals[_JLS_SIGNAL_COUNT]
  * 
  *     def __init__(self, path: str):             # <<<<<<<<<<<<<<
  *         cdef c_jls.jls_twr_s ** wr_ptr = &self._wr
  *         cdef int32_t rc
  */
 
@@ -5846,15 +5893,15 @@
   __pyx_L0:;
   __PYX_XDEC_MEMVIEW(&__pyx_v_path_u8, 1);
   __Pyx_XDECREF(__pyx_v_path_bytes);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":269
+/* "pyjls/binding.pyx":290
  *         _handle_rc('open', rc)
  * 
  *     def __enter__(self):             # <<<<<<<<<<<<<<
  *         return self
  * 
  */
 
@@ -5872,42 +5919,42 @@
 }
 
 static PyObject *__pyx_pf_5pyjls_7binding_6Writer_2__enter__(struct __pyx_obj_5pyjls_7binding_Writer *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__enter__", 0);
 
-  /* "pyjls/binding.pyx":270
+  /* "pyjls/binding.pyx":291
  * 
  *     def __enter__(self):
  *         return self             # <<<<<<<<<<<<<<
  * 
  *     def __exit__(self, type, value, traceback):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __pyx_r = ((PyObject *)__pyx_v_self);
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":269
+  /* "pyjls/binding.pyx":290
  *         _handle_rc('open', rc)
  * 
  *     def __enter__(self):             # <<<<<<<<<<<<<<
  *         return self
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":272
+/* "pyjls/binding.pyx":293
  *         return self
  * 
  *     def __exit__(self, type, value, traceback):             # <<<<<<<<<<<<<<
  *         self.close()
  * 
  */
 
@@ -5944,40 +5991,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 1); __PYX_ERR(0, 272, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 1); __PYX_ERR(0, 293, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_traceback)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 2); __PYX_ERR(0, 272, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 2); __PYX_ERR(0, 293, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__exit__") < 0)) __PYX_ERR(0, 272, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__exit__") < 0)) __PYX_ERR(0, 293, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_type = values[0];
     __pyx_v_value = values[1];
     __pyx_v_traceback = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 272, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 293, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.__exit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_4__exit__(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_type, __pyx_v_value, __pyx_v_traceback);
 
@@ -5993,41 +6040,41 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__exit__", 0);
 
-  /* "pyjls/binding.pyx":273
+  /* "pyjls/binding.pyx":294
  * 
  *     def __exit__(self, type, value, traceback):
  *         self.close()             # <<<<<<<<<<<<<<
  * 
  *     def close(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 273, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 294, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 273, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 294, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":272
+  /* "pyjls/binding.pyx":293
  *         return self
  * 
  *     def __exit__(self, type, value, traceback):             # <<<<<<<<<<<<<<
  *         self.close()
  * 
  */
 
@@ -6042,24 +6089,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":275
+/* "pyjls/binding.pyx":296
  *         self.close()
  * 
  *     def close(self):             # <<<<<<<<<<<<<<
+ *         """Close the JLS file and release all resources."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
- *         with nogil:
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_6close[] = "Close the JLS file and release all resources.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("close (wrapper)", 0);
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_6close(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self));
 
   /* function exit code */
@@ -6070,51 +6118,51 @@
 static PyObject *__pyx_pf_5pyjls_7binding_6Writer_6close(struct __pyx_obj_5pyjls_7binding_Writer *__pyx_v_self) {
   struct jls_twr_s *__pyx_v_wr;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   struct jls_twr_s *__pyx_t_1;
   __Pyx_RefNannySetupContext("close", 0);
 
-  /* "pyjls/binding.pyx":276
- * 
+  /* "pyjls/binding.pyx":298
  *     def close(self):
+ *         """Close the JLS file and release all resources."""
  *         cdef c_jls.jls_twr_s * wr = self._wr             # <<<<<<<<<<<<<<
  *         with nogil:
  *             c_jls.jls_twr_close(wr)
  */
   __pyx_t_1 = __pyx_v_self->_wr;
   __pyx_v_wr = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":277
- *     def close(self):
+  /* "pyjls/binding.pyx":299
+ *         """Close the JLS file and release all resources."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         with nogil:             # <<<<<<<<<<<<<<
  *             c_jls.jls_twr_close(wr)
  * 
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":278
+        /* "pyjls/binding.pyx":300
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         with nogil:
  *             c_jls.jls_twr_close(wr)             # <<<<<<<<<<<<<<
  * 
  *     def flush(self):
  */
         (void)(jls_twr_close(__pyx_v_wr));
       }
 
-      /* "pyjls/binding.pyx":277
- *     def close(self):
+      /* "pyjls/binding.pyx":299
+ *         """Close the JLS file and release all resources."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         with nogil:             # <<<<<<<<<<<<<<
  *             c_jls.jls_twr_close(wr)
  * 
  */
       /*finally:*/ {
         /*normal exit:*/{
@@ -6124,39 +6172,40 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "pyjls/binding.pyx":275
+  /* "pyjls/binding.pyx":296
  *         self.close()
  * 
  *     def close(self):             # <<<<<<<<<<<<<<
+ *         """Close the JLS file and release all resources."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
- *         with nogil:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":280
+/* "pyjls/binding.pyx":302
  *             c_jls.jls_twr_close(wr)
  * 
  *     def flush(self):             # <<<<<<<<<<<<<<
+ *         """Flush any pending data to the JLS file."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
- *         with nogil:
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_9flush(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_8flush[] = "Flush any pending data to the JLS file.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_9flush(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("flush (wrapper)", 0);
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_8flush(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self));
 
   /* function exit code */
@@ -6167,51 +6216,51 @@
 static PyObject *__pyx_pf_5pyjls_7binding_6Writer_8flush(struct __pyx_obj_5pyjls_7binding_Writer *__pyx_v_self) {
   struct jls_twr_s *__pyx_v_wr;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   struct jls_twr_s *__pyx_t_1;
   __Pyx_RefNannySetupContext("flush", 0);
 
-  /* "pyjls/binding.pyx":281
- * 
+  /* "pyjls/binding.pyx":304
  *     def flush(self):
+ *         """Flush any pending data to the JLS file."""
  *         cdef c_jls.jls_twr_s * wr = self._wr             # <<<<<<<<<<<<<<
  *         with nogil:
  *             c_jls.jls_twr_flush(wr)
  */
   __pyx_t_1 = __pyx_v_self->_wr;
   __pyx_v_wr = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":282
- *     def flush(self):
+  /* "pyjls/binding.pyx":305
+ *         """Flush any pending data to the JLS file."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         with nogil:             # <<<<<<<<<<<<<<
  *             c_jls.jls_twr_flush(wr)
  * 
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":283
+        /* "pyjls/binding.pyx":306
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         with nogil:
  *             c_jls.jls_twr_flush(wr)             # <<<<<<<<<<<<<<
  * 
  *     def source_def(self, source_id, name=None, vendor=None, model=None, version=None, serial_number=None):
  */
         (void)(jls_twr_flush(__pyx_v_wr));
       }
 
-      /* "pyjls/binding.pyx":282
- *     def flush(self):
+      /* "pyjls/binding.pyx":305
+ *         """Flush any pending data to the JLS file."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         with nogil:             # <<<<<<<<<<<<<<
  *             c_jls.jls_twr_flush(wr)
  * 
  */
       /*finally:*/ {
         /*normal exit:*/{
@@ -6221,39 +6270,40 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "pyjls/binding.pyx":280
+  /* "pyjls/binding.pyx":302
  *             c_jls.jls_twr_close(wr)
  * 
  *     def flush(self):             # <<<<<<<<<<<<<<
+ *         """Flush any pending data to the JLS file."""
  *         cdef c_jls.jls_twr_s * wr = self._wr
- *         with nogil:
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":285
+/* "pyjls/binding.pyx":308
  *             c_jls.jls_twr_flush(wr)
  * 
  *     def source_def(self, source_id, name=None, vendor=None, model=None, version=None, serial_number=None):             # <<<<<<<<<<<<<<
+ *         """Define a source."""
  *         cdef int32_t rc
- *         cdef c_jls.jls_source_def_s s
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_11source_def(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_10source_def[] = "Define a source.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_11source_def(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_source_id = 0;
   PyObject *__pyx_v_name = 0;
   PyObject *__pyx_v_vendor = 0;
   PyObject *__pyx_v_model = 0;
   PyObject *__pyx_v_version = 0;
   PyObject *__pyx_v_serial_number = 0;
@@ -6323,15 +6373,15 @@
         case  5:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_serial_number);
           if (value) { values[5] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "source_def") < 0)) __PYX_ERR(0, 285, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "source_def") < 0)) __PYX_ERR(0, 308, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
         CYTHON_FALLTHROUGH;
         case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
         CYTHON_FALLTHROUGH;
@@ -6351,15 +6401,15 @@
     __pyx_v_vendor = values[2];
     __pyx_v_model = values[3];
     __pyx_v_version = values[4];
     __pyx_v_serial_number = values[5];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("source_def", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 285, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("source_def", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 308, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.source_def", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_10source_def(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_source_id, __pyx_v_name, __pyx_v_vendor, __pyx_v_model, __pyx_v_version, __pyx_v_serial_number);
 
@@ -6391,228 +6441,228 @@
   int __pyx_t_11;
   PyObject *__pyx_t_12 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("source_def", 0);
 
-  /* "pyjls/binding.pyx":288
+  /* "pyjls/binding.pyx":312
  *         cdef int32_t rc
  *         cdef c_jls.jls_source_def_s s
  *         name_b = _encode_str(name)             # <<<<<<<<<<<<<<
  *         vendor_b = _encode_str(vendor)
  *         model_b = _encode_str(model)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 288, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 312, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_name) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_name);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 288, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 312, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_name_b = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":289
+  /* "pyjls/binding.pyx":313
  *         cdef c_jls.jls_source_def_s s
  *         name_b = _encode_str(name)
  *         vendor_b = _encode_str(vendor)             # <<<<<<<<<<<<<<
  *         model_b = _encode_str(model)
  *         version_b = _encode_str(version)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 289, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 313, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_vendor) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_vendor);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 289, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 313, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_vendor_b = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":290
+  /* "pyjls/binding.pyx":314
  *         name_b = _encode_str(name)
  *         vendor_b = _encode_str(vendor)
  *         model_b = _encode_str(model)             # <<<<<<<<<<<<<<
  *         version_b = _encode_str(version)
  *         serial_number_b = _encode_str(serial_number)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 290, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 314, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_model) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_model);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 290, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 314, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_model_b = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":291
+  /* "pyjls/binding.pyx":315
  *         vendor_b = _encode_str(vendor)
  *         model_b = _encode_str(model)
  *         version_b = _encode_str(version)             # <<<<<<<<<<<<<<
  *         serial_number_b = _encode_str(serial_number)
  *         s.source_id = source_id
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 291, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 315, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_version) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_version);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 291, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 315, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_version_b = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":292
+  /* "pyjls/binding.pyx":316
  *         model_b = _encode_str(model)
  *         version_b = _encode_str(version)
  *         serial_number_b = _encode_str(serial_number)             # <<<<<<<<<<<<<<
  *         s.source_id = source_id
  *         s.name = name_b
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 292, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_serial_number) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_serial_number);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 292, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 316, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_v_serial_number_b = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":293
+  /* "pyjls/binding.pyx":317
  *         version_b = _encode_str(version)
  *         serial_number_b = _encode_str(serial_number)
  *         s.source_id = source_id             # <<<<<<<<<<<<<<
  *         s.name = name_b
  *         s.vendor = vendor_b
  */
-  __pyx_t_4 = __Pyx_PyInt_As_uint16_t(__pyx_v_source_id); if (unlikely((__pyx_t_4 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 293, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_uint16_t(__pyx_v_source_id); if (unlikely((__pyx_t_4 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 317, __pyx_L1_error)
   __pyx_v_s.source_id = __pyx_t_4;
 
-  /* "pyjls/binding.pyx":294
+  /* "pyjls/binding.pyx":318
  *         serial_number_b = _encode_str(serial_number)
  *         s.source_id = source_id
  *         s.name = name_b             # <<<<<<<<<<<<<<
  *         s.vendor = vendor_b
  *         s.model = model_b
  */
-  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_name_b); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 294, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_AsString(__pyx_v_name_b); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 318, __pyx_L1_error)
   __pyx_v_s.name = __pyx_t_5;
 
-  /* "pyjls/binding.pyx":295
+  /* "pyjls/binding.pyx":319
  *         s.source_id = source_id
  *         s.name = name_b
  *         s.vendor = vendor_b             # <<<<<<<<<<<<<<
  *         s.model = model_b
  *         s.version = version_b
  */
-  __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_vendor_b); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 295, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_vendor_b); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 319, __pyx_L1_error)
   __pyx_v_s.vendor = __pyx_t_6;
 
-  /* "pyjls/binding.pyx":296
+  /* "pyjls/binding.pyx":320
  *         s.name = name_b
  *         s.vendor = vendor_b
  *         s.model = model_b             # <<<<<<<<<<<<<<
  *         s.version = version_b
  *         s.serial_number = serial_number_b
  */
-  __pyx_t_7 = __Pyx_PyObject_AsString(__pyx_v_model_b); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(0, 296, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_AsString(__pyx_v_model_b); if (unlikely((!__pyx_t_7) && PyErr_Occurred())) __PYX_ERR(0, 320, __pyx_L1_error)
   __pyx_v_s.model = __pyx_t_7;
 
-  /* "pyjls/binding.pyx":297
+  /* "pyjls/binding.pyx":321
  *         s.vendor = vendor_b
  *         s.model = model_b
  *         s.version = version_b             # <<<<<<<<<<<<<<
  *         s.serial_number = serial_number_b
  *         rc = c_jls.jls_twr_source_def(self._wr, &s)
  */
-  __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_version_b); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 297, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_version_b); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) __PYX_ERR(0, 321, __pyx_L1_error)
   __pyx_v_s.version = __pyx_t_8;
 
-  /* "pyjls/binding.pyx":298
+  /* "pyjls/binding.pyx":322
  *         s.model = model_b
  *         s.version = version_b
  *         s.serial_number = serial_number_b             # <<<<<<<<<<<<<<
  *         rc = c_jls.jls_twr_source_def(self._wr, &s)
  *         _handle_rc('source_def', rc)
  */
-  __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_serial_number_b); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 298, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_AsString(__pyx_v_serial_number_b); if (unlikely((!__pyx_t_9) && PyErr_Occurred())) __PYX_ERR(0, 322, __pyx_L1_error)
   __pyx_v_s.serial_number = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":299
+  /* "pyjls/binding.pyx":323
  *         s.version = version_b
  *         s.serial_number = serial_number_b
  *         rc = c_jls.jls_twr_source_def(self._wr, &s)             # <<<<<<<<<<<<<<
  *         _handle_rc('source_def', rc)
  * 
  */
   __pyx_v_rc = jls_twr_source_def(__pyx_v_self->_wr, (&__pyx_v_s));
 
-  /* "pyjls/binding.pyx":300
+  /* "pyjls/binding.pyx":324
  *         s.serial_number = serial_number_b
  *         rc = c_jls.jls_twr_source_def(self._wr, &s)
  *         _handle_rc('source_def', rc)             # <<<<<<<<<<<<<<
  * 
  *     def source_def_from_struct(self, s: SourceDef):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 300, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 324, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 300, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 324, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_10 = NULL;
   __pyx_t_11 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_10)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -6621,54 +6671,54 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_11 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_n_u_source_def, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_n_u_source_def, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 300, __pyx_L1_error)
+    __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 324, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_12);
     if (__pyx_t_10) {
       __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_10); __pyx_t_10 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_source_def);
     __Pyx_GIVEREF(__pyx_n_u_source_def);
     PyTuple_SET_ITEM(__pyx_t_12, 0+__pyx_t_11, __pyx_n_u_source_def);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_12, 1+__pyx_t_11, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 300, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 324, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":285
+  /* "pyjls/binding.pyx":308
  *             c_jls.jls_twr_flush(wr)
  * 
  *     def source_def(self, source_id, name=None, vendor=None, model=None, version=None, serial_number=None):             # <<<<<<<<<<<<<<
+ *         """Define a source."""
  *         cdef int32_t rc
- *         cdef c_jls.jls_source_def_s s
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -6685,24 +6735,25 @@
   __Pyx_XDECREF(__pyx_v_version_b);
   __Pyx_XDECREF(__pyx_v_serial_number_b);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":302
+/* "pyjls/binding.pyx":326
  *         _handle_rc('source_def', rc)
  * 
  *     def source_def_from_struct(self, s: SourceDef):             # <<<<<<<<<<<<<<
+ *         """Define a source."""
  *         return self.source_def(s.source_id,
- *                                name=s.name,
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_13source_def_from_struct(PyObject *__pyx_v_self, PyObject *__pyx_v_s); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_12source_def_from_struct[] = "Define a source.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_13source_def_from_struct(PyObject *__pyx_v_self, PyObject *__pyx_v_s) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("source_def_from_struct (wrapper)", 0);
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_12source_def_from_struct(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), ((PyObject *)__pyx_v_s));
 
   /* function exit code */
@@ -6718,116 +6769,116 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("source_def_from_struct", 0);
 
-  /* "pyjls/binding.pyx":303
- * 
+  /* "pyjls/binding.pyx":328
  *     def source_def_from_struct(self, s: SourceDef):
+ *         """Define a source."""
  *         return self.source_def(s.source_id,             # <<<<<<<<<<<<<<
  *                                name=s.name,
  *                                vendor=s.vendor,
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_source_def); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 303, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_source_def); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 328, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_source_id); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 303, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_source_id); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 328, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 303, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 328, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
   __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":304
- *     def source_def_from_struct(self, s: SourceDef):
+  /* "pyjls/binding.pyx":329
+ *         """Define a source."""
  *         return self.source_def(s.source_id,
  *                                name=s.name,             # <<<<<<<<<<<<<<
  *                                vendor=s.vendor,
  *                                model=s.model,
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 304, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 304, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_name, __pyx_t_4) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_name, __pyx_t_4) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":305
+  /* "pyjls/binding.pyx":330
  *         return self.source_def(s.source_id,
  *                                name=s.name,
  *                                vendor=s.vendor,             # <<<<<<<<<<<<<<
  *                                model=s.model,
  *                                version=s.version,
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_vendor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 305, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_vendor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_vendor, __pyx_t_4) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_vendor, __pyx_t_4) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":306
+  /* "pyjls/binding.pyx":331
  *                                name=s.name,
  *                                vendor=s.vendor,
  *                                model=s.model,             # <<<<<<<<<<<<<<
  *                                version=s.version,
  *                                serial_number=s.serial_number)
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_model); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 306, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_model); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 331, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_model, __pyx_t_4) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_model, __pyx_t_4) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":307
+  /* "pyjls/binding.pyx":332
  *                                vendor=s.vendor,
  *                                model=s.model,
  *                                version=s.version,             # <<<<<<<<<<<<<<
  *                                serial_number=s.serial_number)
  * 
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_version); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 307, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_version); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 332, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_version, __pyx_t_4) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_version, __pyx_t_4) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":308
+  /* "pyjls/binding.pyx":333
  *                                model=s.model,
  *                                version=s.version,
  *                                serial_number=s.serial_number)             # <<<<<<<<<<<<<<
  * 
  *     def signal_def(self, signal_id, source_id, signal_type=None, data_type=None, sample_rate=None,
  */
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_serial_number); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 308, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_serial_number); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 333, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_serial_number, __pyx_t_4) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_serial_number, __pyx_t_4) < 0) __PYX_ERR(0, 329, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":303
- * 
+  /* "pyjls/binding.pyx":328
  *     def source_def_from_struct(self, s: SourceDef):
+ *         """Define a source."""
  *         return self.source_def(s.source_id,             # <<<<<<<<<<<<<<
  *                                name=s.name,
  *                                vendor=s.vendor,
  */
-  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 303, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_4;
   __pyx_t_4 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":302
+  /* "pyjls/binding.pyx":326
  *         _handle_rc('source_def', rc)
  * 
  *     def source_def_from_struct(self, s: SourceDef):             # <<<<<<<<<<<<<<
+ *         """Define a source."""
  *         return self.source_def(s.source_id,
- *                                name=s.name,
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -6836,24 +6887,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":310
+/* "pyjls/binding.pyx":335
  *                                serial_number=s.serial_number)
  * 
  *     def signal_def(self, signal_id, source_id, signal_type=None, data_type=None, sample_rate=None,             # <<<<<<<<<<<<<<
  *                    samples_per_data=None, sample_decimate_factor=None, entries_per_summary=None,
  *                    summary_decimate_factor=None, annotation_decimate_factor=None, utc_decimate_factor=None,
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_15signal_def(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_14signal_def[] = "Define a signal.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_15signal_def(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_source_id = 0;
   PyObject *__pyx_v_signal_type = 0;
   PyObject *__pyx_v_data_type = 0;
   PyObject *__pyx_v_sample_rate = 0;
   PyObject *__pyx_v_samples_per_data = 0;
@@ -6873,42 +6925,42 @@
   {
     static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_signal_id,&__pyx_n_s_source_id,&__pyx_n_s_signal_type,&__pyx_n_s_data_type,&__pyx_n_s_sample_rate,&__pyx_n_s_samples_per_data,&__pyx_n_s_sample_decimate_factor,&__pyx_n_s_entries_per_summary,&__pyx_n_s_summary_decimate_factor,&__pyx_n_s_annotation_decimate_factor,&__pyx_n_s_utc_decimate_factor,&__pyx_n_s_name,&__pyx_n_s_units,0};
     PyObject* values[13] = {0,0,0,0,0,0,0,0,0,0,0,0,0};
     values[2] = ((PyObject *)Py_None);
     values[3] = ((PyObject *)Py_None);
     values[4] = ((PyObject *)Py_None);
 
-    /* "pyjls/binding.pyx":311
+    /* "pyjls/binding.pyx":336
  * 
  *     def signal_def(self, signal_id, source_id, signal_type=None, data_type=None, sample_rate=None,
  *                    samples_per_data=None, sample_decimate_factor=None, entries_per_summary=None,             # <<<<<<<<<<<<<<
  *                    summary_decimate_factor=None, annotation_decimate_factor=None, utc_decimate_factor=None,
  *                    name=None, units=None):
  */
     values[5] = ((PyObject *)Py_None);
     values[6] = ((PyObject *)Py_None);
     values[7] = ((PyObject *)Py_None);
 
-    /* "pyjls/binding.pyx":312
+    /* "pyjls/binding.pyx":337
  *     def signal_def(self, signal_id, source_id, signal_type=None, data_type=None, sample_rate=None,
  *                    samples_per_data=None, sample_decimate_factor=None, entries_per_summary=None,
  *                    summary_decimate_factor=None, annotation_decimate_factor=None, utc_decimate_factor=None,             # <<<<<<<<<<<<<<
  *                    name=None, units=None):
- *         cdef int32_t rc
+ *         """Define a signal."""
  */
     values[8] = ((PyObject *)Py_None);
     values[9] = ((PyObject *)Py_None);
     values[10] = ((PyObject *)Py_None);
 
-    /* "pyjls/binding.pyx":313
+    /* "pyjls/binding.pyx":338
  *                    samples_per_data=None, sample_decimate_factor=None, entries_per_summary=None,
  *                    summary_decimate_factor=None, annotation_decimate_factor=None, utc_decimate_factor=None,
  *                    name=None, units=None):             # <<<<<<<<<<<<<<
+ *         """Define a signal."""
  *         cdef int32_t rc
- *         cdef c_jls.jls_signal_def_s * s
  */
     values[11] = ((PyObject *)Py_None);
     values[12] = ((PyObject *)Py_None);
     if (unlikely(__pyx_kwds)) {
       Py_ssize_t kw_args;
       const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
       switch (pos_args) {
@@ -6946,15 +6998,15 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_source_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("signal_def", 0, 2, 13, 1); __PYX_ERR(0, 310, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("signal_def", 0, 2, 13, 1); __PYX_ERR(0, 335, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_type);
           if (value) { values[2] = value; kw_args--; }
         }
@@ -7016,15 +7068,15 @@
         case 12:
         if (kw_args > 0) {
           PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_units);
           if (value) { values[12] = value; kw_args--; }
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "signal_def") < 0)) __PYX_ERR(0, 310, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "signal_def") < 0)) __PYX_ERR(0, 335, __pyx_L3_error)
       }
     } else {
       switch (PyTuple_GET_SIZE(__pyx_args)) {
         case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
         CYTHON_FALLTHROUGH;
         case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
         CYTHON_FALLTHROUGH;
@@ -7064,23 +7116,23 @@
     __pyx_v_annotation_decimate_factor = values[9];
     __pyx_v_utc_decimate_factor = values[10];
     __pyx_v_name = values[11];
     __pyx_v_units = values[12];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("signal_def", 0, 2, 13, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 310, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("signal_def", 0, 2, 13, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 335, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.signal_def", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_14signal_def(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_source_id, __pyx_v_signal_type, __pyx_v_data_type, __pyx_v_sample_rate, __pyx_v_samples_per_data, __pyx_v_sample_decimate_factor, __pyx_v_entries_per_summary, __pyx_v_summary_decimate_factor, __pyx_v_annotation_decimate_factor, __pyx_v_utc_decimate_factor, __pyx_v_name, __pyx_v_units);
 
-  /* "pyjls/binding.pyx":310
+  /* "pyjls/binding.pyx":335
  *                                serial_number=s.serial_number)
  * 
  *     def signal_def(self, signal_id, source_id, signal_type=None, data_type=None, sample_rate=None,             # <<<<<<<<<<<<<<
  *                    samples_per_data=None, sample_decimate_factor=None, entries_per_summary=None,
  *                    summary_decimate_factor=None, annotation_decimate_factor=None, utc_decimate_factor=None,
  */
 
@@ -7114,371 +7166,371 @@
   PyObject *__pyx_t_16 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("signal_def", 0);
   __Pyx_INCREF(__pyx_v_data_type);
 
-  /* "pyjls/binding.pyx":316
+  /* "pyjls/binding.pyx":342
  *         cdef int32_t rc
  *         cdef c_jls.jls_signal_def_s * s
  *         s = &self._signals[signal_id]             # <<<<<<<<<<<<<<
  *         if data_type is None:
  *             data_type = DataType.F32
  */
-  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 316, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 342, __pyx_L1_error)
   __pyx_v_s = (&(__pyx_v_self->_signals[__pyx_t_1]));
 
-  /* "pyjls/binding.pyx":317
+  /* "pyjls/binding.pyx":343
  *         cdef c_jls.jls_signal_def_s * s
  *         s = &self._signals[signal_id]
  *         if data_type is None:             # <<<<<<<<<<<<<<
  *             data_type = DataType.F32
  *         elif isinstance(data_type, str):
  */
   __pyx_t_2 = (__pyx_v_data_type == Py_None);
   __pyx_t_3 = (__pyx_t_2 != 0);
   if (__pyx_t_3) {
 
-    /* "pyjls/binding.pyx":318
+    /* "pyjls/binding.pyx":344
  *         s = &self._signals[signal_id]
  *         if data_type is None:
  *             data_type = DataType.F32             # <<<<<<<<<<<<<<
  *         elif isinstance(data_type, str):
  *             data_type = _data_type_as_enum[data_type]
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataType); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 318, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataType); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 344, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_F32); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 318, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_F32); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 344, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF_SET(__pyx_v_data_type, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":317
+    /* "pyjls/binding.pyx":343
  *         cdef c_jls.jls_signal_def_s * s
  *         s = &self._signals[signal_id]
  *         if data_type is None:             # <<<<<<<<<<<<<<
  *             data_type = DataType.F32
  *         elif isinstance(data_type, str):
  */
     goto __pyx_L3;
   }
 
-  /* "pyjls/binding.pyx":319
+  /* "pyjls/binding.pyx":345
  *         if data_type is None:
  *             data_type = DataType.F32
  *         elif isinstance(data_type, str):             # <<<<<<<<<<<<<<
  *             data_type = _data_type_as_enum[data_type]
  *         s.signal_id = signal_id
  */
   __pyx_t_3 = PyUnicode_Check(__pyx_v_data_type); 
   __pyx_t_2 = (__pyx_t_3 != 0);
   if (__pyx_t_2) {
 
-    /* "pyjls/binding.pyx":320
+    /* "pyjls/binding.pyx":346
  *             data_type = DataType.F32
  *         elif isinstance(data_type, str):
  *             data_type = _data_type_as_enum[data_type]             # <<<<<<<<<<<<<<
  *         s.signal_id = signal_id
  *         s.source_id = source_id
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 320, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_data_type_as_enum); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_t_5, __pyx_v_data_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 320, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_t_5, __pyx_v_data_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 346, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF_SET(__pyx_v_data_type, __pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":319
+    /* "pyjls/binding.pyx":345
  *         if data_type is None:
  *             data_type = DataType.F32
  *         elif isinstance(data_type, str):             # <<<<<<<<<<<<<<
  *             data_type = _data_type_as_enum[data_type]
  *         s.signal_id = signal_id
  */
   }
   __pyx_L3:;
 
-  /* "pyjls/binding.pyx":321
+  /* "pyjls/binding.pyx":347
  *         elif isinstance(data_type, str):
  *             data_type = _data_type_as_enum[data_type]
  *         s.signal_id = signal_id             # <<<<<<<<<<<<<<
  *         s.source_id = source_id
  *         s.signal_type = 0 if signal_type is None else int(signal_type)
  */
-  __pyx_t_6 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_6 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 321, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_6 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 347, __pyx_L1_error)
   __pyx_v_s->signal_id = __pyx_t_6;
 
-  /* "pyjls/binding.pyx":322
+  /* "pyjls/binding.pyx":348
  *             data_type = _data_type_as_enum[data_type]
  *         s.signal_id = signal_id
  *         s.source_id = source_id             # <<<<<<<<<<<<<<
  *         s.signal_type = 0 if signal_type is None else int(signal_type)
  *         s.data_type = data_type
  */
-  __pyx_t_6 = __Pyx_PyInt_As_uint16_t(__pyx_v_source_id); if (unlikely((__pyx_t_6 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 322, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_As_uint16_t(__pyx_v_source_id); if (unlikely((__pyx_t_6 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 348, __pyx_L1_error)
   __pyx_v_s->source_id = __pyx_t_6;
 
-  /* "pyjls/binding.pyx":323
+  /* "pyjls/binding.pyx":349
  *         s.signal_id = signal_id
  *         s.source_id = source_id
  *         s.signal_type = 0 if signal_type is None else int(signal_type)             # <<<<<<<<<<<<<<
  *         s.data_type = data_type
  *         s.sample_rate = 0 if sample_rate is None else int(sample_rate)
  */
   __pyx_t_2 = (__pyx_v_signal_type == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_7 = 0;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_signal_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 323, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_signal_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 349, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_8 = __Pyx_PyInt_As_uint8_t(__pyx_t_4); if (unlikely((__pyx_t_8 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 323, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyInt_As_uint8_t(__pyx_t_4); if (unlikely((__pyx_t_8 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 349, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_7 = __pyx_t_8;
   }
   __pyx_v_s->signal_type = __pyx_t_7;
 
-  /* "pyjls/binding.pyx":324
+  /* "pyjls/binding.pyx":350
  *         s.source_id = source_id
  *         s.signal_type = 0 if signal_type is None else int(signal_type)
  *         s.data_type = data_type             # <<<<<<<<<<<<<<
  *         s.sample_rate = 0 if sample_rate is None else int(sample_rate)
  *         s.samples_per_data = 100000 if samples_per_data is None else int(samples_per_data)
  */
-  __pyx_t_9 = __Pyx_PyInt_As_uint32_t(__pyx_v_data_type); if (unlikely((__pyx_t_9 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 324, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyInt_As_uint32_t(__pyx_v_data_type); if (unlikely((__pyx_t_9 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 350, __pyx_L1_error)
   __pyx_v_s->data_type = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":325
+  /* "pyjls/binding.pyx":351
  *         s.signal_type = 0 if signal_type is None else int(signal_type)
  *         s.data_type = data_type
  *         s.sample_rate = 0 if sample_rate is None else int(sample_rate)             # <<<<<<<<<<<<<<
  *         s.samples_per_data = 100000 if samples_per_data is None else int(samples_per_data)
  *         s.sample_decimate_factor = 100 if sample_decimate_factor is None else int(sample_decimate_factor)
  */
   __pyx_t_2 = (__pyx_v_sample_rate == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_sample_rate); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 325, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_sample_rate); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 351, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 325, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 351, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->sample_rate = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":326
+  /* "pyjls/binding.pyx":352
  *         s.data_type = data_type
  *         s.sample_rate = 0 if sample_rate is None else int(sample_rate)
  *         s.samples_per_data = 100000 if samples_per_data is None else int(samples_per_data)             # <<<<<<<<<<<<<<
  *         s.sample_decimate_factor = 100 if sample_decimate_factor is None else int(sample_decimate_factor)
  *         s.entries_per_summary = 20000 if entries_per_summary is None else int(entries_per_summary)
  */
   __pyx_t_2 = (__pyx_v_samples_per_data == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0x186A0;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_samples_per_data); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 326, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_samples_per_data); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 352, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 326, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 352, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->samples_per_data = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":327
+  /* "pyjls/binding.pyx":353
  *         s.sample_rate = 0 if sample_rate is None else int(sample_rate)
  *         s.samples_per_data = 100000 if samples_per_data is None else int(samples_per_data)
  *         s.sample_decimate_factor = 100 if sample_decimate_factor is None else int(sample_decimate_factor)             # <<<<<<<<<<<<<<
  *         s.entries_per_summary = 20000 if entries_per_summary is None else int(entries_per_summary)
  *         s.summary_decimate_factor = 100 if summary_decimate_factor is None else int(summary_decimate_factor)
  */
   __pyx_t_2 = (__pyx_v_sample_decimate_factor == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0x64;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_sample_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 327, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_sample_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 353, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 327, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 353, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->sample_decimate_factor = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":328
+  /* "pyjls/binding.pyx":354
  *         s.samples_per_data = 100000 if samples_per_data is None else int(samples_per_data)
  *         s.sample_decimate_factor = 100 if sample_decimate_factor is None else int(sample_decimate_factor)
  *         s.entries_per_summary = 20000 if entries_per_summary is None else int(entries_per_summary)             # <<<<<<<<<<<<<<
  *         s.summary_decimate_factor = 100 if summary_decimate_factor is None else int(summary_decimate_factor)
  *         s.annotation_decimate_factor = 100 if annotation_decimate_factor is None else int(annotation_decimate_factor)
  */
   __pyx_t_2 = (__pyx_v_entries_per_summary == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0x4E20;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_entries_per_summary); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 328, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_entries_per_summary); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 354, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 328, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 354, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->entries_per_summary = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":329
+  /* "pyjls/binding.pyx":355
  *         s.sample_decimate_factor = 100 if sample_decimate_factor is None else int(sample_decimate_factor)
  *         s.entries_per_summary = 20000 if entries_per_summary is None else int(entries_per_summary)
  *         s.summary_decimate_factor = 100 if summary_decimate_factor is None else int(summary_decimate_factor)             # <<<<<<<<<<<<<<
  *         s.annotation_decimate_factor = 100 if annotation_decimate_factor is None else int(annotation_decimate_factor)
  *         s.utc_decimate_factor = 100 if utc_decimate_factor is None else int(utc_decimate_factor)
  */
   __pyx_t_2 = (__pyx_v_summary_decimate_factor == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0x64;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_summary_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 329, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_summary_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 355, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 329, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 355, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->summary_decimate_factor = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":330
+  /* "pyjls/binding.pyx":356
  *         s.entries_per_summary = 20000 if entries_per_summary is None else int(entries_per_summary)
  *         s.summary_decimate_factor = 100 if summary_decimate_factor is None else int(summary_decimate_factor)
  *         s.annotation_decimate_factor = 100 if annotation_decimate_factor is None else int(annotation_decimate_factor)             # <<<<<<<<<<<<<<
  *         s.utc_decimate_factor = 100 if utc_decimate_factor is None else int(utc_decimate_factor)
  *         name_b = _encode_str(name)
  */
   __pyx_t_2 = (__pyx_v_annotation_decimate_factor == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0x64;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_annotation_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_annotation_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 356, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 330, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->annotation_decimate_factor = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":331
+  /* "pyjls/binding.pyx":357
  *         s.summary_decimate_factor = 100 if summary_decimate_factor is None else int(summary_decimate_factor)
  *         s.annotation_decimate_factor = 100 if annotation_decimate_factor is None else int(annotation_decimate_factor)
  *         s.utc_decimate_factor = 100 if utc_decimate_factor is None else int(utc_decimate_factor)             # <<<<<<<<<<<<<<
  *         name_b = _encode_str(name)
  *         units_b = _encode_str(units)
  */
   __pyx_t_2 = (__pyx_v_utc_decimate_factor == Py_None);
   if ((__pyx_t_2 != 0)) {
     __pyx_t_9 = 0x64;
   } else {
-    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_utc_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 331, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_utc_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 357, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 331, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 357, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_t_9 = __pyx_t_10;
   }
   __pyx_v_s->utc_decimate_factor = __pyx_t_9;
 
-  /* "pyjls/binding.pyx":332
+  /* "pyjls/binding.pyx":358
  *         s.annotation_decimate_factor = 100 if annotation_decimate_factor is None else int(annotation_decimate_factor)
  *         s.utc_decimate_factor = 100 if utc_decimate_factor is None else int(utc_decimate_factor)
  *         name_b = _encode_str(name)             # <<<<<<<<<<<<<<
  *         units_b = _encode_str(units)
  *         s.name = name_b
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 332, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 358, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_11 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_11)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_11);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_4 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_11, __pyx_v_name) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_name);
   __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 332, __pyx_L1_error)
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 358, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_name_b = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":333
+  /* "pyjls/binding.pyx":359
  *         s.utc_decimate_factor = 100 if utc_decimate_factor is None else int(utc_decimate_factor)
  *         name_b = _encode_str(name)
  *         units_b = _encode_str(units)             # <<<<<<<<<<<<<<
  *         s.name = name_b
  *         s.units = units_b
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 333, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_encode_str); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 359, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_11 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_11)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
       __Pyx_INCREF(__pyx_t_11);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_5, function);
     }
   }
   __pyx_t_4 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_11, __pyx_v_units) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_units);
   __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 333, __pyx_L1_error)
+  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 359, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_units_b = __pyx_t_4;
   __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":334
+  /* "pyjls/binding.pyx":360
  *         name_b = _encode_str(name)
  *         units_b = _encode_str(units)
  *         s.name = name_b             # <<<<<<<<<<<<<<
  *         s.units = units_b
  *         rc = c_jls.jls_twr_signal_def(self._wr, s)
  */
-  __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_name_b); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(0, 334, __pyx_L1_error)
+  __pyx_t_12 = __Pyx_PyObject_AsString(__pyx_v_name_b); if (unlikely((!__pyx_t_12) && PyErr_Occurred())) __PYX_ERR(0, 360, __pyx_L1_error)
   __pyx_v_s->name = __pyx_t_12;
 
-  /* "pyjls/binding.pyx":335
+  /* "pyjls/binding.pyx":361
  *         units_b = _encode_str(units)
  *         s.name = name_b
  *         s.units = units_b             # <<<<<<<<<<<<<<
  *         rc = c_jls.jls_twr_signal_def(self._wr, s)
  *         _handle_rc('signal_def', rc)
  */
-  __pyx_t_13 = __Pyx_PyObject_AsString(__pyx_v_units_b); if (unlikely((!__pyx_t_13) && PyErr_Occurred())) __PYX_ERR(0, 335, __pyx_L1_error)
+  __pyx_t_13 = __Pyx_PyObject_AsString(__pyx_v_units_b); if (unlikely((!__pyx_t_13) && PyErr_Occurred())) __PYX_ERR(0, 361, __pyx_L1_error)
   __pyx_v_s->units = __pyx_t_13;
 
-  /* "pyjls/binding.pyx":336
+  /* "pyjls/binding.pyx":362
  *         s.name = name_b
  *         s.units = units_b
  *         rc = c_jls.jls_twr_signal_def(self._wr, s)             # <<<<<<<<<<<<<<
  *         _handle_rc('signal_def', rc)
  * 
  */
   __pyx_v_rc = jls_twr_signal_def(__pyx_v_self->_wr, __pyx_v_s);
 
-  /* "pyjls/binding.pyx":337
+  /* "pyjls/binding.pyx":363
  *         s.units = units_b
  *         rc = c_jls.jls_twr_signal_def(self._wr, s)
  *         _handle_rc('signal_def', rc)             # <<<<<<<<<<<<<<
  * 
  *     def signal_def_from_struct(self, s: SignalDef):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 337, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 363, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_11 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 337, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 363, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __pyx_t_14 = NULL;
   __pyx_t_15 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_14)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -7487,49 +7539,49 @@
       __Pyx_DECREF_SET(__pyx_t_5, function);
       __pyx_t_15 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_14, __pyx_n_u_signal_def, __pyx_t_11};
-    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 363, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_14, __pyx_n_u_signal_def, __pyx_t_11};
-    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 363, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   } else
   #endif
   {
-    __pyx_t_16 = PyTuple_New(2+__pyx_t_15); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_16 = PyTuple_New(2+__pyx_t_15); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 363, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_16);
     if (__pyx_t_14) {
       __Pyx_GIVEREF(__pyx_t_14); PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_14); __pyx_t_14 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_signal_def);
     __Pyx_GIVEREF(__pyx_n_u_signal_def);
     PyTuple_SET_ITEM(__pyx_t_16, 0+__pyx_t_15, __pyx_n_u_signal_def);
     __Pyx_GIVEREF(__pyx_t_11);
     PyTuple_SET_ITEM(__pyx_t_16, 1+__pyx_t_15, __pyx_t_11);
     __pyx_t_11 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_16, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 337, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_16, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 363, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":310
+  /* "pyjls/binding.pyx":335
  *                                serial_number=s.serial_number)
  * 
  *     def signal_def(self, signal_id, source_id, signal_type=None, data_type=None, sample_rate=None,             # <<<<<<<<<<<<<<
  *                    samples_per_data=None, sample_decimate_factor=None, entries_per_summary=None,
  *                    summary_decimate_factor=None, annotation_decimate_factor=None, utc_decimate_factor=None,
  */
 
@@ -7549,24 +7601,25 @@
   __Pyx_XDECREF(__pyx_v_units_b);
   __Pyx_XDECREF(__pyx_v_data_type);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":339
+/* "pyjls/binding.pyx":365
  *         _handle_rc('signal_def', rc)
  * 
  *     def signal_def_from_struct(self, s: SignalDef):             # <<<<<<<<<<<<<<
+ *         """Define a signal."""
  *         return self.signal_def(s.signal_id,
- *                                s.source_id,
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_17signal_def_from_struct(PyObject *__pyx_v_self, PyObject *__pyx_v_s); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_16signal_def_from_struct[] = "Define a signal.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_17signal_def_from_struct(PyObject *__pyx_v_self, PyObject *__pyx_v_s) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("signal_def_from_struct (wrapper)", 0);
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_16signal_def_from_struct(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), ((PyObject *)__pyx_v_s));
 
   /* function exit code */
@@ -7582,209 +7635,209 @@
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("signal_def_from_struct", 0);
 
-  /* "pyjls/binding.pyx":340
- * 
+  /* "pyjls/binding.pyx":367
  *     def signal_def_from_struct(self, s: SignalDef):
+ *         """Define a signal."""
  *         return self.signal_def(s.signal_id,             # <<<<<<<<<<<<<<
  *                                s.source_id,
  *                                signal_type=s.signal_type,
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_signal_def); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 340, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_signal_def); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 367, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_signal_id); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 340, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_signal_id); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 367, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "pyjls/binding.pyx":341
- *     def signal_def_from_struct(self, s: SignalDef):
+  /* "pyjls/binding.pyx":368
+ *         """Define a signal."""
  *         return self.signal_def(s.signal_id,
  *                                s.source_id,             # <<<<<<<<<<<<<<
  *                                signal_type=s.signal_type,
  *                                data_type=s.data_type,
  */
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_source_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 341, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_source_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 368, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
 
-  /* "pyjls/binding.pyx":340
- * 
+  /* "pyjls/binding.pyx":367
  *     def signal_def_from_struct(self, s: SignalDef):
+ *         """Define a signal."""
  *         return self.signal_def(s.signal_id,             # <<<<<<<<<<<<<<
  *                                s.source_id,
  *                                signal_type=s.signal_type,
  */
-  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 340, __pyx_L1_error)
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 367, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_GIVEREF(__pyx_t_2);
   PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
   __pyx_t_2 = 0;
   __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":342
+  /* "pyjls/binding.pyx":369
  *         return self.signal_def(s.signal_id,
  *                                s.source_id,
  *                                signal_type=s.signal_type,             # <<<<<<<<<<<<<<
  *                                data_type=s.data_type,
  *                                sample_rate=s.sample_rate,
  */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 342, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_signal_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 342, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_signal_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_signal_type, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_signal_type, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":343
+  /* "pyjls/binding.pyx":370
  *                                s.source_id,
  *                                signal_type=s.signal_type,
  *                                data_type=s.data_type,             # <<<<<<<<<<<<<<
  *                                sample_rate=s.sample_rate,
  *                                samples_per_data=s.samples_per_data,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_data_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 343, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_data_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 370, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_data_type, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_data_type, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":344
+  /* "pyjls/binding.pyx":371
  *                                signal_type=s.signal_type,
  *                                data_type=s.data_type,
  *                                sample_rate=s.sample_rate,             # <<<<<<<<<<<<<<
  *                                samples_per_data=s.samples_per_data,
  *                                sample_decimate_factor=s.sample_decimate_factor,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_sample_rate); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 344, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_sample_rate); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 371, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_rate, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_rate, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":345
+  /* "pyjls/binding.pyx":372
  *                                data_type=s.data_type,
  *                                sample_rate=s.sample_rate,
  *                                samples_per_data=s.samples_per_data,             # <<<<<<<<<<<<<<
  *                                sample_decimate_factor=s.sample_decimate_factor,
  *                                entries_per_summary=s.entries_per_summary,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_samples_per_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 345, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_samples_per_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 372, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_samples_per_data, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_samples_per_data, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":346
+  /* "pyjls/binding.pyx":373
  *                                sample_rate=s.sample_rate,
  *                                samples_per_data=s.samples_per_data,
  *                                sample_decimate_factor=s.sample_decimate_factor,             # <<<<<<<<<<<<<<
  *                                entries_per_summary=s.entries_per_summary,
  *                                summary_decimate_factor=s.summary_decimate_factor,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_sample_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 346, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_sample_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 373, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":347
+  /* "pyjls/binding.pyx":374
  *                                samples_per_data=s.samples_per_data,
  *                                sample_decimate_factor=s.sample_decimate_factor,
  *                                entries_per_summary=s.entries_per_summary,             # <<<<<<<<<<<<<<
  *                                summary_decimate_factor=s.summary_decimate_factor,
  *                                annotation_decimate_factor=s.annotation_decimate_factor,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_entries_per_summary); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 347, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_entries_per_summary); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 374, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_entries_per_summary, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_entries_per_summary, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":348
+  /* "pyjls/binding.pyx":375
  *                                sample_decimate_factor=s.sample_decimate_factor,
  *                                entries_per_summary=s.entries_per_summary,
  *                                summary_decimate_factor=s.summary_decimate_factor,             # <<<<<<<<<<<<<<
  *                                annotation_decimate_factor=s.annotation_decimate_factor,
  *                                utc_decimate_factor=s.utc_decimate_factor,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_summary_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 348, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_summary_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 375, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_summary_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_summary_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":349
+  /* "pyjls/binding.pyx":376
  *                                entries_per_summary=s.entries_per_summary,
  *                                summary_decimate_factor=s.summary_decimate_factor,
  *                                annotation_decimate_factor=s.annotation_decimate_factor,             # <<<<<<<<<<<<<<
  *                                utc_decimate_factor=s.utc_decimate_factor,
  *                                name=s.name,
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_annotation_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 349, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_annotation_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 376, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_annotation_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_annotation_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":350
+  /* "pyjls/binding.pyx":377
  *                                summary_decimate_factor=s.summary_decimate_factor,
  *                                annotation_decimate_factor=s.annotation_decimate_factor,
  *                                utc_decimate_factor=s.utc_decimate_factor,             # <<<<<<<<<<<<<<
  *                                name=s.name,
  *                                units=s.units)
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_utc_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 350, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_utc_decimate_factor); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 377, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_utc_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_utc_decimate_factor, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":351
+  /* "pyjls/binding.pyx":378
  *                                annotation_decimate_factor=s.annotation_decimate_factor,
  *                                utc_decimate_factor=s.utc_decimate_factor,
  *                                name=s.name,             # <<<<<<<<<<<<<<
  *                                units=s.units)
  * 
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 351, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 378, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_name, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_name, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":352
+  /* "pyjls/binding.pyx":379
  *                                utc_decimate_factor=s.utc_decimate_factor,
  *                                name=s.name,
  *                                units=s.units)             # <<<<<<<<<<<<<<
  * 
  *     def user_data(self, chunk_meta, data):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_units); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 352, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_units); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 379, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_units, __pyx_t_2) < 0) __PYX_ERR(0, 342, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_units, __pyx_t_2) < 0) __PYX_ERR(0, 369, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":340
- * 
+  /* "pyjls/binding.pyx":367
  *     def signal_def_from_struct(self, s: SignalDef):
+ *         """Define a signal."""
  *         return self.signal_def(s.signal_id,             # <<<<<<<<<<<<<<
  *                                s.source_id,
  *                                signal_type=s.signal_type,
  */
-  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 340, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 367, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_r = __pyx_t_2;
   __pyx_t_2 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":339
+  /* "pyjls/binding.pyx":365
  *         _handle_rc('signal_def', rc)
  * 
  *     def signal_def_from_struct(self, s: SignalDef):             # <<<<<<<<<<<<<<
+ *         """Define a signal."""
  *         return self.signal_def(s.signal_id,
- *                                s.source_id,
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3);
@@ -7793,24 +7846,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":354
+/* "pyjls/binding.pyx":381
  *                                units=s.units)
  * 
  *     def user_data(self, chunk_meta, data):             # <<<<<<<<<<<<<<
- *         cdef int32_t rc
- *         cdef uint16_t chunk_meta_u16 = chunk_meta
+ *         """Add user data to the file.
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_19user_data(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_18user_data[] = "Add user data to the file.\n\n        :param chunk_meta: The arbitrary u16 metadata value.\n        :param data: The bytes to store.\n        :raise: On error.\n        ";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_19user_data(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_chunk_meta = 0;
   PyObject *__pyx_v_data = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -7835,32 +7889,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_chunk_meta)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("user_data", 1, 2, 2, 1); __PYX_ERR(0, 354, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("user_data", 1, 2, 2, 1); __PYX_ERR(0, 381, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "user_data") < 0)) __PYX_ERR(0, 354, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "user_data") < 0)) __PYX_ERR(0, 381, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_chunk_meta = values[0];
     __pyx_v_data = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("user_data", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 354, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("user_data", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 381, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.user_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_18user_data(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_chunk_meta, __pyx_v_data);
 
@@ -7895,74 +7949,74 @@
   Py_ssize_t __pyx_t_13;
   int __pyx_t_14;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("user_data", 0);
 
-  /* "pyjls/binding.pyx":356
- *     def user_data(self, chunk_meta, data):
+  /* "pyjls/binding.pyx":389
+ *         """
  *         cdef int32_t rc
  *         cdef uint16_t chunk_meta_u16 = chunk_meta             # <<<<<<<<<<<<<<
  *         cdef c_jls.jls_storage_type_e storage_type
  *         cdef const uint8_t[:] payload_u8
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_chunk_meta); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 356, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_chunk_meta); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 389, __pyx_L1_error)
   __pyx_v_chunk_meta_u16 = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":359
+  /* "pyjls/binding.pyx":392
  *         cdef c_jls.jls_storage_type_e storage_type
  *         cdef const uint8_t[:] payload_u8
  *         cdef const uint8_t * payload_u8_ptr = NULL             # <<<<<<<<<<<<<<
  *         cdef uint32_t payload_length
  *         cdef c_jls.jls_twr_s * wr = self._wr
  */
   __pyx_v_payload_u8_ptr = NULL;
 
-  /* "pyjls/binding.pyx":361
+  /* "pyjls/binding.pyx":394
  *         cdef const uint8_t * payload_u8_ptr = NULL
  *         cdef uint32_t payload_length
  *         cdef c_jls.jls_twr_s * wr = self._wr             # <<<<<<<<<<<<<<
  *         storage_type, payload_bytes, payload_length = _storage_pack(data)
  *         payload_u8 = payload_bytes
  */
   __pyx_t_2 = __pyx_v_self->_wr;
   __pyx_v_wr = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":362
+  /* "pyjls/binding.pyx":395
  *         cdef uint32_t payload_length
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         storage_type, payload_bytes, payload_length = _storage_pack(data)             # <<<<<<<<<<<<<<
  *         payload_u8 = payload_bytes
  *         if 0 != payload_length:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_storage_pack); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 362, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_storage_pack); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 395, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
       __Pyx_INCREF(__pyx_t_5);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_4, function);
     }
   }
   __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_data);
   __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
-  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 362, __pyx_L1_error)
+  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 395, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
     PyObject* sequence = __pyx_t_3;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 3)) {
       if (size > 3) __Pyx_RaiseTooManyValuesError(3);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 362, __pyx_L1_error)
+      __PYX_ERR(0, 395, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
       __pyx_t_6 = PyTuple_GET_ITEM(sequence, 2); 
     } else {
@@ -7970,130 +8024,130 @@
       __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
       __pyx_t_6 = PyList_GET_ITEM(sequence, 2); 
     }
     __Pyx_INCREF(__pyx_t_4);
     __Pyx_INCREF(__pyx_t_5);
     __Pyx_INCREF(__pyx_t_6);
     #else
-    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 362, __pyx_L1_error)
+    __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 395, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 362, __pyx_L1_error)
+    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 395, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_6 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 362, __pyx_L1_error)
+    __pyx_t_6 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 395, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     #endif
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_7 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 362, __pyx_L1_error)
+    __pyx_t_7 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 395, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext;
     index = 0; __pyx_t_4 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_4)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_4);
     index = 1; __pyx_t_5 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_5)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_5);
     index = 2; __pyx_t_6 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_6)) goto __pyx_L3_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_6);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 3) < 0) __PYX_ERR(0, 362, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 3) < 0) __PYX_ERR(0, 395, __pyx_L1_error)
     __pyx_t_8 = NULL;
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     goto __pyx_L4_unpacking_done;
     __pyx_L3_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
     __pyx_t_8 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 362, __pyx_L1_error)
+    __PYX_ERR(0, 395, __pyx_L1_error)
     __pyx_L4_unpacking_done:;
   }
-  __pyx_t_9 = ((enum jls_storage_type_e)__Pyx_PyInt_As_enum__jls_storage_type_e(__pyx_t_4)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 362, __pyx_L1_error)
+  __pyx_t_9 = ((enum jls_storage_type_e)__Pyx_PyInt_As_enum__jls_storage_type_e(__pyx_t_4)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 395, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_6); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 362, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyInt_As_uint32_t(__pyx_t_6); if (unlikely((__pyx_t_10 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 395, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_v_storage_type = __pyx_t_9;
   __pyx_v_payload_bytes = __pyx_t_5;
   __pyx_t_5 = 0;
   __pyx_v_payload_length = __pyx_t_10;
 
-  /* "pyjls/binding.pyx":363
+  /* "pyjls/binding.pyx":396
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         storage_type, payload_bytes, payload_length = _storage_pack(data)
  *         payload_u8 = payload_bytes             # <<<<<<<<<<<<<<
  *         if 0 != payload_length:
  *             payload_u8_ptr = &payload_u8[0]
  */
-  __pyx_t_11 = __Pyx_PyObject_to_MemoryviewSlice_ds_nn_uint8_t__const__(__pyx_v_payload_bytes, 0); if (unlikely(!__pyx_t_11.memview)) __PYX_ERR(0, 363, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyObject_to_MemoryviewSlice_ds_nn_uint8_t__const__(__pyx_v_payload_bytes, 0); if (unlikely(!__pyx_t_11.memview)) __PYX_ERR(0, 396, __pyx_L1_error)
   __pyx_v_payload_u8 = __pyx_t_11;
   __pyx_t_11.memview = NULL;
   __pyx_t_11.data = NULL;
 
-  /* "pyjls/binding.pyx":364
+  /* "pyjls/binding.pyx":397
  *         storage_type, payload_bytes, payload_length = _storage_pack(data)
  *         payload_u8 = payload_bytes
  *         if 0 != payload_length:             # <<<<<<<<<<<<<<
  *             payload_u8_ptr = &payload_u8[0]
  *         with nogil:
  */
   __pyx_t_12 = ((0 != __pyx_v_payload_length) != 0);
   if (__pyx_t_12) {
 
-    /* "pyjls/binding.pyx":365
+    /* "pyjls/binding.pyx":398
  *         payload_u8 = payload_bytes
  *         if 0 != payload_length:
  *             payload_u8_ptr = &payload_u8[0]             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rc = c_jls.jls_twr_user_data(wr, chunk_meta_u16, storage_type, payload_u8_ptr, payload_length)
  */
     __pyx_t_13 = 0;
     __pyx_t_14 = -1;
     if (__pyx_t_13 < 0) {
       __pyx_t_13 += __pyx_v_payload_u8.shape[0];
       if (unlikely(__pyx_t_13 < 0)) __pyx_t_14 = 0;
     } else if (unlikely(__pyx_t_13 >= __pyx_v_payload_u8.shape[0])) __pyx_t_14 = 0;
     if (unlikely(__pyx_t_14 != -1)) {
       __Pyx_RaiseBufferIndexError(__pyx_t_14);
-      __PYX_ERR(0, 365, __pyx_L1_error)
+      __PYX_ERR(0, 398, __pyx_L1_error)
     }
     __pyx_v_payload_u8_ptr = (&(*((uint8_t const  *) ( /* dim=0 */ (__pyx_v_payload_u8.data + __pyx_t_13 * __pyx_v_payload_u8.strides[0]) ))));
 
-    /* "pyjls/binding.pyx":364
+    /* "pyjls/binding.pyx":397
  *         storage_type, payload_bytes, payload_length = _storage_pack(data)
  *         payload_u8 = payload_bytes
  *         if 0 != payload_length:             # <<<<<<<<<<<<<<
  *             payload_u8_ptr = &payload_u8[0]
  *         with nogil:
  */
   }
 
-  /* "pyjls/binding.pyx":366
+  /* "pyjls/binding.pyx":399
  *         if 0 != payload_length:
  *             payload_u8_ptr = &payload_u8[0]
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_user_data(wr, chunk_meta_u16, storage_type, payload_u8_ptr, payload_length)
  * 
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":367
+        /* "pyjls/binding.pyx":400
  *             payload_u8_ptr = &payload_u8[0]
  *         with nogil:
  *             rc = c_jls.jls_twr_user_data(wr, chunk_meta_u16, storage_type, payload_u8_ptr, payload_length)             # <<<<<<<<<<<<<<
  * 
  *         _handle_rc('user_data', rc)
  */
         __pyx_v_rc = jls_twr_user_data(__pyx_v_wr, __pyx_v_chunk_meta_u16, __pyx_v_storage_type, __pyx_v_payload_u8_ptr, __pyx_v_payload_length);
       }
 
-      /* "pyjls/binding.pyx":366
+      /* "pyjls/binding.pyx":399
  *         if 0 != payload_length:
  *             payload_u8_ptr = &payload_u8[0]
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_user_data(wr, chunk_meta_u16, storage_type, payload_u8_ptr, payload_length)
  * 
  */
       /*finally:*/ {
@@ -8104,24 +8158,24 @@
           #endif
           goto __pyx_L8;
         }
         __pyx_L8:;
       }
   }
 
-  /* "pyjls/binding.pyx":369
+  /* "pyjls/binding.pyx":402
  *             rc = c_jls.jls_twr_user_data(wr, chunk_meta_u16, storage_type, payload_u8_ptr, payload_length)
  * 
  *         _handle_rc('user_data', rc)             # <<<<<<<<<<<<<<
  * 
  *     def fsr_f32(self, signal_id, sample_id, data):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 369, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 402, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 369, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 402, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_4 = NULL;
   __pyx_t_14 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
@@ -8130,54 +8184,54 @@
       __Pyx_DECREF_SET(__pyx_t_6, function);
       __pyx_t_14 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_6)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_user_data, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_14, 2+__pyx_t_14); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_14, 2+__pyx_t_14); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 402, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_user_data, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_14, 2+__pyx_t_14); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_14, 2+__pyx_t_14); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 402, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(2+__pyx_t_14); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 369, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2+__pyx_t_14); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 402, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_user_data);
     __Pyx_GIVEREF(__pyx_n_u_user_data);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_14, __pyx_n_u_user_data);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_14, __pyx_t_5);
     __pyx_t_5 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 369, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 402, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":354
+  /* "pyjls/binding.pyx":381
  *                                units=s.units)
  * 
  *     def user_data(self, chunk_meta, data):             # <<<<<<<<<<<<<<
- *         cdef int32_t rc
- *         cdef uint16_t chunk_meta_u16 = chunk_meta
+ *         """Add user data to the file.
+ * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
@@ -8192,24 +8246,25 @@
   __PYX_XDEC_MEMVIEW(&__pyx_v_payload_u8, 1);
   __Pyx_XDECREF(__pyx_v_payload_bytes);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":371
+/* "pyjls/binding.pyx":404
  *         _handle_rc('user_data', rc)
  * 
  *     def fsr_f32(self, signal_id, sample_id, data):             # <<<<<<<<<<<<<<
- *         return self.fsr(signal_id, sample_id, data)
+ *         """Add 32-bit floating-point FSR data to a signal.
  * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_21fsr_f32(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_20fsr_f32[] = "Add 32-bit floating-point FSR data to a signal.\n\n        :param signal_id: The signal id for the data.\n        :param sample_id: The sample id for the first sample in data.\n        :param data: The 32-bit floating point data to add.\n        ";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_21fsr_f32(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_sample_id = 0;
   PyObject *__pyx_v_data = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -8237,40 +8292,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr_f32", 1, 3, 3, 1); __PYX_ERR(0, 371, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr_f32", 1, 3, 3, 1); __PYX_ERR(0, 404, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr_f32", 1, 3, 3, 2); __PYX_ERR(0, 371, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr_f32", 1, 3, 3, 2); __PYX_ERR(0, 404, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr_f32") < 0)) __PYX_ERR(0, 371, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr_f32") < 0)) __PYX_ERR(0, 404, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_sample_id = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fsr_f32", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 371, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fsr_f32", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 404, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.fsr_f32", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_20fsr_f32(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_data);
 
@@ -8288,23 +8343,23 @@
   int __pyx_t_4;
   PyObject *__pyx_t_5 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fsr_f32", 0);
 
-  /* "pyjls/binding.pyx":372
- * 
- *     def fsr_f32(self, signal_id, sample_id, data):
+  /* "pyjls/binding.pyx":411
+ *         :param data: The 32-bit floating point data to add.
+ *         """
  *         return self.fsr(signal_id, sample_id, data)             # <<<<<<<<<<<<<<
  * 
  *     def fsr(self, signal_id, sample_id, data):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fsr); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 372, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fsr); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 411, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   __pyx_t_4 = 0;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -8313,56 +8368,56 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_4 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_3, __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 372, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 411, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_3, __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_data};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 372, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_4, 3+__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 411, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_GOTREF(__pyx_t_1);
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(3+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 372, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(3+__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 411, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_3) {
       __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __pyx_t_3 = NULL;
     }
     __Pyx_INCREF(__pyx_v_signal_id);
     __Pyx_GIVEREF(__pyx_v_signal_id);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_signal_id);
     __Pyx_INCREF(__pyx_v_sample_id);
     __Pyx_GIVEREF(__pyx_v_sample_id);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_v_sample_id);
     __Pyx_INCREF(__pyx_v_data);
     __Pyx_GIVEREF(__pyx_v_data);
     PyTuple_SET_ITEM(__pyx_t_5, 2+__pyx_t_4, __pyx_v_data);
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 372, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 411, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":371
+  /* "pyjls/binding.pyx":404
  *         _handle_rc('user_data', rc)
  * 
  *     def fsr_f32(self, signal_id, sample_id, data):             # <<<<<<<<<<<<<<
- *         return self.fsr(signal_id, sample_id, data)
+ *         """Add 32-bit floating-point FSR data to a signal.
  * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_XDECREF(__pyx_t_2);
@@ -8372,24 +8427,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":374
+/* "pyjls/binding.pyx":413
  *         return self.fsr(signal_id, sample_id, data)
  * 
  *     def fsr(self, signal_id, sample_id, data):             # <<<<<<<<<<<<<<
- *         cdef c_jls.jls_twr_s * wr = self._wr
- *         cdef uint16_t signal_id_u16 = signal_id
+ *         """Add FSR data to a signal.
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_23fsr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_22fsr[] = "Add FSR data to a signal.\n\n        :param signal_id: The signal id for the data.\n        :param sample_id: The sample id for the first sample in data.\n        :param data: The data to add.\n        :raise: On error.\n        ";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_23fsr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_sample_id = 0;
   PyObject *__pyx_v_data = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -8417,40 +8473,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 1); __PYX_ERR(0, 374, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 1); __PYX_ERR(0, 413, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 2); __PYX_ERR(0, 374, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 2); __PYX_ERR(0, 413, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr") < 0)) __PYX_ERR(0, 374, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr") < 0)) __PYX_ERR(0, 413, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_sample_id = values[1];
     __pyx_v_data = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 374, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 413, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.fsr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_22fsr(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_data);
 
@@ -8489,282 +8545,282 @@
   int __pyx_t_15;
   PyObject *__pyx_t_16 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fsr", 0);
 
-  /* "pyjls/binding.pyx":375
- * 
- *     def fsr(self, signal_id, sample_id, data):
+  /* "pyjls/binding.pyx":421
+ *         :raise: On error.
+ *         """
  *         cdef c_jls.jls_twr_s * wr = self._wr             # <<<<<<<<<<<<<<
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t sample_id_i64 = sample_id
  */
   __pyx_t_1 = __pyx_v_self->_wr;
   __pyx_v_wr = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":376
- *     def fsr(self, signal_id, sample_id, data):
+  /* "pyjls/binding.pyx":422
+ *         """
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         cdef uint16_t signal_id_u16 = signal_id             # <<<<<<<<<<<<<<
  *         cdef int64_t sample_id_i64 = sample_id
  *         cdef int32_t rc
  */
-  __pyx_t_2 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_2 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 376, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_2 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 422, __pyx_L1_error)
   __pyx_v_signal_id_u16 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":377
+  /* "pyjls/binding.pyx":423
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t sample_id_i64 = sample_id             # <<<<<<<<<<<<<<
  *         cdef int32_t rc
  *         cdef np.uint8_t [::1] u8
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 377, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 423, __pyx_L1_error)
   __pyx_v_sample_id_i64 = __pyx_t_3;
 
-  /* "pyjls/binding.pyx":384
+  /* "pyjls/binding.pyx":430
  *         cdef uint32_t length
  * 
  *         data_type = self._signals[signal_id].data_type             # <<<<<<<<<<<<<<
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]
  */
-  __pyx_t_4 = __Pyx_PyIndex_AsSsize_t(__pyx_v_signal_id); if (unlikely((__pyx_t_4 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 384, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyIndex_AsSsize_t(__pyx_v_signal_id); if (unlikely((__pyx_t_4 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 430, __pyx_L1_error)
   __pyx_t_5 = (__pyx_v_self->_signals[__pyx_t_4]).data_type;
   __pyx_v_data_type = __pyx_t_5;
 
-  /* "pyjls/binding.pyx":385
+  /* "pyjls/binding.pyx":431
  * 
  *         data_type = self._signals[signal_id].data_type
  *         entry_size_bits = (data_type >> 8) & 0xff             # <<<<<<<<<<<<<<
  *         np_type = _data_type_map[data_type & 0xffff]
  *         if np_type != data.dtype:
  */
   __pyx_v_entry_size_bits = ((__pyx_v_data_type >> 8) & 0xff);
 
-  /* "pyjls/binding.pyx":386
+  /* "pyjls/binding.pyx":432
  *         data_type = self._signals[signal_id].data_type
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]             # <<<<<<<<<<<<<<
  *         if np_type != data.dtype:
  *             raise ValueError(f'Data type mismatch {data.dtype} != {np_type}')
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_data_type_map); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 386, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_data_type_map); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_t_7 = (__pyx_v_data_type & 0xffff);
-  __pyx_t_8 = __Pyx_GetItemInt(__pyx_t_6, __pyx_t_7, long, 1, __Pyx_PyInt_From_long, 0, 1, 1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 386, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_GetItemInt(__pyx_t_6, __pyx_t_7, long, 1, __Pyx_PyInt_From_long, 0, 1, 1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 432, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __pyx_v_np_type = __pyx_t_8;
   __pyx_t_8 = 0;
 
-  /* "pyjls/binding.pyx":387
+  /* "pyjls/binding.pyx":433
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]
  *         if np_type != data.dtype:             # <<<<<<<<<<<<<<
  *             raise ValueError(f'Data type mismatch {data.dtype} != {np_type}')
  *         data_u8 = data.view(dtype=np.uint8)
  */
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_dtype); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 387, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_dtype); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 433, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_6 = PyObject_RichCompare(__pyx_v_np_type, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 387, __pyx_L1_error)
+  __pyx_t_6 = PyObject_RichCompare(__pyx_v_np_type, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 433, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 387, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 433, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   if (unlikely(__pyx_t_9)) {
 
-    /* "pyjls/binding.pyx":388
+    /* "pyjls/binding.pyx":434
  *         np_type = _data_type_map[data_type & 0xffff]
  *         if np_type != data.dtype:
  *             raise ValueError(f'Data type mismatch {data.dtype} != {np_type}')             # <<<<<<<<<<<<<<
  *         data_u8 = data.view(dtype=np.uint8)
  *         u8 = data_u8
  */
-    __pyx_t_6 = PyTuple_New(4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 388, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 434, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __pyx_t_4 = 0;
     __pyx_t_10 = 127;
     __Pyx_INCREF(__pyx_kp_u_Data_type_mismatch);
     __pyx_t_4 += 19;
     __Pyx_GIVEREF(__pyx_kp_u_Data_type_mismatch);
     PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_kp_u_Data_type_mismatch);
-    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_dtype); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 388, __pyx_L1_error)
+    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_dtype); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 434, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_11 = __Pyx_PyObject_FormatSimple(__pyx_t_8, __pyx_empty_unicode); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 388, __pyx_L1_error)
+    __pyx_t_11 = __Pyx_PyObject_FormatSimple(__pyx_t_8, __pyx_empty_unicode); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 434, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_11) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_11) : __pyx_t_10;
     __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_11);
     __Pyx_GIVEREF(__pyx_t_11);
     PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_11);
     __pyx_t_11 = 0;
     __Pyx_INCREF(__pyx_kp_u__8);
     __pyx_t_4 += 4;
     __Pyx_GIVEREF(__pyx_kp_u__8);
     PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_kp_u__8);
-    __pyx_t_11 = __Pyx_PyObject_FormatSimple(__pyx_v_np_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 388, __pyx_L1_error)
+    __pyx_t_11 = __Pyx_PyObject_FormatSimple(__pyx_v_np_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 434, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_11) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_11) : __pyx_t_10;
     __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_11);
     __Pyx_GIVEREF(__pyx_t_11);
     PyTuple_SET_ITEM(__pyx_t_6, 3, __pyx_t_11);
     __pyx_t_11 = 0;
-    __pyx_t_11 = __Pyx_PyUnicode_Join(__pyx_t_6, 4, __pyx_t_4, __pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 388, __pyx_L1_error)
+    __pyx_t_11 = __Pyx_PyUnicode_Join(__pyx_t_6, 4, __pyx_t_4, __pyx_t_10); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 434, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 388, __pyx_L1_error)
+    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 434, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
     __Pyx_Raise(__pyx_t_6, 0, 0, 0);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-    __PYX_ERR(0, 388, __pyx_L1_error)
+    __PYX_ERR(0, 434, __pyx_L1_error)
 
-    /* "pyjls/binding.pyx":387
+    /* "pyjls/binding.pyx":433
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]
  *         if np_type != data.dtype:             # <<<<<<<<<<<<<<
  *             raise ValueError(f'Data type mismatch {data.dtype} != {np_type}')
  *         data_u8 = data.view(dtype=np.uint8)
  */
   }
 
-  /* "pyjls/binding.pyx":389
+  /* "pyjls/binding.pyx":435
  *         if np_type != data.dtype:
  *             raise ValueError(f'Data type mismatch {data.dtype} != {np_type}')
  *         data_u8 = data.view(dtype=np.uint8)             # <<<<<<<<<<<<<<
  *         u8 = data_u8
  *         length = len(data)
  */
-  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_view); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 389, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_view); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_11 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 389, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 389, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_uint8); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 389, __pyx_L1_error)
+  __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_uint8); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_12);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (PyDict_SetItem(__pyx_t_11, __pyx_n_s_dtype, __pyx_t_12) < 0) __PYX_ERR(0, 389, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_11, __pyx_n_s_dtype, __pyx_t_12) < 0) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-  __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_empty_tuple, __pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 389, __pyx_L1_error)
+  __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_empty_tuple, __pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 435, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_12);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   __pyx_v_data_u8 = __pyx_t_12;
   __pyx_t_12 = 0;
 
-  /* "pyjls/binding.pyx":390
+  /* "pyjls/binding.pyx":436
  *             raise ValueError(f'Data type mismatch {data.dtype} != {np_type}')
  *         data_u8 = data.view(dtype=np.uint8)
  *         u8 = data_u8             # <<<<<<<<<<<<<<
  *         length = len(data)
  *         if entry_size_bits == 4:
  */
-  __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_dc_nn___pyx_t_5numpy_uint8_t(__pyx_v_data_u8, PyBUF_WRITABLE); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 390, __pyx_L1_error)
+  __pyx_t_13 = __Pyx_PyObject_to_MemoryviewSlice_dc_nn___pyx_t_5numpy_uint8_t(__pyx_v_data_u8, PyBUF_WRITABLE); if (unlikely(!__pyx_t_13.memview)) __PYX_ERR(0, 436, __pyx_L1_error)
   __pyx_v_u8 = __pyx_t_13;
   __pyx_t_13.memview = NULL;
   __pyx_t_13.data = NULL;
 
-  /* "pyjls/binding.pyx":391
+  /* "pyjls/binding.pyx":437
  *         data_u8 = data.view(dtype=np.uint8)
  *         u8 = data_u8
  *         length = len(data)             # <<<<<<<<<<<<<<
  *         if entry_size_bits == 4:
  *             length *= 2
  */
-  __pyx_t_4 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 391, __pyx_L1_error)
+  __pyx_t_4 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 437, __pyx_L1_error)
   __pyx_v_length = __pyx_t_4;
 
-  /* "pyjls/binding.pyx":392
+  /* "pyjls/binding.pyx":438
  *         u8 = data_u8
  *         length = len(data)
  *         if entry_size_bits == 4:             # <<<<<<<<<<<<<<
  *             length *= 2
  *         elif entry_size_bits == 1:
  */
   switch (__pyx_v_entry_size_bits) {
     case 4:
 
-    /* "pyjls/binding.pyx":393
+    /* "pyjls/binding.pyx":439
  *         length = len(data)
  *         if entry_size_bits == 4:
  *             length *= 2             # <<<<<<<<<<<<<<
  *         elif entry_size_bits == 1:
  *             length *= 8
  */
     __pyx_v_length = (__pyx_v_length * 2);
 
-    /* "pyjls/binding.pyx":392
+    /* "pyjls/binding.pyx":438
  *         u8 = data_u8
  *         length = len(data)
  *         if entry_size_bits == 4:             # <<<<<<<<<<<<<<
  *             length *= 2
  *         elif entry_size_bits == 1:
  */
     break;
     case 1:
 
-    /* "pyjls/binding.pyx":395
+    /* "pyjls/binding.pyx":441
  *             length *= 2
  *         elif entry_size_bits == 1:
  *             length *= 8             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rc = c_jls.jls_twr_fsr(wr, signal_id_u16, sample_id_i64, &u8[0], length)
  */
     __pyx_v_length = (__pyx_v_length * 8);
 
-    /* "pyjls/binding.pyx":394
+    /* "pyjls/binding.pyx":440
  *         if entry_size_bits == 4:
  *             length *= 2
  *         elif entry_size_bits == 1:             # <<<<<<<<<<<<<<
  *             length *= 8
  *         with nogil:
  */
     break;
     default: break;
   }
 
-  /* "pyjls/binding.pyx":396
+  /* "pyjls/binding.pyx":442
  *         elif entry_size_bits == 1:
  *             length *= 8
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_fsr(wr, signal_id_u16, sample_id_i64, &u8[0], length)
  *         _handle_rc('fsr', rc)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":397
+        /* "pyjls/binding.pyx":443
  *             length *= 8
  *         with nogil:
  *             rc = c_jls.jls_twr_fsr(wr, signal_id_u16, sample_id_i64, &u8[0], length)             # <<<<<<<<<<<<<<
  *         _handle_rc('fsr', rc)
  * 
  */
         __pyx_t_14 = 0;
         __pyx_t_15 = -1;
         if (__pyx_t_14 < 0) {
           __pyx_t_14 += __pyx_v_u8.shape[0];
           if (unlikely(__pyx_t_14 < 0)) __pyx_t_15 = 0;
         } else if (unlikely(__pyx_t_14 >= __pyx_v_u8.shape[0])) __pyx_t_15 = 0;
         if (unlikely(__pyx_t_15 != -1)) {
           __Pyx_RaiseBufferIndexErrorNogil(__pyx_t_15);
-          __PYX_ERR(0, 397, __pyx_L5_error)
+          __PYX_ERR(0, 443, __pyx_L5_error)
         }
         __pyx_v_rc = jls_twr_fsr(__pyx_v_wr, __pyx_v_signal_id_u16, __pyx_v_sample_id_i64, (&(*((__pyx_t_5numpy_uint8_t *) ( /* dim=0 */ ((char *) (((__pyx_t_5numpy_uint8_t *) __pyx_v_u8.data) + __pyx_t_14)) )))), __pyx_v_length);
       }
 
-      /* "pyjls/binding.pyx":396
+      /* "pyjls/binding.pyx":442
  *         elif entry_size_bits == 1:
  *             length *= 8
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_fsr(wr, signal_id_u16, sample_id_i64, &u8[0], length)
  *         _handle_rc('fsr', rc)
  */
       /*finally:*/ {
@@ -8782,24 +8838,24 @@
           #endif
           goto __pyx_L1_error;
         }
         __pyx_L6:;
       }
   }
 
-  /* "pyjls/binding.pyx":398
+  /* "pyjls/binding.pyx":444
  *         with nogil:
  *             rc = c_jls.jls_twr_fsr(wr, signal_id_u16, sample_id_i64, &u8[0], length)
  *         _handle_rc('fsr', rc)             # <<<<<<<<<<<<<<
  * 
  *     def annotation(self, signal_id, timestamp, y, annotation_type, group_id, data):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 398, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 444, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
-  __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 398, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 444, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_t_8 = NULL;
   __pyx_t_15 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_11))) {
     __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_11);
     if (likely(__pyx_t_8)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_11);
@@ -8808,54 +8864,54 @@
       __Pyx_DECREF_SET(__pyx_t_11, function);
       __pyx_t_15 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_11)) {
     PyObject *__pyx_temp[3] = {__pyx_t_8, __pyx_n_u_fsr, __pyx_t_6};
-    __pyx_t_12 = __Pyx_PyFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 444, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_GOTREF(__pyx_t_12);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_11)) {
     PyObject *__pyx_temp[3] = {__pyx_t_8, __pyx_n_u_fsr, __pyx_t_6};
-    __pyx_t_12 = __Pyx_PyCFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyCFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_15, 2+__pyx_t_15); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 444, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_GOTREF(__pyx_t_12);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else
   #endif
   {
-    __pyx_t_16 = PyTuple_New(2+__pyx_t_15); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_16 = PyTuple_New(2+__pyx_t_15); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 444, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_16);
     if (__pyx_t_8) {
       __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_t_8); __pyx_t_8 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_fsr);
     __Pyx_GIVEREF(__pyx_n_u_fsr);
     PyTuple_SET_ITEM(__pyx_t_16, 0+__pyx_t_15, __pyx_n_u_fsr);
     __Pyx_GIVEREF(__pyx_t_6);
     PyTuple_SET_ITEM(__pyx_t_16, 1+__pyx_t_15, __pyx_t_6);
     __pyx_t_6 = 0;
-    __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_16, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 398, __pyx_L1_error)
+    __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_16, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 444, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_12);
     __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
   }
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
 
-  /* "pyjls/binding.pyx":374
+  /* "pyjls/binding.pyx":413
  *         return self.fsr(signal_id, sample_id, data)
  * 
  *     def fsr(self, signal_id, sample_id, data):             # <<<<<<<<<<<<<<
- *         cdef c_jls.jls_twr_s * wr = self._wr
- *         cdef uint16_t signal_id_u16 = signal_id
+ *         """Add FSR data to a signal.
+ * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_6);
@@ -8871,24 +8927,25 @@
   __Pyx_XDECREF(__pyx_v_np_type);
   __Pyx_XDECREF(__pyx_v_data_u8);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":400
+/* "pyjls/binding.pyx":446
  *         _handle_rc('fsr', rc)
  * 
  *     def annotation(self, signal_id, timestamp, y, annotation_type, group_id, data):             # <<<<<<<<<<<<<<
- *         cdef c_jls.jls_twr_s * wr = self._wr
- *         cdef uint16_t signal_id_u16 = signal_id
+ *         """Add an annotation to a signal.
+ * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_25annotation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_24annotation[] = "Add an annotation to a signal.\n\n        :param signal_id: The signal id.\n        :param timestamp: The x-axis timestamp in sample_id for FSR and UTC for VSR.\n        :param y: The y-axis value or NAN to automatically position.\n        :param annotation_type: The annotation type.\n        :param data: The data for the annotation.\n        :raise: On error.\n        ";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_25annotation(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_timestamp = 0;
   PyObject *__pyx_v_y = 0;
   PyObject *__pyx_v_annotation_type = 0;
   PyObject *__pyx_v_group_id = 0;
   PyObject *__pyx_v_data = 0;
@@ -8925,43 +8982,43 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_timestamp)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 1); __PYX_ERR(0, 400, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 1); __PYX_ERR(0, 446, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 2); __PYX_ERR(0, 400, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 2); __PYX_ERR(0, 446, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_annotation_type)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 3); __PYX_ERR(0, 400, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 3); __PYX_ERR(0, 446, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  4:
         if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_group_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 4); __PYX_ERR(0, 400, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 4); __PYX_ERR(0, 446, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  5:
         if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 5); __PYX_ERR(0, 400, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, 5); __PYX_ERR(0, 446, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "annotation") < 0)) __PYX_ERR(0, 400, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "annotation") < 0)) __PYX_ERR(0, 446, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 6) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -8974,15 +9031,15 @@
     __pyx_v_y = values[2];
     __pyx_v_annotation_type = values[3];
     __pyx_v_group_id = values[4];
     __pyx_v_data = values[5];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 400, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("annotation", 1, 6, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 446, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.annotation", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_24annotation(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_timestamp, __pyx_v_y, __pyx_v_annotation_type, __pyx_v_group_id, __pyx_v_data);
 
@@ -9028,191 +9085,191 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("annotation", 0);
   __Pyx_INCREF(__pyx_v_y);
   __Pyx_INCREF(__pyx_v_annotation_type);
 
-  /* "pyjls/binding.pyx":401
- * 
- *     def annotation(self, signal_id, timestamp, y, annotation_type, group_id, data):
+  /* "pyjls/binding.pyx":456
+ *         :raise: On error.
+ *         """
  *         cdef c_jls.jls_twr_s * wr = self._wr             # <<<<<<<<<<<<<<
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t timestamp_i64 = timestamp
  */
   __pyx_t_1 = __pyx_v_self->_wr;
   __pyx_v_wr = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":402
- *     def annotation(self, signal_id, timestamp, y, annotation_type, group_id, data):
+  /* "pyjls/binding.pyx":457
+ *         """
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         cdef uint16_t signal_id_u16 = signal_id             # <<<<<<<<<<<<<<
  *         cdef int64_t timestamp_i64 = timestamp
  *         cdef uint8_t group_id_u8 = group_id
  */
-  __pyx_t_2 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_2 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 402, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_2 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 457, __pyx_L1_error)
   __pyx_v_signal_id_u16 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":403
+  /* "pyjls/binding.pyx":458
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t timestamp_i64 = timestamp             # <<<<<<<<<<<<<<
  *         cdef uint8_t group_id_u8 = group_id
  *         cdef float y_f32
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_timestamp); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 403, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_timestamp); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 458, __pyx_L1_error)
   __pyx_v_timestamp_i64 = __pyx_t_3;
 
-  /* "pyjls/binding.pyx":404
+  /* "pyjls/binding.pyx":459
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t timestamp_i64 = timestamp
  *         cdef uint8_t group_id_u8 = group_id             # <<<<<<<<<<<<<<
  *         cdef float y_f32
  *         cdef c_jls.jls_annotation_type_e annotation_type_e
  */
-  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_group_id); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 404, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_uint8_t(__pyx_v_group_id); if (unlikely((__pyx_t_4 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 459, __pyx_L1_error)
   __pyx_v_group_id_u8 = __pyx_t_4;
 
-  /* "pyjls/binding.pyx":412
+  /* "pyjls/binding.pyx":467
  *         cdef int32_t rc
  * 
  *         if y is None:             # <<<<<<<<<<<<<<
  *             y_f32 = NAN
  *         else:
  */
   __pyx_t_5 = (__pyx_v_y == Py_None);
   __pyx_t_6 = (__pyx_t_5 != 0);
   if (__pyx_t_6) {
 
-    /* "pyjls/binding.pyx":413
+    /* "pyjls/binding.pyx":468
  * 
  *         if y is None:
  *             y_f32 = NAN             # <<<<<<<<<<<<<<
  *         else:
  *             y_f32 = y
  */
     __pyx_v_y_f32 = NAN;
 
-    /* "pyjls/binding.pyx":412
+    /* "pyjls/binding.pyx":467
  *         cdef int32_t rc
  * 
  *         if y is None:             # <<<<<<<<<<<<<<
  *             y_f32 = NAN
  *         else:
  */
     goto __pyx_L3;
   }
 
-  /* "pyjls/binding.pyx":415
+  /* "pyjls/binding.pyx":470
  *             y_f32 = NAN
  *         else:
  *             y_f32 = y             # <<<<<<<<<<<<<<
  *         if isinstance(annotation_type, str):
  *             annotation_type = _annotation_map[annotation_type.lower()]
  */
   /*else*/ {
-    __pyx_t_7 = __pyx_PyFloat_AsFloat(__pyx_v_y); if (unlikely((__pyx_t_7 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 415, __pyx_L1_error)
+    __pyx_t_7 = __pyx_PyFloat_AsFloat(__pyx_v_y); if (unlikely((__pyx_t_7 == (float)-1) && PyErr_Occurred())) __PYX_ERR(0, 470, __pyx_L1_error)
     __pyx_v_y_f32 = __pyx_t_7;
   }
   __pyx_L3:;
 
-  /* "pyjls/binding.pyx":416
+  /* "pyjls/binding.pyx":471
  *         else:
  *             y_f32 = y
  *         if isinstance(annotation_type, str):             # <<<<<<<<<<<<<<
  *             annotation_type = _annotation_map[annotation_type.lower()]
  *         annotation_type_e = annotation_type
  */
   __pyx_t_6 = PyUnicode_Check(__pyx_v_annotation_type); 
   __pyx_t_5 = (__pyx_t_6 != 0);
   if (__pyx_t_5) {
 
-    /* "pyjls/binding.pyx":417
+    /* "pyjls/binding.pyx":472
  *             y_f32 = y
  *         if isinstance(annotation_type, str):
  *             annotation_type = _annotation_map[annotation_type.lower()]             # <<<<<<<<<<<<<<
  *         annotation_type_e = annotation_type
  *         storage_type, payload, payload_length = _storage_pack(data)
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_annotation_map); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 417, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_annotation_map); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 472, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_annotation_type, __pyx_n_s_lower); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 417, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_annotation_type, __pyx_n_s_lower); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 472, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __pyx_t_11 = NULL;
     if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_10))) {
       __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_10);
       if (likely(__pyx_t_11)) {
         PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
         __Pyx_INCREF(__pyx_t_11);
         __Pyx_INCREF(function);
         __Pyx_DECREF_SET(__pyx_t_10, function);
       }
     }
     __pyx_t_9 = (__pyx_t_11) ? __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_t_11) : __Pyx_PyObject_CallNoArg(__pyx_t_10);
     __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-    if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 417, __pyx_L1_error)
+    if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 472, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
-    __pyx_t_10 = __Pyx_PyObject_GetItem(__pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 417, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_GetItem(__pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 472, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
     __Pyx_DECREF_SET(__pyx_v_annotation_type, __pyx_t_10);
     __pyx_t_10 = 0;
 
-    /* "pyjls/binding.pyx":416
+    /* "pyjls/binding.pyx":471
  *         else:
  *             y_f32 = y
  *         if isinstance(annotation_type, str):             # <<<<<<<<<<<<<<
  *             annotation_type = _annotation_map[annotation_type.lower()]
  *         annotation_type_e = annotation_type
  */
   }
 
-  /* "pyjls/binding.pyx":418
+  /* "pyjls/binding.pyx":473
  *         if isinstance(annotation_type, str):
  *             annotation_type = _annotation_map[annotation_type.lower()]
  *         annotation_type_e = annotation_type             # <<<<<<<<<<<<<<
  *         storage_type, payload, payload_length = _storage_pack(data)
  *         payload_u8 = payload
  */
-  __pyx_t_12 = ((enum jls_annotation_type_e)__Pyx_PyInt_As_enum__jls_annotation_type_e(__pyx_v_annotation_type)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 418, __pyx_L1_error)
+  __pyx_t_12 = ((enum jls_annotation_type_e)__Pyx_PyInt_As_enum__jls_annotation_type_e(__pyx_v_annotation_type)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 473, __pyx_L1_error)
   __pyx_v_annotation_type_e = __pyx_t_12;
 
-  /* "pyjls/binding.pyx":419
+  /* "pyjls/binding.pyx":474
  *             annotation_type = _annotation_map[annotation_type.lower()]
  *         annotation_type_e = annotation_type
  *         storage_type, payload, payload_length = _storage_pack(data)             # <<<<<<<<<<<<<<
  *         payload_u8 = payload
  *         if y is None or not np.isfinite(y):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_storage_pack); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 419, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_storage_pack); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __pyx_t_8 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
     __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_9);
     if (likely(__pyx_t_8)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
       __Pyx_INCREF(__pyx_t_8);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_9, function);
     }
   }
   __pyx_t_10 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_8, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_data);
   __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 419, __pyx_L1_error)
+  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
   if ((likely(PyTuple_CheckExact(__pyx_t_10))) || (PyList_CheckExact(__pyx_t_10))) {
     PyObject* sequence = __pyx_t_10;
     Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
     if (unlikely(size != 3)) {
       if (size > 3) __Pyx_RaiseTooManyValuesError(3);
       else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
-      __PYX_ERR(0, 419, __pyx_L1_error)
+      __PYX_ERR(0, 474, __pyx_L1_error)
     }
     #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
     if (likely(PyTuple_CheckExact(sequence))) {
       __pyx_t_9 = PyTuple_GET_ITEM(sequence, 0); 
       __pyx_t_8 = PyTuple_GET_ITEM(sequence, 1); 
       __pyx_t_11 = PyTuple_GET_ITEM(sequence, 2); 
     } else {
@@ -9220,172 +9277,172 @@
       __pyx_t_8 = PyList_GET_ITEM(sequence, 1); 
       __pyx_t_11 = PyList_GET_ITEM(sequence, 2); 
     }
     __Pyx_INCREF(__pyx_t_9);
     __Pyx_INCREF(__pyx_t_8);
     __Pyx_INCREF(__pyx_t_11);
     #else
-    __pyx_t_9 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 419, __pyx_L1_error)
+    __pyx_t_9 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 474, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
-    __pyx_t_8 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 419, __pyx_L1_error)
+    __pyx_t_8 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 474, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
-    __pyx_t_11 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 419, __pyx_L1_error)
+    __pyx_t_11 = PySequence_ITEM(sequence, 2); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 474, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_11);
     #endif
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   } else {
     Py_ssize_t index = -1;
-    __pyx_t_13 = PyObject_GetIter(__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 419, __pyx_L1_error)
+    __pyx_t_13 = PyObject_GetIter(__pyx_t_10); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 474, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_13);
     __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
     __pyx_t_14 = Py_TYPE(__pyx_t_13)->tp_iternext;
     index = 0; __pyx_t_9 = __pyx_t_14(__pyx_t_13); if (unlikely(!__pyx_t_9)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_9);
     index = 1; __pyx_t_8 = __pyx_t_14(__pyx_t_13); if (unlikely(!__pyx_t_8)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_8);
     index = 2; __pyx_t_11 = __pyx_t_14(__pyx_t_13); if (unlikely(!__pyx_t_11)) goto __pyx_L5_unpacking_failed;
     __Pyx_GOTREF(__pyx_t_11);
-    if (__Pyx_IternextUnpackEndCheck(__pyx_t_14(__pyx_t_13), 3) < 0) __PYX_ERR(0, 419, __pyx_L1_error)
+    if (__Pyx_IternextUnpackEndCheck(__pyx_t_14(__pyx_t_13), 3) < 0) __PYX_ERR(0, 474, __pyx_L1_error)
     __pyx_t_14 = NULL;
     __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
     goto __pyx_L6_unpacking_done;
     __pyx_L5_unpacking_failed:;
     __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
     __pyx_t_14 = NULL;
     if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
-    __PYX_ERR(0, 419, __pyx_L1_error)
+    __PYX_ERR(0, 474, __pyx_L1_error)
     __pyx_L6_unpacking_done:;
   }
-  __pyx_t_15 = ((enum jls_storage_type_e)__Pyx_PyInt_As_enum__jls_storage_type_e(__pyx_t_9)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 419, __pyx_L1_error)
+  __pyx_t_15 = ((enum jls_storage_type_e)__Pyx_PyInt_As_enum__jls_storage_type_e(__pyx_t_9)); if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_t_16 = __Pyx_PyInt_As_uint32_t(__pyx_t_11); if (unlikely((__pyx_t_16 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 419, __pyx_L1_error)
+  __pyx_t_16 = __Pyx_PyInt_As_uint32_t(__pyx_t_11); if (unlikely((__pyx_t_16 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 474, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   __pyx_v_storage_type = __pyx_t_15;
   __pyx_v_payload = __pyx_t_8;
   __pyx_t_8 = 0;
   __pyx_v_payload_length = __pyx_t_16;
 
-  /* "pyjls/binding.pyx":420
+  /* "pyjls/binding.pyx":475
  *         annotation_type_e = annotation_type
  *         storage_type, payload, payload_length = _storage_pack(data)
  *         payload_u8 = payload             # <<<<<<<<<<<<<<
  *         if y is None or not np.isfinite(y):
  *             y = NAN
  */
-  __pyx_t_17 = __Pyx_PyObject_to_MemoryviewSlice_ds_nn_uint8_t__const__(__pyx_v_payload, 0); if (unlikely(!__pyx_t_17.memview)) __PYX_ERR(0, 420, __pyx_L1_error)
+  __pyx_t_17 = __Pyx_PyObject_to_MemoryviewSlice_ds_nn_uint8_t__const__(__pyx_v_payload, 0); if (unlikely(!__pyx_t_17.memview)) __PYX_ERR(0, 475, __pyx_L1_error)
   __pyx_v_payload_u8 = __pyx_t_17;
   __pyx_t_17.memview = NULL;
   __pyx_t_17.data = NULL;
 
-  /* "pyjls/binding.pyx":421
+  /* "pyjls/binding.pyx":476
  *         storage_type, payload, payload_length = _storage_pack(data)
  *         payload_u8 = payload
  *         if y is None or not np.isfinite(y):             # <<<<<<<<<<<<<<
  *             y = NAN
  *         with nogil:
  */
   __pyx_t_6 = (__pyx_v_y == Py_None);
   __pyx_t_18 = (__pyx_t_6 != 0);
   if (!__pyx_t_18) {
   } else {
     __pyx_t_5 = __pyx_t_18;
     goto __pyx_L8_bool_binop_done;
   }
-  __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_np); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 421, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_11, __pyx_n_s_np); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 476, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
-  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_isfinite); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 421, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_11, __pyx_n_s_isfinite); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 476, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
   __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   __pyx_t_11 = NULL;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
     __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_8);
     if (likely(__pyx_t_11)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
       __Pyx_INCREF(__pyx_t_11);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_8, function);
     }
   }
   __pyx_t_10 = (__pyx_t_11) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_11, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_y);
   __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
-  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 421, __pyx_L1_error)
+  if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 476, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_10);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 421, __pyx_L1_error)
+  __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_t_10); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 476, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
   __pyx_t_6 = ((!__pyx_t_18) != 0);
   __pyx_t_5 = __pyx_t_6;
   __pyx_L8_bool_binop_done:;
   if (__pyx_t_5) {
 
-    /* "pyjls/binding.pyx":422
+    /* "pyjls/binding.pyx":477
  *         payload_u8 = payload
  *         if y is None or not np.isfinite(y):
  *             y = NAN             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rc = c_jls.jls_twr_annotation(wr, signal_id_u16, timestamp_i64, y_f32,
  */
-    __pyx_t_10 = PyFloat_FromDouble(NAN); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 422, __pyx_L1_error)
+    __pyx_t_10 = PyFloat_FromDouble(NAN); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 477, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_10);
     __pyx_t_10 = 0;
 
-    /* "pyjls/binding.pyx":421
+    /* "pyjls/binding.pyx":476
  *         storage_type, payload, payload_length = _storage_pack(data)
  *         payload_u8 = payload
  *         if y is None or not np.isfinite(y):             # <<<<<<<<<<<<<<
  *             y = NAN
  *         with nogil:
  */
   }
 
-  /* "pyjls/binding.pyx":423
+  /* "pyjls/binding.pyx":478
  *         if y is None or not np.isfinite(y):
  *             y = NAN
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_annotation(wr, signal_id_u16, timestamp_i64, y_f32,
  *                 annotation_type_e,
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":426
+        /* "pyjls/binding.pyx":481
  *             rc = c_jls.jls_twr_annotation(wr, signal_id_u16, timestamp_i64, y_f32,
  *                 annotation_type_e,
  *                 group_id_u8, storage_type, &payload_u8[0], payload_length)             # <<<<<<<<<<<<<<
  *         _handle_rc('annotation', rc)
  * 
  */
         __pyx_t_19 = 0;
         __pyx_t_20 = -1;
         if (__pyx_t_19 < 0) {
           __pyx_t_19 += __pyx_v_payload_u8.shape[0];
           if (unlikely(__pyx_t_19 < 0)) __pyx_t_20 = 0;
         } else if (unlikely(__pyx_t_19 >= __pyx_v_payload_u8.shape[0])) __pyx_t_20 = 0;
         if (unlikely(__pyx_t_20 != -1)) {
           __Pyx_RaiseBufferIndexErrorNogil(__pyx_t_20);
-          __PYX_ERR(0, 426, __pyx_L11_error)
+          __PYX_ERR(0, 481, __pyx_L11_error)
         }
 
-        /* "pyjls/binding.pyx":424
+        /* "pyjls/binding.pyx":479
  *             y = NAN
  *         with nogil:
  *             rc = c_jls.jls_twr_annotation(wr, signal_id_u16, timestamp_i64, y_f32,             # <<<<<<<<<<<<<<
  *                 annotation_type_e,
  *                 group_id_u8, storage_type, &payload_u8[0], payload_length)
  */
         __pyx_v_rc = jls_twr_annotation(__pyx_v_wr, __pyx_v_signal_id_u16, __pyx_v_timestamp_i64, __pyx_v_y_f32, __pyx_v_annotation_type_e, __pyx_v_group_id_u8, __pyx_v_storage_type, (&(*((uint8_t const  *) ( /* dim=0 */ (__pyx_v_payload_u8.data + __pyx_t_19 * __pyx_v_payload_u8.strides[0]) )))), __pyx_v_payload_length);
       }
 
-      /* "pyjls/binding.pyx":423
+      /* "pyjls/binding.pyx":478
  *         if y is None or not np.isfinite(y):
  *             y = NAN
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_annotation(wr, signal_id_u16, timestamp_i64, y_f32,
  *                 annotation_type_e,
  */
       /*finally:*/ {
@@ -9403,24 +9460,24 @@
           #endif
           goto __pyx_L1_error;
         }
         __pyx_L12:;
       }
   }
 
-  /* "pyjls/binding.pyx":427
+  /* "pyjls/binding.pyx":482
  *                 annotation_type_e,
  *                 group_id_u8, storage_type, &payload_u8[0], payload_length)
  *         _handle_rc('annotation', rc)             # <<<<<<<<<<<<<<
  * 
  *     def utc(self, signal_id, sample_id, utc_i64):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 482, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_11 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 427, __pyx_L1_error)
+  __pyx_t_11 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 482, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_11);
   __pyx_t_9 = NULL;
   __pyx_t_20 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
     __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_8);
     if (likely(__pyx_t_9)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
@@ -9429,54 +9486,54 @@
       __Pyx_DECREF_SET(__pyx_t_8, function);
       __pyx_t_20 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_8)) {
     PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_n_u_annotation, __pyx_t_11};
-    __pyx_t_10 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_20, 2+__pyx_t_20); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 427, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_20, 2+__pyx_t_20); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_8)) {
     PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_n_u_annotation, __pyx_t_11};
-    __pyx_t_10 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_20, 2+__pyx_t_20); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 427, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyCFunction_FastCall(__pyx_t_8, __pyx_temp+1-__pyx_t_20, 2+__pyx_t_20); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
   } else
   #endif
   {
-    __pyx_t_13 = PyTuple_New(2+__pyx_t_20); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 427, __pyx_L1_error)
+    __pyx_t_13 = PyTuple_New(2+__pyx_t_20); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_13);
     if (__pyx_t_9) {
       __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_9); __pyx_t_9 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_annotation);
     __Pyx_GIVEREF(__pyx_n_u_annotation);
     PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_20, __pyx_n_u_annotation);
     __Pyx_GIVEREF(__pyx_t_11);
     PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_20, __pyx_t_11);
     __pyx_t_11 = 0;
-    __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_13, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 427, __pyx_L1_error)
+    __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_13, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 482, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_10);
     __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
   }
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-  /* "pyjls/binding.pyx":400
+  /* "pyjls/binding.pyx":446
  *         _handle_rc('fsr', rc)
  * 
  *     def annotation(self, signal_id, timestamp, y, annotation_type, group_id, data):             # <<<<<<<<<<<<<<
- *         cdef c_jls.jls_twr_s * wr = self._wr
- *         cdef uint16_t signal_id_u16 = signal_id
+ *         """Add an annotation to a signal.
+ * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_8);
@@ -9493,24 +9550,25 @@
   __Pyx_XDECREF(__pyx_v_y);
   __Pyx_XDECREF(__pyx_v_annotation_type);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":429
+/* "pyjls/binding.pyx":484
  *         _handle_rc('annotation', rc)
  * 
  *     def utc(self, signal_id, sample_id, utc_i64):             # <<<<<<<<<<<<<<
- *         cdef c_jls.jls_twr_s * wr = self._wr
- *         cdef uint16_t signal_id_u16 = signal_id
+ *         """Add a mapping from sample_id to UTC timestamp for an FSR signal.
+ *         :param signal_id: The signal id.
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_27utc(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Writer_26utc[] = "Add a mapping from sample_id to UTC timestamp for an FSR signal.\n        :param signal_id: The signal id.\n        :param sample_id: The sample_id for FSR.\n        :param utc: The UTC timestamp.\n        :raise: On error.\n        ";
 static PyObject *__pyx_pw_5pyjls_7binding_6Writer_27utc(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_sample_id = 0;
   PyObject *__pyx_v_utc_i64 = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -9538,40 +9596,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 1); __PYX_ERR(0, 429, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 1); __PYX_ERR(0, 484, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_utc_i64)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 2); __PYX_ERR(0, 429, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 2); __PYX_ERR(0, 484, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "utc") < 0)) __PYX_ERR(0, 429, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "utc") < 0)) __PYX_ERR(0, 484, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_sample_id = values[1];
     __pyx_v_utc_i64 = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 429, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 484, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Writer.utc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Writer_26utc(((struct __pyx_obj_5pyjls_7binding_Writer *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_utc_i64);
 
@@ -9598,80 +9656,80 @@
   int __pyx_t_8;
   PyObject *__pyx_t_9 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("utc", 0);
 
-  /* "pyjls/binding.pyx":430
- * 
- *     def utc(self, signal_id, sample_id, utc_i64):
+  /* "pyjls/binding.pyx":491
+ *         :raise: On error.
+ *         """
  *         cdef c_jls.jls_twr_s * wr = self._wr             # <<<<<<<<<<<<<<
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t sample_id_i64 = sample_id
  */
   __pyx_t_1 = __pyx_v_self->_wr;
   __pyx_v_wr = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":431
- *     def utc(self, signal_id, sample_id, utc_i64):
+  /* "pyjls/binding.pyx":492
+ *         """
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         cdef uint16_t signal_id_u16 = signal_id             # <<<<<<<<<<<<<<
  *         cdef int64_t sample_id_i64 = sample_id
  *         cdef int64_t utc_i64c = utc_i64
  */
-  __pyx_t_2 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_2 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 431, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_2 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 492, __pyx_L1_error)
   __pyx_v_signal_id_u16 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":432
+  /* "pyjls/binding.pyx":493
  *         cdef c_jls.jls_twr_s * wr = self._wr
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t sample_id_i64 = sample_id             # <<<<<<<<<<<<<<
  *         cdef int64_t utc_i64c = utc_i64
  *         cdef int32_t rc
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 432, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 493, __pyx_L1_error)
   __pyx_v_sample_id_i64 = __pyx_t_3;
 
-  /* "pyjls/binding.pyx":433
+  /* "pyjls/binding.pyx":494
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t sample_id_i64 = sample_id
  *         cdef int64_t utc_i64c = utc_i64             # <<<<<<<<<<<<<<
  *         cdef int32_t rc
  *         with nogil:
  */
-  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_utc_i64); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 433, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_As_int64_t(__pyx_v_utc_i64); if (unlikely((__pyx_t_3 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 494, __pyx_L1_error)
   __pyx_v_utc_i64c = __pyx_t_3;
 
-  /* "pyjls/binding.pyx":435
+  /* "pyjls/binding.pyx":496
  *         cdef int64_t utc_i64c = utc_i64
  *         cdef int32_t rc
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_utc(wr, signal_id_u16, sample_id_i64, utc_i64c)
  *         _handle_rc('utc', rc)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":436
+        /* "pyjls/binding.pyx":497
  *         cdef int32_t rc
  *         with nogil:
  *             rc = c_jls.jls_twr_utc(wr, signal_id_u16, sample_id_i64, utc_i64c)             # <<<<<<<<<<<<<<
  *         _handle_rc('utc', rc)
  * 
  */
         __pyx_v_rc = jls_twr_utc(__pyx_v_wr, __pyx_v_signal_id_u16, __pyx_v_sample_id_i64, __pyx_v_utc_i64c);
       }
 
-      /* "pyjls/binding.pyx":435
+      /* "pyjls/binding.pyx":496
  *         cdef int64_t utc_i64c = utc_i64
  *         cdef int32_t rc
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_twr_utc(wr, signal_id_u16, sample_id_i64, utc_i64c)
  *         _handle_rc('utc', rc)
  */
       /*finally:*/ {
@@ -9682,24 +9740,24 @@
           #endif
           goto __pyx_L5;
         }
         __pyx_L5:;
       }
   }
 
-  /* "pyjls/binding.pyx":437
+  /* "pyjls/binding.pyx":498
  *         with nogil:
  *             rc = c_jls.jls_twr_utc(wr, signal_id_u16, sample_id_i64, utc_i64c)
  *         _handle_rc('utc', rc)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 437, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 498, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 437, __pyx_L1_error)
+  __pyx_t_6 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 498, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
   __pyx_t_7 = NULL;
   __pyx_t_8 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_7)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -9708,54 +9766,54 @@
       __Pyx_DECREF_SET(__pyx_t_5, function);
       __pyx_t_8 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_u_utc, __pyx_t_6};
-    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 437, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 498, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_u_utc, __pyx_t_6};
-    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 437, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 498, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   } else
   #endif
   {
-    __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 437, __pyx_L1_error)
+    __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 498, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_9);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_utc);
     __Pyx_GIVEREF(__pyx_n_u_utc);
     PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_n_u_utc);
     __Pyx_GIVEREF(__pyx_t_6);
     PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_t_6);
     __pyx_t_6 = 0;
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 437, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 498, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-  /* "pyjls/binding.pyx":429
+  /* "pyjls/binding.pyx":484
  *         _handle_rc('annotation', rc)
  * 
  *     def utc(self, signal_id, sample_id, utc_i64):             # <<<<<<<<<<<<<<
- *         cdef c_jls.jls_twr_s * wr = self._wr
- *         cdef uint16_t signal_id_u16 = signal_id
+ *         """Add a mapping from sample_id to UTC timestamp for an FSR signal.
+ *         :param signal_id: The signal id.
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_4);
@@ -9880,15 +9938,15 @@
   __Pyx_AddTraceback("pyjls.binding.Writer.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":444
+/* "pyjls/binding.pyx":505
  *     cdef object cbk_fn
  * 
  *     def __init__(self, is_fsr, cbk_fn):             # <<<<<<<<<<<<<<
  *         self.is_fsr = is_fsr
  *         self.cbk_fn = cbk_fn
  */
 
@@ -9922,32 +9980,32 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_is_fsr)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cbk_fn)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 444, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); __PYX_ERR(0, 505, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 444, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 505, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_is_fsr = values[0];
     __pyx_v_cbk_fn = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 444, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 505, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.AnnotationCallback.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_18AnnotationCallback___init__(((struct __pyx_obj_5pyjls_7binding_AnnotationCallback *)__pyx_v_self), __pyx_v_is_fsr, __pyx_v_cbk_fn);
 
@@ -9961,38 +10019,38 @@
   __Pyx_RefNannyDeclarations
   uint8_t __pyx_t_1;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "pyjls/binding.pyx":445
+  /* "pyjls/binding.pyx":506
  * 
  *     def __init__(self, is_fsr, cbk_fn):
  *         self.is_fsr = is_fsr             # <<<<<<<<<<<<<<
  *         self.cbk_fn = cbk_fn
  * 
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_is_fsr); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 445, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint8_t(__pyx_v_is_fsr); if (unlikely((__pyx_t_1 == ((uint8_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 506, __pyx_L1_error)
   __pyx_v_self->is_fsr = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":446
+  /* "pyjls/binding.pyx":507
  *     def __init__(self, is_fsr, cbk_fn):
  *         self.is_fsr = is_fsr
  *         self.cbk_fn = cbk_fn             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_INCREF(__pyx_v_cbk_fn);
   __Pyx_GIVEREF(__pyx_v_cbk_fn);
   __Pyx_GOTREF(__pyx_v_self->cbk_fn);
   __Pyx_DECREF(__pyx_v_self->cbk_fn);
   __pyx_v_self->cbk_fn = __pyx_v_cbk_fn;
 
-  /* "pyjls/binding.pyx":444
+  /* "pyjls/binding.pyx":505
  *     cdef object cbk_fn
  * 
  *     def __init__(self, is_fsr, cbk_fn):             # <<<<<<<<<<<<<<
  *         self.is_fsr = is_fsr
  *         self.cbk_fn = cbk_fn
  */
 
@@ -10301,15 +10359,15 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":454
+/* "pyjls/binding.pyx":519
  *     cdef object _signals
  * 
  *     def __init__(self, path: str):             # <<<<<<<<<<<<<<
  *         cdef int32_t rc
  *         cdef c_jls.jls_source_def_s * sources
  */
 
@@ -10338,32 +10396,32 @@
       kw_args = PyDict_Size(__pyx_kwds);
       switch (pos_args) {
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_path)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 454, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 519, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
     }
     __pyx_v_path = ((PyObject*)values[0]);
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 454, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 519, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return -1;
   __pyx_L4_argument_unpacking_done:;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_path), (&PyUnicode_Type), 1, "path", 1))) __PYX_ERR(0, 454, __pyx_L1_error)
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_path), (&PyUnicode_Type), 1, "path", 1))) __PYX_ERR(0, 519, __pyx_L1_error)
   __pyx_r = __pyx_pf_5pyjls_7binding_6Reader___init__(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_path);
 
   /* function exit code */
   goto __pyx_L0;
   __pyx_L1_error:;
   __pyx_r = -1;
   __pyx_L0:;
@@ -10403,71 +10461,71 @@
   char const *__pyx_t_18;
   int __pyx_t_19;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__init__", 0);
 
-  /* "pyjls/binding.pyx":460
+  /* "pyjls/binding.pyx":525
  *         cdef uint16_t count
  *         cdef int64_t samples
  *         self._sources: Mapping[int, SourceDef] = {}             # <<<<<<<<<<<<<<
  *         self._signals: Mapping[int, SignalDef] = {}
  *         rc = c_jls.jls_rd_open(&self._rd, path.encode('utf-8'))
  */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 460, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 525, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->_sources);
   __Pyx_DECREF(__pyx_v_self->_sources);
   __pyx_v_self->_sources = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":461
+  /* "pyjls/binding.pyx":526
  *         cdef int64_t samples
  *         self._sources: Mapping[int, SourceDef] = {}
  *         self._signals: Mapping[int, SignalDef] = {}             # <<<<<<<<<<<<<<
  *         rc = c_jls.jls_rd_open(&self._rd, path.encode('utf-8'))
  *         _handle_rc('open', rc)
  */
-  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 461, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 526, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __Pyx_GOTREF(__pyx_v_self->_signals);
   __Pyx_DECREF(__pyx_v_self->_signals);
   __pyx_v_self->_signals = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":462
+  /* "pyjls/binding.pyx":527
  *         self._sources: Mapping[int, SourceDef] = {}
  *         self._signals: Mapping[int, SignalDef] = {}
  *         rc = c_jls.jls_rd_open(&self._rd, path.encode('utf-8'))             # <<<<<<<<<<<<<<
  *         _handle_rc('open', rc)
  * 
  */
   if (unlikely(__pyx_v_path == Py_None)) {
     PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "encode");
-    __PYX_ERR(0, 462, __pyx_L1_error)
+    __PYX_ERR(0, 527, __pyx_L1_error)
   }
-  __pyx_t_1 = PyUnicode_AsUTF8String(__pyx_v_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 462, __pyx_L1_error)
+  __pyx_t_1 = PyUnicode_AsUTF8String(__pyx_v_path); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 527, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_t_1); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 462, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyBytes_AsString(__pyx_t_1); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 527, __pyx_L1_error)
   __pyx_v_rc = jls_rd_open((&__pyx_v_self->_rd), __pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":463
+  /* "pyjls/binding.pyx":528
  *         self._signals: Mapping[int, SignalDef] = {}
  *         rc = c_jls.jls_rd_open(&self._rd, path.encode('utf-8'))
  *         _handle_rc('open', rc)             # <<<<<<<<<<<<<<
  * 
  *         rc = c_jls.jls_rd_sources(self._rd, &sources, &count)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 463, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 463, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 528, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_5 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_5)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -10476,67 +10534,67 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_n_u_open, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 463, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 528, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_n_u_open, __pyx_t_4};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 463, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 528, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 463, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 528, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_5) {
       __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_open);
     __Pyx_GIVEREF(__pyx_n_u_open);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_n_u_open);
     __Pyx_GIVEREF(__pyx_t_4);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_4);
     __pyx_t_4 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 463, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 528, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":465
+  /* "pyjls/binding.pyx":530
  *         _handle_rc('open', rc)
  * 
  *         rc = c_jls.jls_rd_sources(self._rd, &sources, &count)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_sources', rc)
  *         for i in range(count):
  */
   __pyx_v_rc = jls_rd_sources(__pyx_v_self->_rd, (&__pyx_v_sources), (&__pyx_v_count));
 
-  /* "pyjls/binding.pyx":466
+  /* "pyjls/binding.pyx":531
  * 
  *         rc = c_jls.jls_rd_sources(self._rd, &sources, &count)
  *         _handle_rc('rd_sources', rc)             # <<<<<<<<<<<<<<
  *         for i in range(count):
  *             source_def = SourceDef(
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 466, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 531, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 466, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 531, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -10545,192 +10603,192 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_sources, __pyx_t_7};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 466, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 531, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_sources, __pyx_t_7};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 466, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 531, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   } else
   #endif
   {
-    __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 466, __pyx_L1_error)
+    __pyx_t_5 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 531, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_sources);
     __Pyx_GIVEREF(__pyx_n_u_rd_sources);
     PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_6, __pyx_n_u_rd_sources);
     __Pyx_GIVEREF(__pyx_t_7);
     PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_6, __pyx_t_7);
     __pyx_t_7 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 466, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 531, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":467
+  /* "pyjls/binding.pyx":532
  *         rc = c_jls.jls_rd_sources(self._rd, &sources, &count)
  *         _handle_rc('rd_sources', rc)
  *         for i in range(count):             # <<<<<<<<<<<<<<
  *             source_def = SourceDef(
  *                 source_id=sources[i].source_id,
  */
   __pyx_t_8 = __pyx_v_count;
   __pyx_t_9 = __pyx_t_8;
   for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
     __pyx_v_i = __pyx_t_10;
 
-    /* "pyjls/binding.pyx":468
+    /* "pyjls/binding.pyx":533
  *         _handle_rc('rd_sources', rc)
  *         for i in range(count):
  *             source_def = SourceDef(             # <<<<<<<<<<<<<<
  *                 source_id=sources[i].source_id,
  *                 name=sources[i].name.decode('utf-8'),
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_SourceDef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 468, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_SourceDef); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 533, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
 
-    /* "pyjls/binding.pyx":469
+    /* "pyjls/binding.pyx":534
  *         for i in range(count):
  *             source_def = SourceDef(
  *                 source_id=sources[i].source_id,             # <<<<<<<<<<<<<<
  *                 name=sources[i].name.decode('utf-8'),
  *                 vendor=sources[i].vendor.decode('utf-8'),
  */
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 469, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = __Pyx_PyInt_From_uint16_t((__pyx_v_sources[__pyx_v_i]).source_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 469, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_uint16_t((__pyx_v_sources[__pyx_v_i]).source_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_source_id, __pyx_t_5) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_source_id, __pyx_t_5) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":470
+    /* "pyjls/binding.pyx":535
  *             source_def = SourceDef(
  *                 source_id=sources[i].source_id,
  *                 name=sources[i].name.decode('utf-8'),             # <<<<<<<<<<<<<<
  *                 vendor=sources[i].vendor.decode('utf-8'),
  *                 model=sources[i].model.decode('utf-8'),
  */
     __pyx_t_11 = (__pyx_v_sources[__pyx_v_i]).name;
-    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_11, 0, strlen(__pyx_t_11), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 470, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_11, 0, strlen(__pyx_t_11), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 535, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_name, __pyx_t_5) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_name, __pyx_t_5) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":471
+    /* "pyjls/binding.pyx":536
  *                 source_id=sources[i].source_id,
  *                 name=sources[i].name.decode('utf-8'),
  *                 vendor=sources[i].vendor.decode('utf-8'),             # <<<<<<<<<<<<<<
  *                 model=sources[i].model.decode('utf-8'),
  *                 version=sources[i].version.decode('utf-8'),
  */
     __pyx_t_12 = (__pyx_v_sources[__pyx_v_i]).vendor;
-    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_12, 0, strlen(__pyx_t_12), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 471, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_12, 0, strlen(__pyx_t_12), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 536, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_vendor, __pyx_t_5) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_vendor, __pyx_t_5) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":472
+    /* "pyjls/binding.pyx":537
  *                 name=sources[i].name.decode('utf-8'),
  *                 vendor=sources[i].vendor.decode('utf-8'),
  *                 model=sources[i].model.decode('utf-8'),             # <<<<<<<<<<<<<<
  *                 version=sources[i].version.decode('utf-8'),
  *                 serial_number=sources[i].serial_number.decode('utf-8'))
  */
     __pyx_t_13 = (__pyx_v_sources[__pyx_v_i]).model;
-    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_13, 0, strlen(__pyx_t_13), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 472, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_13, 0, strlen(__pyx_t_13), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 537, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_model, __pyx_t_5) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_model, __pyx_t_5) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":473
+    /* "pyjls/binding.pyx":538
  *                 vendor=sources[i].vendor.decode('utf-8'),
  *                 model=sources[i].model.decode('utf-8'),
  *                 version=sources[i].version.decode('utf-8'),             # <<<<<<<<<<<<<<
  *                 serial_number=sources[i].serial_number.decode('utf-8'))
  *             self._sources[sources[i].source_id] = source_def
  */
     __pyx_t_14 = (__pyx_v_sources[__pyx_v_i]).version;
-    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_14, 0, strlen(__pyx_t_14), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 473, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_14, 0, strlen(__pyx_t_14), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 538, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_version, __pyx_t_5) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_version, __pyx_t_5) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":474
+    /* "pyjls/binding.pyx":539
  *                 model=sources[i].model.decode('utf-8'),
  *                 version=sources[i].version.decode('utf-8'),
  *                 serial_number=sources[i].serial_number.decode('utf-8'))             # <<<<<<<<<<<<<<
  *             self._sources[sources[i].source_id] = source_def
  * 
  */
     __pyx_t_15 = (__pyx_v_sources[__pyx_v_i]).serial_number;
-    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_15, 0, strlen(__pyx_t_15), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 474, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_decode_c_string(__pyx_t_15, 0, strlen(__pyx_t_15), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 539, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_serial_number, __pyx_t_5) < 0) __PYX_ERR(0, 469, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_serial_number, __pyx_t_5) < 0) __PYX_ERR(0, 534, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":468
+    /* "pyjls/binding.pyx":533
  *         _handle_rc('rd_sources', rc)
  *         for i in range(count):
  *             source_def = SourceDef(             # <<<<<<<<<<<<<<
  *                 source_id=sources[i].source_id,
  *                 name=sources[i].name.decode('utf-8'),
  */
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 468, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 533, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_source_def, __pyx_t_5);
     __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":475
+    /* "pyjls/binding.pyx":540
  *                 version=sources[i].version.decode('utf-8'),
  *                 serial_number=sources[i].serial_number.decode('utf-8'))
  *             self._sources[sources[i].source_id] = source_def             # <<<<<<<<<<<<<<
  * 
  *         rc = c_jls.jls_rd_signals(self._rd, &signals, &count)
  */
-    if (unlikely(__Pyx_SetItemInt(__pyx_v_self->_sources, (__pyx_v_sources[__pyx_v_i]).source_id, __pyx_v_source_def, uint16_t, 0, __Pyx_PyInt_From_uint16_t, 0, 0, 1) < 0)) __PYX_ERR(0, 475, __pyx_L1_error)
+    if (unlikely(__Pyx_SetItemInt(__pyx_v_self->_sources, (__pyx_v_sources[__pyx_v_i]).source_id, __pyx_v_source_def, uint16_t, 0, __Pyx_PyInt_From_uint16_t, 0, 0, 1) < 0)) __PYX_ERR(0, 540, __pyx_L1_error)
   }
 
-  /* "pyjls/binding.pyx":477
+  /* "pyjls/binding.pyx":542
  *             self._sources[sources[i].source_id] = source_def
  * 
  *         rc = c_jls.jls_rd_signals(self._rd, &signals, &count)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_signals', rc)
  *         for i in range(count):
  */
   __pyx_v_rc = jls_rd_signals(__pyx_v_self->_rd, (&__pyx_v_signals), (&__pyx_v_count));
 
-  /* "pyjls/binding.pyx":478
+  /* "pyjls/binding.pyx":543
  * 
  *         rc = c_jls.jls_rd_signals(self._rd, &signals, &count)
  *         _handle_rc('rd_signals', rc)             # <<<<<<<<<<<<<<
  *         for i in range(count):
  *             signal_id = signals[i].signal_id
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 478, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 543, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 478, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 543, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_7)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -10739,303 +10797,303 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_u_rd_signals, __pyx_t_1};
-    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 478, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 543, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_n_u_rd_signals, __pyx_t_1};
-    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 478, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 543, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 478, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 543, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_signals);
     __Pyx_GIVEREF(__pyx_n_u_rd_signals);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_n_u_rd_signals);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_t_1);
     __pyx_t_1 = 0;
-    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 478, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 543, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-  /* "pyjls/binding.pyx":479
+  /* "pyjls/binding.pyx":544
  *         rc = c_jls.jls_rd_signals(self._rd, &signals, &count)
  *         _handle_rc('rd_signals', rc)
  *         for i in range(count):             # <<<<<<<<<<<<<<
  *             signal_id = signals[i].signal_id
  *             signal_def = SignalDef(
  */
   __pyx_t_8 = __pyx_v_count;
   __pyx_t_9 = __pyx_t_8;
   for (__pyx_t_10 = 0; __pyx_t_10 < __pyx_t_9; __pyx_t_10+=1) {
     __pyx_v_i = __pyx_t_10;
 
-    /* "pyjls/binding.pyx":480
+    /* "pyjls/binding.pyx":545
  *         _handle_rc('rd_signals', rc)
  *         for i in range(count):
  *             signal_id = signals[i].signal_id             # <<<<<<<<<<<<<<
  *             signal_def = SignalDef(
  *                 signal_id=signal_id,
  */
     __pyx_t_16 = (__pyx_v_signals[__pyx_v_i]).signal_id;
     __pyx_v_signal_id = __pyx_t_16;
 
-    /* "pyjls/binding.pyx":481
+    /* "pyjls/binding.pyx":546
  *         for i in range(count):
  *             signal_id = signals[i].signal_id
  *             signal_def = SignalDef(             # <<<<<<<<<<<<<<
  *                 signal_id=signal_id,
  *                 source_id=signals[i].source_id,
  */
-    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_SignalDef); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 481, __pyx_L1_error)
+    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_SignalDef); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 546, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
 
-    /* "pyjls/binding.pyx":482
+    /* "pyjls/binding.pyx":547
  *             signal_id = signals[i].signal_id
  *             signal_def = SignalDef(
  *                 signal_id=signal_id,             # <<<<<<<<<<<<<<
  *                 source_id=signals[i].source_id,
  *                 signal_type=signals[i].signal_type,
  */
-    __pyx_t_3 = __Pyx_PyDict_NewPresized(14); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 482, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyDict_NewPresized(14); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_From_uint16_t(__pyx_v_signal_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 482, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint16_t(__pyx_v_signal_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_signal_id, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_signal_id, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":483
+    /* "pyjls/binding.pyx":548
  *             signal_def = SignalDef(
  *                 signal_id=signal_id,
  *                 source_id=signals[i].source_id,             # <<<<<<<<<<<<<<
  *                 signal_type=signals[i].signal_type,
  *                 data_type=signals[i].data_type,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint16_t((__pyx_v_signals[__pyx_v_i]).source_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 483, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint16_t((__pyx_v_signals[__pyx_v_i]).source_id); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 548, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_source_id, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_source_id, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":484
+    /* "pyjls/binding.pyx":549
  *                 signal_id=signal_id,
  *                 source_id=signals[i].source_id,
  *                 signal_type=signals[i].signal_type,             # <<<<<<<<<<<<<<
  *                 data_type=signals[i].data_type,
  *                 sample_rate=signals[i].sample_rate,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint8_t((__pyx_v_signals[__pyx_v_i]).signal_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 484, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint8_t((__pyx_v_signals[__pyx_v_i]).signal_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 549, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_signal_type, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_signal_type, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":485
+    /* "pyjls/binding.pyx":550
  *                 source_id=signals[i].source_id,
  *                 signal_type=signals[i].signal_type,
  *                 data_type=signals[i].data_type,             # <<<<<<<<<<<<<<
  *                 sample_rate=signals[i].sample_rate,
  *                 samples_per_data=signals[i].samples_per_data,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).data_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 485, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).data_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 550, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_data_type, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_data_type, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":486
+    /* "pyjls/binding.pyx":551
  *                 signal_type=signals[i].signal_type,
  *                 data_type=signals[i].data_type,
  *                 sample_rate=signals[i].sample_rate,             # <<<<<<<<<<<<<<
  *                 samples_per_data=signals[i].samples_per_data,
  *                 sample_decimate_factor=signals[i].sample_decimate_factor,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).sample_rate); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 486, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).sample_rate); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 551, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_rate, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_rate, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":487
+    /* "pyjls/binding.pyx":552
  *                 data_type=signals[i].data_type,
  *                 sample_rate=signals[i].sample_rate,
  *                 samples_per_data=signals[i].samples_per_data,             # <<<<<<<<<<<<<<
  *                 sample_decimate_factor=signals[i].sample_decimate_factor,
  *                 entries_per_summary=signals[i].entries_per_summary,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).samples_per_data); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 487, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).samples_per_data); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 552, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_samples_per_data, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_samples_per_data, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":488
+    /* "pyjls/binding.pyx":553
  *                 sample_rate=signals[i].sample_rate,
  *                 samples_per_data=signals[i].samples_per_data,
  *                 sample_decimate_factor=signals[i].sample_decimate_factor,             # <<<<<<<<<<<<<<
  *                 entries_per_summary=signals[i].entries_per_summary,
  *                 summary_decimate_factor=signals[i].summary_decimate_factor,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).sample_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 488, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).sample_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 553, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":489
+    /* "pyjls/binding.pyx":554
  *                 samples_per_data=signals[i].samples_per_data,
  *                 sample_decimate_factor=signals[i].sample_decimate_factor,
  *                 entries_per_summary=signals[i].entries_per_summary,             # <<<<<<<<<<<<<<
  *                 summary_decimate_factor=signals[i].summary_decimate_factor,
  *                 annotation_decimate_factor=signals[i].annotation_decimate_factor,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).entries_per_summary); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 489, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).entries_per_summary); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 554, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_entries_per_summary, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_entries_per_summary, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":490
+    /* "pyjls/binding.pyx":555
  *                 sample_decimate_factor=signals[i].sample_decimate_factor,
  *                 entries_per_summary=signals[i].entries_per_summary,
  *                 summary_decimate_factor=signals[i].summary_decimate_factor,             # <<<<<<<<<<<<<<
  *                 annotation_decimate_factor=signals[i].annotation_decimate_factor,
  *                 utc_decimate_factor=signals[i].utc_decimate_factor,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).summary_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 490, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).summary_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 555, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_summary_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_summary_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":491
+    /* "pyjls/binding.pyx":556
  *                 entries_per_summary=signals[i].entries_per_summary,
  *                 summary_decimate_factor=signals[i].summary_decimate_factor,
  *                 annotation_decimate_factor=signals[i].annotation_decimate_factor,             # <<<<<<<<<<<<<<
  *                 utc_decimate_factor=signals[i].utc_decimate_factor,
  *                 sample_id_offset=signals[i].sample_id_offset,
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).annotation_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 491, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).annotation_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 556, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_annotation_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_annotation_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":492
+    /* "pyjls/binding.pyx":557
  *                 summary_decimate_factor=signals[i].summary_decimate_factor,
  *                 annotation_decimate_factor=signals[i].annotation_decimate_factor,
  *                 utc_decimate_factor=signals[i].utc_decimate_factor,             # <<<<<<<<<<<<<<
  *                 sample_id_offset=signals[i].sample_id_offset,
  *                 name=signals[i].name.decode('utf-8'),
  */
-    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).utc_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 492, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_uint32_t((__pyx_v_signals[__pyx_v_i]).utc_decimate_factor); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 557, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_utc_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_utc_decimate_factor, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":493
+    /* "pyjls/binding.pyx":558
  *                 annotation_decimate_factor=signals[i].annotation_decimate_factor,
  *                 utc_decimate_factor=signals[i].utc_decimate_factor,
  *                 sample_id_offset=signals[i].sample_id_offset,             # <<<<<<<<<<<<<<
  *                 name=signals[i].name.decode('utf-8'),
  *                 units=signals[i].units.decode('utf-8'))
  */
-    __pyx_t_4 = __Pyx_PyInt_From_int64_t((__pyx_v_signals[__pyx_v_i]).sample_id_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 493, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_From_int64_t((__pyx_v_signals[__pyx_v_i]).sample_id_offset); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 558, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_id_offset, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_sample_id_offset, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":494
+    /* "pyjls/binding.pyx":559
  *                 utc_decimate_factor=signals[i].utc_decimate_factor,
  *                 sample_id_offset=signals[i].sample_id_offset,
  *                 name=signals[i].name.decode('utf-8'),             # <<<<<<<<<<<<<<
  *                 units=signals[i].units.decode('utf-8'))
  *             if signal_def.signal_type == c_jls.JLS_SIGNAL_TYPE_FSR:
  */
     __pyx_t_17 = (__pyx_v_signals[__pyx_v_i]).name;
-    __pyx_t_4 = __Pyx_decode_c_string(__pyx_t_17, 0, strlen(__pyx_t_17), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 494, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_t_17, 0, strlen(__pyx_t_17), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 559, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_name, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_name, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":495
+    /* "pyjls/binding.pyx":560
  *                 sample_id_offset=signals[i].sample_id_offset,
  *                 name=signals[i].name.decode('utf-8'),
  *                 units=signals[i].units.decode('utf-8'))             # <<<<<<<<<<<<<<
  *             if signal_def.signal_type == c_jls.JLS_SIGNAL_TYPE_FSR:
  *                 rc = c_jls.jls_rd_fsr_length(self._rd, signal_id, &samples)
  */
     __pyx_t_18 = (__pyx_v_signals[__pyx_v_i]).units;
-    __pyx_t_4 = __Pyx_decode_c_string(__pyx_t_18, 0, strlen(__pyx_t_18), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 495, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_decode_c_string(__pyx_t_18, 0, strlen(__pyx_t_18), NULL, NULL, PyUnicode_DecodeUTF8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 560, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_units, __pyx_t_4) < 0) __PYX_ERR(0, 482, __pyx_L1_error)
+    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_units, __pyx_t_4) < 0) __PYX_ERR(0, 547, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":481
+    /* "pyjls/binding.pyx":546
  *         for i in range(count):
  *             signal_id = signals[i].signal_id
  *             signal_def = SignalDef(             # <<<<<<<<<<<<<<
  *                 signal_id=signal_id,
  *                 source_id=signals[i].source_id,
  */
-    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 481, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 546, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_XDECREF_SET(__pyx_v_signal_def, __pyx_t_4);
     __pyx_t_4 = 0;
 
-    /* "pyjls/binding.pyx":496
+    /* "pyjls/binding.pyx":561
  *                 name=signals[i].name.decode('utf-8'),
  *                 units=signals[i].units.decode('utf-8'))
  *             if signal_def.signal_type == c_jls.JLS_SIGNAL_TYPE_FSR:             # <<<<<<<<<<<<<<
  *                 rc = c_jls.jls_rd_fsr_length(self._rd, signal_id, &samples)
  *                 _handle_rc('rd_fsr_length', rc)
  */
-    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_signal_def, __pyx_n_s_signal_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 496, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_signal_def, __pyx_n_s_signal_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 561, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_FSR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 496, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_FSR); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 561, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 496, __pyx_L1_error)
+    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 561, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_19 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_19 < 0)) __PYX_ERR(0, 496, __pyx_L1_error)
+    __pyx_t_19 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_19 < 0)) __PYX_ERR(0, 561, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
     if (__pyx_t_19) {
 
-      /* "pyjls/binding.pyx":497
+      /* "pyjls/binding.pyx":562
  *                 units=signals[i].units.decode('utf-8'))
  *             if signal_def.signal_type == c_jls.JLS_SIGNAL_TYPE_FSR:
  *                 rc = c_jls.jls_rd_fsr_length(self._rd, signal_id, &samples)             # <<<<<<<<<<<<<<
  *                 _handle_rc('rd_fsr_length', rc)
  *                 signal_def.length = samples
  */
       __pyx_v_rc = jls_rd_fsr_length(__pyx_v_self->_rd, __pyx_v_signal_id, (&__pyx_v_samples));
 
-      /* "pyjls/binding.pyx":498
+      /* "pyjls/binding.pyx":563
  *             if signal_def.signal_type == c_jls.JLS_SIGNAL_TYPE_FSR:
  *                 rc = c_jls.jls_rd_fsr_length(self._rd, signal_id, &samples)
  *                 _handle_rc('rd_fsr_length', rc)             # <<<<<<<<<<<<<<
  *                 signal_def.length = samples
  *             self._signals[signal_id] = signal_def
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 498, __pyx_L1_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 563, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_3);
-      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 498, __pyx_L1_error)
+      __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 563, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_4);
       __pyx_t_1 = NULL;
       __pyx_t_6 = 0;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
         __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
         if (likely(__pyx_t_1)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -11044,80 +11102,80 @@
           __Pyx_DECREF_SET(__pyx_t_3, function);
           __pyx_t_6 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_3)) {
         PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_n_u_rd_fsr_length, __pyx_t_4};
-        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 498, __pyx_L1_error)
+        __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 563, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
         PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_n_u_rd_fsr_length, __pyx_t_4};
-        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 498, __pyx_L1_error)
+        __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 563, __pyx_L1_error)
         __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
       } else
       #endif
       {
-        __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 498, __pyx_L1_error)
+        __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 563, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_7);
         if (__pyx_t_1) {
           __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1); __pyx_t_1 = NULL;
         }
         __Pyx_INCREF(__pyx_n_u_rd_fsr_length);
         __Pyx_GIVEREF(__pyx_n_u_rd_fsr_length);
         PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_n_u_rd_fsr_length);
         __Pyx_GIVEREF(__pyx_t_4);
         PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_4);
         __pyx_t_4 = 0;
-        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 498, __pyx_L1_error)
+        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 563, __pyx_L1_error)
         __Pyx_GOTREF(__pyx_t_5);
         __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
       }
       __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-      /* "pyjls/binding.pyx":499
+      /* "pyjls/binding.pyx":564
  *                 rc = c_jls.jls_rd_fsr_length(self._rd, signal_id, &samples)
  *                 _handle_rc('rd_fsr_length', rc)
  *                 signal_def.length = samples             # <<<<<<<<<<<<<<
  *             self._signals[signal_id] = signal_def
  * 
  */
-      __pyx_t_5 = __Pyx_PyInt_From_int64_t(__pyx_v_samples); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 499, __pyx_L1_error)
+      __pyx_t_5 = __Pyx_PyInt_From_int64_t(__pyx_v_samples); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 564, __pyx_L1_error)
       __Pyx_GOTREF(__pyx_t_5);
-      if (__Pyx_PyObject_SetAttrStr(__pyx_v_signal_def, __pyx_n_s_length, __pyx_t_5) < 0) __PYX_ERR(0, 499, __pyx_L1_error)
+      if (__Pyx_PyObject_SetAttrStr(__pyx_v_signal_def, __pyx_n_s_length, __pyx_t_5) < 0) __PYX_ERR(0, 564, __pyx_L1_error)
       __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-      /* "pyjls/binding.pyx":496
+      /* "pyjls/binding.pyx":561
  *                 name=signals[i].name.decode('utf-8'),
  *                 units=signals[i].units.decode('utf-8'))
  *             if signal_def.signal_type == c_jls.JLS_SIGNAL_TYPE_FSR:             # <<<<<<<<<<<<<<
  *                 rc = c_jls.jls_rd_fsr_length(self._rd, signal_id, &samples)
  *                 _handle_rc('rd_fsr_length', rc)
  */
     }
 
-    /* "pyjls/binding.pyx":500
+    /* "pyjls/binding.pyx":565
  *                 _handle_rc('rd_fsr_length', rc)
  *                 signal_def.length = samples
  *             self._signals[signal_id] = signal_def             # <<<<<<<<<<<<<<
  * 
  *     def __enter__(self):
  */
-    if (unlikely(__Pyx_SetItemInt(__pyx_v_self->_signals, __pyx_v_signal_id, __pyx_v_signal_def, uint16_t, 0, __Pyx_PyInt_From_uint16_t, 0, 0, 1) < 0)) __PYX_ERR(0, 500, __pyx_L1_error)
+    if (unlikely(__Pyx_SetItemInt(__pyx_v_self->_signals, __pyx_v_signal_id, __pyx_v_signal_def, uint16_t, 0, __Pyx_PyInt_From_uint16_t, 0, 0, 1) < 0)) __PYX_ERR(0, 565, __pyx_L1_error)
   }
 
-  /* "pyjls/binding.pyx":454
+  /* "pyjls/binding.pyx":519
  *     cdef object _signals
  * 
  *     def __init__(self, path: str):             # <<<<<<<<<<<<<<
  *         cdef int32_t rc
  *         cdef c_jls.jls_source_def_s * sources
  */
 
@@ -11135,15 +11193,15 @@
   __pyx_L0:;
   __Pyx_XDECREF(__pyx_v_source_def);
   __Pyx_XDECREF(__pyx_v_signal_def);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":502
+/* "pyjls/binding.pyx":567
  *             self._signals[signal_id] = signal_def
  * 
  *     def __enter__(self):             # <<<<<<<<<<<<<<
  *         return self
  * 
  */
 
@@ -11161,42 +11219,42 @@
 }
 
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_2__enter__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__enter__", 0);
 
-  /* "pyjls/binding.pyx":503
+  /* "pyjls/binding.pyx":568
  * 
  *     def __enter__(self):
  *         return self             # <<<<<<<<<<<<<<
  * 
  *     def __exit__(self, type, value, traceback):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_self));
   __pyx_r = ((PyObject *)__pyx_v_self);
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":502
+  /* "pyjls/binding.pyx":567
  *             self._signals[signal_id] = signal_def
  * 
  *     def __enter__(self):             # <<<<<<<<<<<<<<
  *         return self
  * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":505
+/* "pyjls/binding.pyx":570
  *         return self
  * 
  *     def __exit__(self, type, value, traceback):             # <<<<<<<<<<<<<<
  *         self.close()
  * 
  */
 
@@ -11233,40 +11291,40 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_type)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 1); __PYX_ERR(0, 505, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 1); __PYX_ERR(0, 570, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_traceback)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 2); __PYX_ERR(0, 505, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 2); __PYX_ERR(0, 570, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__exit__") < 0)) __PYX_ERR(0, 505, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__exit__") < 0)) __PYX_ERR(0, 570, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_type = values[0];
     __pyx_v_value = values[1];
     __pyx_v_traceback = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 505, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 570, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.__exit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
   __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_4__exit__(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_type, __pyx_v_value, __pyx_v_traceback);
 
@@ -11282,41 +11340,41 @@
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__exit__", 0);
 
-  /* "pyjls/binding.pyx":506
+  /* "pyjls/binding.pyx":571
  * 
  *     def __exit__(self, type, value, traceback):
  *         self.close()             # <<<<<<<<<<<<<<
  * 
  *     def close(self):
  */
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 506, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 571, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_3 = NULL;
   if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_3)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
       __Pyx_INCREF(__pyx_t_3);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_2, function);
     }
   }
   __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
   __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 506, __pyx_L1_error)
+  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 571, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":505
+  /* "pyjls/binding.pyx":570
  *         return self
  * 
  *     def __exit__(self, type, value, traceback):             # <<<<<<<<<<<<<<
  *         self.close()
  * 
  */
 
@@ -11331,24 +11389,25 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":508
+/* "pyjls/binding.pyx":573
  *         self.close()
  * 
  *     def close(self):             # <<<<<<<<<<<<<<
+ *         """Close the JLS file and free all resources."""
  *         c_jls.jls_rd_close(self._rd)
- * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Reader_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_6close[] = "Close the JLS file and free all resources.";
 static PyObject *__pyx_pw_5pyjls_7binding_6Reader_7close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("close (wrapper)", 0);
   __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_6close(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self));
 
   /* function exit code */
@@ -11357,44 +11416,44 @@
 }
 
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_6close(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("close", 0);
 
-  /* "pyjls/binding.pyx":509
- * 
+  /* "pyjls/binding.pyx":575
  *     def close(self):
+ *         """Close the JLS file and free all resources."""
  *         c_jls.jls_rd_close(self._rd)             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   jls_rd_close(__pyx_v_self->_rd);
 
-  /* "pyjls/binding.pyx":508
+  /* "pyjls/binding.pyx":573
  *         self.close()
  * 
  *     def close(self):             # <<<<<<<<<<<<<<
+ *         """Close the JLS file and free all resources."""
  *         c_jls.jls_rd_close(self._rd)
- * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":512
+/* "pyjls/binding.pyx":578
  * 
  *     @property
  *     def sources(self) -> Mapping[int, SourceDef]:             # <<<<<<<<<<<<<<
+ *         """Return the dict mapping source_id to SourceDef."""
  *         return self._sources
- * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Reader_7sources_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_5pyjls_7binding_6Reader_7sources_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -11407,47 +11466,47 @@
 }
 
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_7sources___get__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "pyjls/binding.pyx":513
- *     @property
+  /* "pyjls/binding.pyx":580
  *     def sources(self) -> Mapping[int, SourceDef]:
+ *         """Return the dict mapping source_id to SourceDef."""
  *         return self._sources             # <<<<<<<<<<<<<<
  * 
  *     @property
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_sources);
   __pyx_r = __pyx_v_self->_sources;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":512
+  /* "pyjls/binding.pyx":578
  * 
  *     @property
  *     def sources(self) -> Mapping[int, SourceDef]:             # <<<<<<<<<<<<<<
+ *         """Return the dict mapping source_id to SourceDef."""
  *         return self._sources
- * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":516
+/* "pyjls/binding.pyx":583
  * 
  *     @property
  *     def signals(self) -> Mapping[int, SignalDef]:             # <<<<<<<<<<<<<<
+ *         """Return the dict mapping signal_id to SignalDef."""
  *         return self._signals
- * 
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw_5pyjls_7binding_6Reader_7signals_1__get__(PyObject *__pyx_v_self); /*proto*/
 static PyObject *__pyx_pw_5pyjls_7binding_6Reader_7signals_1__get__(PyObject *__pyx_v_self) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -11460,52 +11519,307 @@
 }
 
 static PyObject *__pyx_pf_5pyjls_7binding_6Reader_7signals___get__(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__get__", 0);
 
-  /* "pyjls/binding.pyx":517
- *     @property
+  /* "pyjls/binding.pyx":585
  *     def signals(self) -> Mapping[int, SignalDef]:
+ *         """Return the dict mapping signal_id to SignalDef."""
  *         return self._signals             # <<<<<<<<<<<<<<
  * 
- *     def fsr(self, signal_id, start_sample_id, length):
+ *     def signal_lookup(self, spec) -> SignalDef:
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_self->_signals);
   __pyx_r = __pyx_v_self->_signals;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":516
+  /* "pyjls/binding.pyx":583
  * 
  *     @property
  *     def signals(self) -> Mapping[int, SignalDef]:             # <<<<<<<<<<<<<<
+ *         """Return the dict mapping signal_id to SignalDef."""
  *         return self._signals
- * 
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":519
+/* "pyjls/binding.pyx":587
  *         return self._signals
  * 
+ *     def signal_lookup(self, spec) -> SignalDef:             # <<<<<<<<<<<<<<
+ *         """Look up a signal.
+ * 
+ */
+
+/* Python wrapper */
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_9signal_lookup(PyObject *__pyx_v_self, PyObject *__pyx_v_spec); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_8signal_lookup[] = "Look up a signal.\n\n        :param spec: The signal id or name.\n        :return: The signal definition:\n        :raise ValueError: If not found.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_9signal_lookup(PyObject *__pyx_v_self, PyObject *__pyx_v_spec) {
+  PyObject *__pyx_r = 0;
+  __Pyx_RefNannyDeclarations
+  __Pyx_RefNannySetupContext("signal_lookup (wrapper)", 0);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_8signal_lookup(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), ((PyObject *)__pyx_v_spec));
+
+  /* function exit code */
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_8signal_lookup(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_spec) {
+  PyObject *__pyx_v_s = NULL;
+  PyObject *__pyx_r = NULL;
+  __Pyx_RefNannyDeclarations
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  Py_ssize_t __pyx_t_9;
+  Py_ssize_t __pyx_t_10;
+  PyObject *__pyx_t_11 = NULL;
+  int __pyx_t_12;
+  PyObject *__pyx_t_13 = NULL;
+  int __pyx_t_14;
+  int __pyx_lineno = 0;
+  const char *__pyx_filename = NULL;
+  int __pyx_clineno = 0;
+  __Pyx_RefNannySetupContext("signal_lookup", 0);
+
+  /* "pyjls/binding.pyx":594
+ *         :raise ValueError: If not found.
+ *         """
+ *         try:             # <<<<<<<<<<<<<<
+ *             return self._signals[int(spec)]
+ *         except ValueError:
+ */
+  {
+    __Pyx_PyThreadState_declare
+    __Pyx_PyThreadState_assign
+    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
+    __Pyx_XGOTREF(__pyx_t_1);
+    __Pyx_XGOTREF(__pyx_t_2);
+    __Pyx_XGOTREF(__pyx_t_3);
+    /*try:*/ {
+
+      /* "pyjls/binding.pyx":595
+ *         """
+ *         try:
+ *             return self._signals[int(spec)]             # <<<<<<<<<<<<<<
+ *         except ValueError:
+ *             for s in self._signals.values():
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_spec); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 595, __pyx_L3_error)
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_v_self->_signals, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 595, __pyx_L3_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_r = __pyx_t_5;
+      __pyx_t_5 = 0;
+      goto __pyx_L7_try_return;
+
+      /* "pyjls/binding.pyx":594
+ *         :raise ValueError: If not found.
+ *         """
+ *         try:             # <<<<<<<<<<<<<<
+ *             return self._signals[int(spec)]
+ *         except ValueError:
+ */
+    }
+    __pyx_L3_error:;
+    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+
+    /* "pyjls/binding.pyx":596
+ *         try:
+ *             return self._signals[int(spec)]
+ *         except ValueError:             # <<<<<<<<<<<<<<
+ *             for s in self._signals.values():
+ *                 if s.name == spec:
+ */
+    __pyx_t_6 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
+    if (__pyx_t_6) {
+      __Pyx_AddTraceback("pyjls.binding.Reader.signal_lookup", __pyx_clineno, __pyx_lineno, __pyx_filename);
+      if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_4, &__pyx_t_7) < 0) __PYX_ERR(0, 596, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_GOTREF(__pyx_t_7);
+
+      /* "pyjls/binding.pyx":597
+ *             return self._signals[int(spec)]
+ *         except ValueError:
+ *             for s in self._signals.values():             # <<<<<<<<<<<<<<
+ *                 if s.name == spec:
+ *                     return s
+ */
+      __pyx_t_9 = 0;
+      if (unlikely(__pyx_v_self->_signals == Py_None)) {
+        PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "values");
+        __PYX_ERR(0, 597, __pyx_L5_except_error)
+      }
+      __pyx_t_11 = __Pyx_dict_iterator(__pyx_v_self->_signals, 0, __pyx_n_s_values, (&__pyx_t_10), (&__pyx_t_6)); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 597, __pyx_L5_except_error)
+      __Pyx_GOTREF(__pyx_t_11);
+      __Pyx_XDECREF(__pyx_t_8);
+      __pyx_t_8 = __pyx_t_11;
+      __pyx_t_11 = 0;
+      while (1) {
+        __pyx_t_12 = __Pyx_dict_iter_next(__pyx_t_8, __pyx_t_10, &__pyx_t_9, NULL, &__pyx_t_11, NULL, __pyx_t_6);
+        if (unlikely(__pyx_t_12 == 0)) break;
+        if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 597, __pyx_L5_except_error)
+        __Pyx_GOTREF(__pyx_t_11);
+        __Pyx_XDECREF_SET(__pyx_v_s, __pyx_t_11);
+        __pyx_t_11 = 0;
+
+        /* "pyjls/binding.pyx":598
+ *         except ValueError:
+ *             for s in self._signals.values():
+ *                 if s.name == spec:             # <<<<<<<<<<<<<<
+ *                     return s
+ *         raise ValueError(f'signal_lookup failed for {spec}')
+ */
+        __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_s, __pyx_n_s_name); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 598, __pyx_L5_except_error)
+        __Pyx_GOTREF(__pyx_t_11);
+        __pyx_t_13 = PyObject_RichCompare(__pyx_t_11, __pyx_v_spec, Py_EQ); __Pyx_XGOTREF(__pyx_t_13); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 598, __pyx_L5_except_error)
+        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
+        __pyx_t_14 = __Pyx_PyObject_IsTrue(__pyx_t_13); if (unlikely(__pyx_t_14 < 0)) __PYX_ERR(0, 598, __pyx_L5_except_error)
+        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
+        if (__pyx_t_14) {
+
+          /* "pyjls/binding.pyx":599
+ *             for s in self._signals.values():
+ *                 if s.name == spec:
+ *                     return s             # <<<<<<<<<<<<<<
+ *         raise ValueError(f'signal_lookup failed for {spec}')
+ * 
+ */
+          __Pyx_XDECREF(__pyx_r);
+          __Pyx_INCREF(__pyx_v_s);
+          __pyx_r = __pyx_v_s;
+          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+          goto __pyx_L6_except_return;
+
+          /* "pyjls/binding.pyx":598
+ *         except ValueError:
+ *             for s in self._signals.values():
+ *                 if s.name == spec:             # <<<<<<<<<<<<<<
+ *                     return s
+ *         raise ValueError(f'signal_lookup failed for {spec}')
+ */
+        }
+      }
+      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
+      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
+      goto __pyx_L4_exception_handled;
+    }
+    goto __pyx_L5_except_error;
+    __pyx_L5_except_error:;
+
+    /* "pyjls/binding.pyx":594
+ *         :raise ValueError: If not found.
+ *         """
+ *         try:             # <<<<<<<<<<<<<<
+ *             return self._signals[int(spec)]
+ *         except ValueError:
+ */
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+    goto __pyx_L1_error;
+    __pyx_L7_try_return:;
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+    goto __pyx_L0;
+    __pyx_L6_except_return:;
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+    goto __pyx_L0;
+    __pyx_L4_exception_handled:;
+    __Pyx_XGIVEREF(__pyx_t_1);
+    __Pyx_XGIVEREF(__pyx_t_2);
+    __Pyx_XGIVEREF(__pyx_t_3);
+    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
+  }
+
+  /* "pyjls/binding.pyx":600
+ *                 if s.name == spec:
+ *                     return s
+ *         raise ValueError(f'signal_lookup failed for {spec}')             # <<<<<<<<<<<<<<
+ * 
+ *     def fsr(self, signal_id, start_sample_id, length):
+ */
+  __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_spec, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_signal_lookup_failed_for, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 600, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_7);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_Raise(__pyx_t_7, 0, 0, 0);
+  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
+  __PYX_ERR(0, 600, __pyx_L1_error)
+
+  /* "pyjls/binding.pyx":587
+ *         return self._signals
+ * 
+ *     def signal_lookup(self, spec) -> SignalDef:             # <<<<<<<<<<<<<<
+ *         """Look up a signal.
+ * 
+ */
+
+  /* function exit code */
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_7);
+  __Pyx_XDECREF(__pyx_t_8);
+  __Pyx_XDECREF(__pyx_t_11);
+  __Pyx_XDECREF(__pyx_t_13);
+  __Pyx_AddTraceback("pyjls.binding.Reader.signal_lookup", __pyx_clineno, __pyx_lineno, __pyx_filename);
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XDECREF(__pyx_v_s);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_RefNannyFinishContext();
+  return __pyx_r;
+}
+
+/* "pyjls/binding.pyx":602
+ *         raise ValueError(f'signal_lookup failed for {spec}')
+ * 
  *     def fsr(self, signal_id, start_sample_id, length):             # <<<<<<<<<<<<<<
- *         cdef int32_t rc
- *         cdef np.uint8_t [::1] u8
+ *         """Read the FSR data.
+ * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_9fsr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_9fsr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_11fsr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_10fsr[] = "Read the FSR data.\n\n        :param signal_id: The signal id.\n        :param start_sample_id: The starting sample id to read.\n        :param length: The number of samples to read.\n        :return: The data, which varies depending upon the FSR data type.\n\n            u1 and u4 data will be packed in little endian order.\n\n            For u1, unpack with:\n                np.unpackbits(y, bitorder='little')[:len(x)]\n\n            For u4, unpack with\n                d = np.empty(len(y) * 2, dtype=np.uint8)\n                d[0::2] = np.bitwise_and(y, 0x0f)\n                d[1::2] = np.bitwise_and(np.right_shift(y, 4), 0x0f)\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_11fsr(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_start_sample_id = 0;
   PyObject *__pyx_v_length = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -11532,53 +11846,53 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_start_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 1); __PYX_ERR(0, 519, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 1); __PYX_ERR(0, 602, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_length)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 2); __PYX_ERR(0, 519, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, 2); __PYX_ERR(0, 602, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr") < 0)) __PYX_ERR(0, 519, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr") < 0)) __PYX_ERR(0, 602, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_start_sample_id = values[1];
     __pyx_v_length = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 519, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fsr", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 602, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.fsr", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_8fsr(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_start_sample_id, __pyx_v_length);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_10fsr(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_start_sample_id, __pyx_v_length);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_8fsr(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_length) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_10fsr(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_length) {
   int32_t __pyx_v_rc;
   __Pyx_memviewslice __pyx_v_u8 = { 0, 0, { 0 }, { 0 }, { 0 } };
   uint32_t __pyx_v_data_type;
   uint32_t __pyx_v_entry_size_bits;
   uint32_t __pyx_v_u8_length;
   uint16_t __pyx_v_signal_id_u16;
   int64_t __pyx_v_start_sample_id_i64;
@@ -11601,271 +11915,271 @@
   Py_ssize_t __pyx_t_11;
   int __pyx_t_12;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fsr", 0);
 
-  /* "pyjls/binding.pyx":525
+  /* "pyjls/binding.pyx":626
  *         cdef uint32_t entry_size_bits
  *         cdef uint32_t u8_length
  *         cdef uint16_t signal_id_u16 = signal_id             # <<<<<<<<<<<<<<
  *         cdef int64_t start_sample_id_i64 = start_sample_id
  *         cdef int64_t length_i64 = length
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 525, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 626, __pyx_L1_error)
   __pyx_v_signal_id_u16 = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":526
+  /* "pyjls/binding.pyx":627
  *         cdef uint32_t u8_length
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t start_sample_id_i64 = start_sample_id             # <<<<<<<<<<<<<<
  *         cdef int64_t length_i64 = length
  * 
  */
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_start_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 526, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_start_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 627, __pyx_L1_error)
   __pyx_v_start_sample_id_i64 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":527
+  /* "pyjls/binding.pyx":628
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t start_sample_id_i64 = start_sample_id
  *         cdef int64_t length_i64 = length             # <<<<<<<<<<<<<<
  * 
  *         data_type = self._signals[signal_id].data_type
  */
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_length); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 527, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_length); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 628, __pyx_L1_error)
   __pyx_v_length_i64 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":529
+  /* "pyjls/binding.pyx":630
  *         cdef int64_t length_i64 = length
  * 
  *         data_type = self._signals[signal_id].data_type             # <<<<<<<<<<<<<<
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]
  */
-  __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_self->_signals, __pyx_v_signal_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 529, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_self->_signals, __pyx_v_signal_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 630, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_data_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 529, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_data_type); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 630, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 529, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 630, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_data_type = __pyx_t_5;
 
-  /* "pyjls/binding.pyx":530
+  /* "pyjls/binding.pyx":631
  * 
  *         data_type = self._signals[signal_id].data_type
  *         entry_size_bits = (data_type >> 8) & 0xff             # <<<<<<<<<<<<<<
  *         np_type = _data_type_map[data_type & 0xffff]
  *         u8_length = length
  */
   __pyx_v_entry_size_bits = ((__pyx_v_data_type >> 8) & 0xff);
 
-  /* "pyjls/binding.pyx":531
+  /* "pyjls/binding.pyx":632
  *         data_type = self._signals[signal_id].data_type
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]             # <<<<<<<<<<<<<<
  *         u8_length = length
  *         if entry_size_bits == 4:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_data_type_map); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 531, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_data_type_map); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 632, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __pyx_t_6 = (__pyx_v_data_type & 0xffff);
-  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_4, __pyx_t_6, long, 1, __Pyx_PyInt_From_long, 0, 1, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 531, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_4, __pyx_t_6, long, 1, __Pyx_PyInt_From_long, 0, 1, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 632, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_v_np_type = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":532
+  /* "pyjls/binding.pyx":633
  *         entry_size_bits = (data_type >> 8) & 0xff
  *         np_type = _data_type_map[data_type & 0xffff]
  *         u8_length = length             # <<<<<<<<<<<<<<
  *         if entry_size_bits == 4:
  *             u8_length = (length + 1) // 2
  */
-  __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_v_length); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 532, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_v_length); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 633, __pyx_L1_error)
   __pyx_v_u8_length = __pyx_t_5;
 
-  /* "pyjls/binding.pyx":533
+  /* "pyjls/binding.pyx":634
  *         np_type = _data_type_map[data_type & 0xffff]
  *         u8_length = length
  *         if entry_size_bits == 4:             # <<<<<<<<<<<<<<
  *             u8_length = (length + 1) // 2
  *         elif entry_size_bits == 1:
  */
   switch (__pyx_v_entry_size_bits) {
     case 4:
 
-    /* "pyjls/binding.pyx":534
+    /* "pyjls/binding.pyx":635
  *         u8_length = length
  *         if entry_size_bits == 4:
  *             u8_length = (length + 1) // 2             # <<<<<<<<<<<<<<
  *         elif entry_size_bits == 1:
  *             u8_length = (length + 7) // 8
  */
-    __pyx_t_3 = __Pyx_PyInt_AddObjC(__pyx_v_length, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 534, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_AddObjC(__pyx_v_length, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 635, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_4 = __Pyx_PyInt_FloorDivideObjC(__pyx_t_3, __pyx_int_2, 2, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 534, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_FloorDivideObjC(__pyx_t_3, __pyx_int_2, 2, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 635, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-    __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 534, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 635, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __pyx_v_u8_length = __pyx_t_5;
 
-    /* "pyjls/binding.pyx":533
+    /* "pyjls/binding.pyx":634
  *         np_type = _data_type_map[data_type & 0xffff]
  *         u8_length = length
  *         if entry_size_bits == 4:             # <<<<<<<<<<<<<<
  *             u8_length = (length + 1) // 2
  *         elif entry_size_bits == 1:
  */
     break;
     case 1:
 
-    /* "pyjls/binding.pyx":536
+    /* "pyjls/binding.pyx":637
  *             u8_length = (length + 1) // 2
  *         elif entry_size_bits == 1:
  *             u8_length = (length + 7) // 8             # <<<<<<<<<<<<<<
  *         else:
  *             u8_length *= entry_size_bits // 8
  */
-    __pyx_t_4 = __Pyx_PyInt_AddObjC(__pyx_v_length, __pyx_int_7, 7, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 536, __pyx_L1_error)
+    __pyx_t_4 = __Pyx_PyInt_AddObjC(__pyx_v_length, __pyx_int_7, 7, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
-    __pyx_t_3 = __Pyx_PyInt_FloorDivideObjC(__pyx_t_4, __pyx_int_8, 8, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 536, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_FloorDivideObjC(__pyx_t_4, __pyx_int_8, 8, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 637, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-    __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_t_3); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 536, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_As_uint32_t(__pyx_t_3); if (unlikely((__pyx_t_5 == ((uint32_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 637, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __pyx_v_u8_length = __pyx_t_5;
 
-    /* "pyjls/binding.pyx":535
+    /* "pyjls/binding.pyx":636
  *         if entry_size_bits == 4:
  *             u8_length = (length + 1) // 2
  *         elif entry_size_bits == 1:             # <<<<<<<<<<<<<<
  *             u8_length = (length + 7) // 8
  *         else:
  */
     break;
     default:
 
-    /* "pyjls/binding.pyx":538
+    /* "pyjls/binding.pyx":639
  *             u8_length = (length + 7) // 8
  *         else:
  *             u8_length *= entry_size_bits // 8             # <<<<<<<<<<<<<<
  * 
  *         data_u8 = np.empty(u8_length, dtype=np.uint8)
  */
     __pyx_v_u8_length = (__pyx_v_u8_length * __Pyx_div_long(__pyx_v_entry_size_bits, 8));
     break;
   }
 
-  /* "pyjls/binding.pyx":540
+  /* "pyjls/binding.pyx":641
  *             u8_length *= entry_size_bits // 8
  * 
  *         data_u8 = np.empty(u8_length, dtype=np.uint8)             # <<<<<<<<<<<<<<
  *         data = data_u8.view(dtype=np_type)
  *         u8 = data_u8
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_u8_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_u8_length); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
   __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_8);
-  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_uint8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_uint8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_9) < 0) __PYX_ERR(0, 540, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_9) < 0) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
-  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, __pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 540, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, __pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 641, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_data_u8 = __pyx_t_9;
   __pyx_t_9 = 0;
 
-  /* "pyjls/binding.pyx":541
+  /* "pyjls/binding.pyx":642
  * 
  *         data_u8 = np.empty(u8_length, dtype=np.uint8)
  *         data = data_u8.view(dtype=np_type)             # <<<<<<<<<<<<<<
  *         u8 = data_u8
  *         with nogil:
  */
-  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_data_u8, __pyx_n_s_view); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 541, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_data_u8, __pyx_n_s_view); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 642, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 541, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 642, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_v_np_type) < 0) __PYX_ERR(0, 541, __pyx_L1_error)
-  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 541, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_v_np_type) < 0) __PYX_ERR(0, 642, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 642, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_data = __pyx_t_7;
   __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":542
+  /* "pyjls/binding.pyx":643
  *         data_u8 = np.empty(u8_length, dtype=np.uint8)
  *         data = data_u8.view(dtype=np_type)
  *         u8 = data_u8             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rc = c_jls.jls_rd_fsr(self._rd, signal_id_u16, start_sample_id_i64, &u8[0], length_i64)
  */
-  __pyx_t_10 = __Pyx_PyObject_to_MemoryviewSlice_dc_nn___pyx_t_5numpy_uint8_t(__pyx_v_data_u8, PyBUF_WRITABLE); if (unlikely(!__pyx_t_10.memview)) __PYX_ERR(0, 542, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_to_MemoryviewSlice_dc_nn___pyx_t_5numpy_uint8_t(__pyx_v_data_u8, PyBUF_WRITABLE); if (unlikely(!__pyx_t_10.memview)) __PYX_ERR(0, 643, __pyx_L1_error)
   __pyx_v_u8 = __pyx_t_10;
   __pyx_t_10.memview = NULL;
   __pyx_t_10.data = NULL;
 
-  /* "pyjls/binding.pyx":543
+  /* "pyjls/binding.pyx":644
  *         data = data_u8.view(dtype=np_type)
  *         u8 = data_u8
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_rd_fsr(self._rd, signal_id_u16, start_sample_id_i64, &u8[0], length_i64)
  *         _handle_rc('rd_fsr', rc)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":544
+        /* "pyjls/binding.pyx":645
  *         u8 = data_u8
  *         with nogil:
  *             rc = c_jls.jls_rd_fsr(self._rd, signal_id_u16, start_sample_id_i64, &u8[0], length_i64)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_fsr', rc)
  *         return data
  */
         __pyx_t_11 = 0;
         __pyx_t_12 = -1;
         if (__pyx_t_11 < 0) {
           __pyx_t_11 += __pyx_v_u8.shape[0];
           if (unlikely(__pyx_t_11 < 0)) __pyx_t_12 = 0;
         } else if (unlikely(__pyx_t_11 >= __pyx_v_u8.shape[0])) __pyx_t_12 = 0;
         if (unlikely(__pyx_t_12 != -1)) {
           __Pyx_RaiseBufferIndexErrorNogil(__pyx_t_12);
-          __PYX_ERR(0, 544, __pyx_L4_error)
+          __PYX_ERR(0, 645, __pyx_L4_error)
         }
         __pyx_v_rc = jls_rd_fsr(__pyx_v_self->_rd, __pyx_v_signal_id_u16, __pyx_v_start_sample_id_i64, (&(*((__pyx_t_5numpy_uint8_t *) ( /* dim=0 */ ((char *) (((__pyx_t_5numpy_uint8_t *) __pyx_v_u8.data) + __pyx_t_11)) )))), __pyx_v_length_i64);
       }
 
-      /* "pyjls/binding.pyx":543
+      /* "pyjls/binding.pyx":644
  *         data = data_u8.view(dtype=np_type)
  *         u8 = data_u8
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_rd_fsr(self._rd, signal_id_u16, start_sample_id_i64, &u8[0], length_i64)
  *         _handle_rc('rd_fsr', rc)
  */
       /*finally:*/ {
@@ -11883,24 +12197,24 @@
           #endif
           goto __pyx_L1_error;
         }
         __pyx_L5:;
       }
   }
 
-  /* "pyjls/binding.pyx":545
+  /* "pyjls/binding.pyx":646
  *         with nogil:
  *             rc = c_jls.jls_rd_fsr(self._rd, signal_id_u16, start_sample_id_i64, &u8[0], length_i64)
  *         _handle_rc('rd_fsr', rc)             # <<<<<<<<<<<<<<
  *         return data
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 545, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 646, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_9 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 545, __pyx_L1_error)
+  __pyx_t_9 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 646, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_9);
   __pyx_t_4 = NULL;
   __pyx_t_12 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -11909,66 +12223,66 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_12 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_fsr, __pyx_t_9};
-    __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 545, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 646, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_fsr, __pyx_t_9};
-    __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 545, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 646, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
   } else
   #endif
   {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 545, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 646, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_fsr);
     __Pyx_GIVEREF(__pyx_n_u_rd_fsr);
     PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_12, __pyx_n_u_rd_fsr);
     __Pyx_GIVEREF(__pyx_t_9);
     PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_12, __pyx_t_9);
     __pyx_t_9 = 0;
-    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 545, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 646, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":546
+  /* "pyjls/binding.pyx":647
  *             rc = c_jls.jls_rd_fsr(self._rd, signal_id_u16, start_sample_id_i64, &u8[0], length_i64)
  *         _handle_rc('rd_fsr', rc)
  *         return data             # <<<<<<<<<<<<<<
  * 
  *     def fsr_statistics(self, signal_id, start_sample_id, increment, length):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_data);
   __pyx_r = __pyx_v_data;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":519
- *         return self._signals
+  /* "pyjls/binding.pyx":602
+ *         raise ValueError(f'signal_lookup failed for {spec}')
  * 
  *     def fsr(self, signal_id, start_sample_id, length):             # <<<<<<<<<<<<<<
- *         cdef int32_t rc
- *         cdef np.uint8_t [::1] u8
+ *         """Read the FSR data.
+ * 
  */
 
   /* function exit code */
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_3);
   __Pyx_XDECREF(__pyx_t_4);
   __Pyx_XDECREF(__pyx_t_7);
@@ -11983,26 +12297,26 @@
   __Pyx_XDECREF(__pyx_v_data_u8);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":548
+/* "pyjls/binding.pyx":649
  *         return data
  * 
  *     def fsr_statistics(self, signal_id, start_sample_id, increment, length):             # <<<<<<<<<<<<<<
  *         """Read FSR statistics.
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_11fsr_statistics(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5pyjls_7binding_6Reader_10fsr_statistics[] = "Read FSR statistics.\n\n        :param signal_id: The signal id.\n        :param start_sample_id: The starting sample id to read.\n        :param increment: The number of samples represented per return value.\n        :param length: The number of return values to generate.\n        :return The 2-D array[summary][stat] of np.float32 where the stat column is defined by SummaryFSR.\n        ";
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_11fsr_statistics(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_13fsr_statistics(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_12fsr_statistics[] = "Read FSR statistics.\n\n        :param signal_id: The signal id.\n        :param start_sample_id: The starting sample id to read.\n        :param increment: The number of samples represented per return value.\n        :param length: The number of return values to generate.\n        :return: The 2-D array[summary][stat] of np.float32 where the stat column is defined by SummaryFSR.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_13fsr_statistics(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_start_sample_id = 0;
   PyObject *__pyx_v_increment = 0;
   PyObject *__pyx_v_length = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
@@ -12032,31 +12346,31 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_start_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, 1); __PYX_ERR(0, 548, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, 1); __PYX_ERR(0, 649, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_increment)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, 2); __PYX_ERR(0, 548, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, 2); __PYX_ERR(0, 649, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  3:
         if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_length)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, 3); __PYX_ERR(0, 548, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, 3); __PYX_ERR(0, 649, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr_statistics") < 0)) __PYX_ERR(0, 548, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fsr_statistics") < 0)) __PYX_ERR(0, 649, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
@@ -12065,28 +12379,28 @@
     __pyx_v_signal_id = values[0];
     __pyx_v_start_sample_id = values[1];
     __pyx_v_increment = values[2];
     __pyx_v_length = values[3];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 548, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("fsr_statistics", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 649, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.fsr_statistics", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_10fsr_statistics(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_start_sample_id, __pyx_v_increment, __pyx_v_length);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_12fsr_statistics(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_start_sample_id, __pyx_v_increment, __pyx_v_length);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_10fsr_statistics(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_increment, PyObject *__pyx_v_length) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_12fsr_statistics(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_start_sample_id, PyObject *__pyx_v_increment, PyObject *__pyx_v_length) {
   int32_t __pyx_v_rc;
   __Pyx_memviewslice __pyx_v_c_data = { 0, 0, { 0 }, { 0 }, { 0 } };
   uint16_t __pyx_v_signal_id_u16;
   int64_t __pyx_v_start_sample_id_i64;
   int64_t __pyx_v_increment_i64;
   int64_t __pyx_v_length_i64;
   PyObject *__pyx_v_data = NULL;
@@ -12104,126 +12418,126 @@
   Py_ssize_t __pyx_t_10;
   int __pyx_t_11;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("fsr_statistics", 0);
 
-  /* "pyjls/binding.pyx":560
+  /* "pyjls/binding.pyx":661
  *         cdef int32_t rc
  *         cdef np.float64_t [:, :] c_data
  *         cdef uint16_t signal_id_u16 = signal_id             # <<<<<<<<<<<<<<
  *         cdef int64_t start_sample_id_i64 = start_sample_id
  *         cdef int64_t increment_i64 = increment
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 560, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 661, __pyx_L1_error)
   __pyx_v_signal_id_u16 = __pyx_t_1;
 
-  /* "pyjls/binding.pyx":561
+  /* "pyjls/binding.pyx":662
  *         cdef np.float64_t [:, :] c_data
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t start_sample_id_i64 = start_sample_id             # <<<<<<<<<<<<<<
  *         cdef int64_t increment_i64 = increment
  *         cdef int64_t length_i64 = length
  */
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_start_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 561, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_start_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 662, __pyx_L1_error)
   __pyx_v_start_sample_id_i64 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":562
+  /* "pyjls/binding.pyx":663
  *         cdef uint16_t signal_id_u16 = signal_id
  *         cdef int64_t start_sample_id_i64 = start_sample_id
  *         cdef int64_t increment_i64 = increment             # <<<<<<<<<<<<<<
  *         cdef int64_t length_i64 = length
  * 
  */
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_increment); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 562, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_increment); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 663, __pyx_L1_error)
   __pyx_v_increment_i64 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":563
+  /* "pyjls/binding.pyx":664
  *         cdef int64_t start_sample_id_i64 = start_sample_id
  *         cdef int64_t increment_i64 = increment
  *         cdef int64_t length_i64 = length             # <<<<<<<<<<<<<<
  * 
  *         data = np.empty((length, c_jls.JLS_SUMMARY_FSR_COUNT), dtype=np.float64)
  */
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_length); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 563, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_length); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 664, __pyx_L1_error)
   __pyx_v_length_i64 = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":565
+  /* "pyjls/binding.pyx":666
  *         cdef int64_t length_i64 = length
  * 
  *         data = np.empty((length, c_jls.JLS_SUMMARY_FSR_COUNT), dtype=np.float64)             # <<<<<<<<<<<<<<
  *         c_data = data
  *         with nogil:
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_empty); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_COUNT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_COUNT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_INCREF(__pyx_v_length);
   __Pyx_GIVEREF(__pyx_v_length);
   PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_length);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_3);
   __pyx_t_3 = 0;
-  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_5);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
   __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_6);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
-  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_7) < 0) __PYX_ERR(0, 565, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_7) < 0) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 565, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 666, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __pyx_v_data = __pyx_t_7;
   __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":566
+  /* "pyjls/binding.pyx":667
  * 
  *         data = np.empty((length, c_jls.JLS_SUMMARY_FSR_COUNT), dtype=np.float64)
  *         c_data = data             # <<<<<<<<<<<<<<
  *         with nogil:
  *             rc = c_jls.jls_rd_fsr_statistics(self._rd, signal_id_u16, start_sample_id_i64,
  */
-  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dsds_nn___pyx_t_5numpy_float64_t(__pyx_v_data, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 566, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_to_MemoryviewSlice_dsds_nn___pyx_t_5numpy_float64_t(__pyx_v_data, PyBUF_WRITABLE); if (unlikely(!__pyx_t_8.memview)) __PYX_ERR(0, 667, __pyx_L1_error)
   __pyx_v_c_data = __pyx_t_8;
   __pyx_t_8.memview = NULL;
   __pyx_t_8.data = NULL;
 
-  /* "pyjls/binding.pyx":567
+  /* "pyjls/binding.pyx":668
  *         data = np.empty((length, c_jls.JLS_SUMMARY_FSR_COUNT), dtype=np.float64)
  *         c_data = data
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_rd_fsr_statistics(self._rd, signal_id_u16, start_sample_id_i64,
  *                                              increment_i64, &c_data[0, 0], length_i64)
  */
   {
       #ifdef WITH_THREAD
       PyThreadState *_save;
       Py_UNBLOCK_THREADS
       __Pyx_FastGIL_Remember();
       #endif
       /*try:*/ {
 
-        /* "pyjls/binding.pyx":569
+        /* "pyjls/binding.pyx":670
  *         with nogil:
  *             rc = c_jls.jls_rd_fsr_statistics(self._rd, signal_id_u16, start_sample_id_i64,
  *                                              increment_i64, &c_data[0, 0], length_i64)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_fsr_statistics', rc)
  *         return data
  */
         __pyx_t_9 = 0;
@@ -12235,28 +12549,28 @@
         } else if (unlikely(__pyx_t_9 >= __pyx_v_c_data.shape[0])) __pyx_t_11 = 0;
         if (__pyx_t_10 < 0) {
           __pyx_t_10 += __pyx_v_c_data.shape[1];
           if (unlikely(__pyx_t_10 < 0)) __pyx_t_11 = 1;
         } else if (unlikely(__pyx_t_10 >= __pyx_v_c_data.shape[1])) __pyx_t_11 = 1;
         if (unlikely(__pyx_t_11 != -1)) {
           __Pyx_RaiseBufferIndexErrorNogil(__pyx_t_11);
-          __PYX_ERR(0, 569, __pyx_L4_error)
+          __PYX_ERR(0, 670, __pyx_L4_error)
         }
 
-        /* "pyjls/binding.pyx":568
+        /* "pyjls/binding.pyx":669
  *         c_data = data
  *         with nogil:
  *             rc = c_jls.jls_rd_fsr_statistics(self._rd, signal_id_u16, start_sample_id_i64,             # <<<<<<<<<<<<<<
  *                                              increment_i64, &c_data[0, 0], length_i64)
  *         _handle_rc('rd_fsr_statistics', rc)
  */
         __pyx_v_rc = jls_rd_fsr_statistics(__pyx_v_self->_rd, __pyx_v_signal_id_u16, __pyx_v_start_sample_id_i64, __pyx_v_increment_i64, (&(*((__pyx_t_5numpy_float64_t *) ( /* dim=1 */ (( /* dim=0 */ (__pyx_v_c_data.data + __pyx_t_9 * __pyx_v_c_data.strides[0]) ) + __pyx_t_10 * __pyx_v_c_data.strides[1]) )))), __pyx_v_length_i64);
       }
 
-      /* "pyjls/binding.pyx":567
+      /* "pyjls/binding.pyx":668
  *         data = np.empty((length, c_jls.JLS_SUMMARY_FSR_COUNT), dtype=np.float64)
  *         c_data = data
  *         with nogil:             # <<<<<<<<<<<<<<
  *             rc = c_jls.jls_rd_fsr_statistics(self._rd, signal_id_u16, start_sample_id_i64,
  *                                              increment_i64, &c_data[0, 0], length_i64)
  */
       /*finally:*/ {
@@ -12274,24 +12588,24 @@
           #endif
           goto __pyx_L1_error;
         }
         __pyx_L5:;
       }
   }
 
-  /* "pyjls/binding.pyx":570
+  /* "pyjls/binding.pyx":671
  *             rc = c_jls.jls_rd_fsr_statistics(self._rd, signal_id_u16, start_sample_id_i64,
  *                                              increment_i64, &c_data[0, 0], length_i64)
  *         _handle_rc('rd_fsr_statistics', rc)             # <<<<<<<<<<<<<<
  *         return data
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 570, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
-  __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 570, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 671, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_11 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
@@ -12300,61 +12614,61 @@
       __Pyx_DECREF_SET(__pyx_t_5, function);
       __pyx_t_11 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_fsr_statistics, __pyx_t_3};
-    __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 570, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 671, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_fsr_statistics, __pyx_t_3};
-    __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 570, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 671, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 570, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 671, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_fsr_statistics);
     __Pyx_GIVEREF(__pyx_n_u_rd_fsr_statistics);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_11, __pyx_n_u_rd_fsr_statistics);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_11, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 570, __pyx_L1_error)
+    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 671, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":571
+  /* "pyjls/binding.pyx":672
  *                                              increment_i64, &c_data[0, 0], length_i64)
  *         _handle_rc('rd_fsr_statistics', rc)
  *         return data             # <<<<<<<<<<<<<<
  * 
  *     def annotations(self, signal_id, timestamp, cbk_fn):
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(__pyx_v_data);
   __pyx_r = __pyx_v_data;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":548
+  /* "pyjls/binding.pyx":649
  *         return data
  * 
  *     def fsr_statistics(self, signal_id, start_sample_id, increment, length):             # <<<<<<<<<<<<<<
  *         """Read FSR statistics.
  * 
  */
 
@@ -12372,26 +12686,26 @@
   __PYX_XDEC_MEMVIEW(&__pyx_v_c_data, 1);
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":573
+/* "pyjls/binding.pyx":674
  *         return data
  * 
  *     def annotations(self, signal_id, timestamp, cbk_fn):             # <<<<<<<<<<<<<<
  *         """Read annotations from a signal.
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_13annotations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5pyjls_7binding_6Reader_12annotations[] = "Read annotations from a signal.\n\n        :param signal_id: The signal id.\n        :param timestamp: The starting timestamp.  FSR uses sample_id.  VSR uses utc.\n        :param cbk: The function(timestamp, y, annotation_type, group_id, data)\n            to call for each annotation.  Return True to stop iteration over\n            the annotations or False to continue iterating.\n        ";
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_13annotations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_15annotations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_14annotations[] = "Read annotations from a signal.\n\n        :param signal_id: The signal id.\n        :param timestamp: The starting timestamp.  FSR uses sample_id.  VSR uses utc.\n        :param cbk: The function(timestamp, y, annotation_type, group_id, data)\n            to call for each annotation.  Return True to stop iteration over\n            the annotations or False to continue iterating.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_15annotations(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_timestamp = 0;
   PyObject *__pyx_v_cbk_fn = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -12418,53 +12732,53 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_timestamp)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotations", 1, 3, 3, 1); __PYX_ERR(0, 573, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotations", 1, 3, 3, 1); __PYX_ERR(0, 674, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cbk_fn)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("annotations", 1, 3, 3, 2); __PYX_ERR(0, 573, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("annotations", 1, 3, 3, 2); __PYX_ERR(0, 674, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "annotations") < 0)) __PYX_ERR(0, 573, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "annotations") < 0)) __PYX_ERR(0, 674, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_timestamp = values[1];
     __pyx_v_cbk_fn = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("annotations", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 573, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("annotations", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 674, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.annotations", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_12annotations(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_timestamp, __pyx_v_cbk_fn);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_14annotations(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_timestamp, __pyx_v_cbk_fn);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_12annotations(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_timestamp, PyObject *__pyx_v_cbk_fn) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_14annotations(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_timestamp, PyObject *__pyx_v_cbk_fn) {
   int32_t __pyx_v_rc;
   PyObject *__pyx_v_is_fsr = NULL;
   struct __pyx_obj_5pyjls_7binding_AnnotationCallback *__pyx_v_user_data = NULL;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
@@ -12475,76 +12789,76 @@
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("annotations", 0);
 
-  /* "pyjls/binding.pyx":583
+  /* "pyjls/binding.pyx":684
  *         """
  *         cdef int32_t rc
  *         is_fsr = self._signals[signal_id].signal_type == c_jls.JLS_SIGNAL_TYPE_FSR             # <<<<<<<<<<<<<<
  *         user_data = AnnotationCallback(is_fsr, cbk_fn)
  *         rc = c_jls.jls_rd_annotations(self._rd, signal_id, timestamp, _annotation_cbk_fn, <void *> user_data)
  */
-  __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_self->_signals, __pyx_v_signal_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 583, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_self->_signals, __pyx_v_signal_id); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 684, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_signal_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 583, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_signal_type); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 684, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_FSR); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 583, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_FSR); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 684, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 583, __pyx_L1_error)
+  __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_1, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 684, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_v_is_fsr = __pyx_t_3;
   __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":584
+  /* "pyjls/binding.pyx":685
  *         cdef int32_t rc
  *         is_fsr = self._signals[signal_id].signal_type == c_jls.JLS_SIGNAL_TYPE_FSR
  *         user_data = AnnotationCallback(is_fsr, cbk_fn)             # <<<<<<<<<<<<<<
  *         rc = c_jls.jls_rd_annotations(self._rd, signal_id, timestamp, _annotation_cbk_fn, <void *> user_data)
  *         _handle_rc('rd_annotations', rc)
  */
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 584, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 685, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_INCREF(__pyx_v_is_fsr);
   __Pyx_GIVEREF(__pyx_v_is_fsr);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_is_fsr);
   __Pyx_INCREF(__pyx_v_cbk_fn);
   __Pyx_GIVEREF(__pyx_v_cbk_fn);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_cbk_fn);
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pyjls_7binding_AnnotationCallback), __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 584, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pyjls_7binding_AnnotationCallback), __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 685, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_user_data = ((struct __pyx_obj_5pyjls_7binding_AnnotationCallback *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":585
+  /* "pyjls/binding.pyx":686
  *         is_fsr = self._signals[signal_id].signal_type == c_jls.JLS_SIGNAL_TYPE_FSR
  *         user_data = AnnotationCallback(is_fsr, cbk_fn)
  *         rc = c_jls.jls_rd_annotations(self._rd, signal_id, timestamp, _annotation_cbk_fn, <void *> user_data)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_annotations', rc)
  * 
  */
-  __pyx_t_4 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_4 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 585, __pyx_L1_error)
-  __pyx_t_5 = __Pyx_PyInt_As_int64_t(__pyx_v_timestamp); if (unlikely((__pyx_t_5 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 585, __pyx_L1_error)
+  __pyx_t_4 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_4 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 686, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_As_int64_t(__pyx_v_timestamp); if (unlikely((__pyx_t_5 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 686, __pyx_L1_error)
   __pyx_v_rc = jls_rd_annotations(__pyx_v_self->_rd, __pyx_t_4, __pyx_t_5, __pyx_f_5pyjls_7binding__annotation_cbk_fn, ((void *)__pyx_v_user_data));
 
-  /* "pyjls/binding.pyx":586
+  /* "pyjls/binding.pyx":687
  *         user_data = AnnotationCallback(is_fsr, cbk_fn)
  *         rc = c_jls.jls_rd_annotations(self._rd, signal_id, timestamp, _annotation_cbk_fn, <void *> user_data)
  *         _handle_rc('rd_annotations', rc)             # <<<<<<<<<<<<<<
  * 
  *     def user_data(self, cbk_fn):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 586, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 687, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 586, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 687, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __pyx_t_6 = NULL;
   __pyx_t_7 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
@@ -12553,49 +12867,49 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_7 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_rd_annotations, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 687, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_rd_annotations, __pyx_t_2};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 687, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 687, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     if (__pyx_t_6) {
       __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_annotations);
     __Pyx_GIVEREF(__pyx_n_u_rd_annotations);
     PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_n_u_rd_annotations);
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_2);
     __pyx_t_2 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 586, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 687, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":573
+  /* "pyjls/binding.pyx":674
  *         return data
  * 
  *     def annotations(self, signal_id, timestamp, cbk_fn):             # <<<<<<<<<<<<<<
  *         """Read annotations from a signal.
  * 
  */
 
@@ -12614,69 +12928,70 @@
   __Pyx_XDECREF(__pyx_v_is_fsr);
   __Pyx_XDECREF((PyObject *)__pyx_v_user_data);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":588
+/* "pyjls/binding.pyx":689
  *         _handle_rc('rd_annotations', rc)
  * 
  *     def user_data(self, cbk_fn):             # <<<<<<<<<<<<<<
- *         cdef int32_t rc
- *         rc = c_jls.jls_rd_user_data(self._rd, _user_data_cbk_fn, <void *> cbk_fn)
+ *         """Get the user data.
+ * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_15user_data(PyObject *__pyx_v_self, PyObject *__pyx_v_cbk_fn); /*proto*/
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_15user_data(PyObject *__pyx_v_self, PyObject *__pyx_v_cbk_fn) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_17user_data(PyObject *__pyx_v_self, PyObject *__pyx_v_cbk_fn); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_16user_data[] = "Get the user data.\n\n        :param cbk_fn: The callable(chunk_meta_u16, data) called for each\n            user_data entry.  Return True to stop iterating over subsequent\n            user data entries or False to continue iterating.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_17user_data(PyObject *__pyx_v_self, PyObject *__pyx_v_cbk_fn) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("user_data (wrapper)", 0);
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_14user_data(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), ((PyObject *)__pyx_v_cbk_fn));
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_16user_data(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), ((PyObject *)__pyx_v_cbk_fn));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_14user_data(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_cbk_fn) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_16user_data(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_cbk_fn) {
   int32_t __pyx_v_rc;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   PyObject *__pyx_t_2 = NULL;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
   int __pyx_t_5;
   PyObject *__pyx_t_6 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("user_data", 0);
 
-  /* "pyjls/binding.pyx":590
- *     def user_data(self, cbk_fn):
+  /* "pyjls/binding.pyx":697
+ *         """
  *         cdef int32_t rc
  *         rc = c_jls.jls_rd_user_data(self._rd, _user_data_cbk_fn, <void *> cbk_fn)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_user_data', rc)
  * 
  */
   __pyx_v_rc = jls_rd_user_data(__pyx_v_self->_rd, __pyx_f_5pyjls_7binding__user_data_cbk_fn, ((void *)__pyx_v_cbk_fn));
 
-  /* "pyjls/binding.pyx":591
+  /* "pyjls/binding.pyx":698
  *         cdef int32_t rc
  *         rc = c_jls.jls_rd_user_data(self._rd, _user_data_cbk_fn, <void *> cbk_fn)
  *         _handle_rc('rd_user_data', rc)             # <<<<<<<<<<<<<<
  * 
  *     def utc(self, signal_id, sample_id, cbk_fn):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 591, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 591, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 698, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
@@ -12685,54 +13000,54 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_user_data, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 698, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_n_u_rd_user_data, __pyx_t_3};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 698, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 591, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_user_data);
     __Pyx_GIVEREF(__pyx_n_u_rd_user_data);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_n_u_rd_user_data);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_3);
     __pyx_t_3 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 591, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 698, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":588
+  /* "pyjls/binding.pyx":689
  *         _handle_rc('rd_annotations', rc)
  * 
  *     def user_data(self, cbk_fn):             # <<<<<<<<<<<<<<
- *         cdef int32_t rc
- *         rc = c_jls.jls_rd_user_data(self._rd, _user_data_cbk_fn, <void *> cbk_fn)
+ *         """Get the user data.
+ * 
  */
 
   /* function exit code */
   __pyx_r = Py_None; __Pyx_INCREF(Py_None);
   goto __pyx_L0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
@@ -12744,26 +13059,26 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":593
+/* "pyjls/binding.pyx":700
  *         _handle_rc('rd_user_data', rc)
  * 
  *     def utc(self, signal_id, sample_id, cbk_fn):             # <<<<<<<<<<<<<<
  *         """Read the sample_id / utc pairs from a FSR signal.
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_17utc(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5pyjls_7binding_6Reader_16utc[] = "Read the sample_id / utc pairs from a FSR signal.\n\n        :param signal_id: The signal id.\n        :param sample_id: The starting sample_id.\n        :param cbk: The function(entries)\n            to call for each annotation.  Entries is an Nx2 numpy array of\n            [sample_id, utc_timestamp].\n            Return True to stop iteration over the annotations\n            or False to continue iterating.\n        ";
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_17utc(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_19utc(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_18utc[] = "Read the sample_id / utc pairs from a FSR signal.\n\n        :param signal_id: The signal id.\n        :param sample_id: The starting sample_id.\n        :param cbk: The function(entries)\n            to call for each annotation.  Entries is an Nx2 numpy array of\n            [sample_id, utc_timestamp].\n            Return True to stop iteration over the annotations\n            or False to continue iterating.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_19utc(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_sample_id = 0;
   PyObject *__pyx_v_cbk_fn = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
@@ -12790,53 +13105,53 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 1); __PYX_ERR(0, 593, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 1); __PYX_ERR(0, 700, __pyx_L3_error)
         }
         CYTHON_FALLTHROUGH;
         case  2:
         if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_cbk_fn)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 2); __PYX_ERR(0, 593, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, 2); __PYX_ERR(0, 700, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "utc") < 0)) __PYX_ERR(0, 593, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "utc") < 0)) __PYX_ERR(0, 700, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
       values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_sample_id = values[1];
     __pyx_v_cbk_fn = values[2];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 593, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("utc", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 700, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.utc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_16utc(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_cbk_fn);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_18utc(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id, __pyx_v_cbk_fn);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_16utc(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id, PyObject *__pyx_v_cbk_fn) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_18utc(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id, PyObject *__pyx_v_cbk_fn) {
   int32_t __pyx_v_rc;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   uint16_t __pyx_t_1;
   int64_t __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
   PyObject *__pyx_t_4 = NULL;
@@ -12845,35 +13160,35 @@
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("utc", 0);
 
-  /* "pyjls/binding.pyx":605
+  /* "pyjls/binding.pyx":712
  *         """
  *         cdef int32_t rc
  *         rc = c_jls.jls_rd_utc(self._rd, signal_id, sample_id, _utc_cbk_fn, <void *> cbk_fn)             # <<<<<<<<<<<<<<
  *         _handle_rc('rd_utc', rc)
  * 
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 605, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 605, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 712, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 712, __pyx_L1_error)
   __pyx_v_rc = jls_rd_utc(__pyx_v_self->_rd, __pyx_t_1, __pyx_t_2, __pyx_f_5pyjls_7binding__utc_cbk_fn, ((void *)__pyx_v_cbk_fn));
 
-  /* "pyjls/binding.pyx":606
+  /* "pyjls/binding.pyx":713
  *         cdef int32_t rc
  *         rc = c_jls.jls_rd_utc(self._rd, signal_id, sample_id, _utc_cbk_fn, <void *> cbk_fn)
  *         _handle_rc('rd_utc', rc)             # <<<<<<<<<<<<<<
  * 
  *     def sample_id_to_timestamp(self, signal_id, sample_id):
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 606, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 713, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 606, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 713, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_6 = NULL;
   __pyx_t_7 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -12882,49 +13197,49 @@
       __Pyx_DECREF_SET(__pyx_t_4, function);
       __pyx_t_7 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_rd_utc, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 713, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_rd_utc, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 713, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 606, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 713, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     if (__pyx_t_6) {
       __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_rd_utc);
     __Pyx_GIVEREF(__pyx_n_u_rd_utc);
     PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_n_u_rd_utc);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
     __pyx_t_5 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 606, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 713, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":593
+  /* "pyjls/binding.pyx":700
  *         _handle_rc('rd_user_data', rc)
  * 
  *     def utc(self, signal_id, sample_id, cbk_fn):             # <<<<<<<<<<<<<<
  *         """Read the sample_id / utc pairs from a FSR signal.
  * 
  */
 
@@ -12941,26 +13256,26 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":608
+/* "pyjls/binding.pyx":715
  *         _handle_rc('rd_utc', rc)
  * 
  *     def sample_id_to_timestamp(self, signal_id, sample_id):             # <<<<<<<<<<<<<<
  *         """Convert sample_id to UTC timestamp for FSR signals.
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_19sample_id_to_timestamp(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5pyjls_7binding_6Reader_18sample_id_to_timestamp[] = "Convert sample_id to UTC timestamp for FSR signals.\n\n        :param signal_id: The signal id.\n        :param sample_id: The sample_id to convert.\n        :return: The JLS timestamp corresponding to sample_id.\n        :raise RuntimeError: on error.\n        ";
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_19sample_id_to_timestamp(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_21sample_id_to_timestamp(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_20sample_id_to_timestamp[] = "Convert sample_id to UTC timestamp for FSR signals.\n\n        :param signal_id: The signal id.\n        :param sample_id: The sample_id to convert.\n        :return: The JLS timestamp corresponding to sample_id.\n        :raise RuntimeError: on error.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_21sample_id_to_timestamp(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_sample_id = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -12984,45 +13299,45 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample_id)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("sample_id_to_timestamp", 1, 2, 2, 1); __PYX_ERR(0, 608, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("sample_id_to_timestamp", 1, 2, 2, 1); __PYX_ERR(0, 715, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sample_id_to_timestamp") < 0)) __PYX_ERR(0, 608, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "sample_id_to_timestamp") < 0)) __PYX_ERR(0, 715, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_sample_id = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("sample_id_to_timestamp", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 608, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("sample_id_to_timestamp", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 715, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.sample_id_to_timestamp", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_18sample_id_to_timestamp(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_20sample_id_to_timestamp(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_sample_id);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_18sample_id_to_timestamp(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_20sample_id_to_timestamp(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_sample_id) {
   int64_t __pyx_v_utc_timestamp;
   int32_t __pyx_v_rc;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   uint16_t __pyx_t_1;
   int64_t __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
@@ -13032,35 +13347,35 @@
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("sample_id_to_timestamp", 0);
 
-  /* "pyjls/binding.pyx":617
+  /* "pyjls/binding.pyx":724
  *         """
  *         cdef int64_t utc_timestamp
  *         rc = c_jls.jls_rd_sample_id_to_timestamp(self._rd, signal_id, sample_id, &utc_timestamp)             # <<<<<<<<<<<<<<
  *         _handle_rc('sample_id_to_timestamp', rc)
  *         return utc_timestamp
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 617, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 617, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 724, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_sample_id); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 724, __pyx_L1_error)
   __pyx_v_rc = jls_rd_sample_id_to_timestamp(__pyx_v_self->_rd, __pyx_t_1, __pyx_t_2, (&__pyx_v_utc_timestamp));
 
-  /* "pyjls/binding.pyx":618
+  /* "pyjls/binding.pyx":725
  *         cdef int64_t utc_timestamp
  *         rc = c_jls.jls_rd_sample_id_to_timestamp(self._rd, signal_id, sample_id, &utc_timestamp)
  *         _handle_rc('sample_id_to_timestamp', rc)             # <<<<<<<<<<<<<<
  *         return utc_timestamp
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 618, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 725, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 618, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 725, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_6 = NULL;
   __pyx_t_7 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -13069,63 +13384,63 @@
       __Pyx_DECREF_SET(__pyx_t_4, function);
       __pyx_t_7 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_sample_id_to_timestamp, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 725, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_sample_id_to_timestamp, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 725, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 618, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 725, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     if (__pyx_t_6) {
       __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_sample_id_to_timestamp);
     __Pyx_GIVEREF(__pyx_n_u_sample_id_to_timestamp);
     PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_n_u_sample_id_to_timestamp);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
     __pyx_t_5 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 618, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 725, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":619
+  /* "pyjls/binding.pyx":726
  *         rc = c_jls.jls_rd_sample_id_to_timestamp(self._rd, signal_id, sample_id, &utc_timestamp)
  *         _handle_rc('sample_id_to_timestamp', rc)
  *         return utc_timestamp             # <<<<<<<<<<<<<<
  * 
  *     def timestamp_to_sample_id(self, signal_id, utc_timestamp):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __Pyx_PyInt_From_int64_t(__pyx_v_utc_timestamp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 619, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int64_t(__pyx_v_utc_timestamp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 726, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":608
+  /* "pyjls/binding.pyx":715
  *         _handle_rc('rd_utc', rc)
  * 
  *     def sample_id_to_timestamp(self, signal_id, sample_id):             # <<<<<<<<<<<<<<
  *         """Convert sample_id to UTC timestamp for FSR signals.
  * 
  */
 
@@ -13140,26 +13455,26 @@
   __pyx_r = NULL;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":621
+/* "pyjls/binding.pyx":728
  *         return utc_timestamp
  * 
  *     def timestamp_to_sample_id(self, signal_id, utc_timestamp):             # <<<<<<<<<<<<<<
  *         """Convert UTC timestamp to sample_id for FSR signals.
  * 
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_21timestamp_to_sample_id(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
-static char __pyx_doc_5pyjls_7binding_6Reader_20timestamp_to_sample_id[] = "Convert UTC timestamp to sample_id for FSR signals.\n\n        :param signal_id: The signal id.\n        :param utc_timestamp: The UTC timestamp to convert.\n        :return: The sample_id corresponding to utc_timestamp.\n        :raise RuntimeError: on error.\n        ";
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_21timestamp_to_sample_id(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_23timestamp_to_sample_id(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_5pyjls_7binding_6Reader_22timestamp_to_sample_id[] = "Convert UTC timestamp to sample_id for FSR signals.\n\n        :param signal_id: The signal id.\n        :param utc_timestamp: The UTC timestamp to convert.\n        :return: The sample_id corresponding to utc_timestamp.\n        :raise RuntimeError: on error.\n        ";
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_23timestamp_to_sample_id(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
   PyObject *__pyx_v_signal_id = 0;
   PyObject *__pyx_v_utc_timestamp = 0;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
@@ -13183,45 +13498,45 @@
         case  0:
         if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_signal_id)) != 0)) kw_args--;
         else goto __pyx_L5_argtuple_error;
         CYTHON_FALLTHROUGH;
         case  1:
         if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_utc_timestamp)) != 0)) kw_args--;
         else {
-          __Pyx_RaiseArgtupleInvalid("timestamp_to_sample_id", 1, 2, 2, 1); __PYX_ERR(0, 621, __pyx_L3_error)
+          __Pyx_RaiseArgtupleInvalid("timestamp_to_sample_id", 1, 2, 2, 1); __PYX_ERR(0, 728, __pyx_L3_error)
         }
       }
       if (unlikely(kw_args > 0)) {
-        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "timestamp_to_sample_id") < 0)) __PYX_ERR(0, 621, __pyx_L3_error)
+        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "timestamp_to_sample_id") < 0)) __PYX_ERR(0, 728, __pyx_L3_error)
       }
     } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
       goto __pyx_L5_argtuple_error;
     } else {
       values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
       values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
     }
     __pyx_v_signal_id = values[0];
     __pyx_v_utc_timestamp = values[1];
   }
   goto __pyx_L4_argument_unpacking_done;
   __pyx_L5_argtuple_error:;
-  __Pyx_RaiseArgtupleInvalid("timestamp_to_sample_id", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 621, __pyx_L3_error)
+  __Pyx_RaiseArgtupleInvalid("timestamp_to_sample_id", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 728, __pyx_L3_error)
   __pyx_L3_error:;
   __Pyx_AddTraceback("pyjls.binding.Reader.timestamp_to_sample_id", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __Pyx_RefNannyFinishContext();
   return NULL;
   __pyx_L4_argument_unpacking_done:;
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_20timestamp_to_sample_id(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_utc_timestamp);
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_22timestamp_to_sample_id(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), __pyx_v_signal_id, __pyx_v_utc_timestamp);
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_20timestamp_to_sample_id(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_utc_timestamp) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_22timestamp_to_sample_id(struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, PyObject *__pyx_v_signal_id, PyObject *__pyx_v_utc_timestamp) {
   int64_t __pyx_v_sample_id;
   int32_t __pyx_v_rc;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   uint16_t __pyx_t_1;
   int64_t __pyx_t_2;
   PyObject *__pyx_t_3 = NULL;
@@ -13231,35 +13546,35 @@
   int __pyx_t_7;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("timestamp_to_sample_id", 0);
 
-  /* "pyjls/binding.pyx":630
+  /* "pyjls/binding.pyx":737
  *         """
  *         cdef int64_t sample_id
  *         rc = c_jls.jls_rd_timestamp_to_sample_id(self._rd, signal_id, utc_timestamp, &sample_id)             # <<<<<<<<<<<<<<
  *         _handle_rc('timestamp_to_sample_id', rc)
  *         return sample_id
  */
-  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 630, __pyx_L1_error)
-  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_utc_timestamp); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 630, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_As_uint16_t(__pyx_v_signal_id); if (unlikely((__pyx_t_1 == ((uint16_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 737, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_As_int64_t(__pyx_v_utc_timestamp); if (unlikely((__pyx_t_2 == ((int64_t)-1)) && PyErr_Occurred())) __PYX_ERR(0, 737, __pyx_L1_error)
   __pyx_v_rc = jls_rd_timestamp_to_sample_id(__pyx_v_self->_rd, __pyx_t_1, __pyx_t_2, (&__pyx_v_sample_id));
 
-  /* "pyjls/binding.pyx":631
+  /* "pyjls/binding.pyx":738
  *         cdef int64_t sample_id
  *         rc = c_jls.jls_rd_timestamp_to_sample_id(self._rd, signal_id, utc_timestamp, &sample_id)
  *         _handle_rc('timestamp_to_sample_id', rc)             # <<<<<<<<<<<<<<
  *         return sample_id
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 631, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_handle_rc); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 738, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 631, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyInt_From_int32_t(__pyx_v_rc); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 738, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __pyx_t_6 = NULL;
   __pyx_t_7 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
     __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
     if (likely(__pyx_t_6)) {
       PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
@@ -13268,63 +13583,63 @@
       __Pyx_DECREF_SET(__pyx_t_4, function);
       __pyx_t_7 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_timestamp_to_sample_id, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 631, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 738, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
     PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_n_u_timestamp_to_sample_id, __pyx_t_5};
-    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 631, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 738, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 631, __pyx_L1_error)
+    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 738, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_8);
     if (__pyx_t_6) {
       __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
     }
     __Pyx_INCREF(__pyx_n_u_timestamp_to_sample_id);
     __Pyx_GIVEREF(__pyx_n_u_timestamp_to_sample_id);
     PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_n_u_timestamp_to_sample_id);
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_5);
     __pyx_t_5 = 0;
-    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 631, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 738, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
   }
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":632
+  /* "pyjls/binding.pyx":739
  *         rc = c_jls.jls_rd_timestamp_to_sample_id(self._rd, signal_id, utc_timestamp, &sample_id)
  *         _handle_rc('timestamp_to_sample_id', rc)
  *         return sample_id             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __Pyx_PyInt_From_int64_t(__pyx_v_sample_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 632, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_int64_t(__pyx_v_sample_id); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 739, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":621
+  /* "pyjls/binding.pyx":728
  *         return utc_timestamp
  * 
  *     def timestamp_to_sample_id(self, signal_id, utc_timestamp):             # <<<<<<<<<<<<<<
  *         """Convert UTC timestamp to sample_id for FSR signals.
  * 
  */
 
@@ -13346,27 +13661,27 @@
 /* "(tree fragment)":1
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("self._rd cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_23__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_23__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_25__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_25__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_22__reduce_cython__(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self));
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_24__reduce_cython__(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_22__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_24__reduce_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__reduce_cython__", 0);
@@ -13403,27 +13718,27 @@
  * def __reduce_cython__(self):
  *     raise TypeError("self._rd cannot be converted to a Python object for pickling")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("self._rd cannot be converted to a Python object for pickling")
  */
 
 /* Python wrapper */
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_25__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
-static PyObject *__pyx_pw_5pyjls_7binding_6Reader_25__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_27__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyObject *__pyx_pw_5pyjls_7binding_6Reader_27__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
-  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_24__setstate_cython__(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
+  __pyx_r = __pyx_pf_5pyjls_7binding_6Reader_26__setstate_cython__(((struct __pyx_obj_5pyjls_7binding_Reader *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-static PyObject *__pyx_pf_5pyjls_7binding_6Reader_24__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
+static PyObject *__pyx_pf_5pyjls_7binding_6Reader_26__setstate_cython__(CYTHON_UNUSED struct __pyx_obj_5pyjls_7binding_Reader *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__setstate_cython__", 0);
@@ -13452,15 +13767,15 @@
   __Pyx_AddTraceback("pyjls.binding.Reader.__setstate_cython__", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = NULL;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":635
+/* "pyjls/binding.pyx":742
  * 
  * 
  * cdef int32_t _annotation_cbk_fn(void * user_data, const c_jls.jls_annotation_s * annotation):             # <<<<<<<<<<<<<<
  *     obj: AnnotationCallback = <object> user_data
  *     data = _storage_unpack(annotation[0].storage_type, annotation[0].data, annotation[0].data_size)
  */
 
@@ -13489,121 +13804,121 @@
   PyObject *__pyx_t_15 = NULL;
   int32_t __pyx_t_16;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_annotation_cbk_fn", 0);
 
-  /* "pyjls/binding.pyx":636
+  /* "pyjls/binding.pyx":743
  * 
  * cdef int32_t _annotation_cbk_fn(void * user_data, const c_jls.jls_annotation_s * annotation):
  *     obj: AnnotationCallback = <object> user_data             # <<<<<<<<<<<<<<
  *     data = _storage_unpack(annotation[0].storage_type, annotation[0].data, annotation[0].data_size)
  *     y = annotation[0].y
  */
-  if (!(likely(((((PyObject *)__pyx_v_user_data)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_user_data), __pyx_ptype_5pyjls_7binding_AnnotationCallback))))) __PYX_ERR(0, 636, __pyx_L1_error)
+  if (!(likely(((((PyObject *)__pyx_v_user_data)) == Py_None) || likely(__Pyx_TypeTest(((PyObject *)__pyx_v_user_data), __pyx_ptype_5pyjls_7binding_AnnotationCallback))))) __PYX_ERR(0, 743, __pyx_L1_error)
   __pyx_t_1 = ((PyObject *)__pyx_v_user_data);
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_obj = ((struct __pyx_obj_5pyjls_7binding_AnnotationCallback *)__pyx_t_1);
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":637
+  /* "pyjls/binding.pyx":744
  * cdef int32_t _annotation_cbk_fn(void * user_data, const c_jls.jls_annotation_s * annotation):
  *     obj: AnnotationCallback = <object> user_data
  *     data = _storage_unpack(annotation[0].storage_type, annotation[0].data, annotation[0].data_size)             # <<<<<<<<<<<<<<
  *     y = annotation[0].y
  *     timestamp = annotation[0].timestamp
  */
-  __pyx_t_1 = __pyx_f_5pyjls_7binding__storage_unpack((__pyx_v_annotation[0]).storage_type, (__pyx_v_annotation[0]).data, (__pyx_v_annotation[0]).data_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 637, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5pyjls_7binding__storage_unpack((__pyx_v_annotation[0]).storage_type, (__pyx_v_annotation[0]).data, (__pyx_v_annotation[0]).data_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 744, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_data = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":638
+  /* "pyjls/binding.pyx":745
  *     obj: AnnotationCallback = <object> user_data
  *     data = _storage_unpack(annotation[0].storage_type, annotation[0].data, annotation[0].data_size)
  *     y = annotation[0].y             # <<<<<<<<<<<<<<
  *     timestamp = annotation[0].timestamp
  *     if not obj.is_fsr:
  */
-  __pyx_t_1 = PyFloat_FromDouble((__pyx_v_annotation[0]).y); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 638, __pyx_L1_error)
+  __pyx_t_1 = PyFloat_FromDouble((__pyx_v_annotation[0]).y); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 745, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_y = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":639
+  /* "pyjls/binding.pyx":746
  *     data = _storage_unpack(annotation[0].storage_type, annotation[0].data, annotation[0].data_size)
  *     y = annotation[0].y
  *     timestamp = annotation[0].timestamp             # <<<<<<<<<<<<<<
  *     if not obj.is_fsr:
  *         timestamp = annotation[0].timestamp
  */
   __pyx_t_2 = (__pyx_v_annotation[0]).timestamp;
   __pyx_v_timestamp = __pyx_t_2;
 
-  /* "pyjls/binding.pyx":640
+  /* "pyjls/binding.pyx":747
  *     y = annotation[0].y
  *     timestamp = annotation[0].timestamp
  *     if not obj.is_fsr:             # <<<<<<<<<<<<<<
  *         timestamp = annotation[0].timestamp
  *     if not isfinite(y):
  */
   __pyx_t_3 = ((!(__pyx_v_obj->is_fsr != 0)) != 0);
   if (__pyx_t_3) {
 
-    /* "pyjls/binding.pyx":641
+    /* "pyjls/binding.pyx":748
  *     timestamp = annotation[0].timestamp
  *     if not obj.is_fsr:
  *         timestamp = annotation[0].timestamp             # <<<<<<<<<<<<<<
  *     if not isfinite(y):
  *         y = None
  */
     __pyx_t_2 = (__pyx_v_annotation[0]).timestamp;
     __pyx_v_timestamp = __pyx_t_2;
 
-    /* "pyjls/binding.pyx":640
+    /* "pyjls/binding.pyx":747
  *     y = annotation[0].y
  *     timestamp = annotation[0].timestamp
  *     if not obj.is_fsr:             # <<<<<<<<<<<<<<
  *         timestamp = annotation[0].timestamp
  *     if not isfinite(y):
  */
   }
 
-  /* "pyjls/binding.pyx":642
+  /* "pyjls/binding.pyx":749
  *     if not obj.is_fsr:
  *         timestamp = annotation[0].timestamp
  *     if not isfinite(y):             # <<<<<<<<<<<<<<
  *         y = None
  *     try:
  */
-  __pyx_t_4 = __pyx_PyFloat_AsDouble(__pyx_v_y); if (unlikely((__pyx_t_4 == (long double)-1) && PyErr_Occurred())) __PYX_ERR(0, 642, __pyx_L1_error)
+  __pyx_t_4 = __pyx_PyFloat_AsDouble(__pyx_v_y); if (unlikely((__pyx_t_4 == (long double)-1) && PyErr_Occurred())) __PYX_ERR(0, 749, __pyx_L1_error)
   __pyx_t_3 = ((!(isfinite(__pyx_t_4) != 0)) != 0);
   if (__pyx_t_3) {
 
-    /* "pyjls/binding.pyx":643
+    /* "pyjls/binding.pyx":750
  *         timestamp = annotation[0].timestamp
  *     if not isfinite(y):
  *         y = None             # <<<<<<<<<<<<<<
  *     try:
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)
  */
     __Pyx_INCREF(Py_None);
     __Pyx_DECREF_SET(__pyx_v_y, Py_None);
 
-    /* "pyjls/binding.pyx":642
+    /* "pyjls/binding.pyx":749
  *     if not obj.is_fsr:
  *         timestamp = annotation[0].timestamp
  *     if not isfinite(y):             # <<<<<<<<<<<<<<
  *         y = None
  *     try:
  */
   }
 
-  /* "pyjls/binding.pyx":644
+  /* "pyjls/binding.pyx":751
  *     if not isfinite(y):
  *         y = None
  *     try:             # <<<<<<<<<<<<<<
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)
  *     except Exception:
  */
   {
@@ -13611,26 +13926,26 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7);
     __Pyx_XGOTREF(__pyx_t_5);
     __Pyx_XGOTREF(__pyx_t_6);
     __Pyx_XGOTREF(__pyx_t_7);
     /*try:*/ {
 
-      /* "pyjls/binding.pyx":645
+      /* "pyjls/binding.pyx":752
  *         y = None
  *     try:
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)             # <<<<<<<<<<<<<<
  *     except Exception:
  *         logging.getLogger(__name__).exception('in annotation callback')
  */
-      __pyx_t_8 = __Pyx_PyInt_From_int64_t(__pyx_v_timestamp); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 645, __pyx_L5_error)
+      __pyx_t_8 = __Pyx_PyInt_From_int64_t(__pyx_v_timestamp); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 752, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_9 = __Pyx_PyInt_From_uint8_t((__pyx_v_annotation[0]).annotation_type); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 645, __pyx_L5_error)
+      __pyx_t_9 = __Pyx_PyInt_From_uint8_t((__pyx_v_annotation[0]).annotation_type); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 752, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_9);
-      __pyx_t_10 = __Pyx_PyInt_From_uint8_t((__pyx_v_annotation[0]).group_id); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 645, __pyx_L5_error)
+      __pyx_t_10 = __Pyx_PyInt_From_uint8_t((__pyx_v_annotation[0]).group_id); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 752, __pyx_L5_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_INCREF(__pyx_v_obj->cbk_fn);
       __pyx_t_11 = __pyx_v_obj->cbk_fn; __pyx_t_12 = NULL;
       __pyx_t_13 = 0;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_11))) {
         __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_11);
         if (likely(__pyx_t_12)) {
@@ -13640,35 +13955,35 @@
           __Pyx_DECREF_SET(__pyx_t_11, function);
           __pyx_t_13 = 1;
         }
       }
       #if CYTHON_FAST_PYCALL
       if (PyFunction_Check(__pyx_t_11)) {
         PyObject *__pyx_temp[6] = {__pyx_t_12, __pyx_t_8, __pyx_v_y, __pyx_t_9, __pyx_t_10, __pyx_v_data};
-        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_13, 5+__pyx_t_13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 645, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_13, 5+__pyx_t_13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 752, __pyx_L5_error)
         __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       } else
       #endif
       #if CYTHON_FAST_PYCCALL
       if (__Pyx_PyFastCFunction_Check(__pyx_t_11)) {
         PyObject *__pyx_temp[6] = {__pyx_t_12, __pyx_t_8, __pyx_v_y, __pyx_t_9, __pyx_t_10, __pyx_v_data};
-        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_13, 5+__pyx_t_13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 645, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_11, __pyx_temp+1-__pyx_t_13, 5+__pyx_t_13); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 752, __pyx_L5_error)
         __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
         __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
         __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
       } else
       #endif
       {
-        __pyx_t_14 = PyTuple_New(5+__pyx_t_13); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 645, __pyx_L5_error)
+        __pyx_t_14 = PyTuple_New(5+__pyx_t_13); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 752, __pyx_L5_error)
         __Pyx_GOTREF(__pyx_t_14);
         if (__pyx_t_12) {
           __Pyx_GIVEREF(__pyx_t_12); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_12); __pyx_t_12 = NULL;
         }
         __Pyx_GIVEREF(__pyx_t_8);
         PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_13, __pyx_t_8);
         __Pyx_INCREF(__pyx_v_y);
@@ -13680,23 +13995,23 @@
         PyTuple_SET_ITEM(__pyx_t_14, 3+__pyx_t_13, __pyx_t_10);
         __Pyx_INCREF(__pyx_v_data);
         __Pyx_GIVEREF(__pyx_v_data);
         PyTuple_SET_ITEM(__pyx_t_14, 4+__pyx_t_13, __pyx_v_data);
         __pyx_t_8 = 0;
         __pyx_t_9 = 0;
         __pyx_t_10 = 0;
-        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 645, __pyx_L5_error)
+        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 752, __pyx_L5_error)
         __Pyx_GOTREF(__pyx_t_1);
         __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
       }
       __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
       __pyx_v_rc = __pyx_t_1;
       __pyx_t_1 = 0;
 
-      /* "pyjls/binding.pyx":644
+      /* "pyjls/binding.pyx":751
  *     if not isfinite(y):
  *         y = None
  *     try:             # <<<<<<<<<<<<<<
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)
  *     except Exception:
  */
     }
@@ -13709,80 +14024,80 @@
     __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
     __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
     __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
     __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
     __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
     __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
 
-    /* "pyjls/binding.pyx":646
+    /* "pyjls/binding.pyx":753
  *     try:
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)
  *     except Exception:             # <<<<<<<<<<<<<<
  *         logging.getLogger(__name__).exception('in annotation callback')
  *         return 1
  */
     __pyx_t_13 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_13) {
       __Pyx_AddTraceback("pyjls.binding._annotation_cbk_fn", __pyx_clineno, __pyx_lineno, __pyx_filename);
-      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_11, &__pyx_t_14) < 0) __PYX_ERR(0, 646, __pyx_L7_except_error)
+      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_11, &__pyx_t_14) < 0) __PYX_ERR(0, 753, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_1);
       __Pyx_GOTREF(__pyx_t_11);
       __Pyx_GOTREF(__pyx_t_14);
 
-      /* "pyjls/binding.pyx":647
+      /* "pyjls/binding.pyx":754
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)
  *     except Exception:
  *         logging.getLogger(__name__).exception('in annotation callback')             # <<<<<<<<<<<<<<
  *         return 1
  *     return 1 if bool(rc) else 0
  */
-      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_logging); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 647, __pyx_L7_except_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_logging); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 754, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_8);
-      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_getLogger); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 647, __pyx_L7_except_error)
+      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_getLogger); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 754, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_12);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_name_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 647, __pyx_L7_except_error)
+      __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_name_2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 754, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_8);
       __pyx_t_15 = NULL;
       if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_12))) {
         __pyx_t_15 = PyMethod_GET_SELF(__pyx_t_12);
         if (likely(__pyx_t_15)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
           __Pyx_INCREF(__pyx_t_15);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_12, function);
         }
       }
       __pyx_t_9 = (__pyx_t_15) ? __Pyx_PyObject_Call2Args(__pyx_t_12, __pyx_t_15, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_12, __pyx_t_8);
       __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
-      if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 647, __pyx_L7_except_error)
+      if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 754, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_9);
       __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
-      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_exception); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 647, __pyx_L7_except_error)
+      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_exception); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 754, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_12);
       __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
       __pyx_t_9 = NULL;
       if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_12))) {
         __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_12);
         if (likely(__pyx_t_9)) {
           PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
           __Pyx_INCREF(__pyx_t_9);
           __Pyx_INCREF(function);
           __Pyx_DECREF_SET(__pyx_t_12, function);
         }
       }
       __pyx_t_10 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_12, __pyx_t_9, __pyx_kp_u_in_annotation_callback) : __Pyx_PyObject_CallOneArg(__pyx_t_12, __pyx_kp_u_in_annotation_callback);
       __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
-      if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 647, __pyx_L7_except_error)
+      if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 754, __pyx_L7_except_error)
       __Pyx_GOTREF(__pyx_t_10);
       __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
       __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
 
-      /* "pyjls/binding.pyx":648
+      /* "pyjls/binding.pyx":755
  *     except Exception:
  *         logging.getLogger(__name__).exception('in annotation callback')
  *         return 1             # <<<<<<<<<<<<<<
  *     return 1 if bool(rc) else 0
  * 
  */
       __pyx_r = 1;
@@ -13790,15 +14105,15 @@
       __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
       __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
       goto __pyx_L8_except_return;
     }
     goto __pyx_L7_except_error;
     __pyx_L7_except_error:;
 
-    /* "pyjls/binding.pyx":644
+    /* "pyjls/binding.pyx":751
  *     if not isfinite(y):
  *         y = None
  *     try:             # <<<<<<<<<<<<<<
  *         rc = obj.cbk_fn(timestamp, y, annotation[0].annotation_type, annotation[0].group_id, data)
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_5);
@@ -13811,31 +14126,31 @@
     __Pyx_XGIVEREF(__pyx_t_6);
     __Pyx_XGIVEREF(__pyx_t_7);
     __Pyx_ExceptionReset(__pyx_t_5, __pyx_t_6, __pyx_t_7);
     goto __pyx_L0;
     __pyx_L10_try_end:;
   }
 
-  /* "pyjls/binding.pyx":649
+  /* "pyjls/binding.pyx":756
  *         logging.getLogger(__name__).exception('in annotation callback')
  *         return 1
  *     return 1 if bool(rc) else 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_rc); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 649, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_rc); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 756, __pyx_L1_error)
   if (((!(!__pyx_t_3)) != 0)) {
     __pyx_t_16 = 1;
   } else {
     __pyx_t_16 = 0;
   }
   __pyx_r = __pyx_t_16;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":635
+  /* "pyjls/binding.pyx":742
  * 
  * 
  * cdef int32_t _annotation_cbk_fn(void * user_data, const c_jls.jls_annotation_s * annotation):             # <<<<<<<<<<<<<<
  *     obj: AnnotationCallback = <object> user_data
  *     data = _storage_unpack(annotation[0].storage_type, annotation[0].data, annotation[0].data_size)
  */
 
@@ -13856,15 +14171,15 @@
   __Pyx_XDECREF(__pyx_v_data);
   __Pyx_XDECREF(__pyx_v_y);
   __Pyx_XDECREF(__pyx_v_rc);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":652
+/* "pyjls/binding.pyx":759
  * 
  * 
  * cdef int32_t _user_data_cbk_fn(void * user_data, uint16_t chunk_meta, c_jls.jls_storage_type_e storage_type,             # <<<<<<<<<<<<<<
  *         uint8_t * data, uint32_t data_size):
  *     cbk_fn = <object> user_data
  */
 
@@ -13883,46 +14198,46 @@
   int32_t __pyx_t_7;
   int __pyx_t_8;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_user_data_cbk_fn", 0);
 
-  /* "pyjls/binding.pyx":654
+  /* "pyjls/binding.pyx":761
  * cdef int32_t _user_data_cbk_fn(void * user_data, uint16_t chunk_meta, c_jls.jls_storage_type_e storage_type,
  *         uint8_t * data, uint32_t data_size):
  *     cbk_fn = <object> user_data             # <<<<<<<<<<<<<<
  *     d = _storage_unpack(storage_type, data, data_size)
  *     rc = cbk_fn(chunk_meta, d)
  */
   __pyx_t_1 = ((PyObject *)__pyx_v_user_data);
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_cbk_fn = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":655
+  /* "pyjls/binding.pyx":762
  *         uint8_t * data, uint32_t data_size):
  *     cbk_fn = <object> user_data
  *     d = _storage_unpack(storage_type, data, data_size)             # <<<<<<<<<<<<<<
  *     rc = cbk_fn(chunk_meta, d)
  *     return 1 if bool(rc) else 0
  */
-  __pyx_t_1 = __pyx_f_5pyjls_7binding__storage_unpack(__pyx_v_storage_type, __pyx_v_data, __pyx_v_data_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 655, __pyx_L1_error)
+  __pyx_t_1 = __pyx_f_5pyjls_7binding__storage_unpack(__pyx_v_storage_type, __pyx_v_data, __pyx_v_data_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 762, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_v_d = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":656
+  /* "pyjls/binding.pyx":763
  *     cbk_fn = <object> user_data
  *     d = _storage_unpack(storage_type, data, data_size)
  *     rc = cbk_fn(chunk_meta, d)             # <<<<<<<<<<<<<<
  *     return 1 if bool(rc) else 0
  * 
  */
-  __pyx_t_2 = __Pyx_PyInt_From_uint16_t(__pyx_v_chunk_meta); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 656, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyInt_From_uint16_t(__pyx_v_chunk_meta); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 763, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_INCREF(__pyx_v_cbk_fn);
   __pyx_t_3 = __pyx_v_cbk_fn; __pyx_t_4 = NULL;
   __pyx_t_5 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
     if (likely(__pyx_t_4)) {
@@ -13932,66 +14247,66 @@
       __Pyx_DECREF_SET(__pyx_t_3, function);
       __pyx_t_5 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_2, __pyx_v_d};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
     PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_t_2, __pyx_v_d};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   } else
   #endif
   {
-    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_6);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_2);
     PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_t_2);
     __Pyx_INCREF(__pyx_v_d);
     __Pyx_GIVEREF(__pyx_v_d);
     PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_v_d);
     __pyx_t_2 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 656, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 763, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
   }
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_rc = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":657
+  /* "pyjls/binding.pyx":764
  *     d = _storage_unpack(storage_type, data, data_size)
  *     rc = cbk_fn(chunk_meta, d)
  *     return 1 if bool(rc) else 0             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_rc); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 657, __pyx_L1_error)
+  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_rc); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 764, __pyx_L1_error)
   if (((!(!__pyx_t_8)) != 0)) {
     __pyx_t_7 = 1;
   } else {
     __pyx_t_7 = 0;
   }
   __pyx_r = __pyx_t_7;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":652
+  /* "pyjls/binding.pyx":759
  * 
  * 
  * cdef int32_t _user_data_cbk_fn(void * user_data, uint16_t chunk_meta, c_jls.jls_storage_type_e storage_type,             # <<<<<<<<<<<<<<
  *         uint8_t * data, uint32_t data_size):
  *     cbk_fn = <object> user_data
  */
 
@@ -14008,15 +14323,15 @@
   __Pyx_XDECREF(__pyx_v_cbk_fn);
   __Pyx_XDECREF(__pyx_v_d);
   __Pyx_XDECREF(__pyx_v_rc);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "pyjls/binding.pyx":660
+/* "pyjls/binding.pyx":767
  * 
  * 
  * cdef int32_t _utc_cbk_fn(void * user_data, const c_jls.jls_utc_summary_entry_s * utc, uint32_t size):             # <<<<<<<<<<<<<<
  *     cdef uint32_t idx
  *     cbk_fn = <object> user_data
  */
 
@@ -14038,130 +14353,130 @@
   int32_t __pyx_t_9;
   int __pyx_t_10;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("_utc_cbk_fn", 0);
 
-  /* "pyjls/binding.pyx":662
+  /* "pyjls/binding.pyx":769
  * cdef int32_t _utc_cbk_fn(void * user_data, const c_jls.jls_utc_summary_entry_s * utc, uint32_t size):
  *     cdef uint32_t idx
  *     cbk_fn = <object> user_data             # <<<<<<<<<<<<<<
  *     entries = np.empty((size, 2), dtype=np.int64)
  *     for idx in range(size):
  */
   __pyx_t_1 = ((PyObject *)__pyx_v_user_data);
   __Pyx_INCREF(__pyx_t_1);
   __pyx_v_cbk_fn = __pyx_t_1;
   __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":663
+  /* "pyjls/binding.pyx":770
  *     cdef uint32_t idx
  *     cbk_fn = <object> user_data
  *     entries = np.empty((size, 2), dtype=np.int64)             # <<<<<<<<<<<<<<
  *     for idx in range(size):
  *         entries[idx, 0] = utc[idx].sample_id
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_empty); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_GIVEREF(__pyx_t_1);
   PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
   __Pyx_INCREF(__pyx_int_2);
   __Pyx_GIVEREF(__pyx_int_2);
   PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_2);
   __pyx_t_1 = 0;
-  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_3);
   PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
   __pyx_t_3 = 0;
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_int64); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_int64); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_5) < 0) __PYX_ERR(0, 663, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_t_5) < 0) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
-  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 663, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 770, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_entries = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "pyjls/binding.pyx":664
+  /* "pyjls/binding.pyx":771
  *     cbk_fn = <object> user_data
  *     entries = np.empty((size, 2), dtype=np.int64)
  *     for idx in range(size):             # <<<<<<<<<<<<<<
  *         entries[idx, 0] = utc[idx].sample_id
  *         entries[idx, 1] = utc[idx].timestamp
  */
   __pyx_t_6 = __pyx_v_size;
   __pyx_t_7 = __pyx_t_6;
   for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
     __pyx_v_idx = __pyx_t_8;
 
-    /* "pyjls/binding.pyx":665
+    /* "pyjls/binding.pyx":772
  *     entries = np.empty((size, 2), dtype=np.int64)
  *     for idx in range(size):
  *         entries[idx, 0] = utc[idx].sample_id             # <<<<<<<<<<<<<<
  *         entries[idx, 1] = utc[idx].timestamp
  *     rc = cbk_fn(entries)
  */
-    __pyx_t_5 = __Pyx_PyInt_From_int64_t((__pyx_v_utc[__pyx_v_idx]).sample_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 665, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_int64_t((__pyx_v_utc[__pyx_v_idx]).sample_id); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 772, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_idx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 665, __pyx_L1_error)
+    __pyx_t_3 = __Pyx_PyInt_From_uint32_t(__pyx_v_idx); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 772, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
-    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 665, __pyx_L1_error)
+    __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 772, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_GIVEREF(__pyx_t_3);
     PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_int_0);
     __pyx_t_3 = 0;
-    if (unlikely(PyObject_SetItem(__pyx_v_entries, __pyx_t_1, __pyx_t_5) < 0)) __PYX_ERR(0, 665, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_entries, __pyx_t_1, __pyx_t_5) < 0)) __PYX_ERR(0, 772, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
 
-    /* "pyjls/binding.pyx":666
+    /* "pyjls/binding.pyx":773
  *     for idx in range(size):
  *         entries[idx, 0] = utc[idx].sample_id
  *         entries[idx, 1] = utc[idx].timestamp             # <<<<<<<<<<<<<<
  *     rc = cbk_fn(entries)
  *     return 1 if bool(rc) else 0
  */
-    __pyx_t_5 = __Pyx_PyInt_From_int64_t((__pyx_v_utc[__pyx_v_idx]).timestamp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 666, __pyx_L1_error)
+    __pyx_t_5 = __Pyx_PyInt_From_int64_t((__pyx_v_utc[__pyx_v_idx]).timestamp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 773, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_5);
-    __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_idx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 666, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyInt_From_uint32_t(__pyx_v_idx); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 773, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
-    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 666, __pyx_L1_error)
+    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 773, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_3);
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
     __Pyx_INCREF(__pyx_int_1);
     __Pyx_GIVEREF(__pyx_int_1);
     PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_1);
     __pyx_t_1 = 0;
-    if (unlikely(PyObject_SetItem(__pyx_v_entries, __pyx_t_3, __pyx_t_5) < 0)) __PYX_ERR(0, 666, __pyx_L1_error)
+    if (unlikely(PyObject_SetItem(__pyx_v_entries, __pyx_t_3, __pyx_t_5) < 0)) __PYX_ERR(0, 773, __pyx_L1_error)
     __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   }
 
-  /* "pyjls/binding.pyx":667
+  /* "pyjls/binding.pyx":774
  *         entries[idx, 0] = utc[idx].sample_id
  *         entries[idx, 1] = utc[idx].timestamp
  *     rc = cbk_fn(entries)             # <<<<<<<<<<<<<<
  *     return 1 if bool(rc) else 0
  */
   __Pyx_INCREF(__pyx_v_cbk_fn);
   __pyx_t_3 = __pyx_v_cbk_fn; __pyx_t_1 = NULL;
@@ -14172,35 +14487,35 @@
       __Pyx_INCREF(__pyx_t_1);
       __Pyx_INCREF(function);
       __Pyx_DECREF_SET(__pyx_t_3, function);
     }
   }
   __pyx_t_5 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_1, __pyx_v_entries) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_entries);
   __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 667, __pyx_L1_error)
+  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 774, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __pyx_v_rc = __pyx_t_5;
   __pyx_t_5 = 0;
 
-  /* "pyjls/binding.pyx":668
+  /* "pyjls/binding.pyx":775
  *         entries[idx, 1] = utc[idx].timestamp
  *     rc = cbk_fn(entries)
  *     return 1 if bool(rc) else 0             # <<<<<<<<<<<<<<
  */
-  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_v_rc); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 668, __pyx_L1_error)
+  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_v_rc); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 775, __pyx_L1_error)
   if (((!(!__pyx_t_10)) != 0)) {
     __pyx_t_9 = 1;
   } else {
     __pyx_t_9 = 0;
   }
   __pyx_r = __pyx_t_9;
   goto __pyx_L0;
 
-  /* "pyjls/binding.pyx":660
+  /* "pyjls/binding.pyx":767
  * 
  * 
  * cdef int32_t _utc_cbk_fn(void * user_data, const c_jls.jls_utc_summary_entry_s * utc, uint32_t size):             # <<<<<<<<<<<<<<
  *     cdef uint32_t idx
  *     cbk_fn = <object> user_data
  */
 
@@ -14628,15 +14943,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":734
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -14645,29 +14960,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":735
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":735
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 735, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":734
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -14678,15 +14993,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":737
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -14695,29 +15010,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":738
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":738
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 738, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":737
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -14728,15 +15043,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":740
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -14745,29 +15060,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":741
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":741
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 741, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":740
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -14778,15 +15093,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":743
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -14795,29 +15110,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":744
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":744
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 744, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":743
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -14828,15 +15143,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":746
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -14845,29 +15160,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":747
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":747
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 747, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":746
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -14878,212 +15193,212 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":749
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":750
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":750
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
   if (__pyx_t_1) {
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":751
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":751
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":750
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":750
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":753
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":753
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":749
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":928
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("set_array_base", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":929
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":929
  * 
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
  *     PyArray_SetBaseObject(arr, base)
  * 
  */
   Py_INCREF(__pyx_v_base);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":930
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":930
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
   (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":928
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":932
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("get_array_base", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":933
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":933
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
  *     if base is NULL:
  *         return None
  */
   __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":934
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":935
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":935
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     return <object>base
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":934
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   }
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":936
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":936
  *     if base is NULL:
  *         return None
  *     return <object>base             # <<<<<<<<<<<<<<
  * 
  * # Versions of the import_* functions which are more suitable for
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_base));
   __pyx_r = ((PyObject *)__pyx_v_base);
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":932
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":940
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -15099,15 +15414,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_array", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":941
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
   {
@@ -15115,53 +15430,53 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":942
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":942
  * cdef inline int import_array() except -1:
  *     try:
  *         __pyx_import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
       __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 942, __pyx_L3_error)
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":941
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":943
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":943
  *     try:
  *         __pyx_import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 943, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":944
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 944, __pyx_L5_except_error)
@@ -15169,30 +15484,30 @@
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(2, 944, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":941
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":940
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -15207,15 +15522,15 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":946
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -15231,15 +15546,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_umath", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":947
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -15247,53 +15562,53 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":948
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":948
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 948, __pyx_L3_error)
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":947
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":949
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":949
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 949, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":950
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 950, __pyx_L5_except_error)
@@ -15301,30 +15616,30 @@
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(2, 950, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":947
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":946
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -15339,15 +15654,15 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":952
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -15363,15 +15678,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_ufunc", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":953
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -15379,53 +15694,53 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":954
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":954
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(2, 954, __pyx_L3_error)
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":953
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":955
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":955
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(2, 955, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":956
+      /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":956
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef extern from *:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(2, 956, __pyx_L5_except_error)
@@ -15433,30 +15748,30 @@
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(2, 956, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":953
+    /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":952
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -15471,176 +15786,176 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":966
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":966
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_timedelta64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_timedelta64_object", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":978
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":978
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyTimedeltaArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyTimedeltaArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":966
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":966
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":981
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":981
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_datetime64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_datetime64_object", 0);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":993
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":993
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyDatetimeArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyDatetimeArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":981
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":981
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":996
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":996
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
 static CYTHON_INLINE npy_datetime __pyx_f_5numpy_get_datetime64_value(PyObject *__pyx_v_obj) {
   npy_datetime __pyx_r;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1003
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1003
  *     also needed.  That can be found using `get_datetime64_unit`.
  *     """
  *     return (<PyDatetimeScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyDatetimeScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":996
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":996
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1006
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1006
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
 static CYTHON_INLINE npy_timedelta __pyx_f_5numpy_get_timedelta64_value(PyObject *__pyx_v_obj) {
   npy_timedelta __pyx_r;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1010
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1010
  *     returns the int64 value underlying scalar numpy timedelta64 object
  *     """
  *     return (<PyTimedeltaScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyTimedeltaScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1006
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1006
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1013
+/* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1013
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
 static CYTHON_INLINE NPY_DATETIMEUNIT __pyx_f_5numpy_get_datetime64_unit(PyObject *__pyx_v_obj) {
   NPY_DATETIMEUNIT __pyx_r;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1017
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1017
  *     returns the unit part of the dtype for a numpy datetime64 object.
  *     """
  *     return <NPY_DATETIMEUNIT>(<PyDatetimeScalarObject*>obj).obmeta.base             # <<<<<<<<<<<<<<
  */
   __pyx_r = ((NPY_DATETIMEUNIT)((PyDatetimeScalarObject *)__pyx_v_obj)->obmeta.base);
   goto __pyx_L0;
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":1013
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":1013
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
@@ -28709,25 +29024,25 @@
   #endif
   (*Py_TYPE(o)->tp_free)(o);
 }
 
 static PyMethodDef __pyx_methods_5pyjls_7binding_Writer[] = {
   {"__enter__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_3__enter__, METH_NOARGS, 0},
   {"__exit__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_5__exit__, METH_VARARGS|METH_KEYWORDS, 0},
-  {"close", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_7close, METH_NOARGS, 0},
-  {"flush", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_9flush, METH_NOARGS, 0},
-  {"source_def", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_11source_def, METH_VARARGS|METH_KEYWORDS, 0},
-  {"source_def_from_struct", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_13source_def_from_struct, METH_O, 0},
-  {"signal_def", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_15signal_def, METH_VARARGS|METH_KEYWORDS, 0},
-  {"signal_def_from_struct", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_17signal_def_from_struct, METH_O, 0},
-  {"user_data", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_19user_data, METH_VARARGS|METH_KEYWORDS, 0},
-  {"fsr_f32", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_21fsr_f32, METH_VARARGS|METH_KEYWORDS, 0},
-  {"fsr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_23fsr, METH_VARARGS|METH_KEYWORDS, 0},
-  {"annotation", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_25annotation, METH_VARARGS|METH_KEYWORDS, 0},
-  {"utc", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_27utc, METH_VARARGS|METH_KEYWORDS, 0},
+  {"close", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_7close, METH_NOARGS, __pyx_doc_5pyjls_7binding_6Writer_6close},
+  {"flush", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_9flush, METH_NOARGS, __pyx_doc_5pyjls_7binding_6Writer_8flush},
+  {"source_def", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_11source_def, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_10source_def},
+  {"source_def_from_struct", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_13source_def_from_struct, METH_O, __pyx_doc_5pyjls_7binding_6Writer_12source_def_from_struct},
+  {"signal_def", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_15signal_def, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_14signal_def},
+  {"signal_def_from_struct", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_17signal_def_from_struct, METH_O, __pyx_doc_5pyjls_7binding_6Writer_16signal_def_from_struct},
+  {"user_data", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_19user_data, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_18user_data},
+  {"fsr_f32", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_21fsr_f32, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_20fsr_f32},
+  {"fsr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_23fsr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_22fsr},
+  {"annotation", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_25annotation, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_24annotation},
+  {"utc", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Writer_27utc, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Writer_26utc},
   {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_29__reduce_cython__, METH_NOARGS, 0},
   {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Writer_31__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type_5pyjls_7binding_Writer = {
   PyVarObject_HEAD_INIT(0, 0)
@@ -28756,15 +29071,15 @@
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
-  0, /*tp_doc*/
+  "Create a new JLS writer.\n\n    :param path: The output JLS file path.\n    ", /*tp_doc*/
   0, /*tp_traverse*/
   0, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_5pyjls_7binding_Writer, /*tp_methods*/
@@ -28982,30 +29297,31 @@
 static PyObject *__pyx_getprop_5pyjls_7binding_6Reader_signals(PyObject *o, CYTHON_UNUSED void *x) {
   return __pyx_pw_5pyjls_7binding_6Reader_7signals_1__get__(o);
 }
 
 static PyMethodDef __pyx_methods_5pyjls_7binding_Reader[] = {
   {"__enter__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_3__enter__, METH_NOARGS, 0},
   {"__exit__", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_5__exit__, METH_VARARGS|METH_KEYWORDS, 0},
-  {"close", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_7close, METH_NOARGS, 0},
-  {"fsr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_9fsr, METH_VARARGS|METH_KEYWORDS, 0},
-  {"fsr_statistics", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_11fsr_statistics, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_10fsr_statistics},
-  {"annotations", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_13annotations, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_12annotations},
-  {"user_data", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_15user_data, METH_O, 0},
-  {"utc", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_17utc, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_16utc},
-  {"sample_id_to_timestamp", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_19sample_id_to_timestamp, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_18sample_id_to_timestamp},
-  {"timestamp_to_sample_id", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_21timestamp_to_sample_id, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_20timestamp_to_sample_id},
-  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_23__reduce_cython__, METH_NOARGS, 0},
-  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_25__setstate_cython__, METH_O, 0},
+  {"close", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_7close, METH_NOARGS, __pyx_doc_5pyjls_7binding_6Reader_6close},
+  {"signal_lookup", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_9signal_lookup, METH_O, __pyx_doc_5pyjls_7binding_6Reader_8signal_lookup},
+  {"fsr", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_11fsr, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_10fsr},
+  {"fsr_statistics", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_13fsr_statistics, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_12fsr_statistics},
+  {"annotations", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_15annotations, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_14annotations},
+  {"user_data", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_17user_data, METH_O, __pyx_doc_5pyjls_7binding_6Reader_16user_data},
+  {"utc", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_19utc, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_18utc},
+  {"sample_id_to_timestamp", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_21sample_id_to_timestamp, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_20sample_id_to_timestamp},
+  {"timestamp_to_sample_id", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_5pyjls_7binding_6Reader_23timestamp_to_sample_id, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pyjls_7binding_6Reader_22timestamp_to_sample_id},
+  {"__reduce_cython__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_25__reduce_cython__, METH_NOARGS, 0},
+  {"__setstate_cython__", (PyCFunction)__pyx_pw_5pyjls_7binding_6Reader_27__setstate_cython__, METH_O, 0},
   {0, 0, 0, 0}
 };
 
 static struct PyGetSetDef __pyx_getsets_5pyjls_7binding_Reader[] = {
-  {(char *)"sources", __pyx_getprop_5pyjls_7binding_6Reader_sources, 0, (char *)0, 0},
-  {(char *)"signals", __pyx_getprop_5pyjls_7binding_6Reader_signals, 0, (char *)0, 0},
+  {(char *)"sources", __pyx_getprop_5pyjls_7binding_6Reader_sources, 0, (char *)"Return the dict mapping source_id to SourceDef.", 0},
+  {(char *)"signals", __pyx_getprop_5pyjls_7binding_6Reader_signals, 0, (char *)"Return the dict mapping signal_id to SignalDef.", 0},
   {0, 0, 0, 0, 0}
 };
 
 static PyTypeObject __pyx_type_5pyjls_7binding_Reader = {
   PyVarObject_HEAD_INIT(0, 0)
   "pyjls.binding.Reader", /*tp_name*/
   sizeof(struct __pyx_obj_5pyjls_7binding_Reader), /*tp_basicsize*/
@@ -29032,15 +29348,15 @@
   0, /*tp_hash*/
   0, /*tp_call*/
   0, /*tp_str*/
   0, /*tp_getattro*/
   0, /*tp_setattro*/
   0, /*tp_as_buffer*/
   Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
-  0, /*tp_doc*/
+  "Open a JLS v2 file for reading.\n\n    :param path: The path to the JLS file.\n    ", /*tp_doc*/
   __pyx_tp_traverse_5pyjls_7binding_Reader, /*tp_traverse*/
   __pyx_tp_clear_5pyjls_7binding_Reader, /*tp_clear*/
   0, /*tp_richcompare*/
   0, /*tp_weaklistoffset*/
   0, /*tp_iter*/
   0, /*tp_iternext*/
   __pyx_methods_5pyjls_7binding_Reader, /*tp_methods*/
@@ -29916,14 +30232,18 @@
   {&__pyx_n_s_SignalType, __pyx_k_SignalType, sizeof(__pyx_k_SignalType), 0, 0, 1, 1},
   {&__pyx_n_u_SignalType, __pyx_k_SignalType, sizeof(__pyx_k_SignalType), 0, 1, 0, 1},
   {&__pyx_n_s_SourceDef, __pyx_k_SourceDef, sizeof(__pyx_k_SourceDef), 0, 0, 1, 1},
   {&__pyx_n_u_SourceDef, __pyx_k_SourceDef, sizeof(__pyx_k_SourceDef), 0, 1, 0, 1},
   {&__pyx_n_s_SummaryFSR, __pyx_k_SummaryFSR, sizeof(__pyx_k_SummaryFSR), 0, 0, 1, 1},
   {&__pyx_n_u_SummaryFSR, __pyx_k_SummaryFSR, sizeof(__pyx_k_SummaryFSR), 0, 1, 0, 1},
   {&__pyx_n_s_TEXT, __pyx_k_TEXT, sizeof(__pyx_k_TEXT), 0, 0, 1, 1},
+  {&__pyx_kp_s_The_FSR_column_enumeration, __pyx_k_The_FSR_column_enumeration, sizeof(__pyx_k_The_FSR_column_enumeration), 0, 0, 1, 0},
+  {&__pyx_kp_s_The_annotation_type_enumeration, __pyx_k_The_annotation_type_enumeration, sizeof(__pyx_k_The_annotation_type_enumeration), 0, 0, 1, 0},
+  {&__pyx_kp_s_The_signal_data_type_enumeration, __pyx_k_The_signal_data_type_enumeration, sizeof(__pyx_k_The_signal_data_type_enumeration), 0, 0, 1, 0},
+  {&__pyx_kp_s_The_signal_type_enumeration, __pyx_k_The_signal_type_enumeration, sizeof(__pyx_k_The_signal_type_enumeration), 0, 0, 1, 0},
   {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
   {&__pyx_n_s_U1, __pyx_k_U1, sizeof(__pyx_k_U1), 0, 0, 1, 1},
   {&__pyx_n_s_U16, __pyx_k_U16, sizeof(__pyx_k_U16), 0, 0, 1, 1},
   {&__pyx_n_s_U32, __pyx_k_U32, sizeof(__pyx_k_U32), 0, 0, 1, 1},
   {&__pyx_n_s_U4, __pyx_k_U4, sizeof(__pyx_k_U4), 0, 0, 1, 1},
   {&__pyx_n_s_U64, __pyx_k_U64, sizeof(__pyx_k_U64), 0, 0, 1, 1},
   {&__pyx_n_s_U8, __pyx_k_U8, sizeof(__pyx_k_U8), 0, 0, 1, 1},
@@ -30108,14 +30428,15 @@
   {&__pyx_n_s_serial_number, __pyx_k_serial_number, sizeof(__pyx_k_serial_number), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
   {&__pyx_n_s_signal_def, __pyx_k_signal_def, sizeof(__pyx_k_signal_def), 0, 0, 1, 1},
   {&__pyx_n_u_signal_def, __pyx_k_signal_def, sizeof(__pyx_k_signal_def), 0, 1, 0, 1},
   {&__pyx_n_s_signal_id, __pyx_k_signal_id, sizeof(__pyx_k_signal_id), 0, 0, 1, 1},
+  {&__pyx_kp_u_signal_lookup_failed_for, __pyx_k_signal_lookup_failed_for, sizeof(__pyx_k_signal_lookup_failed_for), 0, 1, 0, 0},
   {&__pyx_n_s_signal_type, __pyx_k_signal_type, sizeof(__pyx_k_signal_type), 0, 0, 1, 1},
   {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
   {&__pyx_n_s_source_def, __pyx_k_source_def, sizeof(__pyx_k_source_def), 0, 0, 1, 1},
   {&__pyx_n_u_source_def, __pyx_k_source_def, sizeof(__pyx_k_source_def), 0, 1, 0, 1},
   {&__pyx_n_s_source_id, __pyx_k_source_id, sizeof(__pyx_k_source_id), 0, 0, 1, 1},
   {&__pyx_n_s_split, __pyx_k_split, sizeof(__pyx_k_split), 0, 0, 1, 1},
   {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
@@ -30163,27 +30484,28 @@
   {&__pyx_n_u_utc, __pyx_k_utc, sizeof(__pyx_k_utc), 0, 1, 0, 1},
   {&__pyx_n_s_utc_decimate_factor, __pyx_k_utc_decimate_factor, sizeof(__pyx_k_utc_decimate_factor), 0, 0, 1, 1},
   {&__pyx_n_s_utc_i64, __pyx_k_utc_i64, sizeof(__pyx_k_utc_i64), 0, 0, 1, 1},
   {&__pyx_n_s_utc_timestamp, __pyx_k_utc_timestamp, sizeof(__pyx_k_utc_timestamp), 0, 0, 1, 1},
   {&__pyx_n_s_utc_to_jls, __pyx_k_utc_to_jls, sizeof(__pyx_k_utc_to_jls), 0, 0, 1, 1},
   {&__pyx_kp_u_utf_8, __pyx_k_utf_8, sizeof(__pyx_k_utf_8), 0, 1, 0, 0},
   {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
+  {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
   {&__pyx_n_s_vendor, __pyx_k_vendor, sizeof(__pyx_k_vendor), 0, 0, 1, 1},
   {&__pyx_n_s_version, __pyx_k_version, sizeof(__pyx_k_version), 0, 0, 1, 1},
   {&__pyx_n_u_vertical_marker, __pyx_k_vertical_marker, sizeof(__pyx_k_vertical_marker), 0, 1, 0, 1},
   {&__pyx_n_s_view, __pyx_k_view, sizeof(__pyx_k_view), 0, 0, 1, 1},
   {&__pyx_n_u_vmarker, __pyx_k_vmarker, sizeof(__pyx_k_vmarker), 0, 1, 0, 1},
   {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
-  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(0, 251, __pyx_L1_error)
-  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 388, __pyx_L1_error)
+  __pyx_builtin_RuntimeError = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeError); if (!__pyx_builtin_RuntimeError) __PYX_ERR(0, 268, __pyx_L1_error)
+  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 434, __pyx_L1_error)
   __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(1, 2, __pyx_L1_error)
-  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 467, __pyx_L1_error)
+  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 532, __pyx_L1_error)
   __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(2, 944, __pyx_L1_error)
   __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(1, 149, __pyx_L1_error)
   __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(1, 152, __pyx_L1_error)
   __pyx_builtin_Ellipsis = __Pyx_GetBuiltinName(__pyx_n_s_Ellipsis); if (!__pyx_builtin_Ellipsis) __PYX_ERR(1, 406, __pyx_L1_error)
   __pyx_builtin_id = __Pyx_GetBuiltinName(__pyx_n_s_id); if (!__pyx_builtin_id) __PYX_ERR(1, 615, __pyx_L1_error)
   __pyx_builtin_IndexError = __Pyx_GetBuiltinName(__pyx_n_s_IndexError); if (!__pyx_builtin_IndexError) __PYX_ERR(1, 834, __pyx_L1_error)
   return 0;
@@ -30191,22 +30513,22 @@
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "pyjls/binding.pyx":189
+  /* "pyjls/binding.pyx":198
  *     with gil:
  *         m = msg.decode('utf-8').strip()
  *         level, location, s = m.split(' ', 2)             # <<<<<<<<<<<<<<
  *         lvl = _log_level_map.get(level, logging.DEBUG)
  *         filename, line, _ = location.split(':')
  */
-  __pyx_tuple__2 = PyTuple_Pack(2, __pyx_kp_u_, __pyx_int_2); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 189, __pyx_L1_error)
+  __pyx_tuple__2 = PyTuple_Pack(2, __pyx_kp_u_, __pyx_int_2); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 198, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__2);
   __Pyx_GIVEREF(__pyx_tuple__2);
 
   /* "(tree fragment)":2
  * def __reduce_cython__(self):
  *     raise TypeError("self._wr cannot be converted to a Python object for pickling")             # <<<<<<<<<<<<<<
  * def __setstate_cython__(self, __pyx_state):
@@ -30243,26 +30565,26 @@
   __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_s_self__rd_cannot_be_converted_to); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__12);
   __Pyx_GIVEREF(__pyx_tuple__12);
   __pyx_tuple__13 = PyTuple_Pack(3, __pyx_int_3248624, __pyx_int_200305830, __pyx_int_134405936); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(1, 4, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__13);
   __Pyx_GIVEREF(__pyx_tuple__13);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":944
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
   __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(2, 944, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__14);
   __Pyx_GIVEREF(__pyx_tuple__14);
 
-  /* "../../../bin/Python3_8_10/lib/site-packages/numpy/__init__.pxd":950
+  /* "../../../../../tmp/build-env-pr837epv/lib/python3.11/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
   __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(2, 950, __pyx_L1_error)
@@ -30472,121 +30794,121 @@
  * 
  */
   __pyx_tuple__35 = PyTuple_Pack(3, __pyx_n_s_basetype, __pyx_n_s_size, __pyx_n_s_q); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 50, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__35);
   __Pyx_GIVEREF(__pyx_tuple__35);
   __pyx_codeobj__36 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__35, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_data_type_def, 50, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__36)) __PYX_ERR(0, 50, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":120
+  /* "pyjls/binding.pyx":126
  * 
  * 
  * def _populate_data_type():             # <<<<<<<<<<<<<<
  *     for key, value in list(_data_type_as_enum.items()):
  *         _data_type_as_enum[value] = value
  */
-  __pyx_tuple__37 = PyTuple_Pack(2, __pyx_n_s_key, __pyx_n_s_value); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __pyx_tuple__37 = PyTuple_Pack(2, __pyx_n_s_key, __pyx_n_s_value); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 126, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__37);
   __Pyx_GIVEREF(__pyx_tuple__37);
-  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_populate_data_type, 120, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(0, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_populate_data_type, 126, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(0, 126, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":130
+  /* "pyjls/binding.pyx":136
  * 
  * 
  * def data_type_as_enum(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_enum[data_type]
  * 
  */
-  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_n_s_data_type); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 130, __pyx_L1_error)
+  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_n_s_data_type); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 136, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__39);
   __Pyx_GIVEREF(__pyx_tuple__39);
-  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_data_type_as_enum_2, 130, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 130, __pyx_L1_error)
+  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_data_type_as_enum_2, 136, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(0, 136, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":134
+  /* "pyjls/binding.pyx":140
  * 
  * 
  * def data_type_as_str(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_str[data_type]
  * 
  */
-  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_n_s_data_type); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 134, __pyx_L1_error)
+  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_n_s_data_type); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 140, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__41);
   __Pyx_GIVEREF(__pyx_tuple__41);
-  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_data_type_as_str_2, 134, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 134, __pyx_L1_error)
+  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_data_type_as_str_2, 140, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 140, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":199
+  /* "pyjls/binding.pyx":208
  * 
  * 
  * def jls_inject_log(level, filename, line, msg):             # <<<<<<<<<<<<<<
  *     cdef char * c_msg
  *     location = ':'.join([filename, str(line), ''])
  */
-  __pyx_tuple__44 = PyTuple_Pack(6, __pyx_n_s_level, __pyx_n_s_filename, __pyx_n_s_line, __pyx_n_s_msg, __pyx_n_s_c_msg, __pyx_n_s_location); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 199, __pyx_L1_error)
+  __pyx_tuple__44 = PyTuple_Pack(6, __pyx_n_s_level, __pyx_n_s_filename, __pyx_n_s_line, __pyx_n_s_msg, __pyx_n_s_c_msg, __pyx_n_s_location); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 208, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__44);
   __Pyx_GIVEREF(__pyx_tuple__44);
-  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_jls_inject_log, 199, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 199, __pyx_L1_error)
+  __pyx_codeobj__45 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__44, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_jls_inject_log, 208, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__45)) __PYX_ERR(0, 208, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":207
+  /* "pyjls/binding.pyx":216
  * 
  * 
  * def _encode_str(s):             # <<<<<<<<<<<<<<
  *     if s is None:
  *         s = ''
  */
-  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_n_s_s_2); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 207, __pyx_L1_error)
+  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_n_s_s_2); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 216, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__46);
   __Pyx_GIVEREF(__pyx_tuple__46);
-  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_encode_str, 207, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 207, __pyx_L1_error)
+  __pyx_codeobj__47 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__46, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_encode_str, 216, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__47)) __PYX_ERR(0, 216, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":213
+  /* "pyjls/binding.pyx":222
  * 
  * 
  * def _storage_pack(data):             # <<<<<<<<<<<<<<
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  */
-  __pyx_tuple__48 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_s_2); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 213, __pyx_L1_error)
+  __pyx_tuple__48 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_s_2); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 222, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__48);
   __Pyx_GIVEREF(__pyx_tuple__48);
-  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_storage_pack, 213, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 213, __pyx_L1_error)
+  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_storage_pack, 222, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 222, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":236
+  /* "pyjls/binding.pyx":245
  * 
  * 
  * def utc_to_jls(utc):             # <<<<<<<<<<<<<<
  *     """Convert from python UTC timestamp to jls timestamp."""
  *     return int((utc - _UTC_OFFSET) * SECOND)
  */
-  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_n_s_utc); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 236, __pyx_L1_error)
+  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_n_s_utc); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 245, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__50);
   __Pyx_GIVEREF(__pyx_tuple__50);
-  __pyx_codeobj__51 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__50, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_utc_to_jls, 236, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__51)) __PYX_ERR(0, 236, __pyx_L1_error)
+  __pyx_codeobj__51 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__50, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_utc_to_jls, 245, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__51)) __PYX_ERR(0, 245, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":241
+  /* "pyjls/binding.pyx":250
  * 
  * 
  * def jls_to_utc(timestamp):             # <<<<<<<<<<<<<<
- *     """Convert from jls timestamp to python UTC timestamp."""
- *     return (timestamp / SECOND) + _UTC_OFFSET
+ *     """Convert from jls timestamp to python UTC timestamp.
+ * 
  */
-  __pyx_tuple__52 = PyTuple_Pack(1, __pyx_n_s_timestamp); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 241, __pyx_L1_error)
+  __pyx_tuple__52 = PyTuple_Pack(1, __pyx_n_s_timestamp); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__52);
   __Pyx_GIVEREF(__pyx_tuple__52);
-  __pyx_codeobj__53 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__52, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_jls_to_utc, 241, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__53)) __PYX_ERR(0, 241, __pyx_L1_error)
+  __pyx_codeobj__53 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__52, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_jls_to_utc, 250, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__53)) __PYX_ERR(0, 250, __pyx_L1_error)
 
-  /* "pyjls/binding.pyx":246
+  /* "pyjls/binding.pyx":263
  * 
  * 
  * def _handle_rc(name, rc):             # <<<<<<<<<<<<<<
  *     if rc == 0:
  *         return
  */
-  __pyx_tuple__54 = PyTuple_Pack(4, __pyx_n_s_name, __pyx_n_s_rc, __pyx_n_s_rc_name, __pyx_n_s_rc_descr); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(0, 246, __pyx_L1_error)
+  __pyx_tuple__54 = PyTuple_Pack(4, __pyx_n_s_name, __pyx_n_s_rc, __pyx_n_s_rc_name, __pyx_n_s_rc_descr); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(0, 263, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__54);
   __Pyx_GIVEREF(__pyx_tuple__54);
-  __pyx_codeobj__55 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__54, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_handle_rc, 246, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__55)) __PYX_ERR(0, 246, __pyx_L1_error)
+  __pyx_codeobj__55 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__54, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_pyjls_binding_pyx, __pyx_n_s_handle_rc, 263, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__55)) __PYX_ERR(0, 263, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_AnnotationCallback(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
   __pyx_tuple__56 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__56)) __PYX_ERR(1, 1, __pyx_L1_error)
@@ -30733,43 +31055,43 @@
 static int __Pyx_modinit_type_init_code(void) {
   __Pyx_RefNannyDeclarations
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
   /*--- Type init code ---*/
-  if (PyType_Ready(&__pyx_type_5pyjls_7binding_Writer) < 0) __PYX_ERR(0, 254, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_5pyjls_7binding_Writer) < 0) __PYX_ERR(0, 271, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_5pyjls_7binding_Writer.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyjls_7binding_Writer.tp_dictoffset && __pyx_type_5pyjls_7binding_Writer.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_5pyjls_7binding_Writer.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Writer, (PyObject *)&__pyx_type_5pyjls_7binding_Writer) < 0) __PYX_ERR(0, 254, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyjls_7binding_Writer) < 0) __PYX_ERR(0, 254, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Writer, (PyObject *)&__pyx_type_5pyjls_7binding_Writer) < 0) __PYX_ERR(0, 271, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyjls_7binding_Writer) < 0) __PYX_ERR(0, 271, __pyx_L1_error)
   __pyx_ptype_5pyjls_7binding_Writer = &__pyx_type_5pyjls_7binding_Writer;
-  if (PyType_Ready(&__pyx_type_5pyjls_7binding_AnnotationCallback) < 0) __PYX_ERR(0, 440, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_5pyjls_7binding_AnnotationCallback) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_5pyjls_7binding_AnnotationCallback.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyjls_7binding_AnnotationCallback.tp_dictoffset && __pyx_type_5pyjls_7binding_AnnotationCallback.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_5pyjls_7binding_AnnotationCallback.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AnnotationCallback, (PyObject *)&__pyx_type_5pyjls_7binding_AnnotationCallback) < 0) __PYX_ERR(0, 440, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyjls_7binding_AnnotationCallback) < 0) __PYX_ERR(0, 440, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_AnnotationCallback, (PyObject *)&__pyx_type_5pyjls_7binding_AnnotationCallback) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyjls_7binding_AnnotationCallback) < 0) __PYX_ERR(0, 501, __pyx_L1_error)
   __pyx_ptype_5pyjls_7binding_AnnotationCallback = &__pyx_type_5pyjls_7binding_AnnotationCallback;
-  if (PyType_Ready(&__pyx_type_5pyjls_7binding_Reader) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
+  if (PyType_Ready(&__pyx_type_5pyjls_7binding_Reader) < 0) __PYX_ERR(0, 510, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type_5pyjls_7binding_Reader.tp_print = 0;
   #endif
   if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_5pyjls_7binding_Reader.tp_dictoffset && __pyx_type_5pyjls_7binding_Reader.tp_getattro == PyObject_GenericGetAttr)) {
     __pyx_type_5pyjls_7binding_Reader.tp_getattro = __Pyx_PyObject_GenericGetAttr;
   }
-  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Reader, (PyObject *)&__pyx_type_5pyjls_7binding_Reader) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
-  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyjls_7binding_Reader) < 0) __PYX_ERR(0, 449, __pyx_L1_error)
+  if (PyObject_SetAttr(__pyx_m, __pyx_n_s_Reader, (PyObject *)&__pyx_type_5pyjls_7binding_Reader) < 0) __PYX_ERR(0, 510, __pyx_L1_error)
+  if (__Pyx_setup_reduce((PyObject*)&__pyx_type_5pyjls_7binding_Reader) < 0) __PYX_ERR(0, 510, __pyx_L1_error)
   __pyx_ptype_5pyjls_7binding_Reader = &__pyx_type_5pyjls_7binding_Reader;
   __pyx_vtabptr_array = &__pyx_vtable_array;
   __pyx_vtable_array.get_memview = (PyObject *(*)(struct __pyx_array_obj *))__pyx_array_get_memview;
   if (PyType_Ready(&__pyx_type___pyx_array) < 0) __PYX_ERR(1, 106, __pyx_L1_error)
   #if PY_VERSION_HEX < 0x030800B1
   __pyx_type___pyx_array.tp_print = 0;
   #endif
@@ -31353,32 +31675,32 @@
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
   /* "pyjls/binding.pyx":61
  * 
  * 
  * class DataType:             # <<<<<<<<<<<<<<
- *     U1 = _data_type_def(_DataTypeBase.UINT, 1, 0)
- *     U4 = _data_type_def(_DataTypeBase.UINT, 4, 0)
+ *     """The signal data type enumeration.
+ * 
  */
-  __pyx_t_3 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_DataType, __pyx_n_s_DataType, (PyObject *) NULL, __pyx_n_s_pyjls_binding, (PyObject *) NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 61, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_DataType, __pyx_n_s_DataType, (PyObject *) NULL, __pyx_n_s_pyjls_binding, __pyx_kp_s_The_signal_data_type_enumeration); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 61, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
 
-  /* "pyjls/binding.pyx":62
- * 
- * class DataType:
+  /* "pyjls/binding.pyx":68
+ *     floating point: F32, F64
+ *     """
  *     U1 = _data_type_def(_DataTypeBase.UINT, 1, 0)             # <<<<<<<<<<<<<<
  *     U4 = _data_type_def(_DataTypeBase.UINT, 4, 0)
  *     U8 = _data_type_def(_DataTypeBase.UINT, 8, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 62, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 62, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 62, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -31388,64 +31710,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_1, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 62, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_1, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 62, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 62, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 68, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_1);
     __Pyx_GIVEREF(__pyx_int_1);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_1);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 62, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 68, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U1, __pyx_t_1) < 0) __PYX_ERR(0, 62, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U1, __pyx_t_1) < 0) __PYX_ERR(0, 68, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":63
- * class DataType:
+  /* "pyjls/binding.pyx":69
+ *     """
  *     U1 = _data_type_def(_DataTypeBase.UINT, 1, 0)
  *     U4 = _data_type_def(_DataTypeBase.UINT, 4, 0)             # <<<<<<<<<<<<<<
  *     U8 = _data_type_def(_DataTypeBase.UINT, 8, 0)
  *     U16 = _data_type_def(_DataTypeBase.UINT, 16, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 63, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 69, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 63, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 69, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 63, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 69, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_7)) {
@@ -31455,64 +31777,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_4, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_4, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 63, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 69, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_4);
     __Pyx_GIVEREF(__pyx_int_4);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_int_4);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 63, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U4, __pyx_t_1) < 0) __PYX_ERR(0, 63, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U4, __pyx_t_1) < 0) __PYX_ERR(0, 69, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":64
+  /* "pyjls/binding.pyx":70
  *     U1 = _data_type_def(_DataTypeBase.UINT, 1, 0)
  *     U4 = _data_type_def(_DataTypeBase.UINT, 4, 0)
  *     U8 = _data_type_def(_DataTypeBase.UINT, 8, 0)             # <<<<<<<<<<<<<<
  *     U16 = _data_type_def(_DataTypeBase.UINT, 16, 0)
  *     U32 = _data_type_def(_DataTypeBase.UINT, 32, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 70, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 70, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 64, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 70, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -31522,64 +31844,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_8, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_8, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 64, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 70, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_8);
     __Pyx_GIVEREF(__pyx_int_8);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_8);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 64, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U8, __pyx_t_1) < 0) __PYX_ERR(0, 64, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U8, __pyx_t_1) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":65
+  /* "pyjls/binding.pyx":71
  *     U4 = _data_type_def(_DataTypeBase.UINT, 4, 0)
  *     U8 = _data_type_def(_DataTypeBase.UINT, 8, 0)
  *     U16 = _data_type_def(_DataTypeBase.UINT, 16, 0)             # <<<<<<<<<<<<<<
  *     U32 = _data_type_def(_DataTypeBase.UINT, 32, 0)
  *     U64 = _data_type_def(_DataTypeBase.UINT, 64, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 71, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 71, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 65, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 71, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_7)) {
@@ -31589,64 +31911,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_16, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_16, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 71, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_16);
     __Pyx_GIVEREF(__pyx_int_16);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_int_16);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 65, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U16, __pyx_t_1) < 0) __PYX_ERR(0, 65, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U16, __pyx_t_1) < 0) __PYX_ERR(0, 71, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":66
+  /* "pyjls/binding.pyx":72
  *     U8 = _data_type_def(_DataTypeBase.UINT, 8, 0)
  *     U16 = _data_type_def(_DataTypeBase.UINT, 16, 0)
  *     U32 = _data_type_def(_DataTypeBase.UINT, 32, 0)             # <<<<<<<<<<<<<<
  *     U64 = _data_type_def(_DataTypeBase.UINT, 64, 0)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 72, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 72, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 66, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 72, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -31656,64 +31978,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_32, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 66, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_32, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 66, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 66, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_32);
     __Pyx_GIVEREF(__pyx_int_32);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_32);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 66, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U32, __pyx_t_1) < 0) __PYX_ERR(0, 66, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U32, __pyx_t_1) < 0) __PYX_ERR(0, 72, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":67
+  /* "pyjls/binding.pyx":73
  *     U16 = _data_type_def(_DataTypeBase.UINT, 16, 0)
  *     U32 = _data_type_def(_DataTypeBase.UINT, 32, 0)
  *     U64 = _data_type_def(_DataTypeBase.UINT, 64, 0)             # <<<<<<<<<<<<<<
  * 
  *     I4 = _data_type_def(_DataTypeBase.INT, 4, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 67, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 73, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 67, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 73, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 67, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_UINT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 73, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_7)) {
@@ -31723,64 +32045,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_64, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_64, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 67, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_64);
     __Pyx_GIVEREF(__pyx_int_64);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_int_64);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U64, __pyx_t_1) < 0) __PYX_ERR(0, 67, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_U64, __pyx_t_1) < 0) __PYX_ERR(0, 73, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":69
+  /* "pyjls/binding.pyx":75
  *     U64 = _data_type_def(_DataTypeBase.UINT, 64, 0)
  * 
  *     I4 = _data_type_def(_DataTypeBase.INT, 4, 0)             # <<<<<<<<<<<<<<
  *     I8 = _data_type_def(_DataTypeBase.INT, 8, 0)
  *     I16 = _data_type_def(_DataTypeBase.INT, 16, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 69, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 69, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 69, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -31790,64 +32112,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_4, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_4, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_4);
     __Pyx_GIVEREF(__pyx_int_4);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_4);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 69, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I4, __pyx_t_1) < 0) __PYX_ERR(0, 69, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I4, __pyx_t_1) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":70
+  /* "pyjls/binding.pyx":76
  * 
  *     I4 = _data_type_def(_DataTypeBase.INT, 4, 0)
  *     I8 = _data_type_def(_DataTypeBase.INT, 8, 0)             # <<<<<<<<<<<<<<
  *     I16 = _data_type_def(_DataTypeBase.INT, 16, 0)
  *     I32 = _data_type_def(_DataTypeBase.INT, 32, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 70, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 76, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 70, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 76, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 70, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 76, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_7)) {
@@ -31857,64 +32179,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_8, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_8, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 76, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_8);
     __Pyx_GIVEREF(__pyx_int_8);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_int_8);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 70, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I8, __pyx_t_1) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I8, __pyx_t_1) < 0) __PYX_ERR(0, 76, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":71
+  /* "pyjls/binding.pyx":77
  *     I4 = _data_type_def(_DataTypeBase.INT, 4, 0)
  *     I8 = _data_type_def(_DataTypeBase.INT, 8, 0)
  *     I16 = _data_type_def(_DataTypeBase.INT, 16, 0)             # <<<<<<<<<<<<<<
  *     I32 = _data_type_def(_DataTypeBase.INT, 32, 0)
  *     I64 = _data_type_def(_DataTypeBase.INT, 64, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 71, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 71, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 71, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -31924,64 +32246,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_16, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_16, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 71, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 77, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_16);
     __Pyx_GIVEREF(__pyx_int_16);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_16);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 71, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 77, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I16, __pyx_t_1) < 0) __PYX_ERR(0, 71, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I16, __pyx_t_1) < 0) __PYX_ERR(0, 77, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":72
+  /* "pyjls/binding.pyx":78
  *     I8 = _data_type_def(_DataTypeBase.INT, 8, 0)
  *     I16 = _data_type_def(_DataTypeBase.INT, 16, 0)
  *     I32 = _data_type_def(_DataTypeBase.INT, 32, 0)             # <<<<<<<<<<<<<<
  *     I64 = _data_type_def(_DataTypeBase.INT, 64, 0)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 72, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 78, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 72, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 78, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 72, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 78, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_7)) {
@@ -31991,64 +32313,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_32, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 78, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_32, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 78, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 72, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 78, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_32);
     __Pyx_GIVEREF(__pyx_int_32);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_int_32);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 72, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 78, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I32, __pyx_t_1) < 0) __PYX_ERR(0, 72, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I32, __pyx_t_1) < 0) __PYX_ERR(0, 78, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":73
+  /* "pyjls/binding.pyx":79
  *     I16 = _data_type_def(_DataTypeBase.INT, 16, 0)
  *     I32 = _data_type_def(_DataTypeBase.INT, 32, 0)
  *     I64 = _data_type_def(_DataTypeBase.INT, 64, 0)             # <<<<<<<<<<<<<<
  * 
  *     F32 = _data_type_def(_DataTypeBase.FLOAT, 32, 0)
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 73, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 73, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 73, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_INT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -32058,64 +32380,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_64, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_64, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 73, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 79, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_64);
     __Pyx_GIVEREF(__pyx_int_64);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_64);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 73, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 79, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I64, __pyx_t_1) < 0) __PYX_ERR(0, 73, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_I64, __pyx_t_1) < 0) __PYX_ERR(0, 79, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":75
+  /* "pyjls/binding.pyx":81
  *     I64 = _data_type_def(_DataTypeBase.INT, 64, 0)
  * 
  *     F32 = _data_type_def(_DataTypeBase.FLOAT, 32, 0)             # <<<<<<<<<<<<<<
  *     F64 = _data_type_def(_DataTypeBase.FLOAT, 64, 0)
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 81, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 81, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_FLOAT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 75, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_FLOAT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 81, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __pyx_t_7 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_7)) {
@@ -32125,64 +32447,64 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_32, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_5, __pyx_int_32, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 75, __pyx_L1_error)
+    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_4);
     if (__pyx_t_7) {
       __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_7); __pyx_t_7 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_32);
     __Pyx_GIVEREF(__pyx_int_32);
     PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_int_32);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 75, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_F32, __pyx_t_1) < 0) __PYX_ERR(0, 75, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_F32, __pyx_t_1) < 0) __PYX_ERR(0, 81, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":76
+  /* "pyjls/binding.pyx":82
  * 
  *     F32 = _data_type_def(_DataTypeBase.FLOAT, 32, 0)
  *     F64 = _data_type_def(_DataTypeBase.FLOAT, 64, 0)             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_data_type_def); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 82, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_DataTypeBase); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 82, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_4);
-  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_FLOAT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 76, __pyx_L1_error)
+  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_FLOAT); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 82, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_5);
   __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
   __pyx_t_4 = NULL;
   __pyx_t_6 = 0;
   if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
     __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
     if (likely(__pyx_t_4)) {
@@ -32192,1206 +32514,1206 @@
       __Pyx_DECREF_SET(__pyx_t_2, function);
       __pyx_t_6 = 1;
     }
   }
   #if CYTHON_FAST_PYCALL
   if (PyFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_64, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   #if CYTHON_FAST_PYCCALL
   if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
     PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_t_5, __pyx_int_64, __pyx_int_0};
-    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
     __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
   } else
   #endif
   {
-    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 76, __pyx_L1_error)
+    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 82, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_7);
     if (__pyx_t_4) {
       __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
     }
     __Pyx_GIVEREF(__pyx_t_5);
     PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_t_5);
     __Pyx_INCREF(__pyx_int_64);
     __Pyx_GIVEREF(__pyx_int_64);
     PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_int_64);
     __Pyx_INCREF(__pyx_int_0);
     __Pyx_GIVEREF(__pyx_int_0);
     PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_int_0);
     __pyx_t_5 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 76, __pyx_L1_error)
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   }
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_F64, __pyx_t_1) < 0) __PYX_ERR(0, 76, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_3, __pyx_n_s_F64, __pyx_t_1) < 0) __PYX_ERR(0, 82, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "pyjls/binding.pyx":61
  * 
  * 
  * class DataType:             # <<<<<<<<<<<<<<
- *     U1 = _data_type_def(_DataTypeBase.UINT, 1, 0)
- *     U4 = _data_type_def(_DataTypeBase.UINT, 4, 0)
+ *     """The signal data type enumeration.
+ * 
  */
   __pyx_t_1 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_DataType, __pyx_empty_tuple, __pyx_t_3, NULL, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 61, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_DataType, __pyx_t_1) < 0) __PYX_ERR(0, 61, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":80
+  /* "pyjls/binding.pyx":86
  * 
  * _data_type_map = {
  *     DataType.U1: np.uint8,      # packed             # <<<<<<<<<<<<<<
  *     DataType.U4: np.uint8,      # packed
  *     DataType.U8: np.uint8,
  */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_U1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_U1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 80, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":81
+  /* "pyjls/binding.pyx":87
  * _data_type_map = {
  *     DataType.U1: np.uint8,      # packed
  *     DataType.U4: np.uint8,      # packed             # <<<<<<<<<<<<<<
  *     DataType.U8: np.uint8,
  *     DataType.U16: np.uint16,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 87, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 87, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_uint8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 81, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_uint8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":82
+  /* "pyjls/binding.pyx":88
  *     DataType.U1: np.uint8,      # packed
  *     DataType.U4: np.uint8,      # packed
  *     DataType.U8: np.uint8,             # <<<<<<<<<<<<<<
  *     DataType.U16: np.uint16,
  *     DataType.U32: np.uint32,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_U8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 82, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_U8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 82, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 88, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":83
+  /* "pyjls/binding.pyx":89
  *     DataType.U4: np.uint8,      # packed
  *     DataType.U8: np.uint8,
  *     DataType.U16: np.uint16,             # <<<<<<<<<<<<<<
  *     DataType.U32: np.uint32,
  *     DataType.U64: np.uint64,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 89, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 89, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_uint16); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 83, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_uint16); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":84
+  /* "pyjls/binding.pyx":90
  *     DataType.U8: np.uint8,
  *     DataType.U16: np.uint16,
  *     DataType.U32: np.uint32,             # <<<<<<<<<<<<<<
  *     DataType.U64: np.uint64,
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_U32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 84, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_U32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 84, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint32); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 84, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint32); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 90, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":85
+  /* "pyjls/binding.pyx":91
  *     DataType.U16: np.uint16,
  *     DataType.U32: np.uint32,
  *     DataType.U64: np.uint64,             # <<<<<<<<<<<<<<
  * 
  *     DataType.I4: np.uint8,      # packed
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 85, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 85, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 85, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_uint64); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 85, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_uint64); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":87
+  /* "pyjls/binding.pyx":93
  *     DataType.U64: np.uint64,
  * 
  *     DataType.I4: np.uint8,      # packed             # <<<<<<<<<<<<<<
  *     DataType.I8: np.int8,
  *     DataType.I16: np.int16,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_I4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_I4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 87, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_uint8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 93, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":88
+  /* "pyjls/binding.pyx":94
  * 
  *     DataType.I4: np.uint8,      # packed
  *     DataType.I8: np.int8,             # <<<<<<<<<<<<<<
  *     DataType.I16: np.int16,
  *     DataType.I32: np.int32,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_int8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 88, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_int8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":89
+  /* "pyjls/binding.pyx":95
  *     DataType.I4: np.uint8,      # packed
  *     DataType.I8: np.int8,
  *     DataType.I16: np.int16,             # <<<<<<<<<<<<<<
  *     DataType.I32: np.int32,
  *     DataType.I64: np.int64,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_I16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_I16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_int16); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 89, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_int16); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 95, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":90
+  /* "pyjls/binding.pyx":96
  *     DataType.I8: np.int8,
  *     DataType.I16: np.int16,
  *     DataType.I32: np.int32,             # <<<<<<<<<<<<<<
  *     DataType.I64: np.int64,
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_int32); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 90, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_int32); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 96, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":91
+  /* "pyjls/binding.pyx":97
  *     DataType.I16: np.int16,
  *     DataType.I32: np.int32,
  *     DataType.I64: np.int64,             # <<<<<<<<<<<<<<
  * 
  *     DataType.F32: np.float32,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 97, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_I64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_I64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 97, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 97, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_int64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 91, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_int64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 97, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":93
+  /* "pyjls/binding.pyx":99
  *     DataType.I64: np.int64,
  * 
  *     DataType.F32: np.float32,             # <<<<<<<<<<<<<<
  *     DataType.F64: np.float64,
  * }
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 93, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_F32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 93, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_F32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 93, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_float32); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 93, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_float32); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_1) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
-  /* "pyjls/binding.pyx":94
+  /* "pyjls/binding.pyx":100
  * 
  *     DataType.F32: np.float32,
  *     DataType.F64: np.float64,             # <<<<<<<<<<<<<<
  * }
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_DataType); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 100, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_F64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 94, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_F64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 94, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 100, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 94, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 100, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 80, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_t_2, __pyx_t_7) < 0) __PYX_ERR(0, 86, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_map, __pyx_t_3) < 0) __PYX_ERR(0, 79, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_map, __pyx_t_3) < 0) __PYX_ERR(0, 85, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":99
+  /* "pyjls/binding.pyx":105
  * 
  * _data_type_as_enum = {
  *     'u1': DataType.U1,             # <<<<<<<<<<<<<<
  *     'u4': DataType.U4,
  *     'u8': DataType.U8,
  */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 99, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u1, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u1, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":100
+  /* "pyjls/binding.pyx":106
  * _data_type_as_enum = {
  *     'u1': DataType.U1,
  *     'u4': DataType.U4,             # <<<<<<<<<<<<<<
  *     'u8': DataType.U8,
  *     'u16': DataType.U16,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 106, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_U4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 100, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_U4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 106, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u4, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u4, __pyx_t_7) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":101
+  /* "pyjls/binding.pyx":107
  *     'u1': DataType.U1,
  *     'u4': DataType.U4,
  *     'u8': DataType.U8,             # <<<<<<<<<<<<<<
  *     'u16': DataType.U16,
  *     'u32': DataType.U32,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 101, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 107, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u8, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u8, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":102
+  /* "pyjls/binding.pyx":108
  *     'u4': DataType.U4,
  *     'u8': DataType.U8,
  *     'u16': DataType.U16,             # <<<<<<<<<<<<<<
  *     'u32': DataType.U32,
  *     'u64': DataType.U64,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_U16); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 102, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_U16); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 108, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u16, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u16, __pyx_t_7) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":103
+  /* "pyjls/binding.pyx":109
  *     'u8': DataType.U8,
  *     'u16': DataType.U16,
  *     'u32': DataType.U32,             # <<<<<<<<<<<<<<
  *     'u64': DataType.U64,
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 103, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_U32); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 109, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u32, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u32, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":104
+  /* "pyjls/binding.pyx":110
  *     'u16': DataType.U16,
  *     'u32': DataType.U32,
  *     'u64': DataType.U64,             # <<<<<<<<<<<<<<
  * 
  *     'i4': DataType.I4,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 110, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_U64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 104, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_U64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 110, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u64, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_u64, __pyx_t_7) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":106
+  /* "pyjls/binding.pyx":112
  *     'u64': DataType.U64,
  * 
  *     'i4': DataType.I4,             # <<<<<<<<<<<<<<
  *     'i8': DataType.I8,
  *     'i16': DataType.I16,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 106, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 112, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 106, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 112, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i4, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i4, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":107
+  /* "pyjls/binding.pyx":113
  * 
  *     'i4': DataType.I4,
  *     'i8': DataType.I8,             # <<<<<<<<<<<<<<
  *     'i16': DataType.I16,
  *     'i32': DataType.I32,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 107, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 113, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_I8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 107, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_I8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 113, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i8, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i8, __pyx_t_7) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":108
+  /* "pyjls/binding.pyx":114
  *     'i4': DataType.I4,
  *     'i8': DataType.I8,
  *     'i16': DataType.I16,             # <<<<<<<<<<<<<<
  *     'i32': DataType.I32,
  *     'i64': DataType.I64,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 108, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 114, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i16, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i16, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":109
+  /* "pyjls/binding.pyx":115
  *     'i8': DataType.I8,
  *     'i16': DataType.I16,
  *     'i32': DataType.I32,             # <<<<<<<<<<<<<<
  *     'i64': DataType.I64,
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 109, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 115, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_I32); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 109, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_I32); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 115, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i32, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i32, __pyx_t_7) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":110
+  /* "pyjls/binding.pyx":116
  *     'i16': DataType.I16,
  *     'i32': DataType.I32,
  *     'i64': DataType.I64,             # <<<<<<<<<<<<<<
  * 
  *     'f32': DataType.F32,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 110, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 116, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 110, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_I64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 116, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i64, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_i64, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":112
+  /* "pyjls/binding.pyx":118
  *     'i64': DataType.I64,
  * 
  *     'f32': DataType.F32,             # <<<<<<<<<<<<<<
  *     'f64': DataType.F64,
  * }
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 112, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_DataType); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_F32); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 112, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_F32); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 118, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_f32, __pyx_t_7) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_f32, __pyx_t_7) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":113
+  /* "pyjls/binding.pyx":119
  * 
  *     'f32': DataType.F32,
  *     'f64': DataType.F64,             # <<<<<<<<<<<<<<
  * }
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 113, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_DataType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 119, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_F64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 113, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_F64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 119, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_f64, __pyx_t_2) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_3, __pyx_n_u_f64, __pyx_t_2) < 0) __PYX_ERR(0, 105, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_enum, __pyx_t_3) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_enum, __pyx_t_3) < 0) __PYX_ERR(0, 104, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":117
+  /* "pyjls/binding.pyx":123
  * 
  * 
  * _data_type_as_str = {}             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_3 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 117, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 123, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_str, __pyx_t_3) < 0) __PYX_ERR(0, 117, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_str, __pyx_t_3) < 0) __PYX_ERR(0, 123, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":120
+  /* "pyjls/binding.pyx":126
  * 
  * 
  * def _populate_data_type():             # <<<<<<<<<<<<<<
  *     for key, value in list(_data_type_as_enum.items()):
  *         _data_type_as_enum[value] = value
  */
-  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_3_populate_data_type, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 120, __pyx_L1_error)
+  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_3_populate_data_type, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 126, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_populate_data_type, __pyx_t_3) < 0) __PYX_ERR(0, 120, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_populate_data_type, __pyx_t_3) < 0) __PYX_ERR(0, 126, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":127
+  /* "pyjls/binding.pyx":133
  * 
  * 
  * _populate_data_type()             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_populate_data_type); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_populate_data_type); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 133, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 127, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 133, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":130
+  /* "pyjls/binding.pyx":136
  * 
  * 
  * def data_type_as_enum(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_enum[data_type]
  * 
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_5data_type_as_enum, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 130, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_5data_type_as_enum, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 136, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_enum_2, __pyx_t_2) < 0) __PYX_ERR(0, 130, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_enum_2, __pyx_t_2) < 0) __PYX_ERR(0, 136, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":134
+  /* "pyjls/binding.pyx":140
  * 
  * 
  * def data_type_as_str(data_type):             # <<<<<<<<<<<<<<
  *     return _data_type_as_str[data_type]
  * 
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_7data_type_as_str, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 134, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_7data_type_as_str, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_str_2, __pyx_t_2) < 0) __PYX_ERR(0, 134, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_data_type_as_str_2, __pyx_t_2) < 0) __PYX_ERR(0, 140, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":138
+  /* "pyjls/binding.pyx":144
  * 
  * 
  * class AnnotationType:             # <<<<<<<<<<<<<<
+ *     """The annotation type enumeration."""
  *     USER = c_jls.JLS_ANNOTATION_TYPE_USER
- *     TEXT = c_jls.JLS_ANNOTATION_TYPE_TEXT
  */
-  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_AnnotationType, __pyx_n_s_AnnotationType, (PyObject *) NULL, __pyx_n_s_pyjls_binding, (PyObject *) NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 138, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_AnnotationType, __pyx_n_s_AnnotationType, (PyObject *) NULL, __pyx_n_s_pyjls_binding, __pyx_kp_s_The_annotation_type_enumeration); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 144, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "pyjls/binding.pyx":139
- * 
+  /* "pyjls/binding.pyx":146
  * class AnnotationType:
+ *     """The annotation type enumeration."""
  *     USER = c_jls.JLS_ANNOTATION_TYPE_USER             # <<<<<<<<<<<<<<
  *     TEXT = c_jls.JLS_ANNOTATION_TYPE_TEXT
  *     VMARKER = c_jls.JLS_ANNOTATION_TYPE_VERTICAL_MARKER
  */
-  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_USER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 139, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_USER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 146, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_USER, __pyx_t_3) < 0) __PYX_ERR(0, 139, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_USER, __pyx_t_3) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":140
- * class AnnotationType:
+  /* "pyjls/binding.pyx":147
+ *     """The annotation type enumeration."""
  *     USER = c_jls.JLS_ANNOTATION_TYPE_USER
  *     TEXT = c_jls.JLS_ANNOTATION_TYPE_TEXT             # <<<<<<<<<<<<<<
  *     VMARKER = c_jls.JLS_ANNOTATION_TYPE_VERTICAL_MARKER
  *     HMARKER = c_jls.JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER
  */
-  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_TEXT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 140, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_TEXT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_TEXT, __pyx_t_3) < 0) __PYX_ERR(0, 140, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_TEXT, __pyx_t_3) < 0) __PYX_ERR(0, 147, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":141
+  /* "pyjls/binding.pyx":148
  *     USER = c_jls.JLS_ANNOTATION_TYPE_USER
  *     TEXT = c_jls.JLS_ANNOTATION_TYPE_TEXT
  *     VMARKER = c_jls.JLS_ANNOTATION_TYPE_VERTICAL_MARKER             # <<<<<<<<<<<<<<
  *     HMARKER = c_jls.JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER
  * 
  */
-  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_VERTICAL_MARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 141, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_VERTICAL_MARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 148, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_VMARKER, __pyx_t_3) < 0) __PYX_ERR(0, 141, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_VMARKER, __pyx_t_3) < 0) __PYX_ERR(0, 148, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":142
+  /* "pyjls/binding.pyx":149
  *     TEXT = c_jls.JLS_ANNOTATION_TYPE_TEXT
  *     VMARKER = c_jls.JLS_ANNOTATION_TYPE_VERTICAL_MARKER
  *     HMARKER = c_jls.JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 142, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyInt_From_enum__jls_annotation_type_e(JLS_ANNOTATION_TYPE_HORIZONTAL_MARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 149, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_HMARKER, __pyx_t_3) < 0) __PYX_ERR(0, 142, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_HMARKER, __pyx_t_3) < 0) __PYX_ERR(0, 149, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":138
+  /* "pyjls/binding.pyx":144
  * 
  * 
  * class AnnotationType:             # <<<<<<<<<<<<<<
+ *     """The annotation type enumeration."""
  *     USER = c_jls.JLS_ANNOTATION_TYPE_USER
- *     TEXT = c_jls.JLS_ANNOTATION_TYPE_TEXT
  */
-  __pyx_t_3 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_AnnotationType, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 138, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_AnnotationType, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 144, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_AnnotationType, __pyx_t_3) < 0) __PYX_ERR(0, 138, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_AnnotationType, __pyx_t_3) < 0) __PYX_ERR(0, 144, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":146
+  /* "pyjls/binding.pyx":153
  * 
  * _annotation_map = {
  *     'user': AnnotationType.USER,             # <<<<<<<<<<<<<<
  *     'usr': AnnotationType.USER,
  *     'text': AnnotationType.TEXT,
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_USER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 146, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_USER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_user, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_user, __pyx_t_7) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":147
+  /* "pyjls/binding.pyx":154
  * _annotation_map = {
  *     'user': AnnotationType.USER,
  *     'usr': AnnotationType.USER,             # <<<<<<<<<<<<<<
  *     'text': AnnotationType.TEXT,
  *     'txt': AnnotationType.TEXT,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_USER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 147, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_USER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 154, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_usr, __pyx_t_3) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_usr, __pyx_t_3) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":148
+  /* "pyjls/binding.pyx":155
  *     'user': AnnotationType.USER,
  *     'usr': AnnotationType.USER,
  *     'text': AnnotationType.TEXT,             # <<<<<<<<<<<<<<
  *     'txt': AnnotationType.TEXT,
  *     'str': AnnotationType.TEXT,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 148, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 155, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 148, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_text, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_text, __pyx_t_7) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":149
+  /* "pyjls/binding.pyx":156
  *     'usr': AnnotationType.USER,
  *     'text': AnnotationType.TEXT,
  *     'txt': AnnotationType.TEXT,             # <<<<<<<<<<<<<<
  *     'str': AnnotationType.TEXT,
  *     'string': AnnotationType.TEXT,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 149, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 156, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_txt, __pyx_t_3) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_txt, __pyx_t_3) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":150
+  /* "pyjls/binding.pyx":157
  *     'text': AnnotationType.TEXT,
  *     'txt': AnnotationType.TEXT,
  *     'str': AnnotationType.TEXT,             # <<<<<<<<<<<<<<
  *     'string': AnnotationType.TEXT,
  *     'marker': AnnotationType.VMARKER,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 150, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 157, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 150, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 157, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_str, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_str, __pyx_t_7) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":151
+  /* "pyjls/binding.pyx":158
  *     'txt': AnnotationType.TEXT,
  *     'str': AnnotationType.TEXT,
  *     'string': AnnotationType.TEXT,             # <<<<<<<<<<<<<<
  *     'marker': AnnotationType.VMARKER,
  *     'vertical_marker': AnnotationType.VMARKER,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 151, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 158, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 151, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_TEXT); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 158, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_string, __pyx_t_3) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_string, __pyx_t_3) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":152
+  /* "pyjls/binding.pyx":159
  *     'str': AnnotationType.TEXT,
  *     'string': AnnotationType.TEXT,
  *     'marker': AnnotationType.VMARKER,             # <<<<<<<<<<<<<<
  *     'vertical_marker': AnnotationType.VMARKER,
  *     'vmarker': AnnotationType.VMARKER,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_VMARKER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 152, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_VMARKER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 159, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_marker, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_marker, __pyx_t_7) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":153
+  /* "pyjls/binding.pyx":160
  *     'string': AnnotationType.TEXT,
  *     'marker': AnnotationType.VMARKER,
  *     'vertical_marker': AnnotationType.VMARKER,             # <<<<<<<<<<<<<<
  *     'vmarker': AnnotationType.VMARKER,
  *     'horizontal_marker': AnnotationType.HMARKER,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 153, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 160, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_VMARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 153, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_VMARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_vertical_marker, __pyx_t_3) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_vertical_marker, __pyx_t_3) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":154
+  /* "pyjls/binding.pyx":161
  *     'marker': AnnotationType.VMARKER,
  *     'vertical_marker': AnnotationType.VMARKER,
  *     'vmarker': AnnotationType.VMARKER,             # <<<<<<<<<<<<<<
  *     'horizontal_marker': AnnotationType.HMARKER,
  *     'hmarker': AnnotationType.HMARKER,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 154, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_VMARKER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 154, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_VMARKER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 161, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_vmarker, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_vmarker, __pyx_t_7) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":155
+  /* "pyjls/binding.pyx":162
  *     'vertical_marker': AnnotationType.VMARKER,
  *     'vmarker': AnnotationType.VMARKER,
  *     'horizontal_marker': AnnotationType.HMARKER,             # <<<<<<<<<<<<<<
  *     'hmarker': AnnotationType.HMARKER,
  * }
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_HMARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 155, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_HMARKER); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_horizontal_marker, __pyx_t_3) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_horizontal_marker, __pyx_t_3) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":156
+  /* "pyjls/binding.pyx":163
  *     'vmarker': AnnotationType.VMARKER,
  *     'horizontal_marker': AnnotationType.HMARKER,
  *     'hmarker': AnnotationType.HMARKER,             # <<<<<<<<<<<<<<
  * }
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_AnnotationType); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 163, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_HMARKER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 156, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_HMARKER); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 163, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_hmarker, __pyx_t_7) < 0) __PYX_ERR(0, 146, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_hmarker, __pyx_t_7) < 0) __PYX_ERR(0, 153, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_annotation_map, __pyx_t_2) < 0) __PYX_ERR(0, 145, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_annotation_map, __pyx_t_2) < 0) __PYX_ERR(0, 152, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":160
+  /* "pyjls/binding.pyx":167
  * 
  * _log_level_map = {
  *     '!': logging.CRITICAL,             # <<<<<<<<<<<<<<
  *     'A': logging.CRITICAL,
  *     'C': logging.CRITICAL,
  */
-  __pyx_t_2 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 160, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_PyDict_NewPresized(10); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 160, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_CRITICAL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 160, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_CRITICAL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u__43, __pyx_t_3) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_kp_u__43, __pyx_t_3) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":161
+  /* "pyjls/binding.pyx":168
  * _log_level_map = {
  *     '!': logging.CRITICAL,
  *     'A': logging.CRITICAL,             # <<<<<<<<<<<<<<
  *     'C': logging.CRITICAL,
  *     'E': logging.ERROR,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 161, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_CRITICAL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 161, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_CRITICAL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_A, __pyx_t_7) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_A, __pyx_t_7) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":162
+  /* "pyjls/binding.pyx":169
  *     '!': logging.CRITICAL,
  *     'A': logging.CRITICAL,
  *     'C': logging.CRITICAL,             # <<<<<<<<<<<<<<
  *     'E': logging.ERROR,
  *     'W': logging.WARNING,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 169, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_CRITICAL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 162, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_CRITICAL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 169, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_C, __pyx_t_3) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_C, __pyx_t_3) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":163
+  /* "pyjls/binding.pyx":170
  *     'A': logging.CRITICAL,
  *     'C': logging.CRITICAL,
  *     'E': logging.ERROR,             # <<<<<<<<<<<<<<
  *     'W': logging.WARNING,
  *     'N': logging.INFO,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 163, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 170, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ERROR); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 163, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ERROR); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 170, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_E, __pyx_t_7) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_E, __pyx_t_7) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":164
+  /* "pyjls/binding.pyx":171
  *     'C': logging.CRITICAL,
  *     'E': logging.ERROR,
  *     'W': logging.WARNING,             # <<<<<<<<<<<<<<
  *     'N': logging.INFO,
  *     'I': logging.INFO,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 171, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_WARNING); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 164, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_WARNING); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 171, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_W, __pyx_t_3) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_W, __pyx_t_3) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":165
+  /* "pyjls/binding.pyx":172
  *     'E': logging.ERROR,
  *     'W': logging.WARNING,
  *     'N': logging.INFO,             # <<<<<<<<<<<<<<
  *     'I': logging.INFO,
  *     'D': logging.DEBUG,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 165, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 172, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_INFO); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 165, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_INFO); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 172, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_N, __pyx_t_7) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_N, __pyx_t_7) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":166
+  /* "pyjls/binding.pyx":173
  *     'W': logging.WARNING,
  *     'N': logging.INFO,
  *     'I': logging.INFO,             # <<<<<<<<<<<<<<
  *     'D': logging.DEBUG,
  *     'D': logging.DEBUG,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 166, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_INFO); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 166, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_INFO); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 173, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_I, __pyx_t_3) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_I, __pyx_t_3) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":167
+  /* "pyjls/binding.pyx":174
  *     'N': logging.INFO,
  *     'I': logging.INFO,
  *     'D': logging.DEBUG,             # <<<<<<<<<<<<<<
  *     'D': logging.DEBUG,
  *     'D': logging.DEBUG,
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 174, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 167, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 174, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_D, __pyx_t_7) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_D, __pyx_t_7) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":168
+  /* "pyjls/binding.pyx":175
  *     'I': logging.INFO,
  *     'D': logging.DEBUG,
  *     'D': logging.DEBUG,             # <<<<<<<<<<<<<<
  *     'D': logging.DEBUG,
  * }
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_logging); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 175, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 168, __pyx_L1_error)
+  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 175, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_D, __pyx_t_3) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_D, __pyx_t_3) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
 
-  /* "pyjls/binding.pyx":169
+  /* "pyjls/binding.pyx":176
  *     'D': logging.DEBUG,
  *     'D': logging.DEBUG,
  *     'D': logging.DEBUG,             # <<<<<<<<<<<<<<
  * }
  * 
  */
-  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 169, __pyx_L1_error)
+  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_logging); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_3);
-  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 169, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DEBUG); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 176, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
   __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
-  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_D, __pyx_t_7) < 0) __PYX_ERR(0, 160, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_t_2, __pyx_n_u_D, __pyx_t_7) < 0) __PYX_ERR(0, 167, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_log_level_map, __pyx_t_2) < 0) __PYX_ERR(0, 159, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_log_level_map, __pyx_t_2) < 0) __PYX_ERR(0, 166, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":173
+  /* "pyjls/binding.pyx":180
  * 
  * 
  * class SignalType:             # <<<<<<<<<<<<<<
+ *     """The signal type enumeration."""
  *     FSR = c_jls.JLS_SIGNAL_TYPE_FSR
- *     VSR = c_jls.JLS_SIGNAL_TYPE_VSR
  */
-  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_SignalType, __pyx_n_s_SignalType, (PyObject *) NULL, __pyx_n_s_pyjls_binding, (PyObject *) NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_SignalType, __pyx_n_s_SignalType, (PyObject *) NULL, __pyx_n_s_pyjls_binding, __pyx_kp_s_The_signal_type_enumeration); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 180, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "pyjls/binding.pyx":174
- * 
+  /* "pyjls/binding.pyx":182
  * class SignalType:
+ *     """The signal type enumeration."""
  *     FSR = c_jls.JLS_SIGNAL_TYPE_FSR             # <<<<<<<<<<<<<<
  *     VSR = c_jls.JLS_SIGNAL_TYPE_VSR
  * 
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_FSR); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 174, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_FSR); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 182, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_FSR, __pyx_t_7) < 0) __PYX_ERR(0, 174, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_FSR, __pyx_t_7) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":175
- * class SignalType:
+  /* "pyjls/binding.pyx":183
+ *     """The signal type enumeration."""
  *     FSR = c_jls.JLS_SIGNAL_TYPE_FSR
  *     VSR = c_jls.JLS_SIGNAL_TYPE_VSR             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_VSR); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 175, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_signal_type_e(JLS_SIGNAL_TYPE_VSR); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 183, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_VSR, __pyx_t_7) < 0) __PYX_ERR(0, 175, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_VSR, __pyx_t_7) < 0) __PYX_ERR(0, 183, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":173
+  /* "pyjls/binding.pyx":180
  * 
  * 
  * class SignalType:             # <<<<<<<<<<<<<<
+ *     """The signal type enumeration."""
  *     FSR = c_jls.JLS_SIGNAL_TYPE_FSR
- *     VSR = c_jls.JLS_SIGNAL_TYPE_VSR
  */
-  __pyx_t_7 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_SignalType, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 173, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_SignalType, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 180, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SignalType, __pyx_t_7) < 0) __PYX_ERR(0, 173, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SignalType, __pyx_t_7) < 0) __PYX_ERR(0, 180, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":178
+  /* "pyjls/binding.pyx":186
  * 
  * 
  * class SummaryFSR:             # <<<<<<<<<<<<<<
+ *     """The FSR column enumeration."""
  *     MEAN = c_jls.JLS_SUMMARY_FSR_MEAN
- *     STD = c_jls.JLS_SUMMARY_FSR_STD
  */
-  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_SummaryFSR, __pyx_n_s_SummaryFSR, (PyObject *) NULL, __pyx_n_s_pyjls_binding, (PyObject *) NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 178, __pyx_L1_error)
+  __pyx_t_2 = __Pyx_Py3MetaclassPrepare((PyObject *) NULL, __pyx_empty_tuple, __pyx_n_s_SummaryFSR, __pyx_n_s_SummaryFSR, (PyObject *) NULL, __pyx_n_s_pyjls_binding, __pyx_kp_s_The_FSR_column_enumeration); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
 
-  /* "pyjls/binding.pyx":179
- * 
+  /* "pyjls/binding.pyx":188
  * class SummaryFSR:
+ *     """The FSR column enumeration."""
  *     MEAN = c_jls.JLS_SUMMARY_FSR_MEAN             # <<<<<<<<<<<<<<
  *     STD = c_jls.JLS_SUMMARY_FSR_STD
  *     MIN = c_jls.JLS_SUMMARY_FSR_MIN
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_MEAN); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 179, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_MEAN); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 188, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_MEAN, __pyx_t_7) < 0) __PYX_ERR(0, 179, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_MEAN, __pyx_t_7) < 0) __PYX_ERR(0, 188, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":180
- * class SummaryFSR:
+  /* "pyjls/binding.pyx":189
+ *     """The FSR column enumeration."""
  *     MEAN = c_jls.JLS_SUMMARY_FSR_MEAN
  *     STD = c_jls.JLS_SUMMARY_FSR_STD             # <<<<<<<<<<<<<<
  *     MIN = c_jls.JLS_SUMMARY_FSR_MIN
  *     MAX = c_jls.JLS_SUMMARY_FSR_MAX
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_STD); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 180, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_STD); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_STD, __pyx_t_7) < 0) __PYX_ERR(0, 180, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_STD, __pyx_t_7) < 0) __PYX_ERR(0, 189, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":181
+  /* "pyjls/binding.pyx":190
  *     MEAN = c_jls.JLS_SUMMARY_FSR_MEAN
  *     STD = c_jls.JLS_SUMMARY_FSR_STD
  *     MIN = c_jls.JLS_SUMMARY_FSR_MIN             # <<<<<<<<<<<<<<
  *     MAX = c_jls.JLS_SUMMARY_FSR_MAX
  *     COUNT = c_jls.JLS_SUMMARY_FSR_COUNT
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_MIN); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 181, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_MIN); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 190, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_MIN, __pyx_t_7) < 0) __PYX_ERR(0, 181, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_MIN, __pyx_t_7) < 0) __PYX_ERR(0, 190, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":182
+  /* "pyjls/binding.pyx":191
  *     STD = c_jls.JLS_SUMMARY_FSR_STD
  *     MIN = c_jls.JLS_SUMMARY_FSR_MIN
  *     MAX = c_jls.JLS_SUMMARY_FSR_MAX             # <<<<<<<<<<<<<<
  *     COUNT = c_jls.JLS_SUMMARY_FSR_COUNT
  * 
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_MAX); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 182, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_MAX); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 191, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_MAX, __pyx_t_7) < 0) __PYX_ERR(0, 182, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_MAX, __pyx_t_7) < 0) __PYX_ERR(0, 191, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":183
+  /* "pyjls/binding.pyx":192
  *     MIN = c_jls.JLS_SUMMARY_FSR_MIN
  *     MAX = c_jls.JLS_SUMMARY_FSR_MAX
  *     COUNT = c_jls.JLS_SUMMARY_FSR_COUNT             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_COUNT); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 183, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_PyInt_From_enum__jls_summary_fsr_e(JLS_SUMMARY_FSR_COUNT); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_COUNT, __pyx_t_7) < 0) __PYX_ERR(0, 183, __pyx_L1_error)
+  if (__Pyx_SetNameInClass(__pyx_t_2, __pyx_n_s_COUNT, __pyx_t_7) < 0) __PYX_ERR(0, 192, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
 
-  /* "pyjls/binding.pyx":178
+  /* "pyjls/binding.pyx":186
  * 
  * 
  * class SummaryFSR:             # <<<<<<<<<<<<<<
+ *     """The FSR column enumeration."""
  *     MEAN = c_jls.JLS_SUMMARY_FSR_MEAN
- *     STD = c_jls.JLS_SUMMARY_FSR_STD
  */
-  __pyx_t_7 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_SummaryFSR, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 178, __pyx_L1_error)
+  __pyx_t_7 = __Pyx_Py3ClassCreate(((PyObject*)&__Pyx_DefaultClassType), __pyx_n_s_SummaryFSR, __pyx_empty_tuple, __pyx_t_2, NULL, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_7);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SummaryFSR, __pyx_t_7) < 0) __PYX_ERR(0, 178, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_SummaryFSR, __pyx_t_7) < 0) __PYX_ERR(0, 186, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":196
+  /* "pyjls/binding.pyx":205
  * 
  * 
  * c_jls.jls_log_register(_log_cbk)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   jls_log_register(__pyx_f_5pyjls_7binding__log_cbk);
 
-  /* "pyjls/binding.pyx":199
+  /* "pyjls/binding.pyx":208
  * 
  * 
  * def jls_inject_log(level, filename, line, msg):             # <<<<<<<<<<<<<<
  *     cdef char * c_msg
  *     location = ':'.join([filename, str(line), ''])
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_9jls_inject_log, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 199, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_9jls_inject_log, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 208, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_jls_inject_log, __pyx_t_2) < 0) __PYX_ERR(0, 199, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_jls_inject_log, __pyx_t_2) < 0) __PYX_ERR(0, 208, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":207
+  /* "pyjls/binding.pyx":216
  * 
  * 
  * def _encode_str(s):             # <<<<<<<<<<<<<<
  *     if s is None:
  *         s = ''
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_11_encode_str, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 207, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_11_encode_str, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 216, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_str, __pyx_t_2) < 0) __PYX_ERR(0, 207, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_encode_str, __pyx_t_2) < 0) __PYX_ERR(0, 216, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":213
+  /* "pyjls/binding.pyx":222
  * 
  * 
  * def _storage_pack(data):             # <<<<<<<<<<<<<<
  *     if data is None:
  *         return c_jls.JLS_STORAGE_TYPE_BINARY, b'', 0
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_13_storage_pack, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 213, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_13_storage_pack, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 222, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_storage_pack, __pyx_t_2) < 0) __PYX_ERR(0, 213, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_storage_pack, __pyx_t_2) < 0) __PYX_ERR(0, 222, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":236
+  /* "pyjls/binding.pyx":245
  * 
  * 
  * def utc_to_jls(utc):             # <<<<<<<<<<<<<<
  *     """Convert from python UTC timestamp to jls timestamp."""
  *     return int((utc - _UTC_OFFSET) * SECOND)
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_15utc_to_jls, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 236, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_15utc_to_jls, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 245, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_utc_to_jls, __pyx_t_2) < 0) __PYX_ERR(0, 236, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_utc_to_jls, __pyx_t_2) < 0) __PYX_ERR(0, 245, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":241
+  /* "pyjls/binding.pyx":250
  * 
  * 
  * def jls_to_utc(timestamp):             # <<<<<<<<<<<<<<
- *     """Convert from jls timestamp to python UTC timestamp."""
- *     return (timestamp / SECOND) + _UTC_OFFSET
+ *     """Convert from jls timestamp to python UTC timestamp.
+ * 
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_17jls_to_utc, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 241, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_17jls_to_utc, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_jls_to_utc, __pyx_t_2) < 0) __PYX_ERR(0, 241, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_jls_to_utc, __pyx_t_2) < 0) __PYX_ERR(0, 250, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
-  /* "pyjls/binding.pyx":246
+  /* "pyjls/binding.pyx":263
  * 
  * 
  * def _handle_rc(name, rc):             # <<<<<<<<<<<<<<
  *     if rc == 0:
  *         return
  */
-  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_19_handle_rc, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 246, __pyx_L1_error)
+  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_5pyjls_7binding_19_handle_rc, NULL, __pyx_n_s_pyjls_binding); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 263, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_2);
-  if (PyDict_SetItem(__pyx_d, __pyx_n_s_handle_rc, __pyx_t_2) < 0) __PYX_ERR(0, 246, __pyx_L1_error)
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_handle_rc, __pyx_t_2) < 0) __PYX_ERR(0, 263, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_AnnotationCallback(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
@@ -35188,14 +35510,437 @@
     if (likely(tp->tp_setattr))
         return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
 #endif
     return PyObject_SetAttr(obj, attr_name, value);
 }
 #endif
 
+/* GetTopmostException */
+#if CYTHON_USE_EXC_INFO_STACK
+static _PyErr_StackItem *
+__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
+{
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
+           exc_info->previous_item != NULL)
+    {
+        exc_info = exc_info->previous_item;
+    }
+    return exc_info;
+}
+#endif
+
+/* SaveResetException */
+#if CYTHON_FAST_THREAD_STATE
+static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
+    *type = exc_info->exc_type;
+    *value = exc_info->exc_value;
+    *tb = exc_info->exc_traceback;
+    #else
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    #endif
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+}
+static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    #if CYTHON_USE_EXC_INFO_STACK
+    _PyErr_StackItem *exc_info = tstate->exc_info;
+    tmp_type = exc_info->exc_type;
+    tmp_value = exc_info->exc_value;
+    tmp_tb = exc_info->exc_traceback;
+    exc_info->exc_type = type;
+    exc_info->exc_value = value;
+    exc_info->exc_traceback = tb;
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+#endif
+
+/* GetException */
+#if CYTHON_FAST_THREAD_STATE
+static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
+#else
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
+#endif
+{
+    PyObject *local_type, *local_value, *local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    local_type = tstate->curexc_type;
+    local_value = tstate->curexc_value;
+    local_tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+#else
+    PyErr_Fetch(&local_type, &local_value, &local_tb);
+#endif
+    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
+#if CYTHON_FAST_THREAD_STATE
+    if (unlikely(tstate->curexc_type))
+#else
+    if (unlikely(PyErr_Occurred()))
+#endif
+        goto bad;
+    #if PY_MAJOR_VERSION >= 3
+    if (local_tb) {
+        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
+            goto bad;
+    }
+    #endif
+    Py_XINCREF(local_tb);
+    Py_XINCREF(local_type);
+    Py_XINCREF(local_value);
+    *type = local_type;
+    *value = local_value;
+    *tb = local_tb;
+#if CYTHON_FAST_THREAD_STATE
+    #if CYTHON_USE_EXC_INFO_STACK
+    {
+        _PyErr_StackItem *exc_info = tstate->exc_info;
+        tmp_type = exc_info->exc_type;
+        tmp_value = exc_info->exc_value;
+        tmp_tb = exc_info->exc_traceback;
+        exc_info->exc_type = local_type;
+        exc_info->exc_value = local_value;
+        exc_info->exc_traceback = local_tb;
+    }
+    #else
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = local_type;
+    tstate->exc_value = local_value;
+    tstate->exc_traceback = local_tb;
+    #endif
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+#else
+    PyErr_SetExcInfo(local_type, local_value, local_tb);
+#endif
+    return 0;
+bad:
+    *type = 0;
+    *value = 0;
+    *tb = 0;
+    Py_XDECREF(local_type);
+    Py_XDECREF(local_value);
+    Py_XDECREF(local_tb);
+    return -1;
+}
+
+/* PyObjectGetMethod */
+static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
+    PyObject *attr;
+#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
+    PyTypeObject *tp = Py_TYPE(obj);
+    PyObject *descr;
+    descrgetfunc f = NULL;
+    PyObject **dictptr, *dict;
+    int meth_found = 0;
+    assert (*method == NULL);
+    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
+        attr = __Pyx_PyObject_GetAttrStr(obj, name);
+        goto try_unpack;
+    }
+    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
+        return 0;
+    }
+    descr = _PyType_Lookup(tp, name);
+    if (likely(descr != NULL)) {
+        Py_INCREF(descr);
+#if PY_MAJOR_VERSION >= 3
+        #ifdef __Pyx_CyFunction_USED
+        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
+        #else
+        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type)))
+        #endif
+#else
+        #ifdef __Pyx_CyFunction_USED
+        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
+        #else
+        if (likely(PyFunction_Check(descr)))
+        #endif
+#endif
+        {
+            meth_found = 1;
+        } else {
+            f = Py_TYPE(descr)->tp_descr_get;
+            if (f != NULL && PyDescr_IsData(descr)) {
+                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
+                Py_DECREF(descr);
+                goto try_unpack;
+            }
+        }
+    }
+    dictptr = _PyObject_GetDictPtr(obj);
+    if (dictptr != NULL && (dict = *dictptr) != NULL) {
+        Py_INCREF(dict);
+        attr = __Pyx_PyDict_GetItemStr(dict, name);
+        if (attr != NULL) {
+            Py_INCREF(attr);
+            Py_DECREF(dict);
+            Py_XDECREF(descr);
+            goto try_unpack;
+        }
+        Py_DECREF(dict);
+    }
+    if (meth_found) {
+        *method = descr;
+        return 1;
+    }
+    if (f != NULL) {
+        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
+        Py_DECREF(descr);
+        goto try_unpack;
+    }
+    if (descr != NULL) {
+        *method = descr;
+        return 0;
+    }
+    PyErr_Format(PyExc_AttributeError,
+#if PY_MAJOR_VERSION >= 3
+                 "'%.50s' object has no attribute '%U'",
+                 tp->tp_name, name);
+#else
+                 "'%.50s' object has no attribute '%.400s'",
+                 tp->tp_name, PyString_AS_STRING(name));
+#endif
+    return 0;
+#else
+    attr = __Pyx_PyObject_GetAttrStr(obj, name);
+    goto try_unpack;
+#endif
+try_unpack:
+#if CYTHON_UNPACK_METHODS
+    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
+        PyObject *function = PyMethod_GET_FUNCTION(attr);
+        Py_INCREF(function);
+        Py_DECREF(attr);
+        *method = function;
+        return 1;
+    }
+#endif
+    *method = attr;
+    return 0;
+}
+
+/* PyObjectCallMethod0 */
+static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
+    PyObject *method = NULL, *result = NULL;
+    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
+    if (likely(is_method)) {
+        result = __Pyx_PyObject_CallOneArg(method, obj);
+        Py_DECREF(method);
+        return result;
+    }
+    if (unlikely(!method)) goto bad;
+    result = __Pyx_PyObject_CallNoArg(method);
+    Py_DECREF(method);
+bad:
+    return result;
+}
+
+/* RaiseNoneIterError */
+static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
+}
+
+/* UnpackTupleError */
+static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
+    if (t == Py_None) {
+      __Pyx_RaiseNoneNotIterableError();
+    } else if (PyTuple_GET_SIZE(t) < index) {
+      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
+    } else {
+      __Pyx_RaiseTooManyValuesError(index);
+    }
+}
+
+/* UnpackTuple2 */
+static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
+        PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2, int decref_tuple) {
+    PyObject *value1 = NULL, *value2 = NULL;
+#if CYTHON_COMPILING_IN_PYPY
+    value1 = PySequence_ITEM(tuple, 0);  if (unlikely(!value1)) goto bad;
+    value2 = PySequence_ITEM(tuple, 1);  if (unlikely(!value2)) goto bad;
+#else
+    value1 = PyTuple_GET_ITEM(tuple, 0);  Py_INCREF(value1);
+    value2 = PyTuple_GET_ITEM(tuple, 1);  Py_INCREF(value2);
+#endif
+    if (decref_tuple) {
+        Py_DECREF(tuple);
+    }
+    *pvalue1 = value1;
+    *pvalue2 = value2;
+    return 0;
+#if CYTHON_COMPILING_IN_PYPY
+bad:
+    Py_XDECREF(value1);
+    Py_XDECREF(value2);
+    if (decref_tuple) { Py_XDECREF(tuple); }
+    return -1;
+#endif
+}
+static int __Pyx_unpack_tuple2_generic(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
+                                       int has_known_size, int decref_tuple) {
+    Py_ssize_t index;
+    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
+    iternextfunc iternext;
+    iter = PyObject_GetIter(tuple);
+    if (unlikely(!iter)) goto bad;
+    if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
+    iternext = Py_TYPE(iter)->tp_iternext;
+    value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
+    value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
+    if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
+    Py_DECREF(iter);
+    *pvalue1 = value1;
+    *pvalue2 = value2;
+    return 0;
+unpacking_failed:
+    if (!has_known_size && __Pyx_IterFinish() == 0)
+        __Pyx_RaiseNeedMoreValuesError(index);
+bad:
+    Py_XDECREF(iter);
+    Py_XDECREF(value1);
+    Py_XDECREF(value2);
+    if (decref_tuple) { Py_XDECREF(tuple); }
+    return -1;
+}
+
+/* dict_iter */
+static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
+                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
+    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
+    *p_source_is_dict = is_dict;
+    if (is_dict) {
+#if !CYTHON_COMPILING_IN_PYPY
+        *p_orig_length = PyDict_Size(iterable);
+        Py_INCREF(iterable);
+        return iterable;
+#elif PY_MAJOR_VERSION >= 3
+        static PyObject *py_items = NULL, *py_keys = NULL, *py_values = NULL;
+        PyObject **pp = NULL;
+        if (method_name) {
+            const char *name = PyUnicode_AsUTF8(method_name);
+            if (strcmp(name, "iteritems") == 0) pp = &py_items;
+            else if (strcmp(name, "iterkeys") == 0) pp = &py_keys;
+            else if (strcmp(name, "itervalues") == 0) pp = &py_values;
+            if (pp) {
+                if (!*pp) {
+                    *pp = PyUnicode_FromString(name + 4);
+                    if (!*pp)
+                        return NULL;
+                }
+                method_name = *pp;
+            }
+        }
+#endif
+    }
+    *p_orig_length = 0;
+    if (method_name) {
+        PyObject* iter;
+        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
+        if (!iterable)
+            return NULL;
+#if !CYTHON_COMPILING_IN_PYPY
+        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
+            return iterable;
+#endif
+        iter = PyObject_GetIter(iterable);
+        Py_DECREF(iterable);
+        return iter;
+    }
+    return PyObject_GetIter(iterable);
+}
+static CYTHON_INLINE int __Pyx_dict_iter_next(
+        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
+        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
+    PyObject* next_item;
+#if !CYTHON_COMPILING_IN_PYPY
+    if (source_is_dict) {
+        PyObject *key, *value;
+        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
+            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
+            return -1;
+        }
+        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
+            return 0;
+        }
+        if (pitem) {
+            PyObject* tuple = PyTuple_New(2);
+            if (unlikely(!tuple)) {
+                return -1;
+            }
+            Py_INCREF(key);
+            Py_INCREF(value);
+            PyTuple_SET_ITEM(tuple, 0, key);
+            PyTuple_SET_ITEM(tuple, 1, value);
+            *pitem = tuple;
+        } else {
+            if (pkey) {
+                Py_INCREF(key);
+                *pkey = key;
+            }
+            if (pvalue) {
+                Py_INCREF(value);
+                *pvalue = value;
+            }
+        }
+        return 1;
+    } else if (PyTuple_CheckExact(iter_obj)) {
+        Py_ssize_t pos = *ppos;
+        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
+        *ppos = pos + 1;
+        next_item = PyTuple_GET_ITEM(iter_obj, pos);
+        Py_INCREF(next_item);
+    } else if (PyList_CheckExact(iter_obj)) {
+        Py_ssize_t pos = *ppos;
+        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
+        *ppos = pos + 1;
+        next_item = PyList_GET_ITEM(iter_obj, pos);
+        Py_INCREF(next_item);
+    } else
+#endif
+    {
+        next_item = PyIter_Next(iter_obj);
+        if (unlikely(!next_item)) {
+            return __Pyx_IterFinish();
+        }
+    }
+    if (pitem) {
+        *pitem = next_item;
+    } else if (pkey && pvalue) {
+        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
+            return -1;
+    } else if (pkey) {
+        *pkey = next_item;
+    } else {
+        *pvalue = next_item;
+    }
+    return 1;
+}
+
 /* PyIntBinop */
 #if !CYTHON_COMPILING_IN_PYPY
 #if PY_MAJOR_VERSION < 3 || CYTHON_USE_PYLONG_INTERNALS
 #define __Pyx_PyInt_FloorDivideObjC_ZeroDivisionError(operand)\
     if (unlikely(zerodivision_check && ((operand) == 0))) {\
         PyErr_SetString(PyExc_ZeroDivisionError, "integer division by zero");\
         return NULL;\
@@ -35475,144 +36220,14 @@
     if (likely(__Pyx_TypeCheck(obj, type)))
         return 1;
     PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                  Py_TYPE(obj)->tp_name, type->tp_name);
     return 0;
 }
 
-/* GetTopmostException */
-#if CYTHON_USE_EXC_INFO_STACK
-static _PyErr_StackItem *
-__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
-{
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
-           exc_info->previous_item != NULL)
-    {
-        exc_info = exc_info->previous_item;
-    }
-    return exc_info;
-}
-#endif
-
-/* SaveResetException */
-#if CYTHON_FAST_THREAD_STATE
-static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
-    *type = exc_info->exc_type;
-    *value = exc_info->exc_value;
-    *tb = exc_info->exc_traceback;
-    #else
-    *type = tstate->exc_type;
-    *value = tstate->exc_value;
-    *tb = tstate->exc_traceback;
-    #endif
-    Py_XINCREF(*type);
-    Py_XINCREF(*value);
-    Py_XINCREF(*tb);
-}
-static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    #if CYTHON_USE_EXC_INFO_STACK
-    _PyErr_StackItem *exc_info = tstate->exc_info;
-    tmp_type = exc_info->exc_type;
-    tmp_value = exc_info->exc_value;
-    tmp_tb = exc_info->exc_traceback;
-    exc_info->exc_type = type;
-    exc_info->exc_value = value;
-    exc_info->exc_traceback = tb;
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = type;
-    tstate->exc_value = value;
-    tstate->exc_traceback = tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-}
-#endif
-
-/* GetException */
-#if CYTHON_FAST_THREAD_STATE
-static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
-#else
-static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
-#endif
-{
-    PyObject *local_type, *local_value, *local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    PyObject *tmp_type, *tmp_value, *tmp_tb;
-    local_type = tstate->curexc_type;
-    local_value = tstate->curexc_value;
-    local_tb = tstate->curexc_traceback;
-    tstate->curexc_type = 0;
-    tstate->curexc_value = 0;
-    tstate->curexc_traceback = 0;
-#else
-    PyErr_Fetch(&local_type, &local_value, &local_tb);
-#endif
-    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
-#if CYTHON_FAST_THREAD_STATE
-    if (unlikely(tstate->curexc_type))
-#else
-    if (unlikely(PyErr_Occurred()))
-#endif
-        goto bad;
-    #if PY_MAJOR_VERSION >= 3
-    if (local_tb) {
-        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
-            goto bad;
-    }
-    #endif
-    Py_XINCREF(local_tb);
-    Py_XINCREF(local_type);
-    Py_XINCREF(local_value);
-    *type = local_type;
-    *value = local_value;
-    *tb = local_tb;
-#if CYTHON_FAST_THREAD_STATE
-    #if CYTHON_USE_EXC_INFO_STACK
-    {
-        _PyErr_StackItem *exc_info = tstate->exc_info;
-        tmp_type = exc_info->exc_type;
-        tmp_value = exc_info->exc_value;
-        tmp_tb = exc_info->exc_traceback;
-        exc_info->exc_type = local_type;
-        exc_info->exc_value = local_value;
-        exc_info->exc_traceback = local_tb;
-    }
-    #else
-    tmp_type = tstate->exc_type;
-    tmp_value = tstate->exc_value;
-    tmp_tb = tstate->exc_traceback;
-    tstate->exc_type = local_type;
-    tstate->exc_value = local_value;
-    tstate->exc_traceback = local_tb;
-    #endif
-    Py_XDECREF(tmp_type);
-    Py_XDECREF(tmp_value);
-    Py_XDECREF(tmp_tb);
-#else
-    PyErr_SetExcInfo(local_type, local_value, local_tb);
-#endif
-    return 0;
-bad:
-    *type = 0;
-    *value = 0;
-    *tb = 0;
-    Py_XDECREF(local_type);
-    Py_XDECREF(local_value);
-    Py_XDECREF(local_tb);
-    return -1;
-}
-
 /* Import */
 static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
     PyObject *empty_list = 0;
     PyObject *module = 0;
     PyObject *global_dict = 0;
     PyObject *empty_dict = 0;
     PyObject *list;
@@ -35859,19 +36474,14 @@
 static CYTHON_INLINE Py_ssize_t __Pyx_div_Py_ssize_t(Py_ssize_t a, Py_ssize_t b) {
     Py_ssize_t q = a / b;
     Py_ssize_t r = a - q*b;
     q -= ((r != 0) & ((r ^ b) < 0));
     return q;
 }
 
-/* RaiseNoneIterError */
-static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
-    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
-}
-
 /* SwapException */
 #if CYTHON_FAST_THREAD_STATE
 static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
     PyObject *tmp_type, *tmp_value, *tmp_tb;
     #if CYTHON_USE_EXC_INFO_STACK
     _PyErr_StackItem *exc_info = tstate->exc_info;
     tmp_type = exc_info->exc_type;
```

### Comparing `pyjls-0.7.0/pyjls/entry_points/__init__.py` & `pyjls-0.7.1/pyjls/entry_points/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-# Copyright 2018-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from . import annotate, export, info
-
-__all__ = [annotate, export, info]
-"""This list of available command modules.  Each module must contain a 
-parser_config(subparser) function.  The function must return the callable(args)
-that will be executed for the command."""
+# Copyright 2018-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from . import annotate, export, info, plot
+
+__all__ = [annotate, export, info, plot]
+"""This list of available command modules.  Each module must contain a 
+parser_config(subparser) function.  The function must return the callable(args)
+that will be executed for the command."""
```

### Comparing `pyjls-0.7.0/pyjls/entry_points/annotate.py` & `pyjls-0.7.1/pyjls/entry_points/annotate.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,66 +1,66 @@
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from pyjls import Reader, Writer, SourceDef, SignalDef, AnnotationType
-import logging
-import numpy as np
-import os
-
-log = logging.getLogger(__name__)
-
-
-def parser_config(p):
-    """Generate a JLS annotation file."""
-    p.add_argument('in_file',
-                   help='The input JLS file path')
-    p.add_argument('--name',
-                   default='anno',
-                   help='The annotation file subname')
-    return on_cmd
-
-
-def on_cmd(args):
-    path = os.path.dirname(args.in_file)
-    fname = os.path.basename(args.in_file)
-    fbase, fext = os.path.splitext(fname)
-    fout = os.path.join(path, f'{fbase}.{args.name}{fext}')
-
-    with Writer(fout) as w:
-        with Reader(args.in_file) as r:
-            sources: list[SourceDef] = list(r.sources.values())
-            signals: list[SignalDef] = list(r.signals.values())
-            for source in sources:
-                if source.source_id:
-                    w.source_def_from_struct(source)
-            for signal in signals:
-                if signal.signal_id:
-                    w.signal_def_from_struct(signal)
-        signal = signals[1]  # for now
-        generator = np.random.default_rng()
-        timestamps = generator.integers(0, signal.length, 12)
-        timestamps = sorted(timestamps)
-        event_strs = ['on', 'off', 'start', 'stop', 'off by 1']
-        marker_idx = 1
-        for idx, timestamp in enumerate(timestamps):
-            anno_type = idx % 4
-            if anno_type <= 1:
-                event_str = np.random.choice(event_strs)
-                w.annotation(signal.signal_id, timestamp, AnnotationType.TEXT, 0, None, event_str)
-            elif anno_type == 2:
-                w.annotation(signal.signal_id, timestamp, AnnotationType.MARKER, 0, None, str(marker_idx))
-                marker_idx += 1
-            elif anno_type == 3:
-                w.annotation(signal.signal_id, timestamp, AnnotationType.MARKER, 0, None, f'{marker_idx}a')
-                w.annotation(signal.signal_id, timestamp + 100, AnnotationType.MARKER, 0, None, f'{marker_idx}b')
-                marker_idx += 1
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from pyjls import Reader, Writer, SourceDef, SignalDef, AnnotationType
+import logging
+import numpy as np
+import os
+
+log = logging.getLogger(__name__)
+
+
+def parser_config(p):
+    """Generate a JLS annotation file."""
+    p.add_argument('in_file',
+                   help='The input JLS file path')
+    p.add_argument('--name',
+                   default='anno',
+                   help='The annotation file subname')
+    return on_cmd
+
+
+def on_cmd(args):
+    path = os.path.dirname(args.in_file)
+    fname = os.path.basename(args.in_file)
+    fbase, fext = os.path.splitext(fname)
+    fout = os.path.join(path, f'{fbase}.{args.name}{fext}')
+
+    with Writer(fout) as w:
+        with Reader(args.in_file) as r:
+            sources: list[SourceDef] = list(r.sources.values())
+            signals: list[SignalDef] = list(r.signals.values())
+            for source in sources:
+                if source.source_id:
+                    w.source_def_from_struct(source)
+            for signal in signals:
+                if signal.signal_id:
+                    w.signal_def_from_struct(signal)
+        signal = signals[1]  # for now
+        generator = np.random.default_rng()
+        timestamps = generator.integers(0, signal.length, 12)
+        timestamps = sorted(timestamps)
+        event_strs = ['on', 'off', 'start', 'stop', 'off by 1']
+        marker_idx = 1
+        for idx, timestamp in enumerate(timestamps):
+            anno_type = idx % 4
+            if anno_type <= 1:
+                event_str = np.random.choice(event_strs)
+                w.annotation(signal.signal_id, timestamp, AnnotationType.TEXT, 0, None, event_str)
+            elif anno_type == 2:
+                w.annotation(signal.signal_id, timestamp, AnnotationType.MARKER, 0, None, str(marker_idx))
+                marker_idx += 1
+            elif anno_type == 3:
+                w.annotation(signal.signal_id, timestamp, AnnotationType.MARKER, 0, None, f'{marker_idx}a')
+                w.annotation(signal.signal_id, timestamp + 100, AnnotationType.MARKER, 0, None, f'{marker_idx}b')
+                marker_idx += 1
```

### Comparing `pyjls-0.7.0/pyjls/entry_points/info.py` & `pyjls-0.7.1/pyjls/entry_points/info.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from pyjls import Reader
-import logging
-import textwrap
-
-log = logging.getLogger(__name__)
-
-
-def parser_config(p):
-    """JLS file info."""
-    p.add_argument('--verbose', '-v',
-                   action='store_true',
-                   help='Display verbose information.')
-    p.add_argument('--utc',
-                   action='store_true',
-                   help='Display the UTC data for each channel.')
-    p.add_argument('filename',
-                   help='JLS filename')
-    return on_cmd
-
-
-def _user_data_cbk(chunk_meta, data):
-    suffix = ''
-    if len(data) > 64:
-        data = data[:64]
-        suffix = '...'
-    print(f'    {chunk_meta}: {data}{suffix}')
-
-
-def on_cmd(args):
-    with Reader(args.filename) as r:
-        print('Sources:')
-        for source in r.sources.values():
-            s = source.info(verbose=args.verbose)
-            print(textwrap.indent(s, "    "))
-        print('Signals:')
-        for signal in r.signals.values():
-            s = signal.info(verbose=args.verbose)
-            print(textwrap.indent(s, "    "))
-            if args.utc:
-                def on_utc(entries):
-                    for sample_id, timestamp in entries:
-                        print(f'       {sample_id}, {timestamp}')
-                r.utc(signal.signal_id, -signal.sample_rate, on_utc)
-
-        print('User Data:')
-        r.user_data(_user_data_cbk)
-
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from pyjls import Reader
+import logging
+import textwrap
+
+log = logging.getLogger(__name__)
+
+
+def parser_config(p):
+    """JLS file info."""
+    p.add_argument('--verbose', '-v',
+                   action='store_true',
+                   help='Display verbose information.')
+    p.add_argument('--utc',
+                   action='store_true',
+                   help='Display the UTC data for each channel.')
+    p.add_argument('filename',
+                   help='JLS filename')
+    return on_cmd
+
+
+def _user_data_cbk(chunk_meta, data):
+    suffix = ''
+    if len(data) > 64:
+        data = data[:64]
+        suffix = '...'
+    print(f'    {chunk_meta}: {data}{suffix}')
+
+
+def on_cmd(args):
+    with Reader(args.filename) as r:
+        print('Sources:')
+        for source in r.sources.values():
+            s = source.info(verbose=args.verbose)
+            print(textwrap.indent(s, "    "))
+        print('Signals:')
+        for signal in r.signals.values():
+            s = signal.info(verbose=args.verbose)
+            print(textwrap.indent(s, "    "))
+            if args.utc:
+                def on_utc(entries):
+                    for sample_id, timestamp in entries:
+                        print(f'       {sample_id}, {timestamp}')
+                r.utc(signal.signal_id, -signal.sample_rate, on_utc)
+
+        print('User Data:')
+        r.user_data(_user_data_cbk)
+
```

### Comparing `pyjls-0.7.0/pyjls/test/__init__.py` & `pyjls-0.7.1/pyjls/test/__init__.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
```

### Comparing `pyjls-0.7.0/pyjls/test/test_binding.py` & `pyjls-0.7.1/pyjls/test/test_binding.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,236 +1,236 @@
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the 'License');
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an 'AS IS' BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from pyjls.binding import SECOND, Writer, Reader, SummaryFSR, DataType, jls_inject_log
-import io
-import logging
-from logging import StreamHandler
-import os
-import tempfile
-import unittest
-import numpy as np
-
-
-class TestBinding(unittest.TestCase):
-
-    def setUp(self):
-        f = tempfile.NamedTemporaryFile(delete=False, suffix='.jls')
-        f.close()
-        self._path = f.name
-        self.user_data = []
-        self.annotations = []
-        self._utc = []
-
-    def _on_user_data(self, *args):
-        self.user_data.append(args)
-
-    def _on_annotations(self, *args):
-        self.annotations.append(args)
-
-    def _on_utc(self, entries):
-        self._utc.append(entries)
-        return False
-
-    @property
-    def utc(self):
-        return np.concatenate(self._utc)
-
-    def tearDown(self) -> None:
-        if os.path.isfile(self._path):
-            os.remove(self._path)
-
-    def test_source_with_none_strs(self):
-        with Writer(self._path) as w:
-            w.source_def(source_id=1, name='name', vendor='vendor', model='',
-                         version=None, serial_number='serial_number')
-            w.signal_def(3, source_id=1, sample_rate=1000000, name='current', units='A')
-        with Reader(self._path) as r:
-            self.assertEqual(2, len(r.sources))
-            self.assertEqual([0, 1], sorted(r.sources.keys()))
-            s = r.sources[1]
-            self.assertEqual(1, s.source_id)
-            self.assertEqual('name', s.name)
-            self.assertEqual('', s.model)
-            self.assertEqual('', s.version)
-
-    def test_fsr_f32(self):
-        data = np.arange(110000, dtype=np.float32)
-        with Writer(self._path) as w:
-            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
-                         version='version', serial_number='serial_number')
-            w.signal_def(3, source_id=1, sample_rate=1000000, name='current', units='A')
-            w.fsr(3, 0, data)
-
-        with Reader(self._path) as r:
-            self.assertEqual(2, len(r.sources))
-            self.assertEqual([0, 1], sorted(r.sources.keys()))
-            s = r.sources[1]
-            self.assertEqual(1, s.source_id)
-            self.assertEqual('name', s.name)
-            self.assertEqual('vendor', s.vendor)
-            self.assertEqual('model', s.model)
-            self.assertEqual('version', s.version)
-            self.assertEqual('serial_number', s.serial_number)
-
-            self.assertEqual(2, len(r.signals))
-            self.assertEqual([0, 3], sorted(r.signals.keys()))
-            s = r.signals[3]
-            self.assertEqual(3, s.signal_id)
-            self.assertEqual(1, s.source_id)
-            self.assertEqual(0, s.signal_type)
-            self.assertEqual(1000000, s.sample_rate)
-            self.assertEqual(83200, s.samples_per_data)
-            self.assertEqual(104, s.sample_decimate_factor)
-            self.assertEqual(20000, s.entries_per_summary)
-            self.assertEqual(100, s.summary_decimate_factor)
-            self.assertEqual(100, s.annotation_decimate_factor)
-            self.assertEqual(100, s.utc_decimate_factor)
-            self.assertEqual('current', s.name)
-            self.assertEqual('A', s.units)
-            self.assertEqual(len(data), s.length)
-
-            np.testing.assert_allclose(data, r.fsr(3, 0, len(data)))
-            stats = r.fsr_statistics(3, 0, len(data), 1)
-            np.testing.assert_allclose(np.mean(data, dtype=np.float64), stats[0, SummaryFSR.MEAN])
-            np.testing.assert_allclose(np.min(data), stats[0, SummaryFSR.MIN])
-            np.testing.assert_allclose(np.max(data), stats[0, SummaryFSR.MAX])
-            np.testing.assert_allclose(np.std(data, ddof=1), stats[0, SummaryFSR.STD], rtol=1e-6)
-
-    def test_fsr_u1(self):
-        data = np.zeros(1024, dtype=np.uint8)
-        data[1::2] = 1
-        src = np.packbits(data, bitorder='little')
-
-        with Writer(self._path) as w:
-            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
-                         version='version', serial_number='serial_number')
-            w.signal_def(3, source_id=1, data_type=DataType.U1, sample_rate=1000000, name='current', units='A')
-            w.fsr(3, 0, src)
-
-        with Reader(self._path) as r:
-            self.assertEqual(2, len(r.sources))
-            self.assertEqual([0, 1], sorted(r.sources.keys()))
-            self.assertEqual(1, r.sources[1].source_id)
-            self.assertEqual(2, len(r.signals))
-            s = r.signals[3]
-            self.assertEqual(DataType.U1, r.signals[3].data_type)
-            self.assertEqual(len(data), s.length)
-
-            dst = r.fsr(3, 0, s.length)
-            dst_data = np.unpackbits(dst, count=s.length, bitorder='little')
-            np.testing.assert_allclose(data, dst_data)
-
-            stats = r.fsr_statistics(3, 0, s.length, 1)
-            np.testing.assert_allclose(np.mean(data), stats[0, SummaryFSR.MEAN])
-            np.testing.assert_allclose(np.min(data), stats[0, SummaryFSR.MIN])
-            np.testing.assert_allclose(np.max(data), stats[0, SummaryFSR.MAX])
-            np.testing.assert_allclose(np.std(data, ddof=1), stats[0, SummaryFSR.STD], rtol=1e-6)
-
-    def test_user_data(self):
-        data = [
-            (1, b'user binary'),
-            (2, 'user string'),
-            (3, {'user': 'json'}),
-        ]
-        with Writer(self._path) as w:
-            for d in data:
-                w.user_data(*d)
-        with Reader(self._path) as r:
-            r.user_data(self._on_user_data)
-        self.assertEqual(data, self.user_data)
-
-    def _annotation_gen(self, signal_id):
-        annotations = [
-            (0, 2.0,  3, 23, '2'),
-            (10, None, 0, 20, b'annotation binary'),
-            (11, None, 1, 21, 'annotation str'),
-            (12, 1.0,  2, 22, '1'),
-        ]
-        with Writer(self._path) as w:
-            fs = 1000000
-            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
-                         version='version', serial_number='serial_number')
-            w.signal_def(signal_id=signal_id, source_id=1, sample_rate=fs, name='current', units='A')
-            for a in annotations:
-                w.annotation(signal_id, *a)
-        return annotations
-
-    def test_annotation(self):
-        signal_id = 3
-        expected = self._annotation_gen(signal_id)
-        with Reader(self._path) as r:
-            r.annotations(signal_id, 0, self._on_annotations)
-        self.assertEqual(expected, self.annotations)
-
-    def test_annotation_seek(self):
-        signal_id = 3
-        expected = self._annotation_gen(signal_id)
-        with Reader(self._path) as r:
-            r.annotations(signal_id, expected[2][0], self._on_annotations)
-        self.assertEqual(expected[2:], self.annotations)
-
-    def _utc_gen(self, signal_id, sample_id_offset=None):
-        sample_id_offset = 0 if sample_id_offset is None else int(sample_id_offset)
-        data = []
-        with Writer(self._path) as w:
-            fs = 1000000
-            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
-                         version='version', serial_number='serial_number')
-            w.signal_def(signal_id=signal_id, source_id=1, sample_rate=fs, name='current', units='A')
-            w.fsr_f32(3, sample_id_offset, np.array([1, 2, 3, 4], dtype=np.float32))
-            for entry in range(100):
-                sample_id = entry * fs
-                timestamp = entry + 60 * 60 * 24 * 365  # in seconds
-                data.append([sample_id, timestamp])
-                w.utc(signal_id, sample_id + sample_id_offset, timestamp)
-        return np.array(data, dtype=np.int64)
-
-    def test_utc(self):
-        signal_id = 3
-        path_base, path_ext = os.path.splitext(self._path)
-        for idx in range(2):
-            self.subTest(idx)
-            self._path = f'{path_base}_{idx:04d}{path_ext}'
-            sample_id_offset = idx * 1_000_000
-            expected = self._utc_gen(signal_id, sample_id_offset=sample_id_offset)
-            with Reader(self._path) as r:
-                self.assertEqual(sample_id_offset, r.signals[signal_id].sample_id_offset)
-                r.utc(signal_id, 0, self._on_utc)
-                self.assertEqual(60 * 60 * 24 * 365, r.sample_id_to_timestamp(signal_id, 0))
-                self.assertEqual(0, r.timestamp_to_sample_id(signal_id, 60 * 60 * 24 * 365))
-            np.testing.assert_equal(expected, self.utc)
-            os.remove(self._path)
-            self._utc = []
-
-    def test_utc_seek(self):
-        signal_id = 3
-        expected = self._utc_gen(signal_id)
-        expected = expected[len(expected) // 2:, :]
-        with Reader(self._path) as r:
-            r.utc(signal_id, expected[0, 0], self._on_utc)
-        np.testing.assert_equal(expected, self.utc)
-
-    def test_log(self):
-        log = logging.getLogger('pyjls.c')
-        formatter = logging.Formatter("%(levelname)s:%(filename)s:%(lineno)d:%(name)s:%(message)s")
-        stream = io.StringIO()
-        stream_handler = StreamHandler(stream)
-        stream_handler.setFormatter(formatter)
-        log.addHandler(stream_handler)
-        jls_inject_log('I', 'hello', 10, 'world')
-        jls_inject_log('D', 'debug', 11, 'debug1')
-        stream_handler.setLevel(logging.INFO)
-        jls_inject_log('D', 'debug', 12, 'debug2')
-        expect = ['INFO:hello:10:pyjls.c:world', 'DEBUG:debug:11:pyjls.c:debug1', '']
-        self.assertEqual('\n'.join(expect), stream.getvalue())
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the 'License');
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an 'AS IS' BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from pyjls.binding import SECOND, Writer, Reader, SummaryFSR, DataType, jls_inject_log
+import io
+import logging
+from logging import StreamHandler
+import os
+import tempfile
+import unittest
+import numpy as np
+
+
+class TestBinding(unittest.TestCase):
+
+    def setUp(self):
+        f = tempfile.NamedTemporaryFile(delete=False, suffix='.jls')
+        f.close()
+        self._path = f.name
+        self.user_data = []
+        self.annotations = []
+        self._utc = []
+
+    def _on_user_data(self, *args):
+        self.user_data.append(args)
+
+    def _on_annotations(self, *args):
+        self.annotations.append(args)
+
+    def _on_utc(self, entries):
+        self._utc.append(entries)
+        return False
+
+    @property
+    def utc(self):
+        return np.concatenate(self._utc)
+
+    def tearDown(self) -> None:
+        if os.path.isfile(self._path):
+            os.remove(self._path)
+
+    def test_source_with_none_strs(self):
+        with Writer(self._path) as w:
+            w.source_def(source_id=1, name='name', vendor='vendor', model='',
+                         version=None, serial_number='serial_number')
+            w.signal_def(3, source_id=1, sample_rate=1000000, name='current', units='A')
+        with Reader(self._path) as r:
+            self.assertEqual(2, len(r.sources))
+            self.assertEqual([0, 1], sorted(r.sources.keys()))
+            s = r.sources[1]
+            self.assertEqual(1, s.source_id)
+            self.assertEqual('name', s.name)
+            self.assertEqual('', s.model)
+            self.assertEqual('', s.version)
+
+    def test_fsr_f32(self):
+        data = np.arange(110000, dtype=np.float32)
+        with Writer(self._path) as w:
+            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
+                         version='version', serial_number='serial_number')
+            w.signal_def(3, source_id=1, sample_rate=1000000, name='current', units='A')
+            w.fsr(3, 0, data)
+
+        with Reader(self._path) as r:
+            self.assertEqual(2, len(r.sources))
+            self.assertEqual([0, 1], sorted(r.sources.keys()))
+            s = r.sources[1]
+            self.assertEqual(1, s.source_id)
+            self.assertEqual('name', s.name)
+            self.assertEqual('vendor', s.vendor)
+            self.assertEqual('model', s.model)
+            self.assertEqual('version', s.version)
+            self.assertEqual('serial_number', s.serial_number)
+
+            self.assertEqual(2, len(r.signals))
+            self.assertEqual([0, 3], sorted(r.signals.keys()))
+            s = r.signals[3]
+            self.assertEqual(3, s.signal_id)
+            self.assertEqual(1, s.source_id)
+            self.assertEqual(0, s.signal_type)
+            self.assertEqual(1000000, s.sample_rate)
+            self.assertEqual(83200, s.samples_per_data)
+            self.assertEqual(104, s.sample_decimate_factor)
+            self.assertEqual(20000, s.entries_per_summary)
+            self.assertEqual(100, s.summary_decimate_factor)
+            self.assertEqual(100, s.annotation_decimate_factor)
+            self.assertEqual(100, s.utc_decimate_factor)
+            self.assertEqual('current', s.name)
+            self.assertEqual('A', s.units)
+            self.assertEqual(len(data), s.length)
+
+            np.testing.assert_allclose(data, r.fsr(3, 0, len(data)))
+            stats = r.fsr_statistics(3, 0, len(data), 1)
+            np.testing.assert_allclose(np.mean(data, dtype=np.float64), stats[0, SummaryFSR.MEAN])
+            np.testing.assert_allclose(np.min(data), stats[0, SummaryFSR.MIN])
+            np.testing.assert_allclose(np.max(data), stats[0, SummaryFSR.MAX])
+            np.testing.assert_allclose(np.std(data, ddof=1), stats[0, SummaryFSR.STD], rtol=1e-6)
+
+    def test_fsr_u1(self):
+        data = np.zeros(1024, dtype=np.uint8)
+        data[1::2] = 1
+        src = np.packbits(data, bitorder='little')
+
+        with Writer(self._path) as w:
+            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
+                         version='version', serial_number='serial_number')
+            w.signal_def(3, source_id=1, data_type=DataType.U1, sample_rate=1000000, name='current', units='A')
+            w.fsr(3, 0, src)
+
+        with Reader(self._path) as r:
+            self.assertEqual(2, len(r.sources))
+            self.assertEqual([0, 1], sorted(r.sources.keys()))
+            self.assertEqual(1, r.sources[1].source_id)
+            self.assertEqual(2, len(r.signals))
+            s = r.signals[3]
+            self.assertEqual(DataType.U1, r.signals[3].data_type)
+            self.assertEqual(len(data), s.length)
+
+            dst = r.fsr(3, 0, s.length)
+            dst_data = np.unpackbits(dst, count=s.length, bitorder='little')
+            np.testing.assert_allclose(data, dst_data)
+
+            stats = r.fsr_statistics(3, 0, s.length, 1)
+            np.testing.assert_allclose(np.mean(data), stats[0, SummaryFSR.MEAN])
+            np.testing.assert_allclose(np.min(data), stats[0, SummaryFSR.MIN])
+            np.testing.assert_allclose(np.max(data), stats[0, SummaryFSR.MAX])
+            np.testing.assert_allclose(np.std(data, ddof=1), stats[0, SummaryFSR.STD], rtol=1e-6)
+
+    def test_user_data(self):
+        data = [
+            (1, b'user binary'),
+            (2, 'user string'),
+            (3, {'user': 'json'}),
+        ]
+        with Writer(self._path) as w:
+            for d in data:
+                w.user_data(*d)
+        with Reader(self._path) as r:
+            r.user_data(self._on_user_data)
+        self.assertEqual(data, self.user_data)
+
+    def _annotation_gen(self, signal_id):
+        annotations = [
+            (0, 2.0,  3, 23, '2'),
+            (10, None, 0, 20, b'annotation binary'),
+            (11, None, 1, 21, 'annotation str'),
+            (12, 1.0,  2, 22, '1'),
+        ]
+        with Writer(self._path) as w:
+            fs = 1000000
+            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
+                         version='version', serial_number='serial_number')
+            w.signal_def(signal_id=signal_id, source_id=1, sample_rate=fs, name='current', units='A')
+            for a in annotations:
+                w.annotation(signal_id, *a)
+        return annotations
+
+    def test_annotation(self):
+        signal_id = 3
+        expected = self._annotation_gen(signal_id)
+        with Reader(self._path) as r:
+            r.annotations(signal_id, 0, self._on_annotations)
+        self.assertEqual(expected, self.annotations)
+
+    def test_annotation_seek(self):
+        signal_id = 3
+        expected = self._annotation_gen(signal_id)
+        with Reader(self._path) as r:
+            r.annotations(signal_id, expected[2][0], self._on_annotations)
+        self.assertEqual(expected[2:], self.annotations)
+
+    def _utc_gen(self, signal_id, sample_id_offset=None):
+        sample_id_offset = 0 if sample_id_offset is None else int(sample_id_offset)
+        data = []
+        with Writer(self._path) as w:
+            fs = 1000000
+            w.source_def(source_id=1, name='name', vendor='vendor', model='model',
+                         version='version', serial_number='serial_number')
+            w.signal_def(signal_id=signal_id, source_id=1, sample_rate=fs, name='current', units='A')
+            w.fsr_f32(3, sample_id_offset, np.array([1, 2, 3, 4], dtype=np.float32))
+            for entry in range(100):
+                sample_id = entry * fs
+                timestamp = entry + 60 * 60 * 24 * 365  # in seconds
+                data.append([sample_id, timestamp])
+                w.utc(signal_id, sample_id + sample_id_offset, timestamp)
+        return np.array(data, dtype=np.int64)
+
+    def test_utc(self):
+        signal_id = 3
+        path_base, path_ext = os.path.splitext(self._path)
+        for idx in range(2):
+            self.subTest(idx)
+            self._path = f'{path_base}_{idx:04d}{path_ext}'
+            sample_id_offset = idx * 1_000_000
+            expected = self._utc_gen(signal_id, sample_id_offset=sample_id_offset)
+            with Reader(self._path) as r:
+                self.assertEqual(sample_id_offset, r.signals[signal_id].sample_id_offset)
+                r.utc(signal_id, 0, self._on_utc)
+                self.assertEqual(60 * 60 * 24 * 365, r.sample_id_to_timestamp(signal_id, 0))
+                self.assertEqual(0, r.timestamp_to_sample_id(signal_id, 60 * 60 * 24 * 365))
+            np.testing.assert_equal(expected, self.utc)
+            os.remove(self._path)
+            self._utc = []
+
+    def test_utc_seek(self):
+        signal_id = 3
+        expected = self._utc_gen(signal_id)
+        expected = expected[len(expected) // 2:, :]
+        with Reader(self._path) as r:
+            r.utc(signal_id, expected[0, 0], self._on_utc)
+        np.testing.assert_equal(expected, self.utc)
+
+    def test_log(self):
+        log = logging.getLogger('pyjls.c')
+        formatter = logging.Formatter("%(levelname)s:%(filename)s:%(lineno)d:%(name)s:%(message)s")
+        stream = io.StringIO()
+        stream_handler = StreamHandler(stream)
+        stream_handler.setFormatter(formatter)
+        log.addHandler(stream_handler)
+        jls_inject_log('I', 'hello', 10, 'world')
+        jls_inject_log('D', 'debug', 11, 'debug1')
+        stream_handler.setLevel(logging.INFO)
+        jls_inject_log('D', 'debug', 12, 'debug2')
+        expect = ['INFO:hello:10:pyjls.c:world', 'DEBUG:debug:11:pyjls.c:debug1', '']
+        self.assertEqual('\n'.join(expect), stream.getvalue())
```

### Comparing `pyjls-0.7.0/pyjls/v1/__init__.py` & `pyjls-0.7.1/pyjls/v1/__init__.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
```

### Comparing `pyjls-0.7.0/pyjls.egg-info/PKG-INFO` & `pyjls-0.7.1/pyjls.egg-info/PKG-INFO`

 * *Files 12% similar despite different names*

```diff
@@ -1,322 +1,319 @@
-Metadata-Version: 2.1
-Name: pyjls
-Version: 0.7.0
-Summary: Joulescope™ file format
-Home-page: https://joulescope.readthedocs.io
-Author: Jetperch LLC
-Author-email: joulescope-dev@jetperch.com
-License: Apache 2.0
-Project-URL: Bug Reports, https://github.com/jetperch/jls/issues
-Project-URL: Funding, https://www.joulescope.com
-Project-URL: Twitter, https://twitter.com/joulescope
-Project-URL: Source, https://github.com/jetperch/jls/
-Keywords: JLS,Joulescope
-Classifier: Development Status :: 3 - Alpha
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: End Users/Desktop
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Operating System :: Microsoft :: Windows :: Windows 10
-Classifier: Operating System :: MacOS :: MacOS X
-Classifier: Operating System :: POSIX :: Linux
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Software Development :: Embedded Systems
-Classifier: Topic :: Software Development :: Testing
-Classifier: Topic :: System :: Hardware :: Hardware Drivers
-Classifier: Topic :: Utilities
-Requires-Python: ~=3.8
-Description-Content-Type: text/markdown
-License-File: LICENSE
-
-<!--
-# Copyright 2021-2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
--->
-
-main:
-[![Windows amd64](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml)
-[![macOS amd64](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml)
-[![Ubuntu Linux amd64](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml)
-
-develop:
-[![Windows amd64](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/windows_amd64.yml)
-[![macOS amd64](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/macos_amd64.yml)
-[![Ubuntu Linux amd64](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml/badge.svg?branch=develop)](https://github.com/jetperch/jls/actions/workflows/linux_amd64.yml)
-
-
-# JLS
-
-Welcome to the [Joulescope®](https://www.joulescope.com) File Format project.
-The goal of this project is to provide performant data storage for huge, 
-simultaneous, one-dimensional signals. This repository contains:
-
-* The JLS file format specification
-* The implementation in C
-* Language bindings for Python
-
-> **⚠ CAUTION ⚠**  
-> We are actively developing this library.  Some features are not 
-> yet implemented.
-
-
-## License
-
-This project is Copyright © 2017-2022 Jetperch LLC and licensed under the 
-permissive [Apache 2.0](LICENSE).
-
-
-## Features
-
-* Cross-platform
-  * Microsoft Windows x64
-  * Apple macOS x64
-  * Apple macOS ARM
-  * Linux x64
-  * Linux aarch64 (ARM 64-bit).  Supports Raspberry Pi 4.
-* Support for multiple, simultaneous data sources
-* Support for multiple, simultaneous signal waveforms
-* Fixed sample rate signals (FSR)
-  * Handles missing samples gracefully (interpolate) 🔜
-  * Multiple data types including:
-    - Floating point: f32, f64
-    - Unsigned integers: u1, u4, u8, u16, u24, u32, u64 
-    - Signed integers: i4, i8, i16, i24, i32, i64
-    - Fixed-point, signed integers (same bit sizes as signed integers)
-    - Boolean (digital) 1-bit signals = u1
-* Variable sample rate (VSR) signals 🔜
-* Fast read performance
-  * Signal Summaries
-    * "Zoomed out" view with mean, min, max, standard deviation
-    * Provides fast waveform load without any additional processing steps
-  * Automatic load by summary level
-  * Fast seek, next, previous access
-* Sample ID to Wall-clock time (UTC) for FSR signals
-* Annotations
-  * Global VSR annotations
-  * Signal annotations, timestamped to sample_id for FSR and UTC time for VSR
-  * Support for text, marker, and user-defined (text, binary, JSON)
-* User data
-  * Arbitrary data included in the same file
-  * Support for text, binary, and JSON
-* Reliability
-  * Integrated integrity checks using CRC32C
-  * File data still accessible in the case of improper program termination 🔜
-  * Uncorrupted data is still accessible in presence of file corruption 🔜
-  * Write once, except for indices and the doubly-linked list pointers
-* Compression options 🔜
-  * lossless 🔜
-  * lossy 🔜
-  * lossy with downsampling below threshold 🔜
-  * Support level 0 DATA not written (only INDEX & SUMMARY) 🔜
-
-Items marked with 🔜 are under development and coming soon.
-Items marked with ⏳ are planned for future release.
-
-As of March 2022, the JLS v2 file structure is well-defined and stable.
-However, the compression storage formats are not yet defined.
-
-
-## Why JLS?
-
-The world is already full of file formats, and we would rather not create 
-another one.  However, we could not identify a solution that met these
-requirements.  [HDF5](https://www.hdfgroup.org/solutions/hdf5/) meets the
-large storage requirements, but not the reliability and rapid load requirements.
-The [Saleae binary export file format v2](https://support.saleae.com/faq/technical-faq/binary-export-format-logic-2)
-is also not suitable since it buffers stores single, contiguous blocks.
-[Sigrok v2](https://sigrok.org/wiki/File_format:Sigrok/v2) is similar.
-The [Sigrok v3](https://sigrok.org/wiki/File_format:Sigrok/v3) format
-(under development as of Feb 2022) is better in that it stores sequences of
-"packets" containing data blocks, but it still will does not allow for
-fast seek or summaries.
-
-Timeseries databases, such as [InfluxDB](https://www.influxdata.com/), are 
-powerful tools.  However, they are not well-designed for fast sample-rate
-data.
-
-Media containers are another option, especially the ISO base media file format
-used by MPEG4 and many others:
-  * [ISO/IEC 14496-14:2020 Specification](https://www.iso.org/standard/79110.html)
-  * [Overview](https://mpeg.chiariglione.org/standards/mpeg-4/iso-base-media-file-format)
-
-However, the standard does not included the ability to store the signal summaries
-and our specific signal types.  While we could add these features, these formats
-are already complicated, greatly reducing the advantage of repurposing them.
-
-
-## Why JLS v2?
-
-This file format is based upon JLS v1 designed for
-[pyjoulescope](https://github.com/jetperch/pyjoulescope) and used by the
-[Joulescope](https://www.joulescope.com/) test instrument.  We are leveraging
-the lessons learned from v1 to make v2 better, faster, and more extensible.
-
-The JLS v1 format has been great for the Joulescope ecosystem and has
-accomplished the objective of long data captures (days) with fast
-sampling rates (MHz).  However, it now has a long list of issues that are difficult
-to address without a significant restructuring.  The issues include:
-
-- Inflexible storage format (always current, voltage, power, current range, GPI0, GPI1).
-- Unable to store from multiple sources.
-- Unable to store other sources and signals.
-- No annotation support: 
-  [41](https://github.com/jetperch/pyjoulescope_ui/issues/41),
-  [93](https://github.com/jetperch/pyjoulescope_ui/issues/93).
-- Inflexible user data support.
-- Inconsistent performance across sampling rates, zoom levels, and file sizes: 
-  [48](https://github.com/jetperch/pyjoulescope_ui/issues/48),
-  [103](https://github.com/jetperch/pyjoulescope_ui/issues/103).
-- Unable to correlate sample times with UTC:
-  [55](https://github.com/jetperch/pyjoulescope_ui/issues/55).
-
-The JLS v2 file format will address all of these issues, dramatically 
-improve performance, and add new capabilities, such as signal compression.
-
-
-## How?
-
-At its lowest layer, JLS is an enhanced 
-[tag-length-value](https://en.wikipedia.org/wiki/Type-length-value) (TLV)
-format. TLV files form the foundation of many reliable image and video formats, 
-including MPEG4 and PNG.  The enhanced header contains additional fields
-to speed navigation and improve reliability.  The JLS file format calls 
-each TLV a **chunk**.  The enhanced tag-length component the **chunk header**
-or simply **header**.  The file also contains a **file header**, not to be 
-confused with the **chunk header**.  A **chunk** may have zero payload length,
-in which case the next header follows immediately.  Otherwise, a 
-**chunk** consists of a **header** followed by a **payload**. 
-
-The JLS file format defines **sources** that produce data.  The file allows
-the application to clearly define and label the source.  Each source
-can have any number of associated signals.
-
-**Signals** are 1-D sequences of values over time consisting of a single,
-fixed data type.  Each signal can have multiple **tracks** that contain
-data associated with that signal. The JLS file supports two signal types: 
-fixed sample rate (FSR) and variable sample rate (VSR).  FSR signals
-store their sample data in the FSR track using FSR_DATA and FSR_SUMMARY.
-FSR time is denoted by samples using timestamp.  FSR signals also support:
-
-* Sample time to UTC time mapping using the UTC track.
-* Annotations with the ANNOTATION track. 
-
-VSR signals store their sample data in the VSR track.  VSR signals
-specify time in UTC (wall-clock time).  VSR signals also
-support annotations with the ANNOTATION track.
-The JLS file format supports VSR signals that only use the 
-ANNOTATION track and not the VSR track.  Such signals are commonly 
-used to store UART text data where each line contains a UTC timestamp. 
-
-Signals support DATA chunks and SUMMARY chunks.
-The DATA chunks store the actual sample data.  The SUMMARY chunks
-store the reduced statistics, where each statistic entry represents
-multiple samples.  FSR tracks store the mean, min, max, 
-and standard deviation.  Although standard deviation requires the
-writer to compute the square root, standard deviation keeps the
-same units and bit depth requirements as the other fields.  Variance
-requires twice the bit size for integer types since it is squared.
-
-Before each SUMMARY chunk, the JLS file will contain the INDEX chunk
-which contains the starting time and offset for each chunk that 
-contributed to the summary.  This SUMMARY chunk enables fast O(log n)
-navigation of the file.  For FSR tracks, the starting time is 
-calculated rather than stored for each entry.
-
-The JLS file format design supports SUMMARY of SUMMARY.  It supports
-the DATA and up to 15 layers of SUMMARIES.  timestamp is given as a
-64-bit integer, which allows each summary to include only 20 samples
-and still support the full 64-bit integer timestamp space.  In practice, the
-first level summary increases a single value to 4 values, so summary
-steps are usually 50 or more.
-
-Many applications, including the Joulescope UI, prioritize read performance,
-especially visualizing the waveform quickly following open, 
-over write performance.   Waiting to scan through a 1 TB file is not a 
-valid option.  The reader opens the file and scans for sources and signals.
-The application can then quickly load the highest summary of summaries 
-for every signal of interest.  The application can very quickly display this
-data, and then start to retrieve more detailed information as requested.
-
-
-## Example file structure
-
-```
-sof
-header
-USER_DATA(0, NULL)    // Required, point to first real user_data chunk
-SOURCE_DEF(0)         // Required, internal, reserved for global annotations
-SIGNAL_DEF(0, 0.VSR)  // Required, internal, reserved for global annotations
-TRACK_DEF(0.VSR)
-TRACK_HEAD(0.VSR)
-TRACK_DEF(0.ANNO)
-TRACK_HEAD(0.ANNO)
-SOURCE_DEF(1)         // input device 1
-SIGNAL_DEF(1, 1, FSR) // our signal, like "current" or "voltage"
-TRACK_DEF(1.FSR)
-TRACK_HEAD(1.FSR)
-TRACK_DEF(1.ANNO)
-TRACK_HEAD(1.ANNO)
-TRACK_DEF(1.UTC)
-TRACK_HEAD(1.UTC)
-USER_DATA           // just because
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_DATA(1.FSR)
-TRACK_INDEX(1.FSR, lvl=0)
-TRACK_SUMMARY(1.FSR, lvl=1)
-TRACK_INDEX(1.FSR, lvl=1)
-TRACK_SUMMARY(1.FSR, lvl=2)
-USER_DATA           // just because
-eof
-```
-
-Note that TRACK_HEAD(1.FSR) points to the first TRACK_INDEX(1.FSR, lvl=0) and
-TRACK_INDEX(1.FSR, lvl=1). 
-Each TRACK_DATA( is in a doubly-linked list with its next and previous
-neighbors.  Each TRACK_INDEX(1.FSR, lvl=0) is likewise in a separate doubly-linked
-list, and the payload of each TRACK_INDEX points to the summarized TRACK_DATA
-instances.  TRACK_INDEX(1.FSR, lvl=1) points to each TRACK_INDEX(1.FSR, lvl=0) instance.
-As more data is added, the TRACK_INDEX(1.FSR, lvl=1) will also get added to
-the INDEX chunks at the same level.
-
-
-## References
-
-* JLS v1: 
-  [lower-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/datafile.py),
-  [upper-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/data_recorder.py).
-* [Sigrok/v3](https://sigrok.org/wiki/File_format:Sigrok/v3), which shares
-  many of the same motivations.
-* Tag-length-value: [Wikipedia](https://en.wikipedia.org/wiki/Type-length-value).
-* Doubly linked list: [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list).
+Metadata-Version: 2.1
+Name: pyjls
+Version: 0.7.1
+Summary: Joulescope™ file format
+Home-page: https://joulescope.readthedocs.io
+Author: Jetperch LLC
+Author-email: joulescope-dev@jetperch.com
+License: Apache 2.0
+Project-URL: Bug Reports, https://github.com/jetperch/jls/issues
+Project-URL: Funding, https://www.joulescope.com
+Project-URL: Twitter, https://twitter.com/joulescope
+Project-URL: Source, https://github.com/jetperch/jls/
+Keywords: JLS,Joulescope
+Classifier: Development Status :: 3 - Alpha
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: End Users/Desktop
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: Microsoft :: Windows :: Windows 10
+Classifier: Operating System :: MacOS :: MacOS X
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Software Development :: Embedded Systems
+Classifier: Topic :: Software Development :: Testing
+Classifier: Topic :: System :: Hardware :: Hardware Drivers
+Classifier: Topic :: Utilities
+Requires-Python: ~=3.9
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+<!--
+# Copyright 2021-2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+-->
+
+[![main](https://github.com/jetperch/jls/actions/workflows/packaging.yml/badge.svg?branch=main)](https://github.com/jetperch/jls/actions/workflows/packaging.yml)
+
+
+# JLS
+
+Welcome to the [Joulescope®](https://www.joulescope.com) File Format project.
+The goal of this project is to provide performant data storage for huge, 
+simultaneous, one-dimensional signals. This repository contains:
+
+* The JLS file format specification
+* The implementation in C
+* Language bindings for Python
+
+
+## Features
+
+* Cross-platform
+  * Microsoft Windows x64
+  * Apple macOS x64
+  * Apple macOS ARM
+  * Linux x64
+  * Linux aarch64 (ARM 64-bit).  Supports Raspberry Pi 4.
+* Support for multiple, simultaneous data sources
+* Support for multiple, simultaneous signal waveforms
+* Fixed sample rate signals (FSR)
+  * Handles missing samples gracefully (interpolate) 🔜
+  * Multiple data types including:
+    - Floating point: f32, f64
+    - Unsigned integers: u1, u4, u8, u16, u24, u32, u64 
+    - Signed integers: i4, i8, i16, i24, i32, i64
+    - Fixed-point, signed integers (same bit sizes as signed integers)
+    - Boolean (digital) 1-bit signals = u1
+* Variable sample rate (VSR) signals 🔜
+* Fast read performance
+  * Signal Summaries
+    * "Zoomed out" view with mean, min, max, standard deviation
+    * Provides fast waveform load without any additional processing steps
+  * Automatic load by summary level
+  * Fast seek, next, previous access
+* Sample ID to Wall-clock time (UTC) for FSR signals
+* Annotations
+  * Global VSR annotations
+  * Signal annotations, timestamped to sample_id for FSR and UTC time for VSR
+  * Support for text, marker, and user-defined (text, binary, JSON)
+* User data
+  * Arbitrary data included in the same file
+  * Support for text, binary, and JSON
+* Reliability
+  * Integrated integrity checks using CRC32C
+  * File data still accessible in the case of improper program termination 🔜
+  * Uncorrupted data is still accessible in presence of file corruption 🔜
+  * Write once, except for indices and the doubly-linked list pointers
+* Compression options 🔜
+  * lossless 🔜
+  * lossy 🔜
+  * lossy with downsampling below threshold 🔜
+  * Support level 0 DATA not written (only INDEX & SUMMARY) 🔜
+
+Items marked with 🔜 are under development and coming soon.
+Items marked with ⏳ are planned for future release.
+
+As of June 2023, the JLS v2 file structure is well-defined and stable.
+However, the compression storage formats are not yet defined and
+corrupted file recovery is not yet implemented.
+
+
+## Why JLS?
+
+The world is already full of file formats, and we would rather not create 
+another one.  However, we could not identify a solution that met these
+requirements.  [HDF5](https://www.hdfgroup.org/solutions/hdf5/) meets the
+large storage requirements, but not the reliability and rapid load requirements.
+The [Saleae binary export file format v2](https://support.saleae.com/faq/technical-faq/binary-export-format-logic-2)
+is also not suitable since it buffers stores single, contiguous blocks.
+[Sigrok v2](https://sigrok.org/wiki/File_format:Sigrok/v2) is similar.
+The [Sigrok v3](https://sigrok.org/wiki/File_format:Sigrok/v3) format
+(under development as of June 2023) is better in that it stores sequences of
+"packets" containing data blocks, but it still will does not allow for
+fast seek or summaries.
+
+Timeseries databases, such as [InfluxDB](https://www.influxdata.com/), are 
+powerful tools.  However, they are not well-designed for fast sample-rate
+data.
+
+Media containers are another option, especially the ISO base media file format
+used by MPEG4 and many others:
+  * [ISO/IEC 14496-14:2020 Specification](https://www.iso.org/standard/79110.html)
+  * [Overview](https://mpeg.chiariglione.org/standards/mpeg-4/iso-base-media-file-format)
+
+However, the standard does not include the ability to store the signal summaries
+and our specific signal types.  While we could add these features, these formats
+are already complicated, greatly reducing the advantage of repurposing them.
+
+
+## Why JLS v2?
+
+This file format is based upon JLS v1 designed for
+[pyjoulescope](https://github.com/jetperch/pyjoulescope) and used by the
+[Joulescope](https://www.joulescope.com/) test instrument.  We leveraged
+the lessons learned from v1 to make v2 better, faster, and more extensible.
+
+The JLS v1 format has been great for the Joulescope ecosystem and has
+accomplished the objective of long data captures (days) with fast
+sampling rates (MHz).  However, it now has a long list of issues including:
+
+- Inflexible storage format (always current, voltage, power, current range, GPI0, GPI1).
+- Unable to store from multiple sources.
+- Unable to store other sources and signals.
+- No annotation support: 
+  [41](https://github.com/jetperch/pyjoulescope_ui/issues/41),
+  [93](https://github.com/jetperch/pyjoulescope_ui/issues/93).
+- Inflexible user data support.
+- Inconsistent performance across sampling rates, zoom levels, and file sizes: 
+  [48](https://github.com/jetperch/pyjoulescope_ui/issues/48),
+  [103](https://github.com/jetperch/pyjoulescope_ui/issues/103).
+- Unable to correlate sample times with UTC:
+  [55](https://github.com/jetperch/pyjoulescope_ui/issues/55).
+
+The JLS v2 file format addressed all of these issues, dramatically 
+improved performance, and added new capabilities, such as signal compression.
+
+
+## How?
+
+At its lowest layer, JLS is an enhanced 
+[tag-length-value](https://en.wikipedia.org/wiki/Type-length-value) (TLV)
+format. TLV files form the foundation of many reliable image and video formats, 
+including MPEG4 and PNG.  The enhanced header contains additional fields
+to speed navigation and improve reliability.  The JLS file format calls 
+each TLV a **chunk**.  The enhanced tag-length component the **chunk header**
+or simply **header**.  The file also contains a **file header**, not to be 
+confused with the **chunk header**.  A **chunk** may have zero payload length,
+in which case the next header follows immediately.  Otherwise, a 
+**chunk** consists of a **header** followed by a **payload**. 
+
+The JLS file format defines **sources** that produce data.  The file allows
+the application to clearly define and label the source.  Each source
+can have any number of associated signals.
+
+**Signals** are 1-D sequences of values over time consisting of a single,
+fixed data type.  Each signal can have multiple **tracks** that contain
+data associated with that signal. The JLS file supports two signal types: 
+fixed sample rate (FSR) and variable sample rate (VSR).  FSR signals
+store their sample data in the FSR track using FSR_DATA and FSR_SUMMARY.
+FSR time is denoted by samples using timestamp.  FSR signals also support:
+
+* Sample time to UTC time mapping using the UTC track.
+* Annotations with the ANNOTATION track. 
+
+VSR signals store their sample data in the VSR track.  VSR signals
+specify time in UTC (wall-clock time).  VSR signals also
+support annotations with the ANNOTATION track.
+The JLS file format supports VSR signals that only use the 
+ANNOTATION track and not the VSR track.  Such signals are commonly 
+used to store UART text data where each line contains a UTC timestamp. 
+
+Signals support DATA chunks and SUMMARY chunks.
+The DATA chunks store the actual sample data.  The SUMMARY chunks
+store the reduced statistics, where each statistic entry represents
+multiple samples.  FSR tracks store the mean, min, max, 
+and standard deviation.  Although standard deviation requires the
+writer to compute the square root, standard deviation keeps the
+same units and bit depth requirements as the other fields.  Variance
+requires twice the bit size for integer types since it is squared.
+
+Before each SUMMARY chunk, the JLS file will contain the INDEX chunk
+which contains the starting time and offset for each chunk that 
+contributed to the summary.  This SUMMARY chunk enables fast O(log n)
+navigation of the file.  For FSR tracks, the starting time is 
+calculated rather than stored for each entry.
+
+The JLS file format design supports SUMMARY of SUMMARY.  It supports
+the DATA and up to 15 layers of SUMMARIES.  timestamp is given as a
+64-bit integer, which allows each summary to include only 20 samples
+and still support the full 64-bit integer timestamp space.  In practice, the
+first level summary increases a single value to 4 values, so summary
+steps are usually 50 or more.
+
+Many applications, including the Joulescope UI, prioritize read performance,
+especially visualizing the waveform quickly following open, 
+over write performance.   Waiting to scan through a 1 TB file is not a 
+valid option.  The reader opens the file and scans for sources and signals.
+The application can then quickly load the highest summary of summaries 
+for every signal of interest.  The application can very quickly display this
+data, and then start to retrieve more detailed information as requested.
+
+
+## Example file structure
+
+```
+sof
+header
+USER_DATA(0, NULL)    // Required, point to first real user_data chunk
+SOURCE_DEF(0)         // Required, internal, reserved for global annotations
+SIGNAL_DEF(0, 0.VSR)  // Required, internal, reserved for global annotations
+TRACK_DEF(0.VSR)
+TRACK_HEAD(0.VSR)
+TRACK_DEF(0.ANNO)
+TRACK_HEAD(0.ANNO)
+SOURCE_DEF(1)         // input device 1
+SIGNAL_DEF(1, 1, FSR) // our signal, like "current" or "voltage"
+TRACK_DEF(1.FSR)
+TRACK_HEAD(1.FSR)
+TRACK_DEF(1.ANNO)
+TRACK_HEAD(1.ANNO)
+TRACK_DEF(1.UTC)
+TRACK_HEAD(1.UTC)
+USER_DATA           // just because
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_DATA(1.FSR)
+TRACK_INDEX(1.FSR, lvl=0)
+TRACK_SUMMARY(1.FSR, lvl=1)
+TRACK_INDEX(1.FSR, lvl=1)
+TRACK_SUMMARY(1.FSR, lvl=2)
+USER_DATA           // just because
+END
+eof
+```
+
+Note that TRACK_HEAD(1.FSR) points to the first TRACK_INDEX(1.FSR, lvl=0) and
+TRACK_INDEX(1.FSR, lvl=1). 
+Each TRACK_DATA(1.FSR) is in a doubly-linked list with its next and previous
+neighbors.  Each TRACK_INDEX(1.FSR, lvl=0) is likewise in a separate doubly-linked
+list, and the payload of each TRACK_INDEX points to the summarized TRACK_DATA
+instances.  TRACK_INDEX(1.FSR, lvl=1) points to each TRACK_INDEX(1.FSR, lvl=0) instance.
+As more data is added, the TRACK_INDEX(1.FSR, lvl=1) will also get added to
+the INDEX chunks at the same level.
+
+
+## Resources
+
+* [source code](https://github.com/jetperch/jls)
+* [documentation](https://jls.readthedocs.io/en/latest/)
+* [pypi](https://pypi.org/project/pyjls/)
+* [Joulescope](https://www.joulescope.com/) (Joulescope web store)
+* [forum](https://forum.joulescope.com/)
+
+
+## References
+
+* JLS v1: 
+  [lower-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/datafile.py),
+  [upper-layer](https://github.com/jetperch/pyjoulescope/blob/master/joulescope/data_recorder.py).
+* [Sigrok/v3](https://sigrok.org/wiki/File_format:Sigrok/v3), which shares
+  many of the same motivations.
+* Tag-length-value: [Wikipedia](https://en.wikipedia.org/wiki/Type-length-value).
+* Doubly linked list: [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list).
+
+
+## License
+
+This project is Copyright © 2017-2023 Jetperch LLC and licensed under the
+permissive [Apache 2.0 License](./LICENSE).
```

### Comparing `pyjls-0.7.0/pyjls.egg-info/SOURCES.txt` & `pyjls-0.7.1/pyjls.egg-info/SOURCES.txt`

 * *Files 7% similar despite different names*

```diff
@@ -39,20 +39,22 @@
 pyjls.egg-info/entry_points.txt
 pyjls.egg-info/requires.txt
 pyjls.egg-info/top_level.txt
 pyjls/entry_points/__init__.py
 pyjls/entry_points/annotate.py
 pyjls/entry_points/export.py
 pyjls/entry_points/info.py
+pyjls/entry_points/plot.py
 pyjls/test/__init__.py
 pyjls/test/test_binding.py
 pyjls/v1/__init__.py
 src/backend_posix.c
 src/backend_win.c
 src/bit_shift.c
+src/crc32c.c
 src/crc32c_arm_neon.c
 src/crc32c_intel_sse4.c
 src/crc32c_sw.c
 src/datatype.c
 src/ec.c
 src/log.c
 src/msg_ring_buffer.c
```

### Comparing `pyjls-0.7.0/pyproject.toml` & `pyjls-0.7.1/pyproject.toml`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,27 @@
-# Copyright 2022 Jetperch LLC
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# See https://peps.python.org/pep-0518/
-# See https://toml.io/
-
-[build-system]
-# Minimum requirements for the build system to execute.
-requires = [
-    "Cython",
-    "numpy",
-    "pywin32; sys_platform == 'win32'",
-    "setuptools",
-    "wheel",
-]
+# Copyright 2022 Jetperch LLC
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# See https://peps.python.org/pep-0518/
+# See https://toml.io/
+
+[build-system]
+# Minimum requirements for the build system to execute.
+requires = [
+    "Cython",
+    "numpy",
+    "pywin32; sys_platform == 'win32'",
+    "setuptools",
+    "wheel",
+]
+
```

### Comparing `pyjls-0.7.0/src/backend_posix.c` & `pyjls-0.7.1/src/backend_posix.c`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,305 +1,305 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/backend.h"
-#include "jls/wr_prv.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include "jls/time.h"
-
-#define _FILE_OFFSET_BITS
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <time.h>
-#include <pthread.h>
-#include <stdlib.h>
-#include <errno.h>
-
-
-// https://stackoverflow.com/questions/8883512/pthread-condition-variables-vs-win32-events-linux-vs-windows-ce
-struct event_flag {
-    pthread_mutex_t mutex;
-    pthread_cond_t  condition;
-    unsigned int    flag;
-};
-
-struct jls_bkt_s {
-    pthread_mutex_t msg_mutex;
-    pthread_mutex_t process_mutex;
-    struct event_flag * msg_event;
-    pthread_t thread;
-};
-
-// Simplified implementation, for backend purposed.
-struct jls_twr_s {
-    struct jls_bkt_s * bk;  // REQUIRED first entry
-};
-
-static struct event_flag* eventflag_create() {
-    struct event_flag* ev;
-    ev = (struct event_flag*) malloc(sizeof(struct event_flag));
-    pthread_mutex_init(&ev->mutex, NULL);
-    pthread_cond_init(&ev->condition, NULL);
-    ev->flag = 0;
-    return ev;
-}
-
-static void eventflag_destroy(struct event_flag * ev) {
-    if (ev) {
-        pthread_mutex_destroy(&ev->mutex);
-        pthread_cond_destroy(&ev->condition);
-        free(ev);
-    }
-}
-
-static void eventflag_wait(struct event_flag* ev) {
-    pthread_mutex_lock(&ev->mutex);
-    while (!ev->flag) {
-        pthread_cond_wait(&ev->condition, &ev->mutex);
-    }
-    ev->flag = 0;
-    pthread_mutex_unlock(&ev->mutex);
-}
-
-static void eventflag_set(struct event_flag* ev) {
-    pthread_mutex_lock(&ev->mutex);
-    ev->flag = 1;
-    pthread_cond_signal(&ev->condition);
-    pthread_mutex_unlock(&ev->mutex);
-}
-
-// https://docs.microsoft.com/en-us/cpp/c-runtime-library/low-level-i-o?view=msvc-160
-// The C standard library only gets in the way for JLS.
-int32_t jls_bk_fopen(struct jls_bkf_s * self, const char * filename, const char * mode) {
-    int oflag;
-    int fmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
-
-    switch (mode[0]) {
-        case 'w':
-            oflag = O_RDWR | O_CREAT | O_TRUNC;
-            break;
-        case 'r':
-            oflag = O_RDONLY;
-            break;
-        case 'a':
-            oflag = O_RDWR;
-            break;
-        default:
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-    self->fd = open(filename, oflag, fmode);
-    if (self->fd < 0) {
-        JLS_LOGW("open failed with %d: filename=%s, mode=%s", errno, filename, mode);
-        return JLS_ERROR_IO;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fclose(struct jls_bkf_s * self) {
-    if (self->fd != -1) {
-        close(self->fd);
-        self->fd = -1;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fwrite(struct jls_bkf_s * self, const void * buffer, unsigned int count) {
-    ssize_t sz = write(self->fd, buffer, count);
-    if (sz < 0) {
-        JLS_LOGE("write failed %d", errno);
-        return JLS_ERROR_IO;
-    }
-    self->fpos += sz;
-    if (self->fpos > self->fend) {
-        self->fend = self->fpos;
-    }
-    if ((unsigned int) sz != count) {
-        JLS_LOGE("write mismatch %zd != %u", sz, count);
-        return JLS_ERROR_IO;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fread(struct jls_bkf_s * self, void * const buffer, unsigned const buffer_size) {
-    int sz = read(self->fd, buffer, buffer_size);
-    if (sz < 0) {
-        JLS_LOGE("read failed %d", errno);
-        return JLS_ERROR_IO;
-    }
-    self->fpos += sz;
-    if ((unsigned int) sz != buffer_size) {
-        JLS_LOGE("write mismatch %d != %d", sz, buffer_size);
-        return JLS_ERROR_IO;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fseek(struct jls_bkf_s * self, int64_t offset, int origin) {
-    int64_t pos = lseek(self->fd, offset, origin);
-    if (pos < 0) {
-        JLS_LOGE("seek fail %d", errno);
-        return JLS_ERROR_IO;
-    }
-    if ((origin == SEEK_SET) && (pos != offset)) {
-        JLS_LOGE("seek fail %d", errno);
-        return JLS_ERROR_IO;
-    }
-    self->fpos = pos;
-    return 0;
-}
-
-int64_t jls_bk_ftell(struct jls_bkf_s * self) {
-    return lseek(self->fd, 0, SEEK_CUR);
-}
-
-int32_t jls_bk_fflush(struct jls_bkf_s * self) {
-    return fsync(self->fd);
-}
-
-static void * task(void * user_data) {
-    struct jls_twr_s * self = (struct jls_twr_s *) user_data;
-    jls_twr_run(self);
-    return NULL;
-}
-
-struct jls_bkt_s * jls_bkt_initialize(struct jls_twr_s * wr) {
-    struct jls_bkt_s * self = calloc(1, sizeof(struct jls_bkt_s));
-    if (!self) {
-        return NULL;
-    }
-
-    if (pthread_mutex_init(&self->msg_mutex, NULL)) {
-        JLS_LOGE("jls_bkt_initialize: msg_mutex failed");
-        jls_bkt_finalize(self);
-        return NULL;
-    }
-    if (pthread_mutex_init(&self->process_mutex, NULL)) {
-        JLS_LOGE("jls_bkt_initialize: process_mutex failed");
-        jls_bkt_finalize(self);
-        return NULL;
-    }
-
-    self->msg_event = eventflag_create();
-    if (!self->msg_event) {
-        JLS_LOGE("jls_bkt_initialize: eventflag_create failed");
-        jls_bkt_finalize(self);
-        return NULL;
-    }
-
-    wr->bk = self;
-    int rc = pthread_create(&self->thread, NULL, task, wr);
-    if (rc) {
-        JLS_LOGE("jls_bkt_initialize: pthread_create returned %d", rc);
-        jls_bkt_finalize(self);
-        wr->bk = NULL;
-        return NULL;
-    }
-    return self;
-}
-
-void jls_bkt_finalize(struct jls_bkt_s * self) {
-    if (self) {
-        if (self->thread) {
-            void * rv = NULL;
-            int rc = pthread_join(self->thread, &rv);
-            if (rc) {
-                JLS_LOGE("jls_bkt_finalize join failed with %d", rc);
-            }
-        }
-        if (self->msg_event) {
-            eventflag_destroy(self->msg_event);
-            self->msg_event = NULL;
-        }
-        pthread_mutex_destroy(&self->msg_mutex);
-        pthread_mutex_destroy(&self->process_mutex);
-        free(self);
-    }
-}
-
-int jls_bkt_msg_lock(struct jls_bkt_s * self) {
-    int rc = pthread_mutex_lock(&self->msg_mutex);
-    if (rc) {
-        JLS_LOGE("jls_bkt_msg_lock failed %d", (int) rc);
-    }
-    return rc;
-}
-
-int jls_bkt_msg_unlock(struct jls_bkt_s * self) {
-    int rc = pthread_mutex_unlock(&self->msg_mutex);
-    if (rc) {
-        JLS_LOGE("jls_bkt_msg_unlock failed %d", (int) rc);
-    }
-    return rc;
-}
-
-int jls_bkt_process_lock(struct jls_bkt_s * self) {
-    int rc = pthread_mutex_lock(&self->process_mutex);
-    if (rc) {
-        JLS_LOGE("jls_bkt_process_lock failed %d", (int) rc);
-    }
-    return rc;
-}
-
-int jls_bkt_process_unlock(struct jls_bkt_s * self) {
-    int rc = pthread_mutex_unlock(&self->process_mutex);
-    if (rc) {
-        JLS_LOGE("jls_bkt_process_unlock failed %d", (int) rc);
-    }
-    return rc;
-}
-
-void jls_bkt_msg_wait(struct jls_bkt_s * self) {
-    eventflag_wait(self->msg_event);
-}
-
-void jls_bkt_msg_signal(struct jls_bkt_s * self) {
-    eventflag_set(self->msg_event);
-}
-
-void jls_bkt_sleep_ms(uint32_t duration_ms) {
-    struct timespec ts;
-    int rv;
-    ts.tv_sec = duration_ms / 1000;
-    ts.tv_nsec = ((long) (duration_ms % 1000)) * 1000000;
-    do {
-        rv = nanosleep(&ts, &ts);
-    } while (rv && errno == EINTR);
-}
-
-int64_t jls_now(void) {
-    int64_t t;
-    struct timespec ts;
-    if (clock_gettime(CLOCK_REALTIME, &ts)) {
-        JLS_LOGE("clock_gettime error");
-    }
-    t = ((int64_t) ts.tv_sec + JLS_TIME_EPOCH_UNIX_OFFSET_SECONDS) * JLS_TIME_SECOND;
-    t += JLS_COUNTER_TO_TIME(ts.tv_nsec, 1000000000LL);
-    return t;
-}
-
-struct jls_time_counter_s jls_time_counter(void) {
-    struct jls_time_counter_s counter;
-    struct timespec ts;
-    if (clock_gettime(CLOCK_MONOTONIC, &ts)) {
-        JLS_LOGE("clock_gettime error");
-    }
-    counter.value = ((int64_t) ts.tv_sec + JLS_TIME_EPOCH_UNIX_OFFSET_SECONDS) * JLS_TIME_SECOND;
-    counter.value += JLS_COUNTER_TO_TIME(ts.tv_nsec, 1000000000LL);
-    counter.frequency = JLS_TIME_SECOND;
-    return counter;
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/backend.h"
+#include "jls/wr_prv.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include "jls/time.h"
+
+#define _FILE_OFFSET_BITS
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <time.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+// https://stackoverflow.com/questions/8883512/pthread-condition-variables-vs-win32-events-linux-vs-windows-ce
+struct event_flag {
+    pthread_mutex_t mutex;
+    pthread_cond_t  condition;
+    unsigned int    flag;
+};
+
+struct jls_bkt_s {
+    pthread_mutex_t msg_mutex;
+    pthread_mutex_t process_mutex;
+    struct event_flag * msg_event;
+    pthread_t thread;
+};
+
+// Simplified implementation, for backend purposed.
+struct jls_twr_s {
+    struct jls_bkt_s * bk;  // REQUIRED first entry
+};
+
+static struct event_flag* eventflag_create() {
+    struct event_flag* ev;
+    ev = (struct event_flag*) malloc(sizeof(struct event_flag));
+    pthread_mutex_init(&ev->mutex, NULL);
+    pthread_cond_init(&ev->condition, NULL);
+    ev->flag = 0;
+    return ev;
+}
+
+static void eventflag_destroy(struct event_flag * ev) {
+    if (ev) {
+        pthread_mutex_destroy(&ev->mutex);
+        pthread_cond_destroy(&ev->condition);
+        free(ev);
+    }
+}
+
+static void eventflag_wait(struct event_flag* ev) {
+    pthread_mutex_lock(&ev->mutex);
+    while (!ev->flag) {
+        pthread_cond_wait(&ev->condition, &ev->mutex);
+    }
+    ev->flag = 0;
+    pthread_mutex_unlock(&ev->mutex);
+}
+
+static void eventflag_set(struct event_flag* ev) {
+    pthread_mutex_lock(&ev->mutex);
+    ev->flag = 1;
+    pthread_cond_signal(&ev->condition);
+    pthread_mutex_unlock(&ev->mutex);
+}
+
+// https://docs.microsoft.com/en-us/cpp/c-runtime-library/low-level-i-o?view=msvc-160
+// The C standard library only gets in the way for JLS.
+int32_t jls_bk_fopen(struct jls_bkf_s * self, const char * filename, const char * mode) {
+    int oflag;
+    int fmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
+
+    switch (mode[0]) {
+        case 'w':
+            oflag = O_RDWR | O_CREAT | O_TRUNC;
+            break;
+        case 'r':
+            oflag = O_RDONLY;
+            break;
+        case 'a':
+            oflag = O_RDWR;
+            break;
+        default:
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+    self->fd = open(filename, oflag, fmode);
+    if (self->fd < 0) {
+        JLS_LOGW("open failed with %d: filename=%s, mode=%s", errno, filename, mode);
+        return JLS_ERROR_IO;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fclose(struct jls_bkf_s * self) {
+    if (self->fd != -1) {
+        close(self->fd);
+        self->fd = -1;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fwrite(struct jls_bkf_s * self, const void * buffer, unsigned int count) {
+    ssize_t sz = write(self->fd, buffer, count);
+    if (sz < 0) {
+        JLS_LOGE("write failed %d", errno);
+        return JLS_ERROR_IO;
+    }
+    self->fpos += sz;
+    if (self->fpos > self->fend) {
+        self->fend = self->fpos;
+    }
+    if ((unsigned int) sz != count) {
+        JLS_LOGE("write mismatch %zd != %u", sz, count);
+        return JLS_ERROR_IO;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fread(struct jls_bkf_s * self, void * const buffer, unsigned const buffer_size) {
+    int sz = read(self->fd, buffer, buffer_size);
+    if (sz < 0) {
+        JLS_LOGE("read failed %d", errno);
+        return JLS_ERROR_IO;
+    }
+    self->fpos += sz;
+    if ((unsigned int) sz != buffer_size) {
+        JLS_LOGE("write mismatch %d != %d", sz, buffer_size);
+        return JLS_ERROR_IO;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fseek(struct jls_bkf_s * self, int64_t offset, int origin) {
+    int64_t pos = lseek(self->fd, offset, origin);
+    if (pos < 0) {
+        JLS_LOGE("seek fail %d", errno);
+        return JLS_ERROR_IO;
+    }
+    if ((origin == SEEK_SET) && (pos != offset)) {
+        JLS_LOGE("seek fail %d", errno);
+        return JLS_ERROR_IO;
+    }
+    self->fpos = pos;
+    return 0;
+}
+
+int64_t jls_bk_ftell(struct jls_bkf_s * self) {
+    return lseek(self->fd, 0, SEEK_CUR);
+}
+
+int32_t jls_bk_fflush(struct jls_bkf_s * self) {
+    return fsync(self->fd);
+}
+
+static void * task(void * user_data) {
+    struct jls_twr_s * self = (struct jls_twr_s *) user_data;
+    jls_twr_run(self);
+    return NULL;
+}
+
+struct jls_bkt_s * jls_bkt_initialize(struct jls_twr_s * wr) {
+    struct jls_bkt_s * self = calloc(1, sizeof(struct jls_bkt_s));
+    if (!self) {
+        return NULL;
+    }
+
+    if (pthread_mutex_init(&self->msg_mutex, NULL)) {
+        JLS_LOGE("jls_bkt_initialize: msg_mutex failed");
+        jls_bkt_finalize(self);
+        return NULL;
+    }
+    if (pthread_mutex_init(&self->process_mutex, NULL)) {
+        JLS_LOGE("jls_bkt_initialize: process_mutex failed");
+        jls_bkt_finalize(self);
+        return NULL;
+    }
+
+    self->msg_event = eventflag_create();
+    if (!self->msg_event) {
+        JLS_LOGE("jls_bkt_initialize: eventflag_create failed");
+        jls_bkt_finalize(self);
+        return NULL;
+    }
+
+    wr->bk = self;
+    int rc = pthread_create(&self->thread, NULL, task, wr);
+    if (rc) {
+        JLS_LOGE("jls_bkt_initialize: pthread_create returned %d", rc);
+        jls_bkt_finalize(self);
+        wr->bk = NULL;
+        return NULL;
+    }
+    return self;
+}
+
+void jls_bkt_finalize(struct jls_bkt_s * self) {
+    if (self) {
+        if (self->thread) {
+            void * rv = NULL;
+            int rc = pthread_join(self->thread, &rv);
+            if (rc) {
+                JLS_LOGE("jls_bkt_finalize join failed with %d", rc);
+            }
+        }
+        if (self->msg_event) {
+            eventflag_destroy(self->msg_event);
+            self->msg_event = NULL;
+        }
+        pthread_mutex_destroy(&self->msg_mutex);
+        pthread_mutex_destroy(&self->process_mutex);
+        free(self);
+    }
+}
+
+int jls_bkt_msg_lock(struct jls_bkt_s * self) {
+    int rc = pthread_mutex_lock(&self->msg_mutex);
+    if (rc) {
+        JLS_LOGE("jls_bkt_msg_lock failed %d", (int) rc);
+    }
+    return rc;
+}
+
+int jls_bkt_msg_unlock(struct jls_bkt_s * self) {
+    int rc = pthread_mutex_unlock(&self->msg_mutex);
+    if (rc) {
+        JLS_LOGE("jls_bkt_msg_unlock failed %d", (int) rc);
+    }
+    return rc;
+}
+
+int jls_bkt_process_lock(struct jls_bkt_s * self) {
+    int rc = pthread_mutex_lock(&self->process_mutex);
+    if (rc) {
+        JLS_LOGE("jls_bkt_process_lock failed %d", (int) rc);
+    }
+    return rc;
+}
+
+int jls_bkt_process_unlock(struct jls_bkt_s * self) {
+    int rc = pthread_mutex_unlock(&self->process_mutex);
+    if (rc) {
+        JLS_LOGE("jls_bkt_process_unlock failed %d", (int) rc);
+    }
+    return rc;
+}
+
+void jls_bkt_msg_wait(struct jls_bkt_s * self) {
+    eventflag_wait(self->msg_event);
+}
+
+void jls_bkt_msg_signal(struct jls_bkt_s * self) {
+    eventflag_set(self->msg_event);
+}
+
+void jls_bkt_sleep_ms(uint32_t duration_ms) {
+    struct timespec ts;
+    int rv;
+    ts.tv_sec = duration_ms / 1000;
+    ts.tv_nsec = ((long) (duration_ms % 1000)) * 1000000;
+    do {
+        rv = nanosleep(&ts, &ts);
+    } while (rv && errno == EINTR);
+}
+
+int64_t jls_now(void) {
+    int64_t t;
+    struct timespec ts;
+    if (clock_gettime(CLOCK_REALTIME, &ts)) {
+        JLS_LOGE("clock_gettime error");
+    }
+    t = ((int64_t) ts.tv_sec + JLS_TIME_EPOCH_UNIX_OFFSET_SECONDS) * JLS_TIME_SECOND;
+    t += JLS_COUNTER_TO_TIME(ts.tv_nsec, 1000000000LL);
+    return t;
+}
+
+struct jls_time_counter_s jls_time_counter(void) {
+    struct jls_time_counter_s counter;
+    struct timespec ts;
+    if (clock_gettime(CLOCK_MONOTONIC, &ts)) {
+        JLS_LOGE("clock_gettime error");
+    }
+    counter.value = ((int64_t) ts.tv_sec + JLS_TIME_EPOCH_UNIX_OFFSET_SECONDS) * JLS_TIME_SECOND;
+    counter.value += JLS_COUNTER_TO_TIME(ts.tv_nsec, 1000000000LL);
+    counter.frequency = JLS_TIME_SECOND;
+    return counter;
+}
```

### Comparing `pyjls-0.7.0/src/backend_win.c` & `pyjls-0.7.1/src/backend_win.c`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,295 +1,295 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/backend.h"
-#include "jls/wr_prv.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include "jls/time.h"
-
-#include <windows.h>
-#include <io.h>
-#include <fcntl.h>
-#include <sys\stat.h>
-#include <share.h>
-
-
-struct jls_bkt_s {
-    HANDLE msg_mutex;
-    HANDLE process_mutex;
-    HANDLE msg_event;
-    HANDLE thread;
-};
-
-// Simplified implementation, for backend purposed.
-struct jls_twr_s {
-    struct jls_bkt_s * bk;  // REQUIRED first entry
-};
-
-// https://docs.microsoft.com/en-us/cpp/c-runtime-library/low-level-i-o?view=msvc-160
-// The C standard library only gets in the way for JLS.
-int32_t jls_bk_fopen(struct jls_bkf_s * self, const char * filename, const char * mode) {
-    int oflag;
-    int shflag;
-
-    switch (mode[0]) {
-        case 'w':
-            oflag = _O_BINARY | _O_CREAT | _O_RDWR | _O_RANDOM | _O_TRUNC;
-            shflag = _SH_DENYWR;
-            break;
-        case 'r':
-            oflag = _O_BINARY | _O_RDONLY | _O_RANDOM;
-            shflag = _SH_DENYNO;
-            break;
-        case 'a':
-            oflag = _O_BINARY | _O_RDWR | _O_RANDOM;
-            shflag = _SH_DENYWR;
-            break;
-        default:
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-    errno_t err = _sopen_s(&self->fd, filename, oflag, shflag, _S_IREAD | _S_IWRITE);
-    if (err != 0) {
-        JLS_LOGW("open failed with %d: filename=%s, mode=%s", err, filename, mode);
-        return JLS_ERROR_IO;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fclose(struct jls_bkf_s * self) {
-    if (self->fd != -1) {
-        _close(self->fd);
-        self->fd = -1;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fwrite(struct jls_bkf_s * self, const void * buffer, unsigned int count) {
-    int sz = _write(self->fd, buffer, count);
-    if (sz < 0) {
-        JLS_LOGE("write failed %d", errno);
-        return JLS_ERROR_IO;
-    }
-    self->fpos += sz;
-    if (self->fpos > self->fend) {
-        self->fend = self->fpos;
-    }
-    if ((unsigned int) sz != count) {
-        JLS_LOGE("write mismatch %d != %d", sz, count);
-        return JLS_ERROR_IO;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fread(struct jls_bkf_s * self, void * const buffer, unsigned const buffer_size) {
-    int sz = _read(self->fd, buffer, buffer_size);
-    if (sz < 0) {
-        JLS_LOGE("read failed %d", errno);
-        return JLS_ERROR_IO;
-    }
-    self->fpos += sz;
-    if ((unsigned int) sz != buffer_size) {
-        JLS_LOGE("write mismatch %d != %d", sz, buffer_size);
-        return JLS_ERROR_IO;
-    }
-    return 0;
-}
-
-int32_t jls_bk_fseek(struct jls_bkf_s * self, int64_t offset, int origin) {
-    int64_t pos = _lseeki64(self->fd, offset, origin);
-    if (pos < 0) {
-        JLS_LOGE("seek fail %d", errno);
-        return JLS_ERROR_IO;
-    }
-    if ((origin == SEEK_SET) && (pos != offset)) {
-        JLS_LOGE("seek fail %d", errno);
-        return JLS_ERROR_IO;
-    }
-    self->fpos = pos;
-    return 0;
-}
-
-int64_t jls_bk_ftell(struct jls_bkf_s * self) {
-    return _telli64(self->fd);
-}
-
-int32_t jls_bk_fflush(struct jls_bkf_s * self) {
-    return _commit(self->fd);
-}
-
-static DWORD WINAPI task(LPVOID lpParam) {
-    struct jls_twr_s * self = (struct jls_twr_s *) lpParam;
-    return jls_twr_run(self);
-}
-
-
-struct jls_bkt_s * jls_bkt_initialize(struct jls_twr_s * wr) {
-    struct jls_bkt_s * self = calloc(1, sizeof(struct jls_bkt_s));
-    if (!self) {
-        return NULL;
-    }
-    self->msg_mutex = CreateMutex(
-            NULL,                   // default security attributes
-            FALSE,                  // initially not owned
-            NULL);                  // unnamed mutex
-    if (!self->msg_mutex) {
-        jls_bkt_finalize(self);
-        return NULL;
-    }
-
-    self->process_mutex = CreateMutex(
-            NULL,                   // default security attributes
-            FALSE,                  // initially not owned
-            NULL);                  // unnamed mutex
-    if (!self->process_mutex) {
-        jls_bkt_finalize(self);
-        return NULL;
-    }
-
-    self->msg_event = CreateEvent(NULL, TRUE, FALSE, NULL);
-    if (!self->msg_event) {
-        jls_bkt_finalize(self);
-        return NULL;
-    }
-
-    wr->bk = self;
-    self->thread = CreateThread(
-            NULL,                   // default security attributes
-            0,                      // use default stack size
-            task,                   // thread function name
-            wr,                     // argument to thread function
-            0,                      // use default creation flags
-            NULL);                  // returns the thread identifier
-    if (!self->thread) {
-        jls_bkt_finalize(self);
-        wr->bk = NULL;
-        return NULL;
-    }
-    if (!SetThreadPriority(self->thread, THREAD_PRIORITY_ABOVE_NORMAL)) {
-        JLS_LOGW("Could not reduce thread priority: %d", (int) GetLastError());
-    }
-    return self;
-}
-
-void jls_bkt_finalize(struct jls_bkt_s * self) {
-    if (self) {
-        if (self->thread) {
-            DWORD rc = WaitForSingleObject(self->thread, JLS_BK_CLOSE_TIMEOUT_MS);
-            if (WAIT_OBJECT_0 != rc) {
-                JLS_LOGE("thread close wait failed %d", (int) rc);
-            }
-            CloseHandle(self->thread);
-            self->thread = NULL;
-        }
-        if (self->msg_event) {
-            CloseHandle(self->msg_event);
-            self->msg_event = NULL;
-        }
-        if (self->msg_mutex) {
-            CloseHandle(self->msg_mutex);
-            self->msg_mutex = NULL;
-        }
-        if (self->process_mutex) {
-            CloseHandle(self->process_mutex);
-            self->process_mutex = NULL;
-        }
-        free(self);
-    }
-}
-
-int jls_bkt_msg_lock(struct jls_bkt_s * self) {
-    DWORD rc = WaitForSingleObject(self->msg_mutex, JLS_BK_MSG_LOCK_TIMEOUT_MS);
-    if (WAIT_OBJECT_0 != rc) {
-        JLS_LOGE("jls_bkt_msg_lock failed %d", (int) rc);
-        return rc;
-    }
-    return 0;
-}
-
-int jls_bkt_msg_unlock(struct jls_bkt_s * self) {
-    if (!ReleaseMutex(self->msg_mutex)) {
-        JLS_LOGE("jls_bkt_msg_unlock failed");
-        return 1;
-    }
-    return 0;
-}
-
-int jls_bkt_process_lock(struct jls_bkt_s * self) {
-    DWORD rc = WaitForSingleObject(self->process_mutex, JLS_BK_PROCESS_LOCK_TIMEOUT_MS);
-    if (WAIT_OBJECT_0 != rc) {
-        JLS_LOGE("jls_bkt_msg_lock failed %d", (int) rc);
-        return rc;
-    }
-    return 0;
-}
-
-int jls_bkt_process_unlock(struct jls_bkt_s * self) {
-    if (!ReleaseMutex(self->process_mutex)) {
-        JLS_LOGE("jls_bkt_msg_unlock failed");
-        return 1;
-    }
-    return 0;
-}
-
-void jls_bkt_msg_wait(struct jls_bkt_s * self) {
-    WaitForSingleObject(self->msg_event, 10);
-    ResetEvent(self->msg_event);
-}
-
-void jls_bkt_msg_signal(struct jls_bkt_s * self) {
-    SetEvent(self->msg_event);
-}
-
-void jls_bkt_sleep_ms(uint32_t duration_ms) {
-    Sleep(duration_ms);
-}
-
-
-int64_t jls_now(void) {
-    // Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
-    // python
-    // import dateutil.parser
-    // dateutil.parser.parse('2018-01-01T00:00:00Z').timestamp() - dateutil.parser.parse('1601-01-01T00:00:00Z').timestamp()
-    static const int64_t offset_s = 131592384000000000LL;  // 100 ns
-    static const uint64_t frequency = 10000000; // 100 ns
-    FILETIME filetime;
-    GetSystemTimePreciseAsFileTime(&filetime);
-    uint64_t t = ((uint64_t) filetime.dwLowDateTime) | (((uint64_t) filetime.dwHighDateTime) << 32);
-    t -= offset_s;
-    return JLS_COUNTER_TO_TIME(t, frequency);
-}
-
-struct jls_time_counter_s jls_time_counter(void) {
-    struct jls_time_counter_s counter;
-    static int first = 1;
-    static uint64_t offset = 0;     // in 34Q30 time
-    static LARGE_INTEGER perf_frequency = {.QuadPart = 0};
-
-    // https://docs.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps
-    LARGE_INTEGER perf_counter;
-
-    QueryPerformanceCounter(&perf_counter);
-
-    if (first) {
-        QueryPerformanceFrequency(&perf_frequency);
-        offset = perf_counter.QuadPart;
-        first = 0;
-    }
-
-    counter.value = perf_counter.QuadPart - offset;
-    counter.frequency = perf_frequency.QuadPart;
-    return counter;
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/backend.h"
+#include "jls/wr_prv.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include "jls/time.h"
+
+#include <windows.h>
+#include <io.h>
+#include <fcntl.h>
+#include <sys\stat.h>
+#include <share.h>
+
+
+struct jls_bkt_s {
+    HANDLE msg_mutex;
+    HANDLE process_mutex;
+    HANDLE msg_event;
+    HANDLE thread;
+};
+
+// Simplified implementation, for backend purposed.
+struct jls_twr_s {
+    struct jls_bkt_s * bk;  // REQUIRED first entry
+};
+
+// https://docs.microsoft.com/en-us/cpp/c-runtime-library/low-level-i-o?view=msvc-160
+// The C standard library only gets in the way for JLS.
+int32_t jls_bk_fopen(struct jls_bkf_s * self, const char * filename, const char * mode) {
+    int oflag;
+    int shflag;
+
+    switch (mode[0]) {
+        case 'w':
+            oflag = _O_BINARY | _O_CREAT | _O_RDWR | _O_RANDOM | _O_TRUNC;
+            shflag = _SH_DENYWR;
+            break;
+        case 'r':
+            oflag = _O_BINARY | _O_RDONLY | _O_RANDOM;
+            shflag = _SH_DENYNO;
+            break;
+        case 'a':
+            oflag = _O_BINARY | _O_RDWR | _O_RANDOM;
+            shflag = _SH_DENYWR;
+            break;
+        default:
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+    errno_t err = _sopen_s(&self->fd, filename, oflag, shflag, _S_IREAD | _S_IWRITE);
+    if (err != 0) {
+        JLS_LOGW("open failed with %d: filename=%s, mode=%s", err, filename, mode);
+        return JLS_ERROR_IO;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fclose(struct jls_bkf_s * self) {
+    if (self->fd != -1) {
+        _close(self->fd);
+        self->fd = -1;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fwrite(struct jls_bkf_s * self, const void * buffer, unsigned int count) {
+    int sz = _write(self->fd, buffer, count);
+    if (sz < 0) {
+        JLS_LOGE("write failed %d", errno);
+        return JLS_ERROR_IO;
+    }
+    self->fpos += sz;
+    if (self->fpos > self->fend) {
+        self->fend = self->fpos;
+    }
+    if ((unsigned int) sz != count) {
+        JLS_LOGE("write mismatch %d != %d", sz, count);
+        return JLS_ERROR_IO;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fread(struct jls_bkf_s * self, void * const buffer, unsigned const buffer_size) {
+    int sz = _read(self->fd, buffer, buffer_size);
+    if (sz < 0) {
+        JLS_LOGE("read failed %d", errno);
+        return JLS_ERROR_IO;
+    }
+    self->fpos += sz;
+    if ((unsigned int) sz != buffer_size) {
+        JLS_LOGE("write mismatch %d != %d", sz, buffer_size);
+        return JLS_ERROR_IO;
+    }
+    return 0;
+}
+
+int32_t jls_bk_fseek(struct jls_bkf_s * self, int64_t offset, int origin) {
+    int64_t pos = _lseeki64(self->fd, offset, origin);
+    if (pos < 0) {
+        JLS_LOGE("seek fail %d", errno);
+        return JLS_ERROR_IO;
+    }
+    if ((origin == SEEK_SET) && (pos != offset)) {
+        JLS_LOGE("seek fail %d", errno);
+        return JLS_ERROR_IO;
+    }
+    self->fpos = pos;
+    return 0;
+}
+
+int64_t jls_bk_ftell(struct jls_bkf_s * self) {
+    return _telli64(self->fd);
+}
+
+int32_t jls_bk_fflush(struct jls_bkf_s * self) {
+    return _commit(self->fd);
+}
+
+static DWORD WINAPI task(LPVOID lpParam) {
+    struct jls_twr_s * self = (struct jls_twr_s *) lpParam;
+    return jls_twr_run(self);
+}
+
+
+struct jls_bkt_s * jls_bkt_initialize(struct jls_twr_s * wr) {
+    struct jls_bkt_s * self = calloc(1, sizeof(struct jls_bkt_s));
+    if (!self) {
+        return NULL;
+    }
+    self->msg_mutex = CreateMutex(
+            NULL,                   // default security attributes
+            FALSE,                  // initially not owned
+            NULL);                  // unnamed mutex
+    if (!self->msg_mutex) {
+        jls_bkt_finalize(self);
+        return NULL;
+    }
+
+    self->process_mutex = CreateMutex(
+            NULL,                   // default security attributes
+            FALSE,                  // initially not owned
+            NULL);                  // unnamed mutex
+    if (!self->process_mutex) {
+        jls_bkt_finalize(self);
+        return NULL;
+    }
+
+    self->msg_event = CreateEvent(NULL, TRUE, FALSE, NULL);
+    if (!self->msg_event) {
+        jls_bkt_finalize(self);
+        return NULL;
+    }
+
+    wr->bk = self;
+    self->thread = CreateThread(
+            NULL,                   // default security attributes
+            0,                      // use default stack size
+            task,                   // thread function name
+            wr,                     // argument to thread function
+            0,                      // use default creation flags
+            NULL);                  // returns the thread identifier
+    if (!self->thread) {
+        jls_bkt_finalize(self);
+        wr->bk = NULL;
+        return NULL;
+    }
+    if (!SetThreadPriority(self->thread, THREAD_PRIORITY_ABOVE_NORMAL)) {
+        JLS_LOGW("Could not reduce thread priority: %d", (int) GetLastError());
+    }
+    return self;
+}
+
+void jls_bkt_finalize(struct jls_bkt_s * self) {
+    if (self) {
+        if (self->thread) {
+            DWORD rc = WaitForSingleObject(self->thread, JLS_BK_CLOSE_TIMEOUT_MS);
+            if (WAIT_OBJECT_0 != rc) {
+                JLS_LOGE("thread close wait failed %d", (int) rc);
+            }
+            CloseHandle(self->thread);
+            self->thread = NULL;
+        }
+        if (self->msg_event) {
+            CloseHandle(self->msg_event);
+            self->msg_event = NULL;
+        }
+        if (self->msg_mutex) {
+            CloseHandle(self->msg_mutex);
+            self->msg_mutex = NULL;
+        }
+        if (self->process_mutex) {
+            CloseHandle(self->process_mutex);
+            self->process_mutex = NULL;
+        }
+        free(self);
+    }
+}
+
+int jls_bkt_msg_lock(struct jls_bkt_s * self) {
+    DWORD rc = WaitForSingleObject(self->msg_mutex, JLS_BK_MSG_LOCK_TIMEOUT_MS);
+    if (WAIT_OBJECT_0 != rc) {
+        JLS_LOGE("jls_bkt_msg_lock failed %d", (int) rc);
+        return rc;
+    }
+    return 0;
+}
+
+int jls_bkt_msg_unlock(struct jls_bkt_s * self) {
+    if (!ReleaseMutex(self->msg_mutex)) {
+        JLS_LOGE("jls_bkt_msg_unlock failed");
+        return 1;
+    }
+    return 0;
+}
+
+int jls_bkt_process_lock(struct jls_bkt_s * self) {
+    DWORD rc = WaitForSingleObject(self->process_mutex, JLS_BK_PROCESS_LOCK_TIMEOUT_MS);
+    if (WAIT_OBJECT_0 != rc) {
+        JLS_LOGE("jls_bkt_msg_lock failed %d", (int) rc);
+        return rc;
+    }
+    return 0;
+}
+
+int jls_bkt_process_unlock(struct jls_bkt_s * self) {
+    if (!ReleaseMutex(self->process_mutex)) {
+        JLS_LOGE("jls_bkt_msg_unlock failed");
+        return 1;
+    }
+    return 0;
+}
+
+void jls_bkt_msg_wait(struct jls_bkt_s * self) {
+    WaitForSingleObject(self->msg_event, 10);
+    ResetEvent(self->msg_event);
+}
+
+void jls_bkt_msg_signal(struct jls_bkt_s * self) {
+    SetEvent(self->msg_event);
+}
+
+void jls_bkt_sleep_ms(uint32_t duration_ms) {
+    Sleep(duration_ms);
+}
+
+
+int64_t jls_now(void) {
+    // Contains a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601 (UTC).
+    // python
+    // import dateutil.parser
+    // dateutil.parser.parse('2018-01-01T00:00:00Z').timestamp() - dateutil.parser.parse('1601-01-01T00:00:00Z').timestamp()
+    static const int64_t offset_s = 131592384000000000LL;  // 100 ns
+    static const uint64_t frequency = 10000000; // 100 ns
+    FILETIME filetime;
+    GetSystemTimePreciseAsFileTime(&filetime);
+    uint64_t t = ((uint64_t) filetime.dwLowDateTime) | (((uint64_t) filetime.dwHighDateTime) << 32);
+    t -= offset_s;
+    return JLS_COUNTER_TO_TIME(t, frequency);
+}
+
+struct jls_time_counter_s jls_time_counter(void) {
+    struct jls_time_counter_s counter;
+    static int first = 1;
+    static uint64_t offset = 0;     // in 34Q30 time
+    static LARGE_INTEGER perf_frequency = {.QuadPart = 0};
+
+    // https://docs.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps
+    LARGE_INTEGER perf_counter;
+
+    QueryPerformanceCounter(&perf_counter);
+
+    if (first) {
+        QueryPerformanceFrequency(&perf_frequency);
+        offset = perf_counter.QuadPart;
+        first = 0;
+    }
+
+    counter.value = perf_counter.QuadPart - offset;
+    counter.frequency = perf_frequency.QuadPart;
+    return counter;
+}
```

### Comparing `pyjls-0.7.0/src/bit_shift.c` & `pyjls-0.7.1/src/bit_shift.c`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-/*
- * Copyright 2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/bit_shift.h"
-#include "jls/ec.h"
-
-int32_t jls_bit_shift_array_right(uint8_t bits, void * data, size_t size) {
-    if ((bits == 0) || (size == 0)) {
-        return 0;
-    }
-    if (bits >= 8) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    uint8_t * u8 = (uint8_t *) data;
-    if (size == 1) {
-        u8[0] >>= bits;
-        return 0;
-    }
-    uint8_t carry = u8[0] >> bits;
-    for (size_t i = 1; i < size; ++i) {
-        u8[i - 1] = (u8[i] << (8 - bits)) | carry;
-        carry = u8[i] >> bits;
-    }
-    return 0;
-}
+/*
+ * Copyright 2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/bit_shift.h"
+#include "jls/ec.h"
+
+int32_t jls_bit_shift_array_right(uint8_t bits, void * data, size_t size) {
+    if ((bits == 0) || (size == 0)) {
+        return 0;
+    }
+    if (bits >= 8) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    uint8_t * u8 = (uint8_t *) data;
+    if (size == 1) {
+        u8[0] >>= bits;
+        return 0;
+    }
+    uint8_t carry = u8[0] >> bits;
+    for (size_t i = 1; i < size; ++i) {
+        u8[i - 1] = (u8[i] << (8 - bits)) | carry;
+        carry = u8[i] >> bits;
+    }
+    return 0;
+}
```

### Comparing `pyjls-0.7.0/src/crc32c_intel_sse4.c` & `pyjls-0.7.1/src/crc32c_intel_sse4.c`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-/*
- * Copyright 2014-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/crc32c.h"
-#include <nmmintrin.h>
-#include <assert.h>
-// https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=crc&expand=1288
-// Could consider https://github.com/htot/crc32c/blob/master/crc32c/crc_iscsi_v_pcl.asm
-
-uint32_t jls_crc32c_hdr(const struct jls_chunk_header_s * hdr) {
-    uint32_t crc32;
-#if defined(__x86_64__) || defined(_M_X64)
-    uint64_t crc64;
-    assert(0 == (0x7 & (intptr_t) hdr));
-    const uint64_t * data = (const uint64_t *) hdr;
-    crc64 = _mm_crc32_u64(0xFFFFFFFF, data[0]);
-    crc64 = _mm_crc32_u64(crc64, data[1]);
-    crc64 = _mm_crc32_u64(crc64, data[2]);
-    crc32 = _mm_crc32_u32((uint32_t) crc64, (uint32_t) data[3]);
-#else
-    assert(0 == (0x3 & (intptr_t) hdr));
-    const uint32_t * data = (const uint32_t *) hdr;
-    crc32 = _mm_crc32_u32(0xFFFFFFFF, data[0]);
-    crc32 = _mm_crc32_u32(crc32, data[1]);
-    crc32 = _mm_crc32_u32(crc32, data[2]);
-    crc32 = _mm_crc32_u32(crc32, data[3]);
-    crc32 = _mm_crc32_u32(crc32, data[4]);
-    crc32 = _mm_crc32_u32(crc32, data[5]);
-    crc32 = _mm_crc32_u32(crc32, data[6]);
-#endif
-    return (crc32 ^ 0xFFFFFFFF);
-}
-
-uint32_t jls_crc32c(uint8_t const *data, uint32_t length) {
-    uint32_t crc = 0xFFFFFFFF;
-    for (; ((length > 0) && (0x7 & (intptr_t) data)); ++data, --length) {
-        crc = _mm_crc32_u8(crc, *data);
-    }
-#if defined(__x86_64__) || defined(_M_X64)
-    for (; length >= 8; data += 8, length -= 8) {
-        crc = (uint32_t) _mm_crc32_u64(crc, *((const uint64_t *) data));
-    }
-#else
-    for (; length >= 4; data += 4, length -= 4) {
-        crc = _mm_crc32_u32(crc, *((const uint32_t *) data));
-    }
-#endif
-    for (; length > 0; ++data, --length) {
-        crc = _mm_crc32_u8(crc, *data);
-    }
-    return (crc ^ 0xFFFFFFFF);
-}
+/*
+ * Copyright 2014-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/crc32c.h"
+#include <nmmintrin.h>
+#include <assert.h>
+// https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=crc&expand=1288
+// Could consider https://github.com/htot/crc32c/blob/master/crc32c/crc_iscsi_v_pcl.asm
+
+uint32_t jls_crc32c_hdr(const struct jls_chunk_header_s * hdr) {
+    uint32_t crc32;
+#if defined(__x86_64__) || defined(_M_X64)
+    uint64_t crc64;
+    assert(0 == (0x7 & (intptr_t) hdr));
+    const uint64_t * data = (const uint64_t *) hdr;
+    crc64 = _mm_crc32_u64(0xFFFFFFFF, data[0]);
+    crc64 = _mm_crc32_u64(crc64, data[1]);
+    crc64 = _mm_crc32_u64(crc64, data[2]);
+    crc32 = _mm_crc32_u32((uint32_t) crc64, (uint32_t) data[3]);
+#else
+    assert(0 == (0x3 & (intptr_t) hdr));
+    const uint32_t * data = (const uint32_t *) hdr;
+    crc32 = _mm_crc32_u32(0xFFFFFFFF, data[0]);
+    crc32 = _mm_crc32_u32(crc32, data[1]);
+    crc32 = _mm_crc32_u32(crc32, data[2]);
+    crc32 = _mm_crc32_u32(crc32, data[3]);
+    crc32 = _mm_crc32_u32(crc32, data[4]);
+    crc32 = _mm_crc32_u32(crc32, data[5]);
+    crc32 = _mm_crc32_u32(crc32, data[6]);
+#endif
+    return (crc32 ^ 0xFFFFFFFF);
+}
+
+uint32_t jls_crc32c(uint8_t const *data, uint32_t length) {
+    uint32_t crc = 0xFFFFFFFF;
+    for (; ((length > 0) && (0x7 & (intptr_t) data)); ++data, --length) {
+        crc = _mm_crc32_u8(crc, *data);
+    }
+#if defined(__x86_64__) || defined(_M_X64)
+    for (; length >= 8; data += 8, length -= 8) {
+        crc = (uint32_t) _mm_crc32_u64(crc, *((const uint64_t *) data));
+    }
+#else
+    for (; length >= 4; data += 4, length -= 4) {
+        crc = _mm_crc32_u32(crc, *((const uint32_t *) data));
+    }
+#endif
+    for (; length > 0; ++data, --length) {
+        crc = _mm_crc32_u8(crc, *data);
+    }
+    return (crc ^ 0xFFFFFFFF);
+}
```

### Comparing `pyjls-0.7.0/src/crc32c_sw.c` & `pyjls-0.7.1/src/crc32c_sw.c`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,542 +1,542 @@
-// Copyright 2008,2009,2010 Massachusetts Institute of Technology.
-// All rights reserved. Use of this source code is governed by a
-// BSD-style license that can be found in the LICENSE.slice-by-8 file.
-
-// Implementations adapted from Intel's Slicing By 8 Sourceforge Project
-// http://sourceforge.net/projects/slicing-by-8/
-/*
- * Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved
- *
- *
- * This software program is licensed subject to the BSD License,
- * available at http://www.opensource.org/licenses/bsd-license.html.
- *
- * Abstract:
- *
- *  Tables for software CRC generation
- */
-
-
-/* Tables generated with code like the following:
-
-#define CRCPOLY 0x82f63b78 // reversed 0x1EDC6F41
-#define CRCINIT 0xFFFFFFFF
-
-void init() {
-    for (uint32_t i = 0; i <= 0xFF; i++) {
-        uint32_t x = i;
-        for (uint32_t j = 0; j < 8; j++)
-            x = (x>>1) ^ (CRCPOLY & (-(int32_t)(x & 1)));
-        g_crc_slicing[0][i] = x;
-    }
-
-    for (uint32_t i = 0; i <= 0xFF; i++) {
-        uint32_t c = g_crc_slicing[0][i];
-        for (uint32_t j = 1; j < 8; j++) {
-            c = g_crc_slicing[0][c & 0xFF] ^ (c >> 8);
-            g_crc_slicing[j][i] = c;
-        }
-    }
-}
-*/
-
-#include "jls/crc32c.h"
-#include <stddef.h>
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o32[256] =
-{
- 0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,
- 0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
- 0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,
- 0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
- 0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,
- 0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
- 0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,
- 0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
- 0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,
- 0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
- 0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,
- 0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
- 0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,
- 0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
- 0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,
- 0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
- 0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,
- 0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
- 0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,
- 0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
- 0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,
- 0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
- 0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,
- 0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
- 0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,
- 0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
- 0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,
- 0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
- 0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
- 0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
- 0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
- 0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o32
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o40[256] =
-{
- 0x00000000, 0x13A29877, 0x274530EE, 0x34E7A899, 0x4E8A61DC, 0x5D28F9AB, 0x69CF5132, 0x7A6DC945,
- 0x9D14C3B8, 0x8EB65BCF, 0xBA51F356, 0xA9F36B21, 0xD39EA264, 0xC03C3A13, 0xF4DB928A, 0xE7790AFD,
- 0x3FC5F181, 0x2C6769F6, 0x1880C16F, 0x0B225918, 0x714F905D, 0x62ED082A, 0x560AA0B3, 0x45A838C4,
- 0xA2D13239, 0xB173AA4E, 0x859402D7, 0x96369AA0, 0xEC5B53E5, 0xFFF9CB92, 0xCB1E630B, 0xD8BCFB7C,
- 0x7F8BE302, 0x6C297B75, 0x58CED3EC, 0x4B6C4B9B, 0x310182DE, 0x22A31AA9, 0x1644B230, 0x05E62A47,
- 0xE29F20BA, 0xF13DB8CD, 0xC5DA1054, 0xD6788823, 0xAC154166, 0xBFB7D911, 0x8B507188, 0x98F2E9FF,
- 0x404E1283, 0x53EC8AF4, 0x670B226D, 0x74A9BA1A, 0x0EC4735F, 0x1D66EB28, 0x298143B1, 0x3A23DBC6,
- 0xDD5AD13B, 0xCEF8494C, 0xFA1FE1D5, 0xE9BD79A2, 0x93D0B0E7, 0x80722890, 0xB4958009, 0xA737187E,
- 0xFF17C604, 0xECB55E73, 0xD852F6EA, 0xCBF06E9D, 0xB19DA7D8, 0xA23F3FAF, 0x96D89736, 0x857A0F41,
- 0x620305BC, 0x71A19DCB, 0x45463552, 0x56E4AD25, 0x2C896460, 0x3F2BFC17, 0x0BCC548E, 0x186ECCF9,
- 0xC0D23785, 0xD370AFF2, 0xE797076B, 0xF4359F1C, 0x8E585659, 0x9DFACE2E, 0xA91D66B7, 0xBABFFEC0,
- 0x5DC6F43D, 0x4E646C4A, 0x7A83C4D3, 0x69215CA4, 0x134C95E1, 0x00EE0D96, 0x3409A50F, 0x27AB3D78,
- 0x809C2506, 0x933EBD71, 0xA7D915E8, 0xB47B8D9F, 0xCE1644DA, 0xDDB4DCAD, 0xE9537434, 0xFAF1EC43,
- 0x1D88E6BE, 0x0E2A7EC9, 0x3ACDD650, 0x296F4E27, 0x53028762, 0x40A01F15, 0x7447B78C, 0x67E52FFB,
- 0xBF59D487, 0xACFB4CF0, 0x981CE469, 0x8BBE7C1E, 0xF1D3B55B, 0xE2712D2C, 0xD69685B5, 0xC5341DC2,
- 0x224D173F, 0x31EF8F48, 0x050827D1, 0x16AABFA6, 0x6CC776E3, 0x7F65EE94, 0x4B82460D, 0x5820DE7A,
- 0xFBC3FAF9, 0xE861628E, 0xDC86CA17, 0xCF245260, 0xB5499B25, 0xA6EB0352, 0x920CABCB, 0x81AE33BC,
- 0x66D73941, 0x7575A136, 0x419209AF, 0x523091D8, 0x285D589D, 0x3BFFC0EA, 0x0F186873, 0x1CBAF004,
- 0xC4060B78, 0xD7A4930F, 0xE3433B96, 0xF0E1A3E1, 0x8A8C6AA4, 0x992EF2D3, 0xADC95A4A, 0xBE6BC23D,
- 0x5912C8C0, 0x4AB050B7, 0x7E57F82E, 0x6DF56059, 0x1798A91C, 0x043A316B, 0x30DD99F2, 0x237F0185,
- 0x844819FB, 0x97EA818C, 0xA30D2915, 0xB0AFB162, 0xCAC27827, 0xD960E050, 0xED8748C9, 0xFE25D0BE,
- 0x195CDA43, 0x0AFE4234, 0x3E19EAAD, 0x2DBB72DA, 0x57D6BB9F, 0x447423E8, 0x70938B71, 0x63311306,
- 0xBB8DE87A, 0xA82F700D, 0x9CC8D894, 0x8F6A40E3, 0xF50789A6, 0xE6A511D1, 0xD242B948, 0xC1E0213F,
- 0x26992BC2, 0x353BB3B5, 0x01DC1B2C, 0x127E835B, 0x68134A1E, 0x7BB1D269, 0x4F567AF0, 0x5CF4E287,
- 0x04D43CFD, 0x1776A48A, 0x23910C13, 0x30339464, 0x4A5E5D21, 0x59FCC556, 0x6D1B6DCF, 0x7EB9F5B8,
- 0x99C0FF45, 0x8A626732, 0xBE85CFAB, 0xAD2757DC, 0xD74A9E99, 0xC4E806EE, 0xF00FAE77, 0xE3AD3600,
- 0x3B11CD7C, 0x28B3550B, 0x1C54FD92, 0x0FF665E5, 0x759BACA0, 0x663934D7, 0x52DE9C4E, 0x417C0439,
- 0xA6050EC4, 0xB5A796B3, 0x81403E2A, 0x92E2A65D, 0xE88F6F18, 0xFB2DF76F, 0xCFCA5FF6, 0xDC68C781,
- 0x7B5FDFFF, 0x68FD4788, 0x5C1AEF11, 0x4FB87766, 0x35D5BE23, 0x26772654, 0x12908ECD, 0x013216BA,
- 0xE64B1C47, 0xF5E98430, 0xC10E2CA9, 0xD2ACB4DE, 0xA8C17D9B, 0xBB63E5EC, 0x8F844D75, 0x9C26D502,
- 0x449A2E7E, 0x5738B609, 0x63DF1E90, 0x707D86E7, 0x0A104FA2, 0x19B2D7D5, 0x2D557F4C, 0x3EF7E73B,
- 0xD98EEDC6, 0xCA2C75B1, 0xFECBDD28, 0xED69455F, 0x97048C1A, 0x84A6146D, 0xB041BCF4, 0xA3E32483
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o40
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o48[256] =
-{
- 0x00000000, 0xA541927E, 0x4F6F520D, 0xEA2EC073, 0x9EDEA41A, 0x3B9F3664, 0xD1B1F617, 0x74F06469,
- 0x38513EC5, 0x9D10ACBB, 0x773E6CC8, 0xD27FFEB6, 0xA68F9ADF, 0x03CE08A1, 0xE9E0C8D2, 0x4CA15AAC,
- 0x70A27D8A, 0xD5E3EFF4, 0x3FCD2F87, 0x9A8CBDF9, 0xEE7CD990, 0x4B3D4BEE, 0xA1138B9D, 0x045219E3,
- 0x48F3434F, 0xEDB2D131, 0x079C1142, 0xA2DD833C, 0xD62DE755, 0x736C752B, 0x9942B558, 0x3C032726,
- 0xE144FB14, 0x4405696A, 0xAE2BA919, 0x0B6A3B67, 0x7F9A5F0E, 0xDADBCD70, 0x30F50D03, 0x95B49F7D,
- 0xD915C5D1, 0x7C5457AF, 0x967A97DC, 0x333B05A2, 0x47CB61CB, 0xE28AF3B5, 0x08A433C6, 0xADE5A1B8,
- 0x91E6869E, 0x34A714E0, 0xDE89D493, 0x7BC846ED, 0x0F382284, 0xAA79B0FA, 0x40577089, 0xE516E2F7,
- 0xA9B7B85B, 0x0CF62A25, 0xE6D8EA56, 0x43997828, 0x37691C41, 0x92288E3F, 0x78064E4C, 0xDD47DC32,
- 0xC76580D9, 0x622412A7, 0x880AD2D4, 0x2D4B40AA, 0x59BB24C3, 0xFCFAB6BD, 0x16D476CE, 0xB395E4B0,
- 0xFF34BE1C, 0x5A752C62, 0xB05BEC11, 0x151A7E6F, 0x61EA1A06, 0xC4AB8878, 0x2E85480B, 0x8BC4DA75,
- 0xB7C7FD53, 0x12866F2D, 0xF8A8AF5E, 0x5DE93D20, 0x29195949, 0x8C58CB37, 0x66760B44, 0xC337993A,
- 0x8F96C396, 0x2AD751E8, 0xC0F9919B, 0x65B803E5, 0x1148678C, 0xB409F5F2, 0x5E273581, 0xFB66A7FF,
- 0x26217BCD, 0x8360E9B3, 0x694E29C0, 0xCC0FBBBE, 0xB8FFDFD7, 0x1DBE4DA9, 0xF7908DDA, 0x52D11FA4,
- 0x1E704508, 0xBB31D776, 0x511F1705, 0xF45E857B, 0x80AEE112, 0x25EF736C, 0xCFC1B31F, 0x6A802161,
- 0x56830647, 0xF3C29439, 0x19EC544A, 0xBCADC634, 0xC85DA25D, 0x6D1C3023, 0x8732F050, 0x2273622E,
- 0x6ED23882, 0xCB93AAFC, 0x21BD6A8F, 0x84FCF8F1, 0xF00C9C98, 0x554D0EE6, 0xBF63CE95, 0x1A225CEB,
- 0x8B277743, 0x2E66E53D, 0xC448254E, 0x6109B730, 0x15F9D359, 0xB0B84127, 0x5A968154, 0xFFD7132A,
- 0xB3764986, 0x1637DBF8, 0xFC191B8B, 0x595889F5, 0x2DA8ED9C, 0x88E97FE2, 0x62C7BF91, 0xC7862DEF,
- 0xFB850AC9, 0x5EC498B7, 0xB4EA58C4, 0x11ABCABA, 0x655BAED3, 0xC01A3CAD, 0x2A34FCDE, 0x8F756EA0,
- 0xC3D4340C, 0x6695A672, 0x8CBB6601, 0x29FAF47F, 0x5D0A9016, 0xF84B0268, 0x1265C21B, 0xB7245065,
- 0x6A638C57, 0xCF221E29, 0x250CDE5A, 0x804D4C24, 0xF4BD284D, 0x51FCBA33, 0xBBD27A40, 0x1E93E83E,
- 0x5232B292, 0xF77320EC, 0x1D5DE09F, 0xB81C72E1, 0xCCEC1688, 0x69AD84F6, 0x83834485, 0x26C2D6FB,
- 0x1AC1F1DD, 0xBF8063A3, 0x55AEA3D0, 0xF0EF31AE, 0x841F55C7, 0x215EC7B9, 0xCB7007CA, 0x6E3195B4,
- 0x2290CF18, 0x87D15D66, 0x6DFF9D15, 0xC8BE0F6B, 0xBC4E6B02, 0x190FF97C, 0xF321390F, 0x5660AB71,
- 0x4C42F79A, 0xE90365E4, 0x032DA597, 0xA66C37E9, 0xD29C5380, 0x77DDC1FE, 0x9DF3018D, 0x38B293F3,
- 0x7413C95F, 0xD1525B21, 0x3B7C9B52, 0x9E3D092C, 0xEACD6D45, 0x4F8CFF3B, 0xA5A23F48, 0x00E3AD36,
- 0x3CE08A10, 0x99A1186E, 0x738FD81D, 0xD6CE4A63, 0xA23E2E0A, 0x077FBC74, 0xED517C07, 0x4810EE79,
- 0x04B1B4D5, 0xA1F026AB, 0x4BDEE6D8, 0xEE9F74A6, 0x9A6F10CF, 0x3F2E82B1, 0xD50042C2, 0x7041D0BC,
- 0xAD060C8E, 0x08479EF0, 0xE2695E83, 0x4728CCFD, 0x33D8A894, 0x96993AEA, 0x7CB7FA99, 0xD9F668E7,
- 0x9557324B, 0x3016A035, 0xDA386046, 0x7F79F238, 0x0B899651, 0xAEC8042F, 0x44E6C45C, 0xE1A75622,
- 0xDDA47104, 0x78E5E37A, 0x92CB2309, 0x378AB177, 0x437AD51E, 0xE63B4760, 0x0C158713, 0xA954156D,
- 0xE5F54FC1, 0x40B4DDBF, 0xAA9A1DCC, 0x0FDB8FB2, 0x7B2BEBDB, 0xDE6A79A5, 0x3444B9D6, 0x91052BA8
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o48
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o56[256] =
-{
- 0x00000000, 0xDD45AAB8, 0xBF672381, 0x62228939, 0x7B2231F3, 0xA6679B4B, 0xC4451272, 0x1900B8CA,
- 0xF64463E6, 0x2B01C95E, 0x49234067, 0x9466EADF, 0x8D665215, 0x5023F8AD, 0x32017194, 0xEF44DB2C,
- 0xE964B13D, 0x34211B85, 0x560392BC, 0x8B463804, 0x924680CE, 0x4F032A76, 0x2D21A34F, 0xF06409F7,
- 0x1F20D2DB, 0xC2657863, 0xA047F15A, 0x7D025BE2, 0x6402E328, 0xB9474990, 0xDB65C0A9, 0x06206A11,
- 0xD725148B, 0x0A60BE33, 0x6842370A, 0xB5079DB2, 0xAC072578, 0x71428FC0, 0x136006F9, 0xCE25AC41,
- 0x2161776D, 0xFC24DDD5, 0x9E0654EC, 0x4343FE54, 0x5A43469E, 0x8706EC26, 0xE524651F, 0x3861CFA7,
- 0x3E41A5B6, 0xE3040F0E, 0x81268637, 0x5C632C8F, 0x45639445, 0x98263EFD, 0xFA04B7C4, 0x27411D7C,
- 0xC805C650, 0x15406CE8, 0x7762E5D1, 0xAA274F69, 0xB327F7A3, 0x6E625D1B, 0x0C40D422, 0xD1057E9A,
- 0xABA65FE7, 0x76E3F55F, 0x14C17C66, 0xC984D6DE, 0xD0846E14, 0x0DC1C4AC, 0x6FE34D95, 0xB2A6E72D,
- 0x5DE23C01, 0x80A796B9, 0xE2851F80, 0x3FC0B538, 0x26C00DF2, 0xFB85A74A, 0x99A72E73, 0x44E284CB,
- 0x42C2EEDA, 0x9F874462, 0xFDA5CD5B, 0x20E067E3, 0x39E0DF29, 0xE4A57591, 0x8687FCA8, 0x5BC25610,
- 0xB4868D3C, 0x69C32784, 0x0BE1AEBD, 0xD6A40405, 0xCFA4BCCF, 0x12E11677, 0x70C39F4E, 0xAD8635F6,
- 0x7C834B6C, 0xA1C6E1D4, 0xC3E468ED, 0x1EA1C255, 0x07A17A9F, 0xDAE4D027, 0xB8C6591E, 0x6583F3A6,
- 0x8AC7288A, 0x57828232, 0x35A00B0B, 0xE8E5A1B3, 0xF1E51979, 0x2CA0B3C1, 0x4E823AF8, 0x93C79040,
- 0x95E7FA51, 0x48A250E9, 0x2A80D9D0, 0xF7C57368, 0xEEC5CBA2, 0x3380611A, 0x51A2E823, 0x8CE7429B,
- 0x63A399B7, 0xBEE6330F, 0xDCC4BA36, 0x0181108E, 0x1881A844, 0xC5C402FC, 0xA7E68BC5, 0x7AA3217D,
- 0x52A0C93F, 0x8FE56387, 0xEDC7EABE, 0x30824006, 0x2982F8CC, 0xF4C75274, 0x96E5DB4D, 0x4BA071F5,
- 0xA4E4AAD9, 0x79A10061, 0x1B838958, 0xC6C623E0, 0xDFC69B2A, 0x02833192, 0x60A1B8AB, 0xBDE41213,
- 0xBBC47802, 0x6681D2BA, 0x04A35B83, 0xD9E6F13B, 0xC0E649F1, 0x1DA3E349, 0x7F816A70, 0xA2C4C0C8,
- 0x4D801BE4, 0x90C5B15C, 0xF2E73865, 0x2FA292DD, 0x36A22A17, 0xEBE780AF, 0x89C50996, 0x5480A32E,
- 0x8585DDB4, 0x58C0770C, 0x3AE2FE35, 0xE7A7548D, 0xFEA7EC47, 0x23E246FF, 0x41C0CFC6, 0x9C85657E,
- 0x73C1BE52, 0xAE8414EA, 0xCCA69DD3, 0x11E3376B, 0x08E38FA1, 0xD5A62519, 0xB784AC20, 0x6AC10698,
- 0x6CE16C89, 0xB1A4C631, 0xD3864F08, 0x0EC3E5B0, 0x17C35D7A, 0xCA86F7C2, 0xA8A47EFB, 0x75E1D443,
- 0x9AA50F6F, 0x47E0A5D7, 0x25C22CEE, 0xF8878656, 0xE1873E9C, 0x3CC29424, 0x5EE01D1D, 0x83A5B7A5,
- 0xF90696D8, 0x24433C60, 0x4661B559, 0x9B241FE1, 0x8224A72B, 0x5F610D93, 0x3D4384AA, 0xE0062E12,
- 0x0F42F53E, 0xD2075F86, 0xB025D6BF, 0x6D607C07, 0x7460C4CD, 0xA9256E75, 0xCB07E74C, 0x16424DF4,
- 0x106227E5, 0xCD278D5D, 0xAF050464, 0x7240AEDC, 0x6B401616, 0xB605BCAE, 0xD4273597, 0x09629F2F,
- 0xE6264403, 0x3B63EEBB, 0x59416782, 0x8404CD3A, 0x9D0475F0, 0x4041DF48, 0x22635671, 0xFF26FCC9,
- 0x2E238253, 0xF36628EB, 0x9144A1D2, 0x4C010B6A, 0x5501B3A0, 0x88441918, 0xEA669021, 0x37233A99,
- 0xD867E1B5, 0x05224B0D, 0x6700C234, 0xBA45688C, 0xA345D046, 0x7E007AFE, 0x1C22F3C7, 0xC167597F,
- 0xC747336E, 0x1A0299D6, 0x782010EF, 0xA565BA57, 0xBC65029D, 0x6120A825, 0x0302211C, 0xDE478BA4,
- 0x31035088, 0xEC46FA30, 0x8E647309, 0x5321D9B1, 0x4A21617B, 0x9764CBC3, 0xF54642FA, 0x2803E842
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o56
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o64[256] =
-{
- 0x00000000, 0x38116FAC, 0x7022DF58, 0x4833B0F4, 0xE045BEB0, 0xD854D11C, 0x906761E8, 0xA8760E44,
- 0xC5670B91, 0xFD76643D, 0xB545D4C9, 0x8D54BB65, 0x2522B521, 0x1D33DA8D, 0x55006A79, 0x6D1105D5,
- 0x8F2261D3, 0xB7330E7F, 0xFF00BE8B, 0xC711D127, 0x6F67DF63, 0x5776B0CF, 0x1F45003B, 0x27546F97,
- 0x4A456A42, 0x725405EE, 0x3A67B51A, 0x0276DAB6, 0xAA00D4F2, 0x9211BB5E, 0xDA220BAA, 0xE2336406,
- 0x1BA8B557, 0x23B9DAFB, 0x6B8A6A0F, 0x539B05A3, 0xFBED0BE7, 0xC3FC644B, 0x8BCFD4BF, 0xB3DEBB13,
- 0xDECFBEC6, 0xE6DED16A, 0xAEED619E, 0x96FC0E32, 0x3E8A0076, 0x069B6FDA, 0x4EA8DF2E, 0x76B9B082,
- 0x948AD484, 0xAC9BBB28, 0xE4A80BDC, 0xDCB96470, 0x74CF6A34, 0x4CDE0598, 0x04EDB56C, 0x3CFCDAC0,
- 0x51EDDF15, 0x69FCB0B9, 0x21CF004D, 0x19DE6FE1, 0xB1A861A5, 0x89B90E09, 0xC18ABEFD, 0xF99BD151,
- 0x37516AAE, 0x0F400502, 0x4773B5F6, 0x7F62DA5A, 0xD714D41E, 0xEF05BBB2, 0xA7360B46, 0x9F2764EA,
- 0xF236613F, 0xCA270E93, 0x8214BE67, 0xBA05D1CB, 0x1273DF8F, 0x2A62B023, 0x625100D7, 0x5A406F7B,
- 0xB8730B7D, 0x806264D1, 0xC851D425, 0xF040BB89, 0x5836B5CD, 0x6027DA61, 0x28146A95, 0x10050539,
- 0x7D1400EC, 0x45056F40, 0x0D36DFB4, 0x3527B018, 0x9D51BE5C, 0xA540D1F0, 0xED736104, 0xD5620EA8,
- 0x2CF9DFF9, 0x14E8B055, 0x5CDB00A1, 0x64CA6F0D, 0xCCBC6149, 0xF4AD0EE5, 0xBC9EBE11, 0x848FD1BD,
- 0xE99ED468, 0xD18FBBC4, 0x99BC0B30, 0xA1AD649C, 0x09DB6AD8, 0x31CA0574, 0x79F9B580, 0x41E8DA2C,
- 0xA3DBBE2A, 0x9BCAD186, 0xD3F96172, 0xEBE80EDE, 0x439E009A, 0x7B8F6F36, 0x33BCDFC2, 0x0BADB06E,
- 0x66BCB5BB, 0x5EADDA17, 0x169E6AE3, 0x2E8F054F, 0x86F90B0B, 0xBEE864A7, 0xF6DBD453, 0xCECABBFF,
- 0x6EA2D55C, 0x56B3BAF0, 0x1E800A04, 0x269165A8, 0x8EE76BEC, 0xB6F60440, 0xFEC5B4B4, 0xC6D4DB18,
- 0xABC5DECD, 0x93D4B161, 0xDBE70195, 0xE3F66E39, 0x4B80607D, 0x73910FD1, 0x3BA2BF25, 0x03B3D089,
- 0xE180B48F, 0xD991DB23, 0x91A26BD7, 0xA9B3047B, 0x01C50A3F, 0x39D46593, 0x71E7D567, 0x49F6BACB,
- 0x24E7BF1E, 0x1CF6D0B2, 0x54C56046, 0x6CD40FEA, 0xC4A201AE, 0xFCB36E02, 0xB480DEF6, 0x8C91B15A,
- 0x750A600B, 0x4D1B0FA7, 0x0528BF53, 0x3D39D0FF, 0x954FDEBB, 0xAD5EB117, 0xE56D01E3, 0xDD7C6E4F,
- 0xB06D6B9A, 0x887C0436, 0xC04FB4C2, 0xF85EDB6E, 0x5028D52A, 0x6839BA86, 0x200A0A72, 0x181B65DE,
- 0xFA2801D8, 0xC2396E74, 0x8A0ADE80, 0xB21BB12C, 0x1A6DBF68, 0x227CD0C4, 0x6A4F6030, 0x525E0F9C,
- 0x3F4F0A49, 0x075E65E5, 0x4F6DD511, 0x777CBABD, 0xDF0AB4F9, 0xE71BDB55, 0xAF286BA1, 0x9739040D,
- 0x59F3BFF2, 0x61E2D05E, 0x29D160AA, 0x11C00F06, 0xB9B60142, 0x81A76EEE, 0xC994DE1A, 0xF185B1B6,
- 0x9C94B463, 0xA485DBCF, 0xECB66B3B, 0xD4A70497, 0x7CD10AD3, 0x44C0657F, 0x0CF3D58B, 0x34E2BA27,
- 0xD6D1DE21, 0xEEC0B18D, 0xA6F30179, 0x9EE26ED5, 0x36946091, 0x0E850F3D, 0x46B6BFC9, 0x7EA7D065,
- 0x13B6D5B0, 0x2BA7BA1C, 0x63940AE8, 0x5B856544, 0xF3F36B00, 0xCBE204AC, 0x83D1B458, 0xBBC0DBF4,
- 0x425B0AA5, 0x7A4A6509, 0x3279D5FD, 0x0A68BA51, 0xA21EB415, 0x9A0FDBB9, 0xD23C6B4D, 0xEA2D04E1,
- 0x873C0134, 0xBF2D6E98, 0xF71EDE6C, 0xCF0FB1C0, 0x6779BF84, 0x5F68D028, 0x175B60DC, 0x2F4A0F70,
- 0xCD796B76, 0xF56804DA, 0xBD5BB42E, 0x854ADB82, 0x2D3CD5C6, 0x152DBA6A, 0x5D1E0A9E, 0x650F6532,
- 0x081E60E7, 0x300F0F4B, 0x783CBFBF, 0x402DD013, 0xE85BDE57, 0xD04AB1FB, 0x9879010F, 0xA0686EA3
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o64
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o72[256] =
-{
- 0x00000000, 0xEF306B19, 0xDB8CA0C3, 0x34BCCBDA, 0xB2F53777, 0x5DC55C6E, 0x697997B4, 0x8649FCAD,
- 0x6006181F, 0x8F367306, 0xBB8AB8DC, 0x54BAD3C5, 0xD2F32F68, 0x3DC34471, 0x097F8FAB, 0xE64FE4B2,
- 0xC00C303E, 0x2F3C5B27, 0x1B8090FD, 0xF4B0FBE4, 0x72F90749, 0x9DC96C50, 0xA975A78A, 0x4645CC93,
- 0xA00A2821, 0x4F3A4338, 0x7B8688E2, 0x94B6E3FB, 0x12FF1F56, 0xFDCF744F, 0xC973BF95, 0x2643D48C,
- 0x85F4168D, 0x6AC47D94, 0x5E78B64E, 0xB148DD57, 0x370121FA, 0xD8314AE3, 0xEC8D8139, 0x03BDEA20,
- 0xE5F20E92, 0x0AC2658B, 0x3E7EAE51, 0xD14EC548, 0x570739E5, 0xB83752FC, 0x8C8B9926, 0x63BBF23F,
- 0x45F826B3, 0xAAC84DAA, 0x9E748670, 0x7144ED69, 0xF70D11C4, 0x183D7ADD, 0x2C81B107, 0xC3B1DA1E,
- 0x25FE3EAC, 0xCACE55B5, 0xFE729E6F, 0x1142F576, 0x970B09DB, 0x783B62C2, 0x4C87A918, 0xA3B7C201,
- 0x0E045BEB, 0xE13430F2, 0xD588FB28, 0x3AB89031, 0xBCF16C9C, 0x53C10785, 0x677DCC5F, 0x884DA746,
- 0x6E0243F4, 0x813228ED, 0xB58EE337, 0x5ABE882E, 0xDCF77483, 0x33C71F9A, 0x077BD440, 0xE84BBF59,
- 0xCE086BD5, 0x213800CC, 0x1584CB16, 0xFAB4A00F, 0x7CFD5CA2, 0x93CD37BB, 0xA771FC61, 0x48419778,
- 0xAE0E73CA, 0x413E18D3, 0x7582D309, 0x9AB2B810, 0x1CFB44BD, 0xF3CB2FA4, 0xC777E47E, 0x28478F67,
- 0x8BF04D66, 0x64C0267F, 0x507CEDA5, 0xBF4C86BC, 0x39057A11, 0xD6351108, 0xE289DAD2, 0x0DB9B1CB,
- 0xEBF65579, 0x04C63E60, 0x307AF5BA, 0xDF4A9EA3, 0x5903620E, 0xB6330917, 0x828FC2CD, 0x6DBFA9D4,
- 0x4BFC7D58, 0xA4CC1641, 0x9070DD9B, 0x7F40B682, 0xF9094A2F, 0x16392136, 0x2285EAEC, 0xCDB581F5,
- 0x2BFA6547, 0xC4CA0E5E, 0xF076C584, 0x1F46AE9D, 0x990F5230, 0x763F3929, 0x4283F2F3, 0xADB399EA,
- 0x1C08B7D6, 0xF338DCCF, 0xC7841715, 0x28B47C0C, 0xAEFD80A1, 0x41CDEBB8, 0x75712062, 0x9A414B7B,
- 0x7C0EAFC9, 0x933EC4D0, 0xA7820F0A, 0x48B26413, 0xCEFB98BE, 0x21CBF3A7, 0x1577387D, 0xFA475364,
- 0xDC0487E8, 0x3334ECF1, 0x0788272B, 0xE8B84C32, 0x6EF1B09F, 0x81C1DB86, 0xB57D105C, 0x5A4D7B45,
- 0xBC029FF7, 0x5332F4EE, 0x678E3F34, 0x88BE542D, 0x0EF7A880, 0xE1C7C399, 0xD57B0843, 0x3A4B635A,
- 0x99FCA15B, 0x76CCCA42, 0x42700198, 0xAD406A81, 0x2B09962C, 0xC439FD35, 0xF08536EF, 0x1FB55DF6,
- 0xF9FAB944, 0x16CAD25D, 0x22761987, 0xCD46729E, 0x4B0F8E33, 0xA43FE52A, 0x90832EF0, 0x7FB345E9,
- 0x59F09165, 0xB6C0FA7C, 0x827C31A6, 0x6D4C5ABF, 0xEB05A612, 0x0435CD0B, 0x308906D1, 0xDFB96DC8,
- 0x39F6897A, 0xD6C6E263, 0xE27A29B9, 0x0D4A42A0, 0x8B03BE0D, 0x6433D514, 0x508F1ECE, 0xBFBF75D7,
- 0x120CEC3D, 0xFD3C8724, 0xC9804CFE, 0x26B027E7, 0xA0F9DB4A, 0x4FC9B053, 0x7B757B89, 0x94451090,
- 0x720AF422, 0x9D3A9F3B, 0xA98654E1, 0x46B63FF8, 0xC0FFC355, 0x2FCFA84C, 0x1B736396, 0xF443088F,
- 0xD200DC03, 0x3D30B71A, 0x098C7CC0, 0xE6BC17D9, 0x60F5EB74, 0x8FC5806D, 0xBB794BB7, 0x544920AE,
- 0xB206C41C, 0x5D36AF05, 0x698A64DF, 0x86BA0FC6, 0x00F3F36B, 0xEFC39872, 0xDB7F53A8, 0x344F38B1,
- 0x97F8FAB0, 0x78C891A9, 0x4C745A73, 0xA344316A, 0x250DCDC7, 0xCA3DA6DE, 0xFE816D04, 0x11B1061D,
- 0xF7FEE2AF, 0x18CE89B6, 0x2C72426C, 0xC3422975, 0x450BD5D8, 0xAA3BBEC1, 0x9E87751B, 0x71B71E02,
- 0x57F4CA8E, 0xB8C4A197, 0x8C786A4D, 0x63480154, 0xE501FDF9, 0x0A3196E0, 0x3E8D5D3A, 0xD1BD3623,
- 0x37F2D291, 0xD8C2B988, 0xEC7E7252, 0x034E194B, 0x8507E5E6, 0x6A378EFF, 0x5E8B4525, 0xB1BB2E3C
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o72
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o80[256] =
-{
- 0x00000000, 0x68032CC8, 0xD0065990, 0xB8057558, 0xA5E0C5D1, 0xCDE3E919, 0x75E69C41, 0x1DE5B089,
- 0x4E2DFD53, 0x262ED19B, 0x9E2BA4C3, 0xF628880B, 0xEBCD3882, 0x83CE144A, 0x3BCB6112, 0x53C84DDA,
- 0x9C5BFAA6, 0xF458D66E, 0x4C5DA336, 0x245E8FFE, 0x39BB3F77, 0x51B813BF, 0xE9BD66E7, 0x81BE4A2F,
- 0xD27607F5, 0xBA752B3D, 0x02705E65, 0x6A7372AD, 0x7796C224, 0x1F95EEEC, 0xA7909BB4, 0xCF93B77C,
- 0x3D5B83BD, 0x5558AF75, 0xED5DDA2D, 0x855EF6E5, 0x98BB466C, 0xF0B86AA4, 0x48BD1FFC, 0x20BE3334,
- 0x73767EEE, 0x1B755226, 0xA370277E, 0xCB730BB6, 0xD696BB3F, 0xBE9597F7, 0x0690E2AF, 0x6E93CE67,
- 0xA100791B, 0xC90355D3, 0x7106208B, 0x19050C43, 0x04E0BCCA, 0x6CE39002, 0xD4E6E55A, 0xBCE5C992,
- 0xEF2D8448, 0x872EA880, 0x3F2BDDD8, 0x5728F110, 0x4ACD4199, 0x22CE6D51, 0x9ACB1809, 0xF2C834C1,
- 0x7AB7077A, 0x12B42BB2, 0xAAB15EEA, 0xC2B27222, 0xDF57C2AB, 0xB754EE63, 0x0F519B3B, 0x6752B7F3,
- 0x349AFA29, 0x5C99D6E1, 0xE49CA3B9, 0x8C9F8F71, 0x917A3FF8, 0xF9791330, 0x417C6668, 0x297F4AA0,
- 0xE6ECFDDC, 0x8EEFD114, 0x36EAA44C, 0x5EE98884, 0x430C380D, 0x2B0F14C5, 0x930A619D, 0xFB094D55,
- 0xA8C1008F, 0xC0C22C47, 0x78C7591F, 0x10C475D7, 0x0D21C55E, 0x6522E996, 0xDD279CCE, 0xB524B006,
- 0x47EC84C7, 0x2FEFA80F, 0x97EADD57, 0xFFE9F19F, 0xE20C4116, 0x8A0F6DDE, 0x320A1886, 0x5A09344E,
- 0x09C17994, 0x61C2555C, 0xD9C72004, 0xB1C40CCC, 0xAC21BC45, 0xC422908D, 0x7C27E5D5, 0x1424C91D,
- 0xDBB77E61, 0xB3B452A9, 0x0BB127F1, 0x63B20B39, 0x7E57BBB0, 0x16549778, 0xAE51E220, 0xC652CEE8,
- 0x959A8332, 0xFD99AFFA, 0x459CDAA2, 0x2D9FF66A, 0x307A46E3, 0x58796A2B, 0xE07C1F73, 0x887F33BB,
- 0xF56E0EF4, 0x9D6D223C, 0x25685764, 0x4D6B7BAC, 0x508ECB25, 0x388DE7ED, 0x808892B5, 0xE88BBE7D,
- 0xBB43F3A7, 0xD340DF6F, 0x6B45AA37, 0x034686FF, 0x1EA33676, 0x76A01ABE, 0xCEA56FE6, 0xA6A6432E,
- 0x6935F452, 0x0136D89A, 0xB933ADC2, 0xD130810A, 0xCCD53183, 0xA4D61D4B, 0x1CD36813, 0x74D044DB,
- 0x27180901, 0x4F1B25C9, 0xF71E5091, 0x9F1D7C59, 0x82F8CCD0, 0xEAFBE018, 0x52FE9540, 0x3AFDB988,
- 0xC8358D49, 0xA036A181, 0x1833D4D9, 0x7030F811, 0x6DD54898, 0x05D66450, 0xBDD31108, 0xD5D03DC0,
- 0x8618701A, 0xEE1B5CD2, 0x561E298A, 0x3E1D0542, 0x23F8B5CB, 0x4BFB9903, 0xF3FEEC5B, 0x9BFDC093,
- 0x546E77EF, 0x3C6D5B27, 0x84682E7F, 0xEC6B02B7, 0xF18EB23E, 0x998D9EF6, 0x2188EBAE, 0x498BC766,
- 0x1A438ABC, 0x7240A674, 0xCA45D32C, 0xA246FFE4, 0xBFA34F6D, 0xD7A063A5, 0x6FA516FD, 0x07A63A35,
- 0x8FD9098E, 0xE7DA2546, 0x5FDF501E, 0x37DC7CD6, 0x2A39CC5F, 0x423AE097, 0xFA3F95CF, 0x923CB907,
- 0xC1F4F4DD, 0xA9F7D815, 0x11F2AD4D, 0x79F18185, 0x6414310C, 0x0C171DC4, 0xB412689C, 0xDC114454,
- 0x1382F328, 0x7B81DFE0, 0xC384AAB8, 0xAB878670, 0xB66236F9, 0xDE611A31, 0x66646F69, 0x0E6743A1,
- 0x5DAF0E7B, 0x35AC22B3, 0x8DA957EB, 0xE5AA7B23, 0xF84FCBAA, 0x904CE762, 0x2849923A, 0x404ABEF2,
- 0xB2828A33, 0xDA81A6FB, 0x6284D3A3, 0x0A87FF6B, 0x17624FE2, 0x7F61632A, 0xC7641672, 0xAF673ABA,
- 0xFCAF7760, 0x94AC5BA8, 0x2CA92EF0, 0x44AA0238, 0x594FB2B1, 0x314C9E79, 0x8949EB21, 0xE14AC7E9,
- 0x2ED97095, 0x46DA5C5D, 0xFEDF2905, 0x96DC05CD, 0x8B39B544, 0xE33A998C, 0x5B3FECD4, 0x333CC01C,
- 0x60F48DC6, 0x08F7A10E, 0xB0F2D456, 0xD8F1F89E, 0xC5144817, 0xAD1764DF, 0x15121187, 0x7D113D4F
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o80
- */
-
-
-
-/*
- * The following CRC lookup table was generated automagically
- * using the following model parameters:
- *
- * Generator Polynomial = ................. 0x1EDC6F41
- * Generator Polynomial Length = .......... 32 bits
- * Reflected Bits = ....................... TRUE
- * Table Generation Offset = .............. 32 bits
- * Number of Slices = ..................... 8 slices
- * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
- * Directory Name = ....................... .\
- * File Name = ............................ 8x256_tables.c
- */
-
-static const uint32_t crc_tableil8_o88[256] =
-{
- 0x00000000, 0x493C7D27, 0x9278FA4E, 0xDB448769, 0x211D826D, 0x6821FF4A, 0xB3657823, 0xFA590504,
- 0x423B04DA, 0x0B0779FD, 0xD043FE94, 0x997F83B3, 0x632686B7, 0x2A1AFB90, 0xF15E7CF9, 0xB86201DE,
- 0x847609B4, 0xCD4A7493, 0x160EF3FA, 0x5F328EDD, 0xA56B8BD9, 0xEC57F6FE, 0x37137197, 0x7E2F0CB0,
- 0xC64D0D6E, 0x8F717049, 0x5435F720, 0x1D098A07, 0xE7508F03, 0xAE6CF224, 0x7528754D, 0x3C14086A,
- 0x0D006599, 0x443C18BE, 0x9F789FD7, 0xD644E2F0, 0x2C1DE7F4, 0x65219AD3, 0xBE651DBA, 0xF759609D,
- 0x4F3B6143, 0x06071C64, 0xDD439B0D, 0x947FE62A, 0x6E26E32E, 0x271A9E09, 0xFC5E1960, 0xB5626447,
- 0x89766C2D, 0xC04A110A, 0x1B0E9663, 0x5232EB44, 0xA86BEE40, 0xE1579367, 0x3A13140E, 0x732F6929,
- 0xCB4D68F7, 0x827115D0, 0x593592B9, 0x1009EF9E, 0xEA50EA9A, 0xA36C97BD, 0x782810D4, 0x31146DF3,
- 0x1A00CB32, 0x533CB615, 0x8878317C, 0xC1444C5B, 0x3B1D495F, 0x72213478, 0xA965B311, 0xE059CE36,
- 0x583BCFE8, 0x1107B2CF, 0xCA4335A6, 0x837F4881, 0x79264D85, 0x301A30A2, 0xEB5EB7CB, 0xA262CAEC,
- 0x9E76C286, 0xD74ABFA1, 0x0C0E38C8, 0x453245EF, 0xBF6B40EB, 0xF6573DCC, 0x2D13BAA5, 0x642FC782,
- 0xDC4DC65C, 0x9571BB7B, 0x4E353C12, 0x07094135, 0xFD504431, 0xB46C3916, 0x6F28BE7F, 0x2614C358,
- 0x1700AEAB, 0x5E3CD38C, 0x857854E5, 0xCC4429C2, 0x361D2CC6, 0x7F2151E1, 0xA465D688, 0xED59ABAF,
- 0x553BAA71, 0x1C07D756, 0xC743503F, 0x8E7F2D18, 0x7426281C, 0x3D1A553B, 0xE65ED252, 0xAF62AF75,
- 0x9376A71F, 0xDA4ADA38, 0x010E5D51, 0x48322076, 0xB26B2572, 0xFB575855, 0x2013DF3C, 0x692FA21B,
- 0xD14DA3C5, 0x9871DEE2, 0x4335598B, 0x0A0924AC, 0xF05021A8, 0xB96C5C8F, 0x6228DBE6, 0x2B14A6C1,
- 0x34019664, 0x7D3DEB43, 0xA6796C2A, 0xEF45110D, 0x151C1409, 0x5C20692E, 0x8764EE47, 0xCE589360,
- 0x763A92BE, 0x3F06EF99, 0xE44268F0, 0xAD7E15D7, 0x572710D3, 0x1E1B6DF4, 0xC55FEA9D, 0x8C6397BA,
- 0xB0779FD0, 0xF94BE2F7, 0x220F659E, 0x6B3318B9, 0x916A1DBD, 0xD856609A, 0x0312E7F3, 0x4A2E9AD4,
- 0xF24C9B0A, 0xBB70E62D, 0x60346144, 0x29081C63, 0xD3511967, 0x9A6D6440, 0x4129E329, 0x08159E0E,
- 0x3901F3FD, 0x703D8EDA, 0xAB7909B3, 0xE2457494, 0x181C7190, 0x51200CB7, 0x8A648BDE, 0xC358F6F9,
- 0x7B3AF727, 0x32068A00, 0xE9420D69, 0xA07E704E, 0x5A27754A, 0x131B086D, 0xC85F8F04, 0x8163F223,
- 0xBD77FA49, 0xF44B876E, 0x2F0F0007, 0x66337D20, 0x9C6A7824, 0xD5560503, 0x0E12826A, 0x472EFF4D,
- 0xFF4CFE93, 0xB67083B4, 0x6D3404DD, 0x240879FA, 0xDE517CFE, 0x976D01D9, 0x4C2986B0, 0x0515FB97,
- 0x2E015D56, 0x673D2071, 0xBC79A718, 0xF545DA3F, 0x0F1CDF3B, 0x4620A21C, 0x9D642575, 0xD4585852,
- 0x6C3A598C, 0x250624AB, 0xFE42A3C2, 0xB77EDEE5, 0x4D27DBE1, 0x041BA6C6, 0xDF5F21AF, 0x96635C88,
- 0xAA7754E2, 0xE34B29C5, 0x380FAEAC, 0x7133D38B, 0x8B6AD68F, 0xC256ABA8, 0x19122CC1, 0x502E51E6,
- 0xE84C5038, 0xA1702D1F, 0x7A34AA76, 0x3308D751, 0xC951D255, 0x806DAF72, 0x5B29281B, 0x1215553C,
- 0x230138CF, 0x6A3D45E8, 0xB179C281, 0xF845BFA6, 0x021CBAA2, 0x4B20C785, 0x906440EC, 0xD9583DCB,
- 0x613A3C15, 0x28064132, 0xF342C65B, 0xBA7EBB7C, 0x4027BE78, 0x091BC35F, 0xD25F4436, 0x9B633911,
- 0xA777317B, 0xEE4B4C5C, 0x350FCB35, 0x7C33B612, 0x866AB316, 0xCF56CE31, 0x14124958, 0x5D2E347F,
- 0xE54C35A1, 0xAC704886, 0x7734CFEF, 0x3E08B2C8, 0xC451B7CC, 0x8D6DCAEB, 0x56294D82, 0x1F1530A5
-};
-
-/*
- * end of the CRC lookup table crc_tableil8_o88
- */
-
-static uint32_t crc32cSlicingBy8(uint32_t crc, const void* data, size_t length) {
-    const char* p_buf = (const char*) data;
-
-    // Handle leading misaligned bytes
-    size_t initial_bytes = (sizeof(int32_t) - (intptr_t)p_buf) & (sizeof(int32_t) - 1);
-    if (length < initial_bytes) initial_bytes = length;
-    for (size_t li = 0; li < initial_bytes; li++) {
-        crc = crc_tableil8_o32[(crc ^ *p_buf++) & 0x000000FF] ^ (crc >> 8);
-    }
-
-    length -= initial_bytes;
-    size_t running_length = length & ~(sizeof(uint64_t) - 1);
-    size_t end_bytes = length - running_length; 
-
-    for (size_t li = 0; li < running_length/8; li++) {
-        crc ^= *(uint32_t*) p_buf;
-        p_buf += 4;
-        uint32_t term1 = crc_tableil8_o88[crc & 0x000000FF] ^
-                crc_tableil8_o80[(crc >> 8) & 0x000000FF];
-        uint32_t term2 = crc >> 16;
-        crc = term1 ^
-              crc_tableil8_o72[term2 & 0x000000FF] ^ 
-              crc_tableil8_o64[(term2 >> 8) & 0x000000FF];
-        term1 = crc_tableil8_o56[(*(uint32_t *)p_buf) & 0x000000FF] ^
-                crc_tableil8_o48[((*(uint32_t *)p_buf) >> 8) & 0x000000FF];
-
-        term2 = (*(uint32_t *)p_buf) >> 16;
-        crc = crc ^ term1 ^
-                crc_tableil8_o40[term2  & 0x000000FF] ^
-                crc_tableil8_o32[(term2 >> 8) & 0x000000FF];
-        p_buf += 4;
-    }
-
-    for (size_t li=0; li < end_bytes; li++) {
-        crc = crc_tableil8_o32[(crc ^ *p_buf++) & 0x000000FF] ^ (crc >> 8);
-    }
-
-    return crc;
-}
-
-uint32_t jls_crc32c_hdr(const struct jls_chunk_header_s * hdr) {
-    uint32_t crc = 0xFFFFFFFF;
-    crc = crc32cSlicingBy8(crc, (unsigned const char*) hdr, 28);
-    return (crc ^ 0xFFFFFFFF);
-}
-
-uint32_t jls_crc32c(uint8_t const *data, uint32_t length) {
-    uint32_t crc = 0xFFFFFFFF;
-    crc = crc32cSlicingBy8(crc, data, length);
-    return (crc ^ 0xFFFFFFFF);
-}
+// Copyright 2008,2009,2010 Massachusetts Institute of Technology.
+// All rights reserved. Use of this source code is governed by a
+// BSD-style license that can be found in the LICENSE.slice-by-8 file.
+
+// Implementations adapted from Intel's Slicing By 8 Sourceforge Project
+// http://sourceforge.net/projects/slicing-by-8/
+/*
+ * Copyright (c) 2004-2006 Intel Corporation - All Rights Reserved
+ *
+ *
+ * This software program is licensed subject to the BSD License,
+ * available at http://www.opensource.org/licenses/bsd-license.html.
+ *
+ * Abstract:
+ *
+ *  Tables for software CRC generation
+ */
+
+
+/* Tables generated with code like the following:
+
+#define CRCPOLY 0x82f63b78 // reversed 0x1EDC6F41
+#define CRCINIT 0xFFFFFFFF
+
+void init() {
+    for (uint32_t i = 0; i <= 0xFF; i++) {
+        uint32_t x = i;
+        for (uint32_t j = 0; j < 8; j++)
+            x = (x>>1) ^ (CRCPOLY & (-(int32_t)(x & 1)));
+        g_crc_slicing[0][i] = x;
+    }
+
+    for (uint32_t i = 0; i <= 0xFF; i++) {
+        uint32_t c = g_crc_slicing[0][i];
+        for (uint32_t j = 1; j < 8; j++) {
+            c = g_crc_slicing[0][c & 0xFF] ^ (c >> 8);
+            g_crc_slicing[j][i] = c;
+        }
+    }
+}
+*/
+
+#include "jls/crc32c.h"
+#include <stddef.h>
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o32[256] =
+{
+ 0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,
+ 0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
+ 0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,
+ 0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
+ 0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,
+ 0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
+ 0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,
+ 0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
+ 0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,
+ 0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
+ 0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,
+ 0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
+ 0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,
+ 0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
+ 0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,
+ 0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
+ 0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,
+ 0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
+ 0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,
+ 0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
+ 0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,
+ 0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
+ 0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,
+ 0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
+ 0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,
+ 0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
+ 0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,
+ 0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
+ 0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
+ 0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
+ 0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
+ 0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o32
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o40[256] =
+{
+ 0x00000000, 0x13A29877, 0x274530EE, 0x34E7A899, 0x4E8A61DC, 0x5D28F9AB, 0x69CF5132, 0x7A6DC945,
+ 0x9D14C3B8, 0x8EB65BCF, 0xBA51F356, 0xA9F36B21, 0xD39EA264, 0xC03C3A13, 0xF4DB928A, 0xE7790AFD,
+ 0x3FC5F181, 0x2C6769F6, 0x1880C16F, 0x0B225918, 0x714F905D, 0x62ED082A, 0x560AA0B3, 0x45A838C4,
+ 0xA2D13239, 0xB173AA4E, 0x859402D7, 0x96369AA0, 0xEC5B53E5, 0xFFF9CB92, 0xCB1E630B, 0xD8BCFB7C,
+ 0x7F8BE302, 0x6C297B75, 0x58CED3EC, 0x4B6C4B9B, 0x310182DE, 0x22A31AA9, 0x1644B230, 0x05E62A47,
+ 0xE29F20BA, 0xF13DB8CD, 0xC5DA1054, 0xD6788823, 0xAC154166, 0xBFB7D911, 0x8B507188, 0x98F2E9FF,
+ 0x404E1283, 0x53EC8AF4, 0x670B226D, 0x74A9BA1A, 0x0EC4735F, 0x1D66EB28, 0x298143B1, 0x3A23DBC6,
+ 0xDD5AD13B, 0xCEF8494C, 0xFA1FE1D5, 0xE9BD79A2, 0x93D0B0E7, 0x80722890, 0xB4958009, 0xA737187E,
+ 0xFF17C604, 0xECB55E73, 0xD852F6EA, 0xCBF06E9D, 0xB19DA7D8, 0xA23F3FAF, 0x96D89736, 0x857A0F41,
+ 0x620305BC, 0x71A19DCB, 0x45463552, 0x56E4AD25, 0x2C896460, 0x3F2BFC17, 0x0BCC548E, 0x186ECCF9,
+ 0xC0D23785, 0xD370AFF2, 0xE797076B, 0xF4359F1C, 0x8E585659, 0x9DFACE2E, 0xA91D66B7, 0xBABFFEC0,
+ 0x5DC6F43D, 0x4E646C4A, 0x7A83C4D3, 0x69215CA4, 0x134C95E1, 0x00EE0D96, 0x3409A50F, 0x27AB3D78,
+ 0x809C2506, 0x933EBD71, 0xA7D915E8, 0xB47B8D9F, 0xCE1644DA, 0xDDB4DCAD, 0xE9537434, 0xFAF1EC43,
+ 0x1D88E6BE, 0x0E2A7EC9, 0x3ACDD650, 0x296F4E27, 0x53028762, 0x40A01F15, 0x7447B78C, 0x67E52FFB,
+ 0xBF59D487, 0xACFB4CF0, 0x981CE469, 0x8BBE7C1E, 0xF1D3B55B, 0xE2712D2C, 0xD69685B5, 0xC5341DC2,
+ 0x224D173F, 0x31EF8F48, 0x050827D1, 0x16AABFA6, 0x6CC776E3, 0x7F65EE94, 0x4B82460D, 0x5820DE7A,
+ 0xFBC3FAF9, 0xE861628E, 0xDC86CA17, 0xCF245260, 0xB5499B25, 0xA6EB0352, 0x920CABCB, 0x81AE33BC,
+ 0x66D73941, 0x7575A136, 0x419209AF, 0x523091D8, 0x285D589D, 0x3BFFC0EA, 0x0F186873, 0x1CBAF004,
+ 0xC4060B78, 0xD7A4930F, 0xE3433B96, 0xF0E1A3E1, 0x8A8C6AA4, 0x992EF2D3, 0xADC95A4A, 0xBE6BC23D,
+ 0x5912C8C0, 0x4AB050B7, 0x7E57F82E, 0x6DF56059, 0x1798A91C, 0x043A316B, 0x30DD99F2, 0x237F0185,
+ 0x844819FB, 0x97EA818C, 0xA30D2915, 0xB0AFB162, 0xCAC27827, 0xD960E050, 0xED8748C9, 0xFE25D0BE,
+ 0x195CDA43, 0x0AFE4234, 0x3E19EAAD, 0x2DBB72DA, 0x57D6BB9F, 0x447423E8, 0x70938B71, 0x63311306,
+ 0xBB8DE87A, 0xA82F700D, 0x9CC8D894, 0x8F6A40E3, 0xF50789A6, 0xE6A511D1, 0xD242B948, 0xC1E0213F,
+ 0x26992BC2, 0x353BB3B5, 0x01DC1B2C, 0x127E835B, 0x68134A1E, 0x7BB1D269, 0x4F567AF0, 0x5CF4E287,
+ 0x04D43CFD, 0x1776A48A, 0x23910C13, 0x30339464, 0x4A5E5D21, 0x59FCC556, 0x6D1B6DCF, 0x7EB9F5B8,
+ 0x99C0FF45, 0x8A626732, 0xBE85CFAB, 0xAD2757DC, 0xD74A9E99, 0xC4E806EE, 0xF00FAE77, 0xE3AD3600,
+ 0x3B11CD7C, 0x28B3550B, 0x1C54FD92, 0x0FF665E5, 0x759BACA0, 0x663934D7, 0x52DE9C4E, 0x417C0439,
+ 0xA6050EC4, 0xB5A796B3, 0x81403E2A, 0x92E2A65D, 0xE88F6F18, 0xFB2DF76F, 0xCFCA5FF6, 0xDC68C781,
+ 0x7B5FDFFF, 0x68FD4788, 0x5C1AEF11, 0x4FB87766, 0x35D5BE23, 0x26772654, 0x12908ECD, 0x013216BA,
+ 0xE64B1C47, 0xF5E98430, 0xC10E2CA9, 0xD2ACB4DE, 0xA8C17D9B, 0xBB63E5EC, 0x8F844D75, 0x9C26D502,
+ 0x449A2E7E, 0x5738B609, 0x63DF1E90, 0x707D86E7, 0x0A104FA2, 0x19B2D7D5, 0x2D557F4C, 0x3EF7E73B,
+ 0xD98EEDC6, 0xCA2C75B1, 0xFECBDD28, 0xED69455F, 0x97048C1A, 0x84A6146D, 0xB041BCF4, 0xA3E32483
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o40
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o48[256] =
+{
+ 0x00000000, 0xA541927E, 0x4F6F520D, 0xEA2EC073, 0x9EDEA41A, 0x3B9F3664, 0xD1B1F617, 0x74F06469,
+ 0x38513EC5, 0x9D10ACBB, 0x773E6CC8, 0xD27FFEB6, 0xA68F9ADF, 0x03CE08A1, 0xE9E0C8D2, 0x4CA15AAC,
+ 0x70A27D8A, 0xD5E3EFF4, 0x3FCD2F87, 0x9A8CBDF9, 0xEE7CD990, 0x4B3D4BEE, 0xA1138B9D, 0x045219E3,
+ 0x48F3434F, 0xEDB2D131, 0x079C1142, 0xA2DD833C, 0xD62DE755, 0x736C752B, 0x9942B558, 0x3C032726,
+ 0xE144FB14, 0x4405696A, 0xAE2BA919, 0x0B6A3B67, 0x7F9A5F0E, 0xDADBCD70, 0x30F50D03, 0x95B49F7D,
+ 0xD915C5D1, 0x7C5457AF, 0x967A97DC, 0x333B05A2, 0x47CB61CB, 0xE28AF3B5, 0x08A433C6, 0xADE5A1B8,
+ 0x91E6869E, 0x34A714E0, 0xDE89D493, 0x7BC846ED, 0x0F382284, 0xAA79B0FA, 0x40577089, 0xE516E2F7,
+ 0xA9B7B85B, 0x0CF62A25, 0xE6D8EA56, 0x43997828, 0x37691C41, 0x92288E3F, 0x78064E4C, 0xDD47DC32,
+ 0xC76580D9, 0x622412A7, 0x880AD2D4, 0x2D4B40AA, 0x59BB24C3, 0xFCFAB6BD, 0x16D476CE, 0xB395E4B0,
+ 0xFF34BE1C, 0x5A752C62, 0xB05BEC11, 0x151A7E6F, 0x61EA1A06, 0xC4AB8878, 0x2E85480B, 0x8BC4DA75,
+ 0xB7C7FD53, 0x12866F2D, 0xF8A8AF5E, 0x5DE93D20, 0x29195949, 0x8C58CB37, 0x66760B44, 0xC337993A,
+ 0x8F96C396, 0x2AD751E8, 0xC0F9919B, 0x65B803E5, 0x1148678C, 0xB409F5F2, 0x5E273581, 0xFB66A7FF,
+ 0x26217BCD, 0x8360E9B3, 0x694E29C0, 0xCC0FBBBE, 0xB8FFDFD7, 0x1DBE4DA9, 0xF7908DDA, 0x52D11FA4,
+ 0x1E704508, 0xBB31D776, 0x511F1705, 0xF45E857B, 0x80AEE112, 0x25EF736C, 0xCFC1B31F, 0x6A802161,
+ 0x56830647, 0xF3C29439, 0x19EC544A, 0xBCADC634, 0xC85DA25D, 0x6D1C3023, 0x8732F050, 0x2273622E,
+ 0x6ED23882, 0xCB93AAFC, 0x21BD6A8F, 0x84FCF8F1, 0xF00C9C98, 0x554D0EE6, 0xBF63CE95, 0x1A225CEB,
+ 0x8B277743, 0x2E66E53D, 0xC448254E, 0x6109B730, 0x15F9D359, 0xB0B84127, 0x5A968154, 0xFFD7132A,
+ 0xB3764986, 0x1637DBF8, 0xFC191B8B, 0x595889F5, 0x2DA8ED9C, 0x88E97FE2, 0x62C7BF91, 0xC7862DEF,
+ 0xFB850AC9, 0x5EC498B7, 0xB4EA58C4, 0x11ABCABA, 0x655BAED3, 0xC01A3CAD, 0x2A34FCDE, 0x8F756EA0,
+ 0xC3D4340C, 0x6695A672, 0x8CBB6601, 0x29FAF47F, 0x5D0A9016, 0xF84B0268, 0x1265C21B, 0xB7245065,
+ 0x6A638C57, 0xCF221E29, 0x250CDE5A, 0x804D4C24, 0xF4BD284D, 0x51FCBA33, 0xBBD27A40, 0x1E93E83E,
+ 0x5232B292, 0xF77320EC, 0x1D5DE09F, 0xB81C72E1, 0xCCEC1688, 0x69AD84F6, 0x83834485, 0x26C2D6FB,
+ 0x1AC1F1DD, 0xBF8063A3, 0x55AEA3D0, 0xF0EF31AE, 0x841F55C7, 0x215EC7B9, 0xCB7007CA, 0x6E3195B4,
+ 0x2290CF18, 0x87D15D66, 0x6DFF9D15, 0xC8BE0F6B, 0xBC4E6B02, 0x190FF97C, 0xF321390F, 0x5660AB71,
+ 0x4C42F79A, 0xE90365E4, 0x032DA597, 0xA66C37E9, 0xD29C5380, 0x77DDC1FE, 0x9DF3018D, 0x38B293F3,
+ 0x7413C95F, 0xD1525B21, 0x3B7C9B52, 0x9E3D092C, 0xEACD6D45, 0x4F8CFF3B, 0xA5A23F48, 0x00E3AD36,
+ 0x3CE08A10, 0x99A1186E, 0x738FD81D, 0xD6CE4A63, 0xA23E2E0A, 0x077FBC74, 0xED517C07, 0x4810EE79,
+ 0x04B1B4D5, 0xA1F026AB, 0x4BDEE6D8, 0xEE9F74A6, 0x9A6F10CF, 0x3F2E82B1, 0xD50042C2, 0x7041D0BC,
+ 0xAD060C8E, 0x08479EF0, 0xE2695E83, 0x4728CCFD, 0x33D8A894, 0x96993AEA, 0x7CB7FA99, 0xD9F668E7,
+ 0x9557324B, 0x3016A035, 0xDA386046, 0x7F79F238, 0x0B899651, 0xAEC8042F, 0x44E6C45C, 0xE1A75622,
+ 0xDDA47104, 0x78E5E37A, 0x92CB2309, 0x378AB177, 0x437AD51E, 0xE63B4760, 0x0C158713, 0xA954156D,
+ 0xE5F54FC1, 0x40B4DDBF, 0xAA9A1DCC, 0x0FDB8FB2, 0x7B2BEBDB, 0xDE6A79A5, 0x3444B9D6, 0x91052BA8
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o48
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o56[256] =
+{
+ 0x00000000, 0xDD45AAB8, 0xBF672381, 0x62228939, 0x7B2231F3, 0xA6679B4B, 0xC4451272, 0x1900B8CA,
+ 0xF64463E6, 0x2B01C95E, 0x49234067, 0x9466EADF, 0x8D665215, 0x5023F8AD, 0x32017194, 0xEF44DB2C,
+ 0xE964B13D, 0x34211B85, 0x560392BC, 0x8B463804, 0x924680CE, 0x4F032A76, 0x2D21A34F, 0xF06409F7,
+ 0x1F20D2DB, 0xC2657863, 0xA047F15A, 0x7D025BE2, 0x6402E328, 0xB9474990, 0xDB65C0A9, 0x06206A11,
+ 0xD725148B, 0x0A60BE33, 0x6842370A, 0xB5079DB2, 0xAC072578, 0x71428FC0, 0x136006F9, 0xCE25AC41,
+ 0x2161776D, 0xFC24DDD5, 0x9E0654EC, 0x4343FE54, 0x5A43469E, 0x8706EC26, 0xE524651F, 0x3861CFA7,
+ 0x3E41A5B6, 0xE3040F0E, 0x81268637, 0x5C632C8F, 0x45639445, 0x98263EFD, 0xFA04B7C4, 0x27411D7C,
+ 0xC805C650, 0x15406CE8, 0x7762E5D1, 0xAA274F69, 0xB327F7A3, 0x6E625D1B, 0x0C40D422, 0xD1057E9A,
+ 0xABA65FE7, 0x76E3F55F, 0x14C17C66, 0xC984D6DE, 0xD0846E14, 0x0DC1C4AC, 0x6FE34D95, 0xB2A6E72D,
+ 0x5DE23C01, 0x80A796B9, 0xE2851F80, 0x3FC0B538, 0x26C00DF2, 0xFB85A74A, 0x99A72E73, 0x44E284CB,
+ 0x42C2EEDA, 0x9F874462, 0xFDA5CD5B, 0x20E067E3, 0x39E0DF29, 0xE4A57591, 0x8687FCA8, 0x5BC25610,
+ 0xB4868D3C, 0x69C32784, 0x0BE1AEBD, 0xD6A40405, 0xCFA4BCCF, 0x12E11677, 0x70C39F4E, 0xAD8635F6,
+ 0x7C834B6C, 0xA1C6E1D4, 0xC3E468ED, 0x1EA1C255, 0x07A17A9F, 0xDAE4D027, 0xB8C6591E, 0x6583F3A6,
+ 0x8AC7288A, 0x57828232, 0x35A00B0B, 0xE8E5A1B3, 0xF1E51979, 0x2CA0B3C1, 0x4E823AF8, 0x93C79040,
+ 0x95E7FA51, 0x48A250E9, 0x2A80D9D0, 0xF7C57368, 0xEEC5CBA2, 0x3380611A, 0x51A2E823, 0x8CE7429B,
+ 0x63A399B7, 0xBEE6330F, 0xDCC4BA36, 0x0181108E, 0x1881A844, 0xC5C402FC, 0xA7E68BC5, 0x7AA3217D,
+ 0x52A0C93F, 0x8FE56387, 0xEDC7EABE, 0x30824006, 0x2982F8CC, 0xF4C75274, 0x96E5DB4D, 0x4BA071F5,
+ 0xA4E4AAD9, 0x79A10061, 0x1B838958, 0xC6C623E0, 0xDFC69B2A, 0x02833192, 0x60A1B8AB, 0xBDE41213,
+ 0xBBC47802, 0x6681D2BA, 0x04A35B83, 0xD9E6F13B, 0xC0E649F1, 0x1DA3E349, 0x7F816A70, 0xA2C4C0C8,
+ 0x4D801BE4, 0x90C5B15C, 0xF2E73865, 0x2FA292DD, 0x36A22A17, 0xEBE780AF, 0x89C50996, 0x5480A32E,
+ 0x8585DDB4, 0x58C0770C, 0x3AE2FE35, 0xE7A7548D, 0xFEA7EC47, 0x23E246FF, 0x41C0CFC6, 0x9C85657E,
+ 0x73C1BE52, 0xAE8414EA, 0xCCA69DD3, 0x11E3376B, 0x08E38FA1, 0xD5A62519, 0xB784AC20, 0x6AC10698,
+ 0x6CE16C89, 0xB1A4C631, 0xD3864F08, 0x0EC3E5B0, 0x17C35D7A, 0xCA86F7C2, 0xA8A47EFB, 0x75E1D443,
+ 0x9AA50F6F, 0x47E0A5D7, 0x25C22CEE, 0xF8878656, 0xE1873E9C, 0x3CC29424, 0x5EE01D1D, 0x83A5B7A5,
+ 0xF90696D8, 0x24433C60, 0x4661B559, 0x9B241FE1, 0x8224A72B, 0x5F610D93, 0x3D4384AA, 0xE0062E12,
+ 0x0F42F53E, 0xD2075F86, 0xB025D6BF, 0x6D607C07, 0x7460C4CD, 0xA9256E75, 0xCB07E74C, 0x16424DF4,
+ 0x106227E5, 0xCD278D5D, 0xAF050464, 0x7240AEDC, 0x6B401616, 0xB605BCAE, 0xD4273597, 0x09629F2F,
+ 0xE6264403, 0x3B63EEBB, 0x59416782, 0x8404CD3A, 0x9D0475F0, 0x4041DF48, 0x22635671, 0xFF26FCC9,
+ 0x2E238253, 0xF36628EB, 0x9144A1D2, 0x4C010B6A, 0x5501B3A0, 0x88441918, 0xEA669021, 0x37233A99,
+ 0xD867E1B5, 0x05224B0D, 0x6700C234, 0xBA45688C, 0xA345D046, 0x7E007AFE, 0x1C22F3C7, 0xC167597F,
+ 0xC747336E, 0x1A0299D6, 0x782010EF, 0xA565BA57, 0xBC65029D, 0x6120A825, 0x0302211C, 0xDE478BA4,
+ 0x31035088, 0xEC46FA30, 0x8E647309, 0x5321D9B1, 0x4A21617B, 0x9764CBC3, 0xF54642FA, 0x2803E842
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o56
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o64[256] =
+{
+ 0x00000000, 0x38116FAC, 0x7022DF58, 0x4833B0F4, 0xE045BEB0, 0xD854D11C, 0x906761E8, 0xA8760E44,
+ 0xC5670B91, 0xFD76643D, 0xB545D4C9, 0x8D54BB65, 0x2522B521, 0x1D33DA8D, 0x55006A79, 0x6D1105D5,
+ 0x8F2261D3, 0xB7330E7F, 0xFF00BE8B, 0xC711D127, 0x6F67DF63, 0x5776B0CF, 0x1F45003B, 0x27546F97,
+ 0x4A456A42, 0x725405EE, 0x3A67B51A, 0x0276DAB6, 0xAA00D4F2, 0x9211BB5E, 0xDA220BAA, 0xE2336406,
+ 0x1BA8B557, 0x23B9DAFB, 0x6B8A6A0F, 0x539B05A3, 0xFBED0BE7, 0xC3FC644B, 0x8BCFD4BF, 0xB3DEBB13,
+ 0xDECFBEC6, 0xE6DED16A, 0xAEED619E, 0x96FC0E32, 0x3E8A0076, 0x069B6FDA, 0x4EA8DF2E, 0x76B9B082,
+ 0x948AD484, 0xAC9BBB28, 0xE4A80BDC, 0xDCB96470, 0x74CF6A34, 0x4CDE0598, 0x04EDB56C, 0x3CFCDAC0,
+ 0x51EDDF15, 0x69FCB0B9, 0x21CF004D, 0x19DE6FE1, 0xB1A861A5, 0x89B90E09, 0xC18ABEFD, 0xF99BD151,
+ 0x37516AAE, 0x0F400502, 0x4773B5F6, 0x7F62DA5A, 0xD714D41E, 0xEF05BBB2, 0xA7360B46, 0x9F2764EA,
+ 0xF236613F, 0xCA270E93, 0x8214BE67, 0xBA05D1CB, 0x1273DF8F, 0x2A62B023, 0x625100D7, 0x5A406F7B,
+ 0xB8730B7D, 0x806264D1, 0xC851D425, 0xF040BB89, 0x5836B5CD, 0x6027DA61, 0x28146A95, 0x10050539,
+ 0x7D1400EC, 0x45056F40, 0x0D36DFB4, 0x3527B018, 0x9D51BE5C, 0xA540D1F0, 0xED736104, 0xD5620EA8,
+ 0x2CF9DFF9, 0x14E8B055, 0x5CDB00A1, 0x64CA6F0D, 0xCCBC6149, 0xF4AD0EE5, 0xBC9EBE11, 0x848FD1BD,
+ 0xE99ED468, 0xD18FBBC4, 0x99BC0B30, 0xA1AD649C, 0x09DB6AD8, 0x31CA0574, 0x79F9B580, 0x41E8DA2C,
+ 0xA3DBBE2A, 0x9BCAD186, 0xD3F96172, 0xEBE80EDE, 0x439E009A, 0x7B8F6F36, 0x33BCDFC2, 0x0BADB06E,
+ 0x66BCB5BB, 0x5EADDA17, 0x169E6AE3, 0x2E8F054F, 0x86F90B0B, 0xBEE864A7, 0xF6DBD453, 0xCECABBFF,
+ 0x6EA2D55C, 0x56B3BAF0, 0x1E800A04, 0x269165A8, 0x8EE76BEC, 0xB6F60440, 0xFEC5B4B4, 0xC6D4DB18,
+ 0xABC5DECD, 0x93D4B161, 0xDBE70195, 0xE3F66E39, 0x4B80607D, 0x73910FD1, 0x3BA2BF25, 0x03B3D089,
+ 0xE180B48F, 0xD991DB23, 0x91A26BD7, 0xA9B3047B, 0x01C50A3F, 0x39D46593, 0x71E7D567, 0x49F6BACB,
+ 0x24E7BF1E, 0x1CF6D0B2, 0x54C56046, 0x6CD40FEA, 0xC4A201AE, 0xFCB36E02, 0xB480DEF6, 0x8C91B15A,
+ 0x750A600B, 0x4D1B0FA7, 0x0528BF53, 0x3D39D0FF, 0x954FDEBB, 0xAD5EB117, 0xE56D01E3, 0xDD7C6E4F,
+ 0xB06D6B9A, 0x887C0436, 0xC04FB4C2, 0xF85EDB6E, 0x5028D52A, 0x6839BA86, 0x200A0A72, 0x181B65DE,
+ 0xFA2801D8, 0xC2396E74, 0x8A0ADE80, 0xB21BB12C, 0x1A6DBF68, 0x227CD0C4, 0x6A4F6030, 0x525E0F9C,
+ 0x3F4F0A49, 0x075E65E5, 0x4F6DD511, 0x777CBABD, 0xDF0AB4F9, 0xE71BDB55, 0xAF286BA1, 0x9739040D,
+ 0x59F3BFF2, 0x61E2D05E, 0x29D160AA, 0x11C00F06, 0xB9B60142, 0x81A76EEE, 0xC994DE1A, 0xF185B1B6,
+ 0x9C94B463, 0xA485DBCF, 0xECB66B3B, 0xD4A70497, 0x7CD10AD3, 0x44C0657F, 0x0CF3D58B, 0x34E2BA27,
+ 0xD6D1DE21, 0xEEC0B18D, 0xA6F30179, 0x9EE26ED5, 0x36946091, 0x0E850F3D, 0x46B6BFC9, 0x7EA7D065,
+ 0x13B6D5B0, 0x2BA7BA1C, 0x63940AE8, 0x5B856544, 0xF3F36B00, 0xCBE204AC, 0x83D1B458, 0xBBC0DBF4,
+ 0x425B0AA5, 0x7A4A6509, 0x3279D5FD, 0x0A68BA51, 0xA21EB415, 0x9A0FDBB9, 0xD23C6B4D, 0xEA2D04E1,
+ 0x873C0134, 0xBF2D6E98, 0xF71EDE6C, 0xCF0FB1C0, 0x6779BF84, 0x5F68D028, 0x175B60DC, 0x2F4A0F70,
+ 0xCD796B76, 0xF56804DA, 0xBD5BB42E, 0x854ADB82, 0x2D3CD5C6, 0x152DBA6A, 0x5D1E0A9E, 0x650F6532,
+ 0x081E60E7, 0x300F0F4B, 0x783CBFBF, 0x402DD013, 0xE85BDE57, 0xD04AB1FB, 0x9879010F, 0xA0686EA3
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o64
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o72[256] =
+{
+ 0x00000000, 0xEF306B19, 0xDB8CA0C3, 0x34BCCBDA, 0xB2F53777, 0x5DC55C6E, 0x697997B4, 0x8649FCAD,
+ 0x6006181F, 0x8F367306, 0xBB8AB8DC, 0x54BAD3C5, 0xD2F32F68, 0x3DC34471, 0x097F8FAB, 0xE64FE4B2,
+ 0xC00C303E, 0x2F3C5B27, 0x1B8090FD, 0xF4B0FBE4, 0x72F90749, 0x9DC96C50, 0xA975A78A, 0x4645CC93,
+ 0xA00A2821, 0x4F3A4338, 0x7B8688E2, 0x94B6E3FB, 0x12FF1F56, 0xFDCF744F, 0xC973BF95, 0x2643D48C,
+ 0x85F4168D, 0x6AC47D94, 0x5E78B64E, 0xB148DD57, 0x370121FA, 0xD8314AE3, 0xEC8D8139, 0x03BDEA20,
+ 0xE5F20E92, 0x0AC2658B, 0x3E7EAE51, 0xD14EC548, 0x570739E5, 0xB83752FC, 0x8C8B9926, 0x63BBF23F,
+ 0x45F826B3, 0xAAC84DAA, 0x9E748670, 0x7144ED69, 0xF70D11C4, 0x183D7ADD, 0x2C81B107, 0xC3B1DA1E,
+ 0x25FE3EAC, 0xCACE55B5, 0xFE729E6F, 0x1142F576, 0x970B09DB, 0x783B62C2, 0x4C87A918, 0xA3B7C201,
+ 0x0E045BEB, 0xE13430F2, 0xD588FB28, 0x3AB89031, 0xBCF16C9C, 0x53C10785, 0x677DCC5F, 0x884DA746,
+ 0x6E0243F4, 0x813228ED, 0xB58EE337, 0x5ABE882E, 0xDCF77483, 0x33C71F9A, 0x077BD440, 0xE84BBF59,
+ 0xCE086BD5, 0x213800CC, 0x1584CB16, 0xFAB4A00F, 0x7CFD5CA2, 0x93CD37BB, 0xA771FC61, 0x48419778,
+ 0xAE0E73CA, 0x413E18D3, 0x7582D309, 0x9AB2B810, 0x1CFB44BD, 0xF3CB2FA4, 0xC777E47E, 0x28478F67,
+ 0x8BF04D66, 0x64C0267F, 0x507CEDA5, 0xBF4C86BC, 0x39057A11, 0xD6351108, 0xE289DAD2, 0x0DB9B1CB,
+ 0xEBF65579, 0x04C63E60, 0x307AF5BA, 0xDF4A9EA3, 0x5903620E, 0xB6330917, 0x828FC2CD, 0x6DBFA9D4,
+ 0x4BFC7D58, 0xA4CC1641, 0x9070DD9B, 0x7F40B682, 0xF9094A2F, 0x16392136, 0x2285EAEC, 0xCDB581F5,
+ 0x2BFA6547, 0xC4CA0E5E, 0xF076C584, 0x1F46AE9D, 0x990F5230, 0x763F3929, 0x4283F2F3, 0xADB399EA,
+ 0x1C08B7D6, 0xF338DCCF, 0xC7841715, 0x28B47C0C, 0xAEFD80A1, 0x41CDEBB8, 0x75712062, 0x9A414B7B,
+ 0x7C0EAFC9, 0x933EC4D0, 0xA7820F0A, 0x48B26413, 0xCEFB98BE, 0x21CBF3A7, 0x1577387D, 0xFA475364,
+ 0xDC0487E8, 0x3334ECF1, 0x0788272B, 0xE8B84C32, 0x6EF1B09F, 0x81C1DB86, 0xB57D105C, 0x5A4D7B45,
+ 0xBC029FF7, 0x5332F4EE, 0x678E3F34, 0x88BE542D, 0x0EF7A880, 0xE1C7C399, 0xD57B0843, 0x3A4B635A,
+ 0x99FCA15B, 0x76CCCA42, 0x42700198, 0xAD406A81, 0x2B09962C, 0xC439FD35, 0xF08536EF, 0x1FB55DF6,
+ 0xF9FAB944, 0x16CAD25D, 0x22761987, 0xCD46729E, 0x4B0F8E33, 0xA43FE52A, 0x90832EF0, 0x7FB345E9,
+ 0x59F09165, 0xB6C0FA7C, 0x827C31A6, 0x6D4C5ABF, 0xEB05A612, 0x0435CD0B, 0x308906D1, 0xDFB96DC8,
+ 0x39F6897A, 0xD6C6E263, 0xE27A29B9, 0x0D4A42A0, 0x8B03BE0D, 0x6433D514, 0x508F1ECE, 0xBFBF75D7,
+ 0x120CEC3D, 0xFD3C8724, 0xC9804CFE, 0x26B027E7, 0xA0F9DB4A, 0x4FC9B053, 0x7B757B89, 0x94451090,
+ 0x720AF422, 0x9D3A9F3B, 0xA98654E1, 0x46B63FF8, 0xC0FFC355, 0x2FCFA84C, 0x1B736396, 0xF443088F,
+ 0xD200DC03, 0x3D30B71A, 0x098C7CC0, 0xE6BC17D9, 0x60F5EB74, 0x8FC5806D, 0xBB794BB7, 0x544920AE,
+ 0xB206C41C, 0x5D36AF05, 0x698A64DF, 0x86BA0FC6, 0x00F3F36B, 0xEFC39872, 0xDB7F53A8, 0x344F38B1,
+ 0x97F8FAB0, 0x78C891A9, 0x4C745A73, 0xA344316A, 0x250DCDC7, 0xCA3DA6DE, 0xFE816D04, 0x11B1061D,
+ 0xF7FEE2AF, 0x18CE89B6, 0x2C72426C, 0xC3422975, 0x450BD5D8, 0xAA3BBEC1, 0x9E87751B, 0x71B71E02,
+ 0x57F4CA8E, 0xB8C4A197, 0x8C786A4D, 0x63480154, 0xE501FDF9, 0x0A3196E0, 0x3E8D5D3A, 0xD1BD3623,
+ 0x37F2D291, 0xD8C2B988, 0xEC7E7252, 0x034E194B, 0x8507E5E6, 0x6A378EFF, 0x5E8B4525, 0xB1BB2E3C
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o72
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o80[256] =
+{
+ 0x00000000, 0x68032CC8, 0xD0065990, 0xB8057558, 0xA5E0C5D1, 0xCDE3E919, 0x75E69C41, 0x1DE5B089,
+ 0x4E2DFD53, 0x262ED19B, 0x9E2BA4C3, 0xF628880B, 0xEBCD3882, 0x83CE144A, 0x3BCB6112, 0x53C84DDA,
+ 0x9C5BFAA6, 0xF458D66E, 0x4C5DA336, 0x245E8FFE, 0x39BB3F77, 0x51B813BF, 0xE9BD66E7, 0x81BE4A2F,
+ 0xD27607F5, 0xBA752B3D, 0x02705E65, 0x6A7372AD, 0x7796C224, 0x1F95EEEC, 0xA7909BB4, 0xCF93B77C,
+ 0x3D5B83BD, 0x5558AF75, 0xED5DDA2D, 0x855EF6E5, 0x98BB466C, 0xF0B86AA4, 0x48BD1FFC, 0x20BE3334,
+ 0x73767EEE, 0x1B755226, 0xA370277E, 0xCB730BB6, 0xD696BB3F, 0xBE9597F7, 0x0690E2AF, 0x6E93CE67,
+ 0xA100791B, 0xC90355D3, 0x7106208B, 0x19050C43, 0x04E0BCCA, 0x6CE39002, 0xD4E6E55A, 0xBCE5C992,
+ 0xEF2D8448, 0x872EA880, 0x3F2BDDD8, 0x5728F110, 0x4ACD4199, 0x22CE6D51, 0x9ACB1809, 0xF2C834C1,
+ 0x7AB7077A, 0x12B42BB2, 0xAAB15EEA, 0xC2B27222, 0xDF57C2AB, 0xB754EE63, 0x0F519B3B, 0x6752B7F3,
+ 0x349AFA29, 0x5C99D6E1, 0xE49CA3B9, 0x8C9F8F71, 0x917A3FF8, 0xF9791330, 0x417C6668, 0x297F4AA0,
+ 0xE6ECFDDC, 0x8EEFD114, 0x36EAA44C, 0x5EE98884, 0x430C380D, 0x2B0F14C5, 0x930A619D, 0xFB094D55,
+ 0xA8C1008F, 0xC0C22C47, 0x78C7591F, 0x10C475D7, 0x0D21C55E, 0x6522E996, 0xDD279CCE, 0xB524B006,
+ 0x47EC84C7, 0x2FEFA80F, 0x97EADD57, 0xFFE9F19F, 0xE20C4116, 0x8A0F6DDE, 0x320A1886, 0x5A09344E,
+ 0x09C17994, 0x61C2555C, 0xD9C72004, 0xB1C40CCC, 0xAC21BC45, 0xC422908D, 0x7C27E5D5, 0x1424C91D,
+ 0xDBB77E61, 0xB3B452A9, 0x0BB127F1, 0x63B20B39, 0x7E57BBB0, 0x16549778, 0xAE51E220, 0xC652CEE8,
+ 0x959A8332, 0xFD99AFFA, 0x459CDAA2, 0x2D9FF66A, 0x307A46E3, 0x58796A2B, 0xE07C1F73, 0x887F33BB,
+ 0xF56E0EF4, 0x9D6D223C, 0x25685764, 0x4D6B7BAC, 0x508ECB25, 0x388DE7ED, 0x808892B5, 0xE88BBE7D,
+ 0xBB43F3A7, 0xD340DF6F, 0x6B45AA37, 0x034686FF, 0x1EA33676, 0x76A01ABE, 0xCEA56FE6, 0xA6A6432E,
+ 0x6935F452, 0x0136D89A, 0xB933ADC2, 0xD130810A, 0xCCD53183, 0xA4D61D4B, 0x1CD36813, 0x74D044DB,
+ 0x27180901, 0x4F1B25C9, 0xF71E5091, 0x9F1D7C59, 0x82F8CCD0, 0xEAFBE018, 0x52FE9540, 0x3AFDB988,
+ 0xC8358D49, 0xA036A181, 0x1833D4D9, 0x7030F811, 0x6DD54898, 0x05D66450, 0xBDD31108, 0xD5D03DC0,
+ 0x8618701A, 0xEE1B5CD2, 0x561E298A, 0x3E1D0542, 0x23F8B5CB, 0x4BFB9903, 0xF3FEEC5B, 0x9BFDC093,
+ 0x546E77EF, 0x3C6D5B27, 0x84682E7F, 0xEC6B02B7, 0xF18EB23E, 0x998D9EF6, 0x2188EBAE, 0x498BC766,
+ 0x1A438ABC, 0x7240A674, 0xCA45D32C, 0xA246FFE4, 0xBFA34F6D, 0xD7A063A5, 0x6FA516FD, 0x07A63A35,
+ 0x8FD9098E, 0xE7DA2546, 0x5FDF501E, 0x37DC7CD6, 0x2A39CC5F, 0x423AE097, 0xFA3F95CF, 0x923CB907,
+ 0xC1F4F4DD, 0xA9F7D815, 0x11F2AD4D, 0x79F18185, 0x6414310C, 0x0C171DC4, 0xB412689C, 0xDC114454,
+ 0x1382F328, 0x7B81DFE0, 0xC384AAB8, 0xAB878670, 0xB66236F9, 0xDE611A31, 0x66646F69, 0x0E6743A1,
+ 0x5DAF0E7B, 0x35AC22B3, 0x8DA957EB, 0xE5AA7B23, 0xF84FCBAA, 0x904CE762, 0x2849923A, 0x404ABEF2,
+ 0xB2828A33, 0xDA81A6FB, 0x6284D3A3, 0x0A87FF6B, 0x17624FE2, 0x7F61632A, 0xC7641672, 0xAF673ABA,
+ 0xFCAF7760, 0x94AC5BA8, 0x2CA92EF0, 0x44AA0238, 0x594FB2B1, 0x314C9E79, 0x8949EB21, 0xE14AC7E9,
+ 0x2ED97095, 0x46DA5C5D, 0xFEDF2905, 0x96DC05CD, 0x8B39B544, 0xE33A998C, 0x5B3FECD4, 0x333CC01C,
+ 0x60F48DC6, 0x08F7A10E, 0xB0F2D456, 0xD8F1F89E, 0xC5144817, 0xAD1764DF, 0x15121187, 0x7D113D4F
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o80
+ */
+
+
+
+/*
+ * The following CRC lookup table was generated automagically
+ * using the following model parameters:
+ *
+ * Generator Polynomial = ................. 0x1EDC6F41
+ * Generator Polynomial Length = .......... 32 bits
+ * Reflected Bits = ....................... TRUE
+ * Table Generation Offset = .............. 32 bits
+ * Number of Slices = ..................... 8 slices
+ * Slice Lengths = ........................ 8 8 8 8 8 8 8 8
+ * Directory Name = ....................... .\
+ * File Name = ............................ 8x256_tables.c
+ */
+
+static const uint32_t crc_tableil8_o88[256] =
+{
+ 0x00000000, 0x493C7D27, 0x9278FA4E, 0xDB448769, 0x211D826D, 0x6821FF4A, 0xB3657823, 0xFA590504,
+ 0x423B04DA, 0x0B0779FD, 0xD043FE94, 0x997F83B3, 0x632686B7, 0x2A1AFB90, 0xF15E7CF9, 0xB86201DE,
+ 0x847609B4, 0xCD4A7493, 0x160EF3FA, 0x5F328EDD, 0xA56B8BD9, 0xEC57F6FE, 0x37137197, 0x7E2F0CB0,
+ 0xC64D0D6E, 0x8F717049, 0x5435F720, 0x1D098A07, 0xE7508F03, 0xAE6CF224, 0x7528754D, 0x3C14086A,
+ 0x0D006599, 0x443C18BE, 0x9F789FD7, 0xD644E2F0, 0x2C1DE7F4, 0x65219AD3, 0xBE651DBA, 0xF759609D,
+ 0x4F3B6143, 0x06071C64, 0xDD439B0D, 0x947FE62A, 0x6E26E32E, 0x271A9E09, 0xFC5E1960, 0xB5626447,
+ 0x89766C2D, 0xC04A110A, 0x1B0E9663, 0x5232EB44, 0xA86BEE40, 0xE1579367, 0x3A13140E, 0x732F6929,
+ 0xCB4D68F7, 0x827115D0, 0x593592B9, 0x1009EF9E, 0xEA50EA9A, 0xA36C97BD, 0x782810D4, 0x31146DF3,
+ 0x1A00CB32, 0x533CB615, 0x8878317C, 0xC1444C5B, 0x3B1D495F, 0x72213478, 0xA965B311, 0xE059CE36,
+ 0x583BCFE8, 0x1107B2CF, 0xCA4335A6, 0x837F4881, 0x79264D85, 0x301A30A2, 0xEB5EB7CB, 0xA262CAEC,
+ 0x9E76C286, 0xD74ABFA1, 0x0C0E38C8, 0x453245EF, 0xBF6B40EB, 0xF6573DCC, 0x2D13BAA5, 0x642FC782,
+ 0xDC4DC65C, 0x9571BB7B, 0x4E353C12, 0x07094135, 0xFD504431, 0xB46C3916, 0x6F28BE7F, 0x2614C358,
+ 0x1700AEAB, 0x5E3CD38C, 0x857854E5, 0xCC4429C2, 0x361D2CC6, 0x7F2151E1, 0xA465D688, 0xED59ABAF,
+ 0x553BAA71, 0x1C07D756, 0xC743503F, 0x8E7F2D18, 0x7426281C, 0x3D1A553B, 0xE65ED252, 0xAF62AF75,
+ 0x9376A71F, 0xDA4ADA38, 0x010E5D51, 0x48322076, 0xB26B2572, 0xFB575855, 0x2013DF3C, 0x692FA21B,
+ 0xD14DA3C5, 0x9871DEE2, 0x4335598B, 0x0A0924AC, 0xF05021A8, 0xB96C5C8F, 0x6228DBE6, 0x2B14A6C1,
+ 0x34019664, 0x7D3DEB43, 0xA6796C2A, 0xEF45110D, 0x151C1409, 0x5C20692E, 0x8764EE47, 0xCE589360,
+ 0x763A92BE, 0x3F06EF99, 0xE44268F0, 0xAD7E15D7, 0x572710D3, 0x1E1B6DF4, 0xC55FEA9D, 0x8C6397BA,
+ 0xB0779FD0, 0xF94BE2F7, 0x220F659E, 0x6B3318B9, 0x916A1DBD, 0xD856609A, 0x0312E7F3, 0x4A2E9AD4,
+ 0xF24C9B0A, 0xBB70E62D, 0x60346144, 0x29081C63, 0xD3511967, 0x9A6D6440, 0x4129E329, 0x08159E0E,
+ 0x3901F3FD, 0x703D8EDA, 0xAB7909B3, 0xE2457494, 0x181C7190, 0x51200CB7, 0x8A648BDE, 0xC358F6F9,
+ 0x7B3AF727, 0x32068A00, 0xE9420D69, 0xA07E704E, 0x5A27754A, 0x131B086D, 0xC85F8F04, 0x8163F223,
+ 0xBD77FA49, 0xF44B876E, 0x2F0F0007, 0x66337D20, 0x9C6A7824, 0xD5560503, 0x0E12826A, 0x472EFF4D,
+ 0xFF4CFE93, 0xB67083B4, 0x6D3404DD, 0x240879FA, 0xDE517CFE, 0x976D01D9, 0x4C2986B0, 0x0515FB97,
+ 0x2E015D56, 0x673D2071, 0xBC79A718, 0xF545DA3F, 0x0F1CDF3B, 0x4620A21C, 0x9D642575, 0xD4585852,
+ 0x6C3A598C, 0x250624AB, 0xFE42A3C2, 0xB77EDEE5, 0x4D27DBE1, 0x041BA6C6, 0xDF5F21AF, 0x96635C88,
+ 0xAA7754E2, 0xE34B29C5, 0x380FAEAC, 0x7133D38B, 0x8B6AD68F, 0xC256ABA8, 0x19122CC1, 0x502E51E6,
+ 0xE84C5038, 0xA1702D1F, 0x7A34AA76, 0x3308D751, 0xC951D255, 0x806DAF72, 0x5B29281B, 0x1215553C,
+ 0x230138CF, 0x6A3D45E8, 0xB179C281, 0xF845BFA6, 0x021CBAA2, 0x4B20C785, 0x906440EC, 0xD9583DCB,
+ 0x613A3C15, 0x28064132, 0xF342C65B, 0xBA7EBB7C, 0x4027BE78, 0x091BC35F, 0xD25F4436, 0x9B633911,
+ 0xA777317B, 0xEE4B4C5C, 0x350FCB35, 0x7C33B612, 0x866AB316, 0xCF56CE31, 0x14124958, 0x5D2E347F,
+ 0xE54C35A1, 0xAC704886, 0x7734CFEF, 0x3E08B2C8, 0xC451B7CC, 0x8D6DCAEB, 0x56294D82, 0x1F1530A5
+};
+
+/*
+ * end of the CRC lookup table crc_tableil8_o88
+ */
+
+static uint32_t crc32cSlicingBy8(uint32_t crc, const void* data, size_t length) {
+    const char* p_buf = (const char*) data;
+
+    // Handle leading misaligned bytes
+    size_t initial_bytes = (sizeof(int32_t) - (intptr_t)p_buf) & (sizeof(int32_t) - 1);
+    if (length < initial_bytes) initial_bytes = length;
+    for (size_t li = 0; li < initial_bytes; li++) {
+        crc = crc_tableil8_o32[(crc ^ *p_buf++) & 0x000000FF] ^ (crc >> 8);
+    }
+
+    length -= initial_bytes;
+    size_t running_length = length & ~(sizeof(uint64_t) - 1);
+    size_t end_bytes = length - running_length; 
+
+    for (size_t li = 0; li < running_length/8; li++) {
+        crc ^= *(uint32_t*) p_buf;
+        p_buf += 4;
+        uint32_t term1 = crc_tableil8_o88[crc & 0x000000FF] ^
+                crc_tableil8_o80[(crc >> 8) & 0x000000FF];
+        uint32_t term2 = crc >> 16;
+        crc = term1 ^
+              crc_tableil8_o72[term2 & 0x000000FF] ^ 
+              crc_tableil8_o64[(term2 >> 8) & 0x000000FF];
+        term1 = crc_tableil8_o56[(*(uint32_t *)p_buf) & 0x000000FF] ^
+                crc_tableil8_o48[((*(uint32_t *)p_buf) >> 8) & 0x000000FF];
+
+        term2 = (*(uint32_t *)p_buf) >> 16;
+        crc = crc ^ term1 ^
+                crc_tableil8_o40[term2  & 0x000000FF] ^
+                crc_tableil8_o32[(term2 >> 8) & 0x000000FF];
+        p_buf += 4;
+    }
+
+    for (size_t li=0; li < end_bytes; li++) {
+        crc = crc_tableil8_o32[(crc ^ *p_buf++) & 0x000000FF] ^ (crc >> 8);
+    }
+
+    return crc;
+}
+
+uint32_t jls_crc32c_hdr(const struct jls_chunk_header_s * hdr) {
+    uint32_t crc = 0xFFFFFFFF;
+    crc = crc32cSlicingBy8(crc, (unsigned const char*) hdr, 28);
+    return (crc ^ 0xFFFFFFFF);
+}
+
+uint32_t jls_crc32c(uint8_t const *data, uint32_t length) {
+    uint32_t crc = 0xFFFFFFFF;
+    crc = crc32cSlicingBy8(crc, data, length);
+    return (crc ^ 0xFFFFFFFF);
+}
```

### Comparing `pyjls-0.7.0/src/datatype.c` & `pyjls-0.7.1/src/datatype.c`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-/*
- * Copyright 2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/datatype.h"
-#include "jls/format.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include <math.h>
-
-
-static inline int8_t uint4_to_int8(uint8_t k) {
-    k = k & 0x0f;
-    if (k & 0x08) {
-        k |= 0xf0;
-    }
-    return (int8_t) k;
-}
-
-#define TO_DOUBLE(type_) { \
-    const type_ * s = (const type_ *) src; \
-    for (uint32_t i = 0; i < samples; ++i) { \
-        *dst++ = (double) *s++; \
-    } \
-    break; \
-}
-
-int32_t jls_dt_buffer_to_f64(const void * src, uint32_t src_datatype, double * dst, size_t samples) {
-    switch (src_datatype & 0xffff) {
-        case JLS_DATATYPE_I4: {
-            const uint8_t *s = (const uint8_t *) src;
-            for (uint32_t i = 0; i < samples; i += 2) {
-                uint8_t k = s[i >> 1];
-                dst[i + 0] = (double) uint4_to_int8(k);
-                dst[i + 1] = (double) uint4_to_int8(k >> 4);
-            }
-            break;
-        }
-        case JLS_DATATYPE_I8: TO_DOUBLE(int8_t);
-        case JLS_DATATYPE_I16: TO_DOUBLE(int16_t);
-        // case JLS_DATATYPE_I24: break; todo
-        case JLS_DATATYPE_I32: TO_DOUBLE(int32_t);
-        case JLS_DATATYPE_I64: TO_DOUBLE(int64_t);
-        case JLS_DATATYPE_U1: {
-            const uint8_t *s = (const uint8_t *) src;
-            for (uint32_t i = 0; i < (samples / 8); ++i) {
-                uint8_t k = s[i];
-                *dst++ = (double) ((k >> 0) & 1);
-                *dst++ = (double) ((k >> 1) & 1);
-                *dst++ = (double) ((k >> 2) & 1);
-                *dst++ = (double) ((k >> 3) & 1);
-                *dst++ = (double) ((k >> 4) & 1);
-                *dst++ = (double) ((k >> 5) & 1);
-                *dst++ = (double) ((k >> 6) & 1);
-                *dst++ = (double) ((k >> 7) & 1);
-            }
-            break;
-        }
-        case JLS_DATATYPE_U4:  {
-            const uint8_t *s = (const uint8_t *) src;
-            for (uint32_t i = 0; i < samples; i += 2) {
-                uint8_t k = s[i >> 1];
-                dst[i + 0] = (double) (k & 0x0f);
-                dst[i + 1] = (double) ((k >> 4) & 0x0f);
-            }
-            break;
-        }
-        case JLS_DATATYPE_U8: TO_DOUBLE(uint8_t);
-        case JLS_DATATYPE_U16: TO_DOUBLE(uint16_t);
-        // case JLS_DATATYPE_U24: break;  todo
-        case JLS_DATATYPE_U32: TO_DOUBLE(uint32_t);
-        case JLS_DATATYPE_U64: TO_DOUBLE(uint64_t);
-
-        case JLS_DATATYPE_F32: TO_DOUBLE(float);
-        case JLS_DATATYPE_F64: TO_DOUBLE(double);
-        default:
-            JLS_LOGW("Invalid data type: 0x%08x", src_datatype);
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    // fixed point support
-    int8_t fp = (int8_t) ((src_datatype & 0xff) >> 16);
-    if ((src_datatype & JLS_DATATYPE_BASETYPE_UINT) && fp) {
-        double scale = pow(2.0, fp);
-        for (uint32_t i = 0; i < samples; ++i) {
-            dst[i] *= scale;
-        }
-    }
-    return 0;
-}
+/*
+ * Copyright 2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/datatype.h"
+#include "jls/format.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include <math.h>
+
+
+static inline int8_t uint4_to_int8(uint8_t k) {
+    k = k & 0x0f;
+    if (k & 0x08) {
+        k |= 0xf0;
+    }
+    return (int8_t) k;
+}
+
+#define TO_DOUBLE(type_) { \
+    const type_ * s = (const type_ *) src; \
+    for (uint32_t i = 0; i < samples; ++i) { \
+        *dst++ = (double) *s++; \
+    } \
+    break; \
+}
+
+int32_t jls_dt_buffer_to_f64(const void * src, uint32_t src_datatype, double * dst, size_t samples) {
+    switch (src_datatype & 0xffff) {
+        case JLS_DATATYPE_I4: {
+            const uint8_t *s = (const uint8_t *) src;
+            for (uint32_t i = 0; i < samples; i += 2) {
+                uint8_t k = s[i >> 1];
+                dst[i + 0] = (double) uint4_to_int8(k);
+                dst[i + 1] = (double) uint4_to_int8(k >> 4);
+            }
+            break;
+        }
+        case JLS_DATATYPE_I8: TO_DOUBLE(int8_t);
+        case JLS_DATATYPE_I16: TO_DOUBLE(int16_t);
+        // case JLS_DATATYPE_I24: break; todo
+        case JLS_DATATYPE_I32: TO_DOUBLE(int32_t);
+        case JLS_DATATYPE_I64: TO_DOUBLE(int64_t);
+        case JLS_DATATYPE_U1: {
+            const uint8_t *s = (const uint8_t *) src;
+            for (uint32_t i = 0; i < (samples / 8); ++i) {
+                uint8_t k = s[i];
+                *dst++ = (double) ((k >> 0) & 1);
+                *dst++ = (double) ((k >> 1) & 1);
+                *dst++ = (double) ((k >> 2) & 1);
+                *dst++ = (double) ((k >> 3) & 1);
+                *dst++ = (double) ((k >> 4) & 1);
+                *dst++ = (double) ((k >> 5) & 1);
+                *dst++ = (double) ((k >> 6) & 1);
+                *dst++ = (double) ((k >> 7) & 1);
+            }
+            break;
+        }
+        case JLS_DATATYPE_U4:  {
+            const uint8_t *s = (const uint8_t *) src;
+            for (uint32_t i = 0; i < samples; i += 2) {
+                uint8_t k = s[i >> 1];
+                dst[i + 0] = (double) (k & 0x0f);
+                dst[i + 1] = (double) ((k >> 4) & 0x0f);
+            }
+            break;
+        }
+        case JLS_DATATYPE_U8: TO_DOUBLE(uint8_t);
+        case JLS_DATATYPE_U16: TO_DOUBLE(uint16_t);
+        // case JLS_DATATYPE_U24: break;  todo
+        case JLS_DATATYPE_U32: TO_DOUBLE(uint32_t);
+        case JLS_DATATYPE_U64: TO_DOUBLE(uint64_t);
+
+        case JLS_DATATYPE_F32: TO_DOUBLE(float);
+        case JLS_DATATYPE_F64: TO_DOUBLE(double);
+        default:
+            JLS_LOGW("Invalid data type: 0x%08x", src_datatype);
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    // fixed point support
+    int8_t fp = (int8_t) ((src_datatype & 0xff) >> 16);
+    if ((src_datatype & JLS_DATATYPE_BASETYPE_UINT) && fp) {
+        double scale = pow(2.0, fp);
+        for (uint32_t i = 0; i < samples; ++i) {
+            dst[i] *= scale;
+        }
+    }
+    return 0;
+}
```

### Comparing `pyjls-0.7.0/src/ec.c` & `pyjls-0.7.1/src/ec.c`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-/*
- * Copyright 2014-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/ec.h"
-
-#define SWITCH_NAME(NAME, TEXT) case JLS_ERROR_ ## NAME: return #NAME;
-#define SWITCH_DESCRIPTION(NAME, TEXT) case JLS_ERROR_ ## NAME: return TEXT;
-
-
-const char * jls_error_code_name(int ec) {
-    switch (ec) {
-        JLS_ERROR_CODES(SWITCH_NAME);
-        default: return "UNKNOWN";
-    }
-}
-
-const char * jls_error_code_description(int ec) {
-    switch (ec) {
-        JLS_ERROR_CODES(SWITCH_DESCRIPTION);
-        default: return "Unknown error";
-    }
-}
+/*
+ * Copyright 2014-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/ec.h"
+
+#define SWITCH_NAME(NAME, TEXT) case JLS_ERROR_ ## NAME: return #NAME;
+#define SWITCH_DESCRIPTION(NAME, TEXT) case JLS_ERROR_ ## NAME: return TEXT;
+
+
+const char * jls_error_code_name(int ec) {
+    switch (ec) {
+        JLS_ERROR_CODES(SWITCH_NAME);
+        default: return "UNKNOWN";
+    }
+}
+
+const char * jls_error_code_description(int ec) {
+    switch (ec) {
+        JLS_ERROR_CODES(SWITCH_DESCRIPTION);
+        default: return "Unknown error";
+    }
+}
```

### Comparing `pyjls-0.7.0/src/msg_ring_buffer.c` & `pyjls-0.7.1/src/msg_ring_buffer.c`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,149 +1,149 @@
-/*
- * Copyright 2020-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/msg_ring_buffer.h"
-#include "jls/log.h"
-#include <string.h>
-
-/*
- * The message storage format is:
- *    sz[7:0], sz[15:8], sz[23:16], sz[31:24], msg[0...N]
- * The message size, sz, must be less than 0x80000000.
- * Any message with the bit[31] set is considered a control header,
- * which indicates wrap_around.
- */
-
-void jls_mrb_init(struct jls_mrb_s * self, uint8_t * buffer, uint32_t buffer_size) {
-    self->buf = buffer;
-    self->buf_size = buffer_size;
-    jls_mrb_clear(self);
-}
-
-void jls_mrb_clear(struct jls_mrb_s * self) {
-    self->head = 0;
-    self->tail = 0;
-    self->count = 0;
-    memset(self->buf, 0, self->buf_size);
-}
-
-uint32_t jls_mrb_used_bytes(struct jls_mrb_s * self) {
-    if (self->head > self->tail) {
-        return self->head - self->tail;
-    } else {
-        return (self-> head + self->buf_size) - self->tail;
-    }
-}
-
-static inline uint8_t * add_sz(uint8_t * p, uint32_t sz) {
-    p[0] = sz & 0xff;
-    p[1] = (sz >> 8) & 0xff;
-    p[2] = (sz >> 16) & 0xff;
-    p[3] = (sz >> 24) & 0xff;
-    return (p + 4);
-}
-
-uint8_t * jls_mrb_alloc(struct jls_mrb_s * self, uint32_t size) {
-    uint8_t *p = self->buf + self->head;
-    uint32_t head = self->head;
-    uint32_t tail = self->tail;
-
-    if (size > self->buf_size) {
-        JLS_LOGE("jls_mrb_alloc too big");
-        return NULL;
-    }
-
-    if (head >= tail) {
-        uint32_t end_idx = head + 4 + size + 4 + (tail ? 0 : 1);
-        if (end_idx < self->buf_size) {
-            // fits as is, no wrap
-        } else if ((size + 5) < tail) {
-            // fits after wrap
-            add_sz(p, 0xffffffffU);
-            p = self->buf;
-        } else if (head == tail) {
-            // Big item, but buffer is empty.  Reset pointers to make room.
-            self->head = 0;
-            self->tail = 0;
-            p = self->buf;
-        } else {
-            return NULL; // does not fit
-        }
-    } else if ((head + size + 5) < tail) {
-        // fits as is
-    } else {
-        return NULL; // does not fit.
-    }
-    p = add_sz(p, size);
-    head = ((uint32_t) (p - self->buf)) + size;
-    if (head >= self->buf_size) {
-        head = 0;
-    }
-    self->head = head;
-    ++self->count;
-    return p;
-}
-
-static inline uint32_t get_sz(uint8_t const * p) {
-    return ((uint32_t) p[0])
-            | (((uint32_t) p[1]) << 8)
-            | (((uint32_t) p[2]) << 16)
-            | (((uint32_t) p[3]) << 24);
-}
-
-uint8_t * jls_mrb_peek(struct jls_mrb_s * self, uint32_t * size) {
-    uint8_t *p = self->buf + self->tail;
-    uint32_t head = self->head;
-    uint32_t sz;
-    *size = 0;
-
-    if (self->tail == head) {
-        return NULL;
-    }
-    sz = get_sz(p);
-    if (sz >= 0x80000000) {
-        // rollover
-        if (head > self->tail) {
-            JLS_LOGE("buffer overflow"); // should never be possible
-            jls_mrb_clear(self);
-            return NULL;
-        }
-        self->tail = 0;
-        if (self->tail == head) {
-            return NULL;
-        }
-        p = self->buf;
-        sz = get_sz(p);
-    }
-    *size = sz;
-    return (p + 4);
-}
-
-
-uint8_t * jls_mrb_pop(struct jls_mrb_s * self, uint32_t * size) {
-    uint8_t *p = jls_mrb_peek(self, size);
-    uint32_t tail = self->tail;
-    if (p) {
-        tail += (4 + *size);
-        if (tail >= self->buf_size) {
-            tail -= self->buf_size;
-        }
-        if (self->count) {
-            --self->count;
-        }
-    }
-    self->tail = tail;
-    return p;
-}
+/*
+ * Copyright 2020-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/msg_ring_buffer.h"
+#include "jls/log.h"
+#include <string.h>
+
+/*
+ * The message storage format is:
+ *    sz[7:0], sz[15:8], sz[23:16], sz[31:24], msg[0...N]
+ * The message size, sz, must be less than 0x80000000.
+ * Any message with the bit[31] set is considered a control header,
+ * which indicates wrap_around.
+ */
+
+void jls_mrb_init(struct jls_mrb_s * self, uint8_t * buffer, uint32_t buffer_size) {
+    self->buf = buffer;
+    self->buf_size = buffer_size;
+    jls_mrb_clear(self);
+}
+
+void jls_mrb_clear(struct jls_mrb_s * self) {
+    self->head = 0;
+    self->tail = 0;
+    self->count = 0;
+    memset(self->buf, 0, self->buf_size);
+}
+
+uint32_t jls_mrb_used_bytes(struct jls_mrb_s * self) {
+    if (self->head > self->tail) {
+        return self->head - self->tail;
+    } else {
+        return (self-> head + self->buf_size) - self->tail;
+    }
+}
+
+static inline uint8_t * add_sz(uint8_t * p, uint32_t sz) {
+    p[0] = sz & 0xff;
+    p[1] = (sz >> 8) & 0xff;
+    p[2] = (sz >> 16) & 0xff;
+    p[3] = (sz >> 24) & 0xff;
+    return (p + 4);
+}
+
+uint8_t * jls_mrb_alloc(struct jls_mrb_s * self, uint32_t size) {
+    uint8_t *p = self->buf + self->head;
+    uint32_t head = self->head;
+    uint32_t tail = self->tail;
+
+    if (size > self->buf_size) {
+        JLS_LOGE("jls_mrb_alloc too big");
+        return NULL;
+    }
+
+    if (head >= tail) {
+        uint32_t end_idx = head + 4 + size + 4 + (tail ? 0 : 1);
+        if (end_idx < self->buf_size) {
+            // fits as is, no wrap
+        } else if ((size + 5) < tail) {
+            // fits after wrap
+            add_sz(p, 0xffffffffU);
+            p = self->buf;
+        } else if (head == tail) {
+            // Big item, but buffer is empty.  Reset pointers to make room.
+            self->head = 0;
+            self->tail = 0;
+            p = self->buf;
+        } else {
+            return NULL; // does not fit
+        }
+    } else if ((head + size + 5) < tail) {
+        // fits as is
+    } else {
+        return NULL; // does not fit.
+    }
+    p = add_sz(p, size);
+    head = ((uint32_t) (p - self->buf)) + size;
+    if (head >= self->buf_size) {
+        head = 0;
+    }
+    self->head = head;
+    ++self->count;
+    return p;
+}
+
+static inline uint32_t get_sz(uint8_t const * p) {
+    return ((uint32_t) p[0])
+            | (((uint32_t) p[1]) << 8)
+            | (((uint32_t) p[2]) << 16)
+            | (((uint32_t) p[3]) << 24);
+}
+
+uint8_t * jls_mrb_peek(struct jls_mrb_s * self, uint32_t * size) {
+    uint8_t *p = self->buf + self->tail;
+    uint32_t head = self->head;
+    uint32_t sz;
+    *size = 0;
+
+    if (self->tail == head) {
+        return NULL;
+    }
+    sz = get_sz(p);
+    if (sz >= 0x80000000) {
+        // rollover
+        if (head > self->tail) {
+            JLS_LOGE("buffer overflow"); // should never be possible
+            jls_mrb_clear(self);
+            return NULL;
+        }
+        self->tail = 0;
+        if (self->tail == head) {
+            return NULL;
+        }
+        p = self->buf;
+        sz = get_sz(p);
+    }
+    *size = sz;
+    return (p + 4);
+}
+
+
+uint8_t * jls_mrb_pop(struct jls_mrb_s * self, uint32_t * size) {
+    uint8_t *p = jls_mrb_peek(self, size);
+    uint32_t tail = self->tail;
+    if (p) {
+        tail += (4 + *size);
+        if (tail >= self->buf_size) {
+            tail -= self->buf_size;
+        }
+        if (self->count) {
+            --self->count;
+        }
+    }
+    self->tail = tail;
+    return p;
+}
```

### Comparing `pyjls-0.7.0/src/raw.c` & `pyjls-0.7.1/src/raw.c`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,499 +1,499 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/raw.h"
-#include "jls/format.h"
-#include "jls/time.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include "jls/crc32c.h"
-#include "jls/version.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-#include "jls/backend.h"
-
-
-
-#define CHUNK_BUFFER_SIZE  (1 << 24)
-static const uint8_t FILE_HDR[] = JLS_HEADER_IDENTIFICATION;
-
-#define ROE(x)  do {                        \
-    int32_t rc__ = (x);                     \
-    if (rc__) {                             \
-        return rc__;                        \
-    }                                       \
-} while (0)
-
-#define RLE(x)  do {                        \
-    int32_t rc__ = (x);                     \
-    if (rc__) {                             \
-        JLS_LOGE("error %d: " #x, rc__);    \
-        return rc__;                        \
-    }                                       \
-} while (0)
-
-struct jls_raw_s {
-    struct jls_bkf_s backend;
-    struct jls_chunk_header_s hdr;  // the current chunk header.
-    int64_t offset;                 // the offset for the current chunk
-    uint8_t write_en;
-    union jls_version_u version;
-};
-
-static inline void invalidate_current_chunk(struct jls_raw_s * self) {
-    self->hdr.tag = JLS_TAG_INVALID;
-}
-
-static inline uint32_t payload_size_on_disk(uint32_t payload_size) {
-    if (!payload_size) {
-        return 0;
-    }
-    uint8_t pad = (uint8_t) ((payload_size + 4) & 7);
-    if (pad != 0) {
-        pad = 8 - pad;
-    }
-    return payload_size + pad + 4;
-}
-
-static int32_t wr_file_header(struct jls_raw_s * self) {
-    int32_t rc = 0;
-    int64_t pos = jls_bk_ftell(&self->backend);
-    jls_bk_fseek(&self->backend, 0L, SEEK_END);
-    int64_t file_sz = jls_bk_ftell(&self->backend);
-    jls_bk_fseek(&self->backend, 0L, SEEK_SET);
-
-    struct jls_file_header_s hdr = {
-            .identification = JLS_HEADER_IDENTIFICATION,
-            .length = file_sz,
-            .version = {.u32 = JLS_FORMAT_VERSION_U32},
-            .crc32 = 0,
-    };
-    hdr.crc32 = jls_crc32c((uint8_t *) &hdr, sizeof(hdr) - 4);
-    RLE(jls_bk_fwrite(&self->backend, &hdr, sizeof(hdr)));
-    if (pos != 0) {
-        jls_bk_fseek(&self->backend, pos, SEEK_SET);
-    } else {
-        self->offset = self->backend.fpos;
-    }
-    return rc;
-}
-
-static int32_t rd_file_header(struct jls_raw_s * self, struct jls_file_header_s * hdr) {
-    if (jls_bk_fread(&self->backend, hdr, sizeof(*hdr))) {
-        JLS_LOGE("could not read file header");
-        return JLS_ERROR_UNSUPPORTED_FILE;
-    }
-    uint32_t crc32 = jls_crc32c((uint8_t *) hdr, sizeof(*hdr) - 4);
-    if (crc32 != hdr->crc32) {
-        JLS_LOGE("file header crc mismatch: 0x%08x != 0x%08x", crc32, hdr->crc32);
-        return JLS_ERROR_UNSUPPORTED_FILE;
-    }
-
-    if (0 != memcmp(FILE_HDR, hdr->identification, sizeof(FILE_HDR))) {
-        JLS_LOGE("invalid file header identification");
-        return JLS_ERROR_UNSUPPORTED_FILE;
-    }
-
-    if (hdr->version.s.major > JLS_FORMAT_VERSION_MAJOR) {
-        JLS_LOGE("unsupported file format: %d > %d", (int) hdr->version.s.major, JLS_FORMAT_VERSION_MAJOR);
-        return JLS_ERROR_UNSUPPORTED_FILE;
-    } else if (hdr->version.s.major < JLS_FORMAT_VERSION_MAJOR) {
-        JLS_LOGI("old file format: %d < %d", (int) hdr->version.s.major, JLS_FORMAT_VERSION_MAJOR);
-    }
-    self->version.u32 = hdr->version.u32;
-
-    if (0 == hdr->length) {
-        JLS_LOGW("file header length 0, not closed gracefully");
-    }
-
-    return 0;
-}
-
-static void fend_get(struct jls_raw_s * self) {
-    int64_t pos = jls_bk_ftell(&self->backend);
-    if (jls_bk_fseek(&self->backend, 0, SEEK_END)) {
-        JLS_LOGE("seek to end failed");
-    } else {
-        self->backend.fend = self->backend.fpos;
-        jls_bk_fseek(&self->backend, pos, SEEK_SET);
-    }
-}
-
-static int32_t read_verify(struct jls_raw_s * self) {
-    struct jls_file_header_s file_hdr;
-    if (!self->backend.fd) {
-        return JLS_ERROR_IO;
-    }
-    int32_t rc = rd_file_header(self, &file_hdr);
-    self->offset = self->backend.fpos;
-    if (!rc) {
-        fend_get(self);
-    }
-    return rc;
-}
-
-int32_t jls_raw_open(struct jls_raw_s ** instance, const char * path, const char * mode) {
-    int32_t rc = 0;
-
-    if (!instance || !path || !mode) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    *instance = NULL;
-
-    struct jls_raw_s * self = calloc(1, sizeof(struct jls_raw_s));
-    if (!self) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    self->backend.fd = -1;
-    ROE(jls_bk_fopen(&self->backend, path, mode));
-
-    switch (mode[0]) {
-        case 'w':
-            self->write_en = 1;
-            rc = wr_file_header(self);
-            self->offset = self->backend.fpos;
-            self->version.u32 = JLS_FORMAT_VERSION_U32;
-            break;
-        case 'r':
-            rc = read_verify(self);
-            break;
-        case 'a':
-            self->write_en = 1;
-            rc = read_verify(self);
-            if (self->version.u32 != JLS_FORMAT_VERSION_U32) {
-                JLS_LOGE("cannot append, different format versions");
-                rc = JLS_ERROR_UNSUPPORTED_FILE;
-            } else if (jls_bk_fseek(&self->backend, 0, SEEK_END)) {
-                rc = JLS_ERROR_IO;
-            } else {
-                self->offset = self->backend.fpos;
-            }
-            break;
-        default:
-            rc = JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    if (rc) {
-        jls_bk_fclose(&self->backend);
-        free(self);
-    } else {
-        *instance = self;
-    }
-    return rc;
-}
-
-int32_t jls_raw_close(struct jls_raw_s * self) {
-    if (self) {
-        if ((self->backend.fd != -1) && (self->write_en)) {
-            wr_file_header(self);
-        }
-        jls_bk_fclose(&self->backend);
-        free(self);
-    }
-    return 0;
-}
-
-union jls_version_u jls_raw_version(struct jls_raw_s * self) {
-    return self->version;
-}
-
-int32_t jls_raw_wr(struct jls_raw_s * self, struct jls_chunk_header_s * hdr, const uint8_t * payload) {
-    JLS_LOGD3("wr @ %" PRId64 " : %d %s", jls_raw_chunk_tell(self), (int) hdr->tag, jls_tag_to_name(hdr->tag));
-    RLE(jls_raw_wr_header(self, hdr));
-    RLE(jls_raw_wr_payload(self, hdr->payload_length, payload));
-    invalidate_current_chunk(self);
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int32_t jls_raw_wr_header(struct jls_raw_s * self, struct jls_chunk_header_s * hdr) {
-    hdr->crc32 = jls_crc32c_hdr(hdr);
-    if (self->offset != self->backend.fpos) {
-        invalidate_current_chunk(self);
-        RLE(jls_bk_fseek(&self->backend, self->offset, SEEK_SET));
-    }
-    if (jls_bk_fwrite(&self->backend, hdr, sizeof(*hdr))) {
-        return JLS_ERROR_IO;
-    }
-    self->hdr = *hdr;
-    return 0;
-}
-
-int32_t jls_raw_wr_payload(struct jls_raw_s * self, uint32_t payload_length, const uint8_t * payload) {
-    if (!self) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    struct jls_chunk_header_s * hdr = &self->hdr;
-    if (hdr->tag == JLS_TAG_INVALID) {
-        RLE(jls_raw_rd_header(self, hdr));
-    }
-    if (!payload_length) {
-        return 0;  // no action necessary
-    }
-    if (!payload) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    uint8_t footer[11] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
-    uint8_t pad = (uint8_t) ((hdr->payload_length + 4) & 7);
-    if (pad != 0) {
-        pad = 8 - pad;
-    }
-    uint32_t crc32 = jls_crc32c(payload, hdr->payload_length);
-    footer[pad + 0] = crc32 & 0xff;
-    footer[pad + 1] = (crc32 >> 8) & 0xff;
-    footer[pad + 2] = (crc32 >> 16) & 0xff;
-    footer[pad + 3] = (crc32 >> 24) & 0xff;
-
-    RLE(jls_bk_fwrite(&self->backend, payload, hdr->payload_length));
-    return jls_bk_fwrite(&self->backend, footer, pad + 4);
-}
-
-int32_t jls_raw_rd(struct jls_raw_s * self, struct jls_chunk_header_s * hdr, uint32_t payload_length_max, uint8_t * payload) {
-    RLE(jls_raw_rd_header(self, hdr));
-    JLS_LOGD1("rd %" PRId64 " : %d %s", self->offset, (int) hdr->tag, jls_tag_to_name(hdr->tag));
-    RLE(jls_raw_rd_payload(self, payload_length_max, payload));
-    invalidate_current_chunk(self);
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int32_t jls_raw_rd_header(struct jls_raw_s * self, struct jls_chunk_header_s * hdr) {
-    struct jls_chunk_header_s * h = &self->hdr;
-    if (hdr) {
-        hdr->tag = JLS_TAG_INVALID;
-    }
-    if (self->hdr.tag == JLS_TAG_INVALID) {
-        if (self->backend.fpos >= self->backend.fend) {
-            JLS_LOGE("fpos %" PRIi64 " >= end %" PRIi64, self->backend.fpos, self->backend.fend);
-            invalidate_current_chunk(self);
-            return JLS_ERROR_EMPTY;
-        }
-        if (self->offset != self->backend.fpos) {
-            if (jls_bk_fseek(&self->backend, self->offset, SEEK_SET)) {
-                JLS_LOGE("seek failed");
-                invalidate_current_chunk(self);
-                return JLS_ERROR_IO;
-            }
-        }
-        self->offset = self->backend.fpos;
-        if (jls_bk_fread(&self->backend, (uint8_t *) h, sizeof(*h))) {
-            invalidate_current_chunk(self);
-            return JLS_ERROR_EMPTY;
-        }
-        uint32_t crc32 = jls_crc32c_hdr(h);
-        if (crc32 != h->crc32) {
-            JLS_LOGE("chunk header crc error: %u != %u", crc32, h->crc32);
-            invalidate_current_chunk(self);
-            return JLS_ERROR_MESSAGE_INTEGRITY;
-        }
-    }
-    if (hdr) {
-        *hdr = self->hdr;
-    }
-    return 0;
-}
-
-int32_t jls_raw_rd_payload(struct jls_raw_s * self, uint32_t payload_length_max, uint8_t * payload) {
-    uint32_t crc32_file;
-    uint32_t crc32_calc;
-    struct jls_chunk_header_s * hdr = &self->hdr;
-    if (hdr->tag == JLS_TAG_INVALID) {
-        RLE(jls_raw_rd_header(self, hdr));
-    }
-    if (!hdr->payload_length) {
-        return 0;
-    }
-
-    uint32_t rd_size = payload_size_on_disk(hdr->payload_length);
-
-    if (rd_size > payload_length_max) {
-        return JLS_ERROR_TOO_BIG;
-    }
-
-    int64_t pos = self->offset + sizeof(struct jls_chunk_header_s);
-    if (pos != self->backend.fpos) {
-        jls_bk_fseek(&self->backend, pos, SEEK_SET);
-        self->backend.fpos = pos;
-    }
-
-    RLE(jls_bk_fread(&self->backend, (uint8_t *) payload, rd_size));
-    crc32_calc = jls_crc32c(payload, hdr->payload_length);
-    crc32_file = ((uint32_t)payload[rd_size - 4])
-        | (((uint32_t)payload[rd_size - 3]) << 8)
-        | (((uint32_t)payload[rd_size - 2]) << 16)
-        | (((uint32_t)payload[rd_size - 1]) << 24);
-    if (crc32_calc != crc32_file) {
-        JLS_LOGE("crc32 mismatch: 0x%08x != 0x%08x", crc32_file, crc32_calc);
-        return JLS_ERROR_MESSAGE_INTEGRITY;
-    }
-    return 0;
-}
-
-int32_t jls_raw_chunk_seek(struct jls_raw_s * self, int64_t offset) {
-    invalidate_current_chunk(self);
-    if (offset == 0) {
-        JLS_LOGW("seek to 0");
-        return JLS_ERROR_IO;
-    }
-    if (jls_bk_fseek(&self->backend, offset, SEEK_SET)) {
-        return JLS_ERROR_IO;
-    }
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int64_t jls_raw_chunk_tell(struct jls_raw_s * self) {
-    return self->offset;
-}
-
-int32_t jls_raw_flush(struct jls_raw_s * self) {
-    return jls_bk_fflush(&self->backend);
-}
-
-int32_t jls_raw_chunk_next(struct jls_raw_s * self) {
-    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
-    invalidate_current_chunk(self);
-    int64_t offset = self->offset;
-    int64_t pos = offset;
-    pos += sizeof(struct jls_chunk_header_s) + payload_size_on_disk(self->hdr.payload_length);
-    if (pos > self->backend.fend) {
-        return JLS_ERROR_EMPTY;
-    }
-    if (pos != self->backend.fpos) {
-        // sequential access
-        if (jls_bk_fseek(&self->backend, pos, SEEK_SET)) {
-            return JLS_ERROR_EMPTY;
-        }
-    }
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int32_t jls_raw_chunk_prev(struct jls_raw_s * self) {
-    if (self->backend.fpos >= self->backend.fend) {
-        invalidate_current_chunk(self);
-        return JLS_ERROR_NOT_FOUND;
-    }
-    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
-    invalidate_current_chunk(self);
-    int64_t offset = self->offset;
-    int64_t pos = offset;
-    pos -= sizeof(struct jls_chunk_header_s) + payload_size_on_disk(self->hdr.payload_prev_length);
-    if (pos < (int64_t) sizeof(struct jls_file_header_s)) {
-        return JLS_ERROR_EMPTY;
-    }
-    if (pos != self->backend.fpos) {
-        // sequential access
-        jls_bk_fseek(&self->backend, pos, SEEK_SET);
-    }
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int32_t jls_raw_item_next(struct jls_raw_s * self) {
-    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
-    int64_t offset = self->hdr.item_next;
-    int64_t pos = offset;
-    if ((pos == 0) || (pos > self->backend.fend)) {
-        return JLS_ERROR_EMPTY;
-    }
-
-    invalidate_current_chunk(self);
-    if (jls_bk_fseek(&self->backend, pos, SEEK_SET)) {
-        return JLS_ERROR_EMPTY;
-    }
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int32_t jls_raw_item_prev(struct jls_raw_s * self) {
-    if (self->backend.fpos >= self->backend.fend) {
-        invalidate_current_chunk(self);
-        return JLS_ERROR_NOT_FOUND;
-    }
-    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
-    int64_t pos = self->hdr.item_prev;
-    if ((pos == 0) || (pos == self->offset)) {
-        return JLS_ERROR_EMPTY;
-    }
-    invalidate_current_chunk(self);
-    RLE(jls_bk_fseek(&self->backend, pos, SEEK_SET));
-    self->offset = self->backend.fpos;
-    return 0;
-}
-
-int64_t jls_raw_chunk_tell_end(struct jls_raw_s * self) {
-    int64_t starting_pos = jls_raw_chunk_tell(self);
-    int64_t end_pos = self->backend.fend - sizeof(struct jls_chunk_header_s);
-    if (end_pos < (int64_t) sizeof(struct jls_file_header_s)) {
-        return 0;
-    }
-    if (jls_raw_chunk_seek(self, end_pos)) {
-        JLS_LOGW("seek to end failed");
-        return 0;
-    }
-    if (jls_raw_rd_header(self, NULL)) {
-        JLS_LOGW("end chunk not found");
-        return 0;
-    }
-    if (self->hdr.tag != JLS_TAG_END) {
-        end_pos = 0;
-    }
-    jls_raw_chunk_seek(self, starting_pos);
-    return end_pos;
-}
-
-const char * jls_tag_to_name(uint8_t tag) {
-    switch (tag) {
-        case JLS_TAG_INVALID:                   return "invalid";
-        case JLS_TAG_SOURCE_DEF:                return "source_def";
-        case JLS_TAG_SIGNAL_DEF:                return "signal_def";
-        case JLS_TAG_TRACK_FSR_DEF:             return "track_fsr_def";
-        case JLS_TAG_TRACK_FSR_HEAD:            return "track_fsr_head";
-        case JLS_TAG_TRACK_FSR_DATA:            return "track_fsr_data";
-        case JLS_TAG_TRACK_FSR_INDEX:           return "track_fsr_index";
-        case JLS_TAG_TRACK_FSR_SUMMARY:         return "track_fsr_summary";
-        case JLS_TAG_TRACK_VSR_DEF:             return "track_vsr_def";
-        case JLS_TAG_TRACK_VSR_HEAD:            return "track_vsr_head";
-        case JLS_TAG_TRACK_VSR_DATA:            return "track_vsr_data";
-        case JLS_TAG_TRACK_VSR_INDEX:           return "track_vsr_index";
-        case JLS_TAG_TRACK_VSR_SUMMARY:         return "track_vsr_summary";
-        case JLS_TAG_TRACK_ANNOTATION_DEF:      return "track_annotation_def";
-        case JLS_TAG_TRACK_ANNOTATION_HEAD:     return "track_annotation_head";
-        case JLS_TAG_TRACK_ANNOTATION_DATA:     return "track_annotation_data";
-        case JLS_TAG_TRACK_ANNOTATION_INDEX:    return "track_annotation_index";
-        case JLS_TAG_TRACK_ANNOTATION_SUMMARY:  return "track_annotation_summary";
-        case JLS_TAG_TRACK_UTC_DEF:             return "track_utc_def";
-        case JLS_TAG_TRACK_UTC_HEAD:            return "track_utc_head";
-        case JLS_TAG_TRACK_UTC_DATA:            return "track_utc_data";
-        case JLS_TAG_TRACK_UTC_INDEX:           return "track_utc_index";
-        case JLS_TAG_TRACK_UTC_SUMMARY:         return "track_utc_summary";
-        case JLS_TAG_USER_DATA:                 return "user_data";
-        case JLS_TAG_END:                       return "end";
-        default:                                return "unknown";
-    }
-}
-
-const char * jls_version_str(void) {
-    return JLS_VERSION_STR;
-}
-
-uint32_t jls_version_u32(void) {
-    return JLS_VERSION_U32;
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/raw.h"
+#include "jls/format.h"
+#include "jls/time.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include "jls/crc32c.h"
+#include "jls/version.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+#include "jls/backend.h"
+
+
+
+#define CHUNK_BUFFER_SIZE  (1 << 24)
+static const uint8_t FILE_HDR[] = JLS_HEADER_IDENTIFICATION;
+
+#define ROE(x)  do {                        \
+    int32_t rc__ = (x);                     \
+    if (rc__) {                             \
+        return rc__;                        \
+    }                                       \
+} while (0)
+
+#define RLE(x)  do {                        \
+    int32_t rc__ = (x);                     \
+    if (rc__) {                             \
+        JLS_LOGE("error %d: " #x, rc__);    \
+        return rc__;                        \
+    }                                       \
+} while (0)
+
+struct jls_raw_s {
+    struct jls_bkf_s backend;
+    struct jls_chunk_header_s hdr;  // the current chunk header.
+    int64_t offset;                 // the offset for the current chunk
+    uint8_t write_en;
+    union jls_version_u version;
+};
+
+static inline void invalidate_current_chunk(struct jls_raw_s * self) {
+    self->hdr.tag = JLS_TAG_INVALID;
+}
+
+static inline uint32_t payload_size_on_disk(uint32_t payload_size) {
+    if (!payload_size) {
+        return 0;
+    }
+    uint8_t pad = (uint8_t) ((payload_size + 4) & 7);
+    if (pad != 0) {
+        pad = 8 - pad;
+    }
+    return payload_size + pad + 4;
+}
+
+static int32_t wr_file_header(struct jls_raw_s * self) {
+    int32_t rc = 0;
+    int64_t pos = jls_bk_ftell(&self->backend);
+    jls_bk_fseek(&self->backend, 0L, SEEK_END);
+    int64_t file_sz = jls_bk_ftell(&self->backend);
+    jls_bk_fseek(&self->backend, 0L, SEEK_SET);
+
+    struct jls_file_header_s hdr = {
+            .identification = JLS_HEADER_IDENTIFICATION,
+            .length = file_sz,
+            .version = {.u32 = JLS_FORMAT_VERSION_U32},
+            .crc32 = 0,
+    };
+    hdr.crc32 = jls_crc32c((uint8_t *) &hdr, sizeof(hdr) - 4);
+    RLE(jls_bk_fwrite(&self->backend, &hdr, sizeof(hdr)));
+    if (pos != 0) {
+        jls_bk_fseek(&self->backend, pos, SEEK_SET);
+    } else {
+        self->offset = self->backend.fpos;
+    }
+    return rc;
+}
+
+static int32_t rd_file_header(struct jls_raw_s * self, struct jls_file_header_s * hdr) {
+    if (jls_bk_fread(&self->backend, hdr, sizeof(*hdr))) {
+        JLS_LOGE("could not read file header");
+        return JLS_ERROR_UNSUPPORTED_FILE;
+    }
+    uint32_t crc32 = jls_crc32c((uint8_t *) hdr, sizeof(*hdr) - 4);
+    if (crc32 != hdr->crc32) {
+        JLS_LOGE("file header crc mismatch: 0x%08x != 0x%08x", crc32, hdr->crc32);
+        return JLS_ERROR_UNSUPPORTED_FILE;
+    }
+
+    if (0 != memcmp(FILE_HDR, hdr->identification, sizeof(FILE_HDR))) {
+        JLS_LOGE("invalid file header identification");
+        return JLS_ERROR_UNSUPPORTED_FILE;
+    }
+
+    if (hdr->version.s.major > JLS_FORMAT_VERSION_MAJOR) {
+        JLS_LOGE("unsupported file format: %d > %d", (int) hdr->version.s.major, JLS_FORMAT_VERSION_MAJOR);
+        return JLS_ERROR_UNSUPPORTED_FILE;
+    } else if (hdr->version.s.major < JLS_FORMAT_VERSION_MAJOR) {
+        JLS_LOGI("old file format: %d < %d", (int) hdr->version.s.major, JLS_FORMAT_VERSION_MAJOR);
+    }
+    self->version.u32 = hdr->version.u32;
+
+    if (0 == hdr->length) {
+        JLS_LOGW("file header length 0, not closed gracefully");
+    }
+
+    return 0;
+}
+
+static void fend_get(struct jls_raw_s * self) {
+    int64_t pos = jls_bk_ftell(&self->backend);
+    if (jls_bk_fseek(&self->backend, 0, SEEK_END)) {
+        JLS_LOGE("seek to end failed");
+    } else {
+        self->backend.fend = self->backend.fpos;
+        jls_bk_fseek(&self->backend, pos, SEEK_SET);
+    }
+}
+
+static int32_t read_verify(struct jls_raw_s * self) {
+    struct jls_file_header_s file_hdr;
+    if (!self->backend.fd) {
+        return JLS_ERROR_IO;
+    }
+    int32_t rc = rd_file_header(self, &file_hdr);
+    self->offset = self->backend.fpos;
+    if (!rc) {
+        fend_get(self);
+    }
+    return rc;
+}
+
+int32_t jls_raw_open(struct jls_raw_s ** instance, const char * path, const char * mode) {
+    int32_t rc = 0;
+
+    if (!instance || !path || !mode) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    *instance = NULL;
+
+    struct jls_raw_s * self = calloc(1, sizeof(struct jls_raw_s));
+    if (!self) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    self->backend.fd = -1;
+    ROE(jls_bk_fopen(&self->backend, path, mode));
+
+    switch (mode[0]) {
+        case 'w':
+            self->write_en = 1;
+            rc = wr_file_header(self);
+            self->offset = self->backend.fpos;
+            self->version.u32 = JLS_FORMAT_VERSION_U32;
+            break;
+        case 'r':
+            rc = read_verify(self);
+            break;
+        case 'a':
+            self->write_en = 1;
+            rc = read_verify(self);
+            if (self->version.u32 != JLS_FORMAT_VERSION_U32) {
+                JLS_LOGE("cannot append, different format versions");
+                rc = JLS_ERROR_UNSUPPORTED_FILE;
+            } else if (jls_bk_fseek(&self->backend, 0, SEEK_END)) {
+                rc = JLS_ERROR_IO;
+            } else {
+                self->offset = self->backend.fpos;
+            }
+            break;
+        default:
+            rc = JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    if (rc) {
+        jls_bk_fclose(&self->backend);
+        free(self);
+    } else {
+        *instance = self;
+    }
+    return rc;
+}
+
+int32_t jls_raw_close(struct jls_raw_s * self) {
+    if (self) {
+        if ((self->backend.fd != -1) && (self->write_en)) {
+            wr_file_header(self);
+        }
+        jls_bk_fclose(&self->backend);
+        free(self);
+    }
+    return 0;
+}
+
+union jls_version_u jls_raw_version(struct jls_raw_s * self) {
+    return self->version;
+}
+
+int32_t jls_raw_wr(struct jls_raw_s * self, struct jls_chunk_header_s * hdr, const uint8_t * payload) {
+    JLS_LOGD3("wr @ %" PRId64 " : %d %s", jls_raw_chunk_tell(self), (int) hdr->tag, jls_tag_to_name(hdr->tag));
+    RLE(jls_raw_wr_header(self, hdr));
+    RLE(jls_raw_wr_payload(self, hdr->payload_length, payload));
+    invalidate_current_chunk(self);
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int32_t jls_raw_wr_header(struct jls_raw_s * self, struct jls_chunk_header_s * hdr) {
+    hdr->crc32 = jls_crc32c_hdr(hdr);
+    if (self->offset != self->backend.fpos) {
+        invalidate_current_chunk(self);
+        RLE(jls_bk_fseek(&self->backend, self->offset, SEEK_SET));
+    }
+    if (jls_bk_fwrite(&self->backend, hdr, sizeof(*hdr))) {
+        return JLS_ERROR_IO;
+    }
+    self->hdr = *hdr;
+    return 0;
+}
+
+int32_t jls_raw_wr_payload(struct jls_raw_s * self, uint32_t payload_length, const uint8_t * payload) {
+    if (!self) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    struct jls_chunk_header_s * hdr = &self->hdr;
+    if (hdr->tag == JLS_TAG_INVALID) {
+        RLE(jls_raw_rd_header(self, hdr));
+    }
+    if (!payload_length) {
+        return 0;  // no action necessary
+    }
+    if (!payload) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    uint8_t footer[11] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+    uint8_t pad = (uint8_t) ((hdr->payload_length + 4) & 7);
+    if (pad != 0) {
+        pad = 8 - pad;
+    }
+    uint32_t crc32 = jls_crc32c(payload, hdr->payload_length);
+    footer[pad + 0] = crc32 & 0xff;
+    footer[pad + 1] = (crc32 >> 8) & 0xff;
+    footer[pad + 2] = (crc32 >> 16) & 0xff;
+    footer[pad + 3] = (crc32 >> 24) & 0xff;
+
+    RLE(jls_bk_fwrite(&self->backend, payload, hdr->payload_length));
+    return jls_bk_fwrite(&self->backend, footer, pad + 4);
+}
+
+int32_t jls_raw_rd(struct jls_raw_s * self, struct jls_chunk_header_s * hdr, uint32_t payload_length_max, uint8_t * payload) {
+    RLE(jls_raw_rd_header(self, hdr));
+    JLS_LOGD1("rd %" PRId64 " : %d %s", self->offset, (int) hdr->tag, jls_tag_to_name(hdr->tag));
+    RLE(jls_raw_rd_payload(self, payload_length_max, payload));
+    invalidate_current_chunk(self);
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int32_t jls_raw_rd_header(struct jls_raw_s * self, struct jls_chunk_header_s * hdr) {
+    struct jls_chunk_header_s * h = &self->hdr;
+    if (hdr) {
+        hdr->tag = JLS_TAG_INVALID;
+    }
+    if (self->hdr.tag == JLS_TAG_INVALID) {
+        if (self->backend.fpos >= self->backend.fend) {
+            JLS_LOGE("fpos %" PRIi64 " >= end %" PRIi64, self->backend.fpos, self->backend.fend);
+            invalidate_current_chunk(self);
+            return JLS_ERROR_EMPTY;
+        }
+        if (self->offset != self->backend.fpos) {
+            if (jls_bk_fseek(&self->backend, self->offset, SEEK_SET)) {
+                JLS_LOGE("seek failed");
+                invalidate_current_chunk(self);
+                return JLS_ERROR_IO;
+            }
+        }
+        self->offset = self->backend.fpos;
+        if (jls_bk_fread(&self->backend, (uint8_t *) h, sizeof(*h))) {
+            invalidate_current_chunk(self);
+            return JLS_ERROR_EMPTY;
+        }
+        uint32_t crc32 = jls_crc32c_hdr(h);
+        if (crc32 != h->crc32) {
+            JLS_LOGE("chunk header crc error: %u != %u", crc32, h->crc32);
+            invalidate_current_chunk(self);
+            return JLS_ERROR_MESSAGE_INTEGRITY;
+        }
+    }
+    if (hdr) {
+        *hdr = self->hdr;
+    }
+    return 0;
+}
+
+int32_t jls_raw_rd_payload(struct jls_raw_s * self, uint32_t payload_length_max, uint8_t * payload) {
+    uint32_t crc32_file;
+    uint32_t crc32_calc;
+    struct jls_chunk_header_s * hdr = &self->hdr;
+    if (hdr->tag == JLS_TAG_INVALID) {
+        RLE(jls_raw_rd_header(self, hdr));
+    }
+    if (!hdr->payload_length) {
+        return 0;
+    }
+
+    uint32_t rd_size = payload_size_on_disk(hdr->payload_length);
+
+    if (rd_size > payload_length_max) {
+        return JLS_ERROR_TOO_BIG;
+    }
+
+    int64_t pos = self->offset + sizeof(struct jls_chunk_header_s);
+    if (pos != self->backend.fpos) {
+        jls_bk_fseek(&self->backend, pos, SEEK_SET);
+        self->backend.fpos = pos;
+    }
+
+    RLE(jls_bk_fread(&self->backend, (uint8_t *) payload, rd_size));
+    crc32_calc = jls_crc32c(payload, hdr->payload_length);
+    crc32_file = ((uint32_t)payload[rd_size - 4])
+        | (((uint32_t)payload[rd_size - 3]) << 8)
+        | (((uint32_t)payload[rd_size - 2]) << 16)
+        | (((uint32_t)payload[rd_size - 1]) << 24);
+    if (crc32_calc != crc32_file) {
+        JLS_LOGE("crc32 mismatch: 0x%08x != 0x%08x", crc32_file, crc32_calc);
+        return JLS_ERROR_MESSAGE_INTEGRITY;
+    }
+    return 0;
+}
+
+int32_t jls_raw_chunk_seek(struct jls_raw_s * self, int64_t offset) {
+    invalidate_current_chunk(self);
+    if (offset == 0) {
+        JLS_LOGW("seek to 0");
+        return JLS_ERROR_IO;
+    }
+    if (jls_bk_fseek(&self->backend, offset, SEEK_SET)) {
+        return JLS_ERROR_IO;
+    }
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int64_t jls_raw_chunk_tell(struct jls_raw_s * self) {
+    return self->offset;
+}
+
+int32_t jls_raw_flush(struct jls_raw_s * self) {
+    return jls_bk_fflush(&self->backend);
+}
+
+int32_t jls_raw_chunk_next(struct jls_raw_s * self) {
+    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
+    invalidate_current_chunk(self);
+    int64_t offset = self->offset;
+    int64_t pos = offset;
+    pos += sizeof(struct jls_chunk_header_s) + payload_size_on_disk(self->hdr.payload_length);
+    if (pos > self->backend.fend) {
+        return JLS_ERROR_EMPTY;
+    }
+    if (pos != self->backend.fpos) {
+        // sequential access
+        if (jls_bk_fseek(&self->backend, pos, SEEK_SET)) {
+            return JLS_ERROR_EMPTY;
+        }
+    }
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int32_t jls_raw_chunk_prev(struct jls_raw_s * self) {
+    if (self->backend.fpos >= self->backend.fend) {
+        invalidate_current_chunk(self);
+        return JLS_ERROR_NOT_FOUND;
+    }
+    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
+    invalidate_current_chunk(self);
+    int64_t offset = self->offset;
+    int64_t pos = offset;
+    pos -= sizeof(struct jls_chunk_header_s) + payload_size_on_disk(self->hdr.payload_prev_length);
+    if (pos < (int64_t) sizeof(struct jls_file_header_s)) {
+        return JLS_ERROR_EMPTY;
+    }
+    if (pos != self->backend.fpos) {
+        // sequential access
+        jls_bk_fseek(&self->backend, pos, SEEK_SET);
+    }
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int32_t jls_raw_item_next(struct jls_raw_s * self) {
+    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
+    int64_t offset = self->hdr.item_next;
+    int64_t pos = offset;
+    if ((pos == 0) || (pos > self->backend.fend)) {
+        return JLS_ERROR_EMPTY;
+    }
+
+    invalidate_current_chunk(self);
+    if (jls_bk_fseek(&self->backend, pos, SEEK_SET)) {
+        return JLS_ERROR_EMPTY;
+    }
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int32_t jls_raw_item_prev(struct jls_raw_s * self) {
+    if (self->backend.fpos >= self->backend.fend) {
+        invalidate_current_chunk(self);
+        return JLS_ERROR_NOT_FOUND;
+    }
+    RLE(jls_raw_rd_header(self, NULL));  // ensure that we have the header
+    int64_t pos = self->hdr.item_prev;
+    if ((pos == 0) || (pos == self->offset)) {
+        return JLS_ERROR_EMPTY;
+    }
+    invalidate_current_chunk(self);
+    RLE(jls_bk_fseek(&self->backend, pos, SEEK_SET));
+    self->offset = self->backend.fpos;
+    return 0;
+}
+
+int64_t jls_raw_chunk_tell_end(struct jls_raw_s * self) {
+    int64_t starting_pos = jls_raw_chunk_tell(self);
+    int64_t end_pos = self->backend.fend - sizeof(struct jls_chunk_header_s);
+    if (end_pos < (int64_t) sizeof(struct jls_file_header_s)) {
+        return 0;
+    }
+    if (jls_raw_chunk_seek(self, end_pos)) {
+        JLS_LOGW("seek to end failed");
+        return 0;
+    }
+    if (jls_raw_rd_header(self, NULL)) {
+        JLS_LOGW("end chunk not found");
+        return 0;
+    }
+    if (self->hdr.tag != JLS_TAG_END) {
+        end_pos = 0;
+    }
+    jls_raw_chunk_seek(self, starting_pos);
+    return end_pos;
+}
+
+const char * jls_tag_to_name(uint8_t tag) {
+    switch (tag) {
+        case JLS_TAG_INVALID:                   return "invalid";
+        case JLS_TAG_SOURCE_DEF:                return "source_def";
+        case JLS_TAG_SIGNAL_DEF:                return "signal_def";
+        case JLS_TAG_TRACK_FSR_DEF:             return "track_fsr_def";
+        case JLS_TAG_TRACK_FSR_HEAD:            return "track_fsr_head";
+        case JLS_TAG_TRACK_FSR_DATA:            return "track_fsr_data";
+        case JLS_TAG_TRACK_FSR_INDEX:           return "track_fsr_index";
+        case JLS_TAG_TRACK_FSR_SUMMARY:         return "track_fsr_summary";
+        case JLS_TAG_TRACK_VSR_DEF:             return "track_vsr_def";
+        case JLS_TAG_TRACK_VSR_HEAD:            return "track_vsr_head";
+        case JLS_TAG_TRACK_VSR_DATA:            return "track_vsr_data";
+        case JLS_TAG_TRACK_VSR_INDEX:           return "track_vsr_index";
+        case JLS_TAG_TRACK_VSR_SUMMARY:         return "track_vsr_summary";
+        case JLS_TAG_TRACK_ANNOTATION_DEF:      return "track_annotation_def";
+        case JLS_TAG_TRACK_ANNOTATION_HEAD:     return "track_annotation_head";
+        case JLS_TAG_TRACK_ANNOTATION_DATA:     return "track_annotation_data";
+        case JLS_TAG_TRACK_ANNOTATION_INDEX:    return "track_annotation_index";
+        case JLS_TAG_TRACK_ANNOTATION_SUMMARY:  return "track_annotation_summary";
+        case JLS_TAG_TRACK_UTC_DEF:             return "track_utc_def";
+        case JLS_TAG_TRACK_UTC_HEAD:            return "track_utc_head";
+        case JLS_TAG_TRACK_UTC_DATA:            return "track_utc_data";
+        case JLS_TAG_TRACK_UTC_INDEX:           return "track_utc_index";
+        case JLS_TAG_TRACK_UTC_SUMMARY:         return "track_utc_summary";
+        case JLS_TAG_USER_DATA:                 return "user_data";
+        case JLS_TAG_END:                       return "end";
+        default:                                return "unknown";
+    }
+}
+
+const char * jls_version_str(void) {
+    return JLS_VERSION_STR;
+}
+
+uint32_t jls_version_u32(void) {
+    return JLS_VERSION_U32;
+}
```

### Comparing `pyjls-0.7.0/src/reader.c` & `pyjls-0.7.1/src/reader.c`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,1451 +1,1451 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/reader.h"
-#include "jls/raw.h"
-#include "jls/format.h"
-#include "jls/datatype.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include "jls/crc32c.h"
-#include "jls/rd_fsr.h"
-#include "jls/statistics.h"
-#include "jls/bit_shift.h"
-#include "jls/util.h"
-#include <inttypes.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdbool.h>
-#include <float.h>
-
-#define PAYLOAD_BUFFER_SIZE_DEFAULT (1 << 25)   // 32 MB
-#define STRING_BUFFER_SIZE_DEFAULT (1 << 23)    // 8 MB
-#define ANNOTATIONS_SIZE_DEFAULT (1 << 20)      // 1 MB
-#define F64_BUF_LENGTH_MIN (1 << 16)
-#define SIGNAL_MASK  (0x0fff)
-#define DECIMATE_PER_DURATION (25)
-
-
-#define ROE(x)  do {                        \
-    int32_t rc__ = (x);                     \
-    if (rc__) {                             \
-        return rc__;                        \
-    }                                       \
-} while (0)
-
-#define RLE(x)  do {                        \
-    int32_t rc__ = (x);                     \
-    if (rc__) {                             \
-        JLS_LOGE("error %d: " #x, rc__);    \
-        return rc__;                        \
-    }                                       \
-} while (0)
-
-#if 0
-struct source_s {
-    struct jls_source_def_s def;
-};
-
-struct signal_s {
-    struct jls_signal_def_s def;
-};
-
-struct jls_rd_s {
-    struct source_s * sources[JLS_SOURCE_COUNT];
-    struct signal_s * signals[JLS_SIGNAL_COUNT];
-    struct jls_chunk_header_s hdr;  // the header for the current chunk
-    uint8_t * chunk_buffer;         // storage for the
-    size_t chunk_buffer_sz;
-    FILE * f;
-};
-#endif
-
-
-struct chunk_s {
-    struct jls_chunk_header_s hdr;
-    int64_t offset;
-};
-
-struct payload_s {
-    uint8_t * start;
-    uint8_t * cur;
-    uint8_t * end;  // current end
-    size_t length;  // current length
-    size_t alloc_size;
-};
-
-struct strings_s {
-    struct strings_s * next;
-    char * start;
-    char * cur;
-    char * end;
-};
-
-struct f64_buf_s {
-    double * start;
-    double * end;
-    size_t alloc_length;  // in double
-    double buffer[];
-};
-
-struct signal_s {
-    int64_t timestamp_start;
-    int64_t timestamp_end;
-    int64_t track_defs[JLS_TRACK_TYPE_COUNT];
-    int64_t track_head_offsets[JLS_TRACK_TYPE_COUNT];
-    int64_t track_head_data[JLS_TRACK_TYPE_COUNT][JLS_SUMMARY_LEVEL_COUNT];
-    struct jls_rd_fsr_s * rd_fsr;
-};
-
-struct jls_rd_s {
-    struct jls_raw_s * raw;
-    struct jls_source_def_s source_def[JLS_SOURCE_COUNT];
-    struct jls_source_def_s source_def_api[JLS_SOURCE_COUNT];
-    struct jls_signal_def_s signal_def[JLS_SIGNAL_COUNT];
-    struct jls_signal_def_s signal_def_api[JLS_SOURCE_COUNT];
-    int64_t signal_length[JLS_SOURCE_COUNT];
-
-    struct signal_s signals[JLS_SIGNAL_COUNT];
-
-    struct chunk_s chunk_cur;
-    struct payload_s payload;
-    struct strings_s * strings_tail;
-    struct strings_s * strings_head;
-    struct f64_buf_s * f64_sample_buf;
-    struct f64_buf_s * f64_stats_buf;
-
-    struct chunk_s source_head;  // source_def
-    struct chunk_s signal_head;  // signal_det, track_*_def, track_*_head
-
-    struct chunk_s user_data_head;  // user_data, ignore first
-};
-
-static int32_t strings_alloc(struct jls_rd_s * self) {
-    struct strings_s * s = malloc(STRING_BUFFER_SIZE_DEFAULT);
-    if (!s) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    char * c8 = (char *) s;
-    s->next = NULL;
-    s->start = c8 + sizeof(struct strings_s);
-    s->cur = s->start;
-    s->end = c8 + STRING_BUFFER_SIZE_DEFAULT;
-    if (!self->strings_head) {
-        self->strings_head = s;
-        self->strings_tail = s;
-    } else {
-        self->strings_tail->next = s;
-    }
-    return 0;
-}
-
-static void strings_free(struct jls_rd_s * self) {
-    struct strings_s * s = self->strings_head;
-    while (s) {
-        struct strings_s * n = s->next;
-        free(s);
-        s = n;
-    }
-}
-
-static int32_t f64_buf_alloc(size_t length, struct f64_buf_s ** buf) {
-    if (*buf) {
-        if ((*buf)->alloc_length >= (size_t) length) {
-            return 0;
-        } else {
-            free(*buf);
-            *buf = NULL;
-        }
-    }
-
-    if (length < F64_BUF_LENGTH_MIN) {
-        length = F64_BUF_LENGTH_MIN;
-    }
-    struct f64_buf_s * b = malloc(sizeof(struct f64_buf_s) + length * sizeof(double));
-    if (!b) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    b->start = b->buffer;
-    b->end = b->buffer + length;
-    b->alloc_length = length;
-    *buf = b;
-    return 0;
-}
-
-static int32_t payload_skip(struct jls_rd_s * self, size_t count) {
-    if ((self->payload.cur + count) > self->payload.end) {
-        return JLS_ERROR_EMPTY;
-    }
-    self->payload.cur += count;
-    return 0;
-}
-
-static int32_t payload_parse_u8(struct jls_rd_s * self, uint8_t * value) {
-    if ((self->payload.cur + 1) > self->payload.end) {
-        return JLS_ERROR_EMPTY;
-    }
-    *value = self->payload.cur[0];
-    self->payload.cur += 1;
-    return 0;
-}
-
-static int32_t payload_parse_u16(struct jls_rd_s * self, uint16_t * value) {
-    if ((self->payload.cur + 2) > self->payload.end) {
-        return JLS_ERROR_EMPTY;
-    }
-    *value = ((uint16_t) self->payload.cur[0])
-            | (((uint16_t) self->payload.cur[1]) << 8);
-    self->payload.cur += 2;
-    return 0;
-}
-
-static int32_t payload_parse_u32(struct jls_rd_s * self, uint32_t * value) {
-    if ((self->payload.cur + 4) > self->payload.end) {
-        return JLS_ERROR_EMPTY;
-    }
-    *value = ((uint32_t) self->payload.cur[0])
-             | (((uint32_t) self->payload.cur[1]) << 8)
-             | (((uint32_t) self->payload.cur[2]) << 16)
-             | (((uint32_t) self->payload.cur[3]) << 24);
-    self->payload.cur += 4;
-    return 0;
-}
-
-#if 0
-
-static int32_t payload_parse_u64(struct jls_rd_s * self, uint64_t * value) {
-    if ((self->payload.cur + 8) > self->payload.end) {
-        return JLS_ERROR_EMPTY;
-    }
-    *value = ((uint64_t) self->payload.cur[0])
-             | (((uint64_t) self->payload.cur[1]) << 8)
-             | (((uint64_t) self->payload.cur[2]) << 16)
-             | (((uint64_t) self->payload.cur[3]) << 24)
-             | (((uint64_t) self->payload.cur[4]) << 32)
-             | (((uint64_t) self->payload.cur[5]) << 40)
-             | (((uint64_t) self->payload.cur[6]) << 48)
-             | (((uint64_t) self->payload.cur[7]) << 56);
-    self->payload.cur += 8;
-    return 0;
-}
-
-#endif
-
-static int32_t payload_parse_str(struct jls_rd_s * self, char ** value) {
-    struct strings_s * s = self->strings_tail;
-    char * str = s->cur;
-    char ch;
-    while (self->payload.cur != self->payload.end) {
-        if (s->cur >= s->end) {
-            ROE(strings_alloc(self));
-            // copy over partial.
-            while (str <= s->end) {
-                *self->strings_tail->cur++ = *str++;
-            }
-            s = self->strings_tail;
-            str = s->start;
-        }
-
-        ch = (char) *self->payload.cur++;
-        *s->cur++ = ch;
-        if (ch == 0) {
-            if (*self->payload.cur == 0x1f) {
-                self->payload.cur++;
-            }
-            *value = str;
-            return 0;
-        }
-    }
-
-    *value = NULL;
-    return JLS_ERROR_EMPTY;
-}
-
-static int32_t rd(struct jls_rd_s * self) {
-    while (1) {
-        self->chunk_cur.offset = jls_raw_chunk_tell(self->raw);
-        int32_t rc = jls_raw_rd(self->raw, &self->chunk_cur.hdr, (uint32_t) self->payload.alloc_size, self->payload.start);
-        if (rc == JLS_ERROR_TOO_BIG) {
-            size_t sz_new = self->payload.alloc_size;
-            while (sz_new < self->chunk_cur.hdr.payload_length) {
-                sz_new *= 2;
-            }
-            uint8_t *ptr = realloc(self->payload.start, sz_new);
-            if (!ptr) {
-                return JLS_ERROR_NOT_ENOUGH_MEMORY;
-            }
-            self->payload.start = ptr;
-            self->payload.cur = ptr;
-            self->payload.end = ptr;
-            self->payload.length = 0;
-            self->payload.alloc_size = sz_new;
-        } else if (rc == 0) {
-            self->payload.cur = self->payload.start;
-            self->payload.length = self->chunk_cur.hdr.payload_length;
-            self->payload.end = self->payload.start + self->payload.length;
-            return 0;
-        } else {
-            return rc;
-        }
-    }
-}
-
-static int32_t scan_sources(struct jls_rd_s * self) {
-    JLS_LOGD1("scan_sources");
-    ROE(jls_raw_chunk_seek(self->raw, self->source_head.offset));
-    while (1) {
-        ROE(rd(self));
-        uint16_t source_id = self->chunk_cur.hdr.chunk_meta;
-        if (source_id >= JLS_SOURCE_COUNT) {
-            JLS_LOGW("source_id %d too big - skip", (int) source_id);
-        } else {
-            struct jls_source_def_s *src = &self->source_def[source_id];
-            ROE(payload_skip(self, 64));
-            ROE(payload_parse_str(self, (char **) &src->name));
-            ROE(payload_parse_str(self, (char **) &src->vendor));
-            ROE(payload_parse_str(self, (char **) &src->model));
-            ROE(payload_parse_str(self, (char **) &src->version));
-            ROE(payload_parse_str(self, (char **) &src->serial_number));
-            src->source_id = source_id;  // indicate that this source is valid!
-            JLS_LOGD1("Found source %d : %s", (int) source_id, src->name);
-        }
-        if (!self->chunk_cur.hdr.item_next) {
-            break;
-        }
-        ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
-    }
-    return 0;
-}
-
-static int32_t signal_validate(struct jls_rd_s * self, uint16_t signal_id, struct jls_signal_def_s * s) {
-    if (signal_id >= JLS_SIGNAL_COUNT) {
-        JLS_LOGW("signal_id %d too big - skip", (int) signal_id);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (self->source_def[s->source_id].source_id != s->source_id) {
-        JLS_LOGW("signal %d: source_id %d not found", (int) signal_id, (int) s->source_id);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    switch (s->signal_type) {
-        case JLS_SIGNAL_TYPE_FSR: break;
-        case JLS_SIGNAL_TYPE_VSR: break;
-        default:
-            JLS_LOGW("signal %d: invalid signal_type: %d", (int) signal_id, (int) s->signal_type);
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    // todo check data_type
-    return 0;
-}
-
-static int32_t handle_signal_def(struct jls_rd_s * self) {
-    uint16_t signal_id = self->chunk_cur.hdr.chunk_meta;
-    if (signal_id >= JLS_SIGNAL_COUNT) {
-        JLS_LOGW("signal_id %d too big - skip", (int) signal_id);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    struct jls_signal_def_s *s = &self->signal_def[signal_id];
-    s->signal_id = signal_id;
-    ROE(payload_parse_u16(self, &s->source_id));
-    ROE(payload_parse_u8(self, &s->signal_type));
-    ROE(payload_skip(self, 1));
-    ROE(payload_parse_u32(self, &s->data_type));
-    ROE(payload_parse_u32(self, &s->sample_rate));
-    ROE(payload_parse_u32(self, &s->samples_per_data));
-    ROE(payload_parse_u32(self, &s->sample_decimate_factor));
-    ROE(payload_parse_u32(self, &s->entries_per_summary));
-    ROE(payload_parse_u32(self, &s->summary_decimate_factor));
-    ROE(payload_parse_u32(self, &s->annotation_decimate_factor));
-    ROE(payload_parse_u32(self, &s->utc_decimate_factor));
-    ROE(payload_skip(self, 92));
-    ROE(payload_parse_str(self, (char **) &s->name));
-    ROE(payload_parse_str(self, (char **) &s->units));
-    if (0 == signal_validate(self, signal_id, s)) {  // validate passed
-        s->signal_id = signal_id;  // indicate that this signal is valid
-        JLS_LOGD1("Found signal %d : %s", (int) signal_id, s->name);
-    }  // else skip
-    return 0;
-}
-
-static bool is_signal_defined(struct jls_rd_s * self, uint16_t signal_id) {
-    signal_id &= SIGNAL_MASK;  // mask off chunk_meta depth
-    if (signal_id >= JLS_SIGNAL_COUNT) {
-        JLS_LOGW("signal_id %d too big", (int) signal_id);
-        return false;
-    }
-    if (self->signal_def[signal_id].signal_id != signal_id) {
-        JLS_LOGW("signal_id %d not defined", (int) signal_id);
-        return false;
-    }
-    return true;
-}
-
-static bool is_signal_defined_type(struct jls_rd_s * self, uint16_t signal_id, enum jls_signal_type_e type) {
-    if (!is_signal_defined(self, signal_id)) {
-        return false;
-    }
-    return self->signal_def[signal_id].signal_type == type;
-}
-
-static inline uint8_t tag_parse_track_type(uint8_t tag) {
-    return (tag >> 3) & 3;
-}
-
-static int32_t validate_track_tag(struct jls_rd_s * self, uint16_t signal_id, uint8_t tag) {
-    if (!is_signal_defined(self, signal_id)) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
-    uint8_t track_type = tag_parse_track_type(tag);
-    switch (signal_def->signal_type) {
-        case JLS_SIGNAL_TYPE_FSR:
-            if ((track_type == JLS_TRACK_TYPE_FSR)
-                || (track_type == JLS_TRACK_TYPE_ANNOTATION)
-                || (track_type == JLS_TRACK_TYPE_UTC)) {
-                // good
-            } else {
-                JLS_LOGW("unsupported track %d for FSR signal", (int) track_type);
-                return JLS_ERROR_PARAMETER_INVALID;
-            }
-            break;
-        case JLS_SIGNAL_TYPE_VSR:
-            if ((track_type == JLS_TRACK_TYPE_VSR)
-                || (track_type == JLS_TRACK_TYPE_ANNOTATION)) {
-                // good
-            } else {
-                JLS_LOGW("unsupported track %d for VSR signal", (int) track_type);
-                return JLS_ERROR_PARAMETER_INVALID;
-            }
-            break;
-        default:
-            // should have already been checked.
-            JLS_LOGW("unsupported signal type: %d", (int) signal_def->signal_type);
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-    return 0;
-}
-
-static int32_t handle_track_def(struct jls_rd_s * self, int64_t pos) {
-    uint16_t signal_id = self->chunk_cur.hdr.chunk_meta & SIGNAL_MASK;
-    ROE(validate_track_tag(self, signal_id, self->chunk_cur.hdr.tag));
-    self->signals[signal_id].track_defs[tag_parse_track_type(self->chunk_cur.hdr.tag)] = pos;
-    return 0;
-}
-
-static int32_t handle_track_head(struct jls_rd_s * self, int64_t pos) {
-    uint16_t signal_id = self->chunk_cur.hdr.chunk_meta & SIGNAL_MASK;
-    ROE(validate_track_tag(self, signal_id, self->chunk_cur.hdr.tag));
-    uint8_t track_type = tag_parse_track_type(self->chunk_cur.hdr.tag);
-
-    self->signals[signal_id].track_head_offsets[track_type] = pos;
-    size_t expect_sz = JLS_SUMMARY_LEVEL_COUNT * sizeof(int64_t);
-
-    if (self->payload.length != expect_sz) {
-        JLS_LOGW("cannot parse signal %d head, sz=%zu, expect=%zu",
-                 (int) signal_id, self->payload.length, expect_sz);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    memcpy(self->signals[signal_id].track_head_data[track_type], self->payload.start, expect_sz);
-    return 0;
-}
-
-static int32_t scan_signals(struct jls_rd_s * self) {
-    JLS_LOGD1("scan_signals");
-    ROE(jls_raw_chunk_seek(self->raw, self->signal_head.offset));
-    while (1) {
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag == JLS_TAG_SIGNAL_DEF) {
-            handle_signal_def(self);
-        } else if ((self->chunk_cur.hdr.tag & 7) == JLS_TRACK_CHUNK_DEF) {
-            handle_track_def(self, self->chunk_cur.offset);
-        } else if ((self->chunk_cur.hdr.tag & 7) == JLS_TRACK_CHUNK_HEAD) {
-            handle_track_head(self, self->chunk_cur.offset);
-        } else {
-            JLS_LOGW("unknown tag %d in signal list", (int) self->chunk_cur.hdr.tag);
-        }
-        if (!self->chunk_cur.hdr.item_next) {
-            break;
-        }
-        ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
-    }
-    return 0;
-}
-
-static int32_t scan_fsr_sample_id(struct jls_rd_s * self) {
-    JLS_LOGD1("scan_fsr_sample_id");
-    for (uint32_t signal_id = 1; signal_id < JLS_SIGNAL_COUNT; ++signal_id) {
-        if ((self->signal_def[signal_id].signal_id != signal_id)
-                || (self->signal_def[signal_id].signal_type != JLS_SIGNAL_TYPE_FSR)) {
-            continue;
-        }
-        struct signal_s * s = &self->signals[signal_id];
-        int64_t offset = s->track_head_data[JLS_TRACK_TYPE_FSR][0];
-        if (offset == 0) {
-            continue;  // no data
-        }
-        ROE(jls_raw_chunk_seek(self->raw, offset));
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_FSR_DATA) {
-            JLS_LOGW("scan_fsr_sample_id tag mismatch: %d", (int) self->chunk_cur.hdr.tag);
-            continue;
-        }
-
-        struct jls_fsr_data_s * r = (struct jls_fsr_data_s *) self->payload.start;
-        self->signal_def[signal_id].sample_id_offset = r->header.timestamp;
-    }
-    return 0;
-}
-
-static int32_t scan(struct jls_rd_s * self) {
-    int32_t rc = 0;
-    uint8_t found = 0;
-
-    for (int i = 0; found != 7; ++i) {
-        if (i == 3) {
-            JLS_LOGW("malformed JLS, continue searching");
-        }
-        int64_t pos = jls_raw_chunk_tell(self->raw);
-        rc = rd(self);
-        if (rc == JLS_ERROR_EMPTY) {
-            return 0;
-        } else if (rc) {
-            return rc;
-        }
-
-        JLS_LOGD1("scan tag %d : %s", self->chunk_cur.hdr.tag, jls_tag_to_name(self->chunk_cur.hdr.tag));
-        switch (self->chunk_cur.hdr.tag) {
-            case JLS_TAG_USER_DATA:
-                found |= 1;
-                if (!self->user_data_head.offset) {
-                    self->user_data_head.offset = pos;
-                    self->user_data_head.hdr = self->chunk_cur.hdr;
-                }
-                break;
-            case JLS_TAG_SOURCE_DEF:
-                found |= 2;
-                if (!self->source_head.offset) {
-                    self->source_head.offset = pos;
-                    self->source_head.hdr = self->chunk_cur.hdr;
-                }
-                break;
-            case JLS_TAG_SIGNAL_DEF:
-                found |= 4;
-                if (!self->signal_head.offset) {
-                    self->signal_head.offset = pos;
-                    self->signal_head.hdr = self->chunk_cur.hdr;
-                }
-                break;
-            default:
-                break;  // skip
-        }
-    }
-    JLS_LOGD1("found initial tags");
-    ROE(scan_sources(self));
-    ROE(scan_signals(self));
-    ROE(scan_fsr_sample_id(self));
-    return 0;
-}
-
-int32_t jls_rd_open(struct jls_rd_s ** instance, const char * path) {
-    if (!instance) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    struct jls_rd_s *self = calloc(1, sizeof(struct jls_rd_s));
-    if (!self) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-
-    for (int32_t k = 0; k < JLS_SOURCE_COUNT; ++k) {
-        self->signal_length[k] = -1;
-    }
-
-    self->payload.start = malloc(PAYLOAD_BUFFER_SIZE_DEFAULT);
-    strings_alloc(self);
-
-    if (!self->payload.start || !self->strings_head) {
-        jls_rd_close(self);
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    self->payload.alloc_size = PAYLOAD_BUFFER_SIZE_DEFAULT;
-    self->payload.cur = self->payload.start;
-    self->payload.end = self->payload.start;
-
-    int32_t rc = jls_raw_open(&self->raw, path, "r");
-    if (rc) {
-        jls_rd_close(self);
-        return rc;
-    }
-
-    if (jls_raw_version(self->raw).s.major < 1) {
-        JLS_LOGE("version < 1.x.x no longer supported");
-        return JLS_ERROR_UNSUPPORTED_FILE;
-    }
-
-    int64_t end_pos = jls_raw_chunk_tell_end(self->raw);
-    if (!end_pos) {
-        JLS_LOGW("not properly closed");
-        // Not properly closed.  Indices & summary may be incomplete.
-        // for most applications, will want to launch file reconstruction tool
-        return JLS_ERROR_MESSAGE_INTEGRITY;
-    }
-
-    ROE(scan(self));
-    *instance = self;
-    return rc;
-}
-
-void jls_rd_close(struct jls_rd_s * self) {
-    if (self) {
-        jls_raw_close(self->raw);
-        strings_free(self);
-        if (self->payload.start) {
-            free(self->payload.start);
-            self->payload.start = NULL;
-        }
-        if (self->f64_stats_buf) {
-            free(self->f64_stats_buf);
-            self->f64_stats_buf = NULL;
-        }
-        if (self->f64_sample_buf) {
-            free(self->f64_sample_buf);
-            self->f64_sample_buf = NULL;
-        }
-        self->raw = NULL;
-        free(self);
-    }
-}
-
-int32_t jls_rd_sources(struct jls_rd_s * self, struct jls_source_def_s ** sources, uint16_t * count) {
-    if (!self || !sources || !count) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    uint16_t c = 0;
-    for (uint16_t i = 0; i < JLS_SOURCE_COUNT; ++i) {
-        if (self->source_def[i].source_id == i) {
-            // Note: source 0 is always defined, so calloc is ok
-            self->source_def_api[c++] = self->source_def[i];
-        }
-    }
-    *sources = self->source_def_api;
-    *count = c;
-    return 0;
-}
-
-int32_t jls_rd_signals(struct jls_rd_s * self, struct jls_signal_def_s ** signals, uint16_t * count) {
-    if (!self || !signals || !count) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    uint16_t c = 0;
-    for (uint16_t i = 0; i < JLS_SIGNAL_COUNT; ++i) {
-        if (self->signal_def[i].signal_id == i) {
-            // Note: signal 0 is always defined, so calloc is ok
-            self->signal_def_api[c++] = self->signal_def[i];
-        }
-    }
-    *signals = self->signal_def_api;
-    *count = c;
-    return 0;
-}
-
-int32_t jls_rd_signal(struct jls_rd_s * self, uint16_t signal_id, struct jls_signal_def_s * signal) {
-    if (!is_signal_defined(self, signal_id)) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-    if (signal) {
-        *signal = self->signal_def[signal_id];
-    }
-    return 0;
-}
-
-static int32_t ts_seek(struct jls_rd_s * self, uint16_t signal_id, uint8_t level,
-                       enum jls_track_type_e track_type, int64_t timestamp) {
-    // timestamp in JLS units with possible non-zero offset
-    if (!is_signal_defined(self, signal_id)) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-    switch (track_type) {
-        case JLS_TRACK_TYPE_VSR: break;
-        case JLS_TRACK_TYPE_ANNOTATION: break;
-        case JLS_TRACK_TYPE_UTC: break;
-        default:
-            JLS_LOGW("ts_seek: unsupported track type: %d", (int) track_type);
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-    struct signal_s * s = &self->signals[signal_id];
-    int64_t offset = 0;
-    int64_t * offsets = s->track_head_data[track_type];
-
-    int initial_level = JLS_SUMMARY_LEVEL_COUNT - 1;
-    for (; initial_level >= 0; --initial_level) {
-        if (offsets[initial_level]) {
-            offset = offsets[initial_level];
-            break;
-        }
-    }
-    if (!offset) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-
-    for (int lvl = initial_level; lvl > level; --lvl) {
-        JLS_LOGD3("signal %d, level %d, offset=%" PRIi64, (int) signal_id, (int) lvl, offset);
-        ROE(jls_raw_chunk_seek(self->raw, offset));
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag != jls_track_tag_pack(track_type, JLS_TRACK_CHUNK_INDEX)) {
-            JLS_LOGW("seek tag mismatch: %d", (int) self->chunk_cur.hdr.tag);
-        }
-
-        struct jls_index_s * r = (struct jls_index_s *) self->payload.start;
-        uint8_t * p_end = (uint8_t *) &r->entries[r->header.entry_count];
-
-        if ((size_t) (p_end - self->payload.start) > self->payload.length) {
-            JLS_LOGE("invalid payload length");
-            return JLS_ERROR_PARAMETER_INVALID;
-        }
-        if ((r->header.entry_count == 0) || (r->header.entry_count & 0x80000000)) {
-            JLS_LOGE("invalid entry count");
-            return JLS_ERROR_PARAMETER_INVALID;
-        }
-
-        int32_t idx = 0;
-        for (; ; ++idx) {
-            if (idx >= (int32_t) r->header.entry_count) {
-                idx = ((int32_t) r->header.entry_count) - 1;
-                break;
-            } else if (r->entries[idx].timestamp> timestamp) {
-                --idx;
-                break;
-            } else if (r->entries[idx].timestamp == timestamp) {
-                break;
-            }
-        }
-        if (idx < 0) {
-            idx = 0;
-        }
-        offset = r->entries[idx].offset;
-    }
-
-    ROE(jls_raw_chunk_seek(self->raw, offset));
-    return 0;
-}
-
-static int32_t fsr_seek(struct jls_rd_s * self, uint16_t signal_id, uint8_t level, int64_t sample_id) {
-    // timestamp in JLS units with possible non-zero offset
-    if (!is_signal_defined(self, signal_id)) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
-    if (signal_def->signal_type != JLS_SIGNAL_TYPE_FSR) {
-        JLS_LOGW("fsr_seek not support for signal type %d", (int) signal_def->signal_type);
-        return JLS_ERROR_NOT_SUPPORTED;
-    }
-    struct signal_s * s = &self->signals[signal_id];
-    int64_t offset = 0;
-    int64_t * offsets = s->track_head_data[JLS_TRACK_TYPE_FSR];
-    int initial_level = JLS_SUMMARY_LEVEL_COUNT - 1;
-    for (; initial_level >= 0; --initial_level) {
-        if (offsets[initial_level]) {
-            offset = offsets[initial_level];
-            break;
-        }
-    }
-    if (!offset) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-
-    for (int lvl = initial_level; lvl > level; --lvl) {
-        // compute the step size in samples between each index entry.
-        int64_t step_size = signal_def->samples_per_data;  // each data chunk
-        if (lvl > 1) {
-            step_size *= signal_def->entries_per_summary /
-                    (signal_def->samples_per_data / signal_def->sample_decimate_factor);
-        }
-        for (int k = 3; k <= lvl; ++k) {
-            step_size *= signal_def->summary_decimate_factor;
-        }
-        JLS_LOGD3("signal %d, level %d, offset=%" PRIi64 ", step_size=%" PRIi64,
-                 (int) signal_id, lvl, offset, step_size);
-        ROE(jls_raw_chunk_seek(self->raw, offset));
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_FSR_INDEX) {
-            JLS_LOGW("seek tag mismatch: %d", (int) self->chunk_cur.hdr.tag);
-        }
-
-        struct jls_fsr_index_s * r = (struct jls_fsr_index_s *) self->payload.start;
-        int64_t chunk_timestamp = r->header.timestamp;
-        int64_t chunk_entries = r->header.entry_count;
-        JLS_LOGD3("timestamp=%" PRIi64 ", entries=%" PRIi64, chunk_timestamp, chunk_entries);
-        uint8_t * p_end = (uint8_t *) &r->offsets[r->header.entry_count];
-
-        if ((size_t) (p_end - self->payload.start) > self->payload.length) {
-            JLS_LOGE("invalid payload length");
-            return JLS_ERROR_PARAMETER_INVALID;
-        }
-
-        int64_t idx = (sample_id - chunk_timestamp) / step_size;
-        if ((idx < 0) || (idx >= chunk_entries)) {
-            JLS_LOGE("invalid index signal %d, level %d, sample_id=%"
-                     PRIi64 " offset=%" PRIi64 ": %" PRIi64 " >= %" PRIi64,
-                     (int) signal_id, lvl, sample_id,
-                     offset, idx, chunk_entries);
-            return JLS_ERROR_IO;
-        }
-        offset = r->offsets[idx];
-    }
-
-    ROE(jls_raw_chunk_seek(self->raw, offset));
-    return 0;
-}
-
-
-int32_t jls_rd_fsr_length(struct jls_rd_s * self, uint16_t signal_id, int64_t * samples) {
-    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (self->signal_length[signal_id] >= 0) {
-        *samples = self->signal_length[signal_id];
-        return 0;
-    }
-
-    struct signal_s * s = &self->signals[signal_id];
-    int64_t offset = 0;
-    int64_t * offsets = s->track_head_data[JLS_TRACK_TYPE_FSR];
-    int level = JLS_SUMMARY_LEVEL_COUNT - 1;
-    for (; level >= 0; --level) {
-        if (offsets[level]) {
-            offset = offsets[level];
-            break;
-        }
-    }
-    if (!offset) {
-        *samples = 0;
-        return 0;
-    }
-    struct jls_fsr_index_s * r;
-
-    for (int lvl = level; lvl > 0; --lvl) {
-        JLS_LOGD3("signal %d, level %d, index=%" PRIi64, (int) signal_id, (int) lvl, offset);
-        ROE(jls_raw_chunk_seek(self->raw, offset));
-        ROE(rd(self));
-
-        r = (struct jls_fsr_index_s *) self->payload.start;
-        if (r->header.entry_size_bits != (sizeof(r->offsets[0]) * 8)) {
-            JLS_LOGE("invalid FSR index entry size: %d bits", (int) r->header.entry_size_bits);
-            return JLS_ERROR_PARAMETER_INVALID;
-        }
-        size_t sz = sizeof(r->header) + r->header.entry_count * sizeof(r->offsets[0]);
-        if (sz > self->payload.length) {
-            JLS_LOGE("invalid payload length");
-            return JLS_ERROR_PARAMETER_INVALID;
-        }
-        if (r->header.entry_count > 0) {
-            offset = r->offsets[r->header.entry_count - 1];
-        }
-    }
-
-    ROE(jls_raw_chunk_seek(self->raw, offset));
-    ROE(rd(self));
-    r = (struct jls_fsr_index_s *) self->payload.start;
-    self->signal_length[signal_id] = r->header.timestamp + r->header.entry_count
-            - self->signal_def[signal_id].sample_id_offset;
-    *samples = self->signal_length[signal_id];
-    return 0;
-}
-
-int32_t jls_rd_fsr(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
-                   void * data, int64_t data_length) {
-    // start_sample_id is API zero-based
-    const int64_t data_length_orig = data_length;
-    int32_t rv = 0;
-    uint8_t * data_u8 = (uint8_t *) data;
-    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
-        JLS_LOGW("signal_id %d invalid", (int) signal_id);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    int64_t samples = 0;
-    ROE(jls_rd_fsr_length(self, signal_id, &samples));
-    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
-    if (data_length <= 0) {
-        return 0;
-    } else if (start_sample_id < 0) {
-        JLS_LOGW("rd_fsr %d %s: start_sample_id invalid %" PRIi64 " length=%" PRIi64,
-                 (int) signal_id, signal_def->name,
-                 start_sample_id, samples);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
-    uint8_t entry_size_bits = jls_datatype_parse_size(signal_def->data_type);
-
-    if ((start_sample_id + data_length) > samples) {
-        JLS_LOGW("rd_fsr %d %s: start=%" PRIi64 " length=%" PRIi64 " > %" PRIi64 " by %" PRIi64,
-                 (int) signal_id, signal_def->name,
-                 start_sample_id, data_length, samples,
-                 start_sample_id + data_length - samples);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    uint8_t shift_right_bits = 0;
-    if (entry_size_bits < 8) {
-        int64_t sample_id = start_sample_id;
-        switch (entry_size_bits) {
-            case 1:
-                sample_id &= ~0x07;
-                if (sample_id != start_sample_id) {
-                    shift_right_bits = (uint8_t) (start_sample_id - sample_id);
-                }
-                break;
-            case 4:
-                sample_id &= ~0x01;
-                if (sample_id != start_sample_id) {
-                    shift_right_bits = 4;
-                }
-                break;
-            default:
-                JLS_LOGW("entry_size_bits invalid: %d", (int) entry_size_bits);
-                return JLS_ERROR_PARAMETER_INVALID;
-        }
-        data_length += start_sample_id - sample_id;
-        start_sample_id = sample_id;
-    }
-
-    //JLS_LOGD3("jls_rd_fsr_f32(%d, %" PRIi64 ")", (int) signal_id, start_sample_id);
-    start_sample_id += sample_id_offset;  // file sample_id
-    ROE(fsr_seek(self, signal_id, 0, start_sample_id));
-    self->chunk_cur.hdr.item_next = jls_raw_chunk_tell(self->raw);
-    while (data_length > 0) {
-        if (jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next)) {
-            return JLS_ERROR_NOT_FOUND;
-        }
-        rv = rd(self);
-        if (rv == JLS_ERROR_EMPTY) {
-            return JLS_ERROR_NOT_FOUND;
-        } else if (rv) {
-            return rv;
-        }
-        struct jls_fsr_data_s * r = (struct jls_fsr_data_s *) self->payload.start;
-        int64_t chunk_sample_id = r->header.timestamp;
-        int64_t chunk_sample_count = r->header.entry_count;
-        if (r->header.entry_size_bits != entry_size_bits) {
-            JLS_LOGE("fsr entry size mismatch");
-            return JLS_ERROR_UNSPECIFIED;
-        }
-        int64_t idx_start = 0;
-        if (start_sample_id > chunk_sample_id) {
-            idx_start = start_sample_id - chunk_sample_id;
-        }
-        chunk_sample_count -= idx_start;
-        if (data_length < chunk_sample_count) {
-            chunk_sample_count = data_length;
-        }
-        uint8_t * u8 = (uint8_t *) &r->data[0];
-        size_t sz_bytes = (size_t) (chunk_sample_count * entry_size_bits + 7) / 8;
-        size_t u8_offset = (size_t) ((idx_start * entry_size_bits) / 8);
-        memcpy(data_u8, u8 + u8_offset, sz_bytes);
-        data_u8 += sz_bytes;
-        data_length -= chunk_sample_count;
-    }
-
-    if (shift_right_bits) {
-        jls_bit_shift_array_right(shift_right_bits, data, (size_t) ((data_length_orig * entry_size_bits + shift_right_bits + 7) / 8));
-    }
-
-    return 0;
-}
-
-JLS_API int32_t jls_rd_fsr_f32(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
-                               float * data, int64_t data_length) {
-    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (self->signal_def[signal_id].data_type != JLS_DATATYPE_F32) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    return jls_rd_fsr(self, signal_id, start_sample_id, data, data_length);
-}
-
-static inline void f32_to_stats(struct jls_statistics_s * stats, const float * data, int64_t count) {
-    stats->k = count;
-    stats->mean = data[JLS_SUMMARY_FSR_MEAN];
-    stats->min = data[JLS_SUMMARY_FSR_MIN];
-    stats->max = data[JLS_SUMMARY_FSR_MAX];
-    if (count > 1) {
-        stats->s = ((double) data[JLS_SUMMARY_FSR_STD]) * data[JLS_SUMMARY_FSR_STD] * (count - 1);
-    } else {
-        stats->s = 0.0;
-    }
-}
-
-static inline void stats_to_f64(double * data, struct jls_statistics_s * stats) {
-    data[JLS_SUMMARY_FSR_MEAN] = stats->mean;
-    data[JLS_SUMMARY_FSR_MIN] = stats->min;
-    data[JLS_SUMMARY_FSR_MAX] = stats->max;
-    data[JLS_SUMMARY_FSR_STD] = sqrt(jls_statistics_var(stats));
-}
-
-static inline void f64_to_stats(struct jls_statistics_s * stats, const double * data, int64_t count) {
-    stats->k = count;
-    stats->mean = data[JLS_SUMMARY_FSR_MEAN];
-    stats->min = data[JLS_SUMMARY_FSR_MIN];
-    stats->max = data[JLS_SUMMARY_FSR_MAX];
-    if (count > 1) {
-        stats->s = ((double) data[JLS_SUMMARY_FSR_STD]) * data[JLS_SUMMARY_FSR_STD] * (count - 1);
-    } else {
-        stats->s = 0.0;
-    }
-}
-
-static int32_t rd_stats_chunk(struct jls_rd_s * self, uint16_t signal_id, uint8_t level) {
-    ROE(rd(self));
-    if (JLS_TAG_TRACK_FSR_SUMMARY != self->chunk_cur.hdr.tag) {
-        JLS_LOGW("unexpected chunk tag %d", (int) self->chunk_cur.hdr.tag);
-        return JLS_ERROR_IO;
-    }
-    uint16_t metadata = (signal_id & SIGNAL_MASK) | (((uint16_t) level) << 12);
-    if (metadata != self->chunk_cur.hdr.chunk_meta) {
-        JLS_LOGW("unexpected chunk meta 0x%04x", (unsigned int) self->chunk_cur.hdr.chunk_meta);
-        return JLS_ERROR_IO;
-    }
-
-    /*
-    // display stats chunk data
-    int64_t *i64 = (int64_t *) self->payload.start;
-    JLS_LOGI("stats chunk: sample_id=%" PRIi64 ", entries=%" PRIi64, i64[0], i64[1]);
-    float * d = (float *) &i64[2];
-    for (int64_t i = 0; i < i64[1] * 4; i += 4) {
-        JLS_LOGI("stats: mean=%f min=%f max=%f std=%f",
-            d[i + JLS_SUMMARY_FSR_MEAN],
-            d[i + JLS_SUMMARY_FSR_MIN],
-            d[i + JLS_SUMMARY_FSR_MAX],
-            d[i + JLS_SUMMARY_FSR_STD]);
-    }
-    */
-    return 0;
-}
-
-static int32_t fsr_statistics(struct jls_rd_s * self, uint16_t signal_id,
-                              int64_t start_sample_id, int64_t increment, uint8_t level,
-                              double * data, int64_t data_length) {
-    // start_sample_id in JLS units with possible non-zero offset
-    JLS_LOGD2("fsr_f32_statistics(signal_id=%d, start_id=%" PRIi64 ", incr=%" PRIi64 ", level=%d, len=%" PRIi64 ")",
-              (int) signal_id, start_sample_id, increment, (int) level, data_length);
-    bool is_f32;
-    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
-    int64_t step_size = signal_def->sample_decimate_factor;
-    for (uint8_t lvl = 2; lvl <= level; ++lvl) {
-        step_size *= signal_def->summary_decimate_factor;
-    }
-    double f64_tmp4[JLS_SUMMARY_FSR_COUNT];
-    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
-
-    ROE(fsr_seek(self, signal_id, level, start_sample_id)); // returns the index
-    ROE(jls_raw_chunk_next(self->raw));  // statistics
-    int64_t pos = jls_raw_chunk_tell(self->raw);
-    ROE(rd_stats_chunk(self, signal_id, level));
-
-    struct jls_fsr_f32_summary_s * f32_summary = (struct jls_fsr_f32_summary_s *) self->payload.start;
-    struct jls_fsr_f64_summary_s * f64_summary = (struct jls_fsr_f64_summary_s *) self->payload.start;
-    int64_t chunk_sample_id = f32_summary->header.timestamp;
-    if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(float) * 8) {
-        is_f32 = true;  // 32-bit float summaries
-    } else if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(double) * 8) {
-        is_f32 = false; // 64-bit float summaries
-    } else {
-        JLS_LOGE("invalid summary entry size: %d", (int) f32_summary->header.entry_size_bits);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    int64_t src_offset = 0;
-    int64_t src_end = f32_summary->header.entry_count;
-    int64_t entry_offset = ((start_sample_id - chunk_sample_id + step_size - 1) / step_size);
-    int64_t entry_sample_id = entry_offset * step_size + chunk_sample_id;
-
-    struct jls_statistics_s stats_accum;
-    jls_statistics_reset(&stats_accum);
-    struct jls_statistics_s stats_next;
-
-    int64_t incr_remaining = increment;
-
-    if (entry_sample_id != start_sample_id) {
-        int64_t incr = entry_sample_id - start_sample_id;
-        // invalidates stats, need to reload, providing API sample_id
-        ROE(jls_rd_fsr_statistics(self, signal_id, start_sample_id - sample_id_offset,
-                                  incr, f64_tmp4, 1));
-        ROE(jls_raw_chunk_seek(self->raw, pos));
-        ROE(rd_stats_chunk(self, signal_id, level));
-        f64_to_stats(&stats_accum, f64_tmp4, incr);
-        incr_remaining -= incr;
-        start_sample_id += incr;
-    }
-    src_offset += entry_offset;
-
-    while (data_length) {
-        if (src_offset >= src_end) {
-            if (self->chunk_cur.hdr.item_next) {
-                ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
-                ROE(rd_stats_chunk(self, signal_id, level));
-                f32_summary = (struct jls_fsr_f32_summary_s *) self->payload.start;
-                f64_summary = (struct jls_fsr_f64_summary_s *) self->payload.start;
-                if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(float) * 8) {
-                    is_f32 = true;  // 32-bit float summaries
-                } else if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(double) * 8) {
-                    is_f32 = false; // 64-bit float summaries
-                } else {
-                    JLS_LOGE("invalid summary entry size: %d", (int) f32_summary->header.entry_size_bits);
-                    return JLS_ERROR_PARAMETER_INVALID;
-                }
-                src_offset = 0;
-                src_end = f32_summary->header.entry_count;
-            } else {
-                if ((incr_remaining <= step_size) && (data_length == 1)) {
-                    // not a problem, will fetch from lower statistics
-                } else {
-                    JLS_LOGW("cannot get final %" PRIi64 " samples", data_length);
-                    for (int64_t idx = 0; idx < (JLS_SUMMARY_FSR_COUNT * data_length); ++idx) {
-                        data[idx] = NAN;
-                    }
-                    return JLS_ERROR_PARAMETER_INVALID;
-                }
-            }
-        }
-
-        if (incr_remaining <= step_size) {
-            if (data_length == 1) {
-                ROE(jls_rd_fsr_statistics(self, signal_id, start_sample_id - sample_id_offset,
-                                          incr_remaining, f64_tmp4, 1));
-                f64_to_stats(&stats_next, f64_tmp4, incr_remaining);
-            } else if (is_f32) {
-                f32_to_stats(&stats_next, f32_summary->data[src_offset], incr_remaining);
-            } else {
-                f64_to_stats(&stats_next, f64_summary->data[src_offset], incr_remaining);
-            }
-            jls_statistics_combine(&stats_accum, &stats_accum, &stats_next);
-            stats_to_f64(data, &stats_accum);
-            data += JLS_SUMMARY_FSR_COUNT;
-            --data_length;
-            int64_t incr = step_size - incr_remaining;
-            if (incr < 0) {
-                JLS_LOGE("internal error");
-                incr = 0;
-                jls_statistics_reset(&stats_accum);
-            } else if (incr == 0) {
-                jls_statistics_reset(&stats_accum);
-            } else if (is_f32) {
-                f32_to_stats(&stats_accum, f32_summary->data[src_offset], incr);
-            } else {
-                f64_to_stats(&stats_accum, f64_summary->data[src_offset], incr);
-            }
-            incr_remaining = increment - incr;
-        } else {
-            if (is_f32) {
-                f32_to_stats(&stats_next, f32_summary->data[src_offset], step_size);
-            } else {
-                f64_to_stats(&stats_next, f64_summary->data[src_offset], step_size);
-            }
-            jls_statistics_combine(&stats_accum, &stats_accum, &stats_next);
-            incr_remaining -= step_size;
-        }
-        start_sample_id += step_size;
-        ++src_offset;
-    }
-    return 0;
-}
-
-int32_t jls_rd_fsr_statistics(struct jls_rd_s * self, uint16_t signal_id,
-                              int64_t start_sample_id, int64_t increment,
-                              double * data, int64_t data_length) {
-    // API zero-based start_sample_id
-    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
-        JLS_LOGW("signal_id %d invalid", (int) signal_id);
-        return JLS_ERROR_PARAMETER_INVALID;
-    } else if (increment <= 0) {
-        JLS_LOGW("invalid increment: %" PRIi64, increment);
-        return JLS_ERROR_PARAMETER_INVALID;
-    } else if (data_length <= 0) {
-        JLS_LOGW("invalid length: %" PRIi64, data_length);
-        return 0;
-    } else if (start_sample_id < 0) {
-        JLS_LOGW("invalid start_sample_id: %" PRIi64, start_sample_id);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    int64_t samples = 0;
-    ROE(jls_rd_fsr_length(self, signal_id, &samples));
-    int64_t end_sample_id = start_sample_id + increment * data_length;
-    if (end_sample_id > samples) {
-        JLS_LOGW("invalid length: %" PRIi64 " > %" PRIi64, end_sample_id, samples);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
-
-    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
-    uint8_t level = 0;
-    int64_t sample_multiple_next = signal_def->sample_decimate_factor;
-    int64_t duration = increment * data_length;
-    while ((increment >= sample_multiple_next)
-            && (duration >= (DECIMATE_PER_DURATION * sample_multiple_next))) {
-        ++level;
-        sample_multiple_next *= signal_def->summary_decimate_factor;
-    }
-    start_sample_id += sample_id_offset; // JLS file sample_id
-
-    if (level) {  // use summaries
-        return fsr_statistics(self, signal_id, start_sample_id, increment, level, data, data_length);
-    }  // else, use sample data
-    JLS_LOGD2("f32(signal_id=%d, start_id=%" PRIi64 ", incr=%" PRIi64 ", level=0, len=%" PRIi64 ")",
-              (int) signal_id, start_sample_id, increment, data_length);
-
-    ROE(f64_buf_alloc((size_t) increment, &self->f64_stats_buf));
-    ROE(f64_buf_alloc((size_t) signal_def->samples_per_data, &self->f64_sample_buf));
-    int64_t buf_offset = 0;
-    uint8_t entry_size_bits = jls_datatype_parse_size(signal_def->data_type);
-    if (entry_size_bits > 32) {
-        JLS_LOGE("entry_size > 64 (float64 stats) not yet supported");
-        return JLS_ERROR_UNSUPPORTED_FILE;
-    }
-
-    ROE(fsr_seek(self, signal_id, 0, start_sample_id));
-    ROE(rd(self));
-    struct jls_fsr_data_s * s = (struct jls_fsr_data_s *) self->payload.start;
-    int64_t chunk_sample_id = s->header.timestamp;
-    if (s->header.entry_size_bits != entry_size_bits) {
-        JLS_LOGE("invalid data entry size: %d", (int) s->header.entry_size_bits);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    jls_dt_buffer_to_f64(&s->data[0], signal_def->data_type, self->f64_sample_buf->start, signal_def->samples_per_data);
-    double * src = &self->f64_sample_buf->start[0];
-    double * src_end = &self->f64_sample_buf->start[s->header.entry_count];
-    if (start_sample_id > chunk_sample_id) {
-        src += start_sample_id - chunk_sample_id;
-    }
-    double v_mean = 0.0;
-    double v_min = DBL_MAX;
-    double v_max = -DBL_MAX;
-    double v_var = 0.0;
-    double mean_scale = 1.0 / increment;
-    double var_scale = 1.0;
-    if (increment > 1) {
-        var_scale = 1.0 / (increment - 1.0);
-    }
-    double v;
-
-    while (data_length > 0) {
-        if (src >= src_end) {
-            ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
-            ROE(rd(self));
-            if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_FSR_DATA) {
-                JLS_LOGW("unexpected chunk tag: %d", (int) self->chunk_cur.hdr.tag);
-            }
-            if (self->chunk_cur.hdr.chunk_meta != signal_id) {
-                JLS_LOGW("unexpected chunk meta: %d", (int) self->chunk_cur.hdr.chunk_meta);
-            }
-            s = (struct jls_fsr_data_s *) self->payload.start;
-            if (s->header.entry_size_bits != entry_size_bits) {
-                JLS_LOGE("invalid data entry size: %d", (int) s->header.entry_size_bits);
-                return JLS_ERROR_PARAMETER_INVALID;
-            }
-            chunk_sample_id = s->header.timestamp;
-            jls_dt_buffer_to_f64(&s->data[0], signal_def->data_type, self->f64_sample_buf->start, signal_def->samples_per_data);
-            src = &self->f64_sample_buf->start[0];
-            src_end = &self->f64_sample_buf->start[s->header.entry_count];
-        }
-        v = *src++;
-        v_mean += v;
-        if (v < v_min) {
-            v_min = v;
-        }
-        if (v > v_max) {
-            v_max = v;
-        }
-        self->f64_stats_buf->start[buf_offset++] = v;
-
-        if (buf_offset >= increment) {
-            v_mean *= mean_scale;
-            v_var = 0.0;
-            for (int64_t i = 0; i < increment; ++i) {
-                double v_diff = self->f64_stats_buf->start[i] - v_mean;
-                v_var += v_diff * v_diff;
-            }
-            v_var *= var_scale;
-
-            data[JLS_SUMMARY_FSR_MEAN] = v_mean;
-            data[JLS_SUMMARY_FSR_MIN] = v_min;
-            data[JLS_SUMMARY_FSR_MAX] = v_max;
-            data[JLS_SUMMARY_FSR_STD] = sqrt(v_var);
-            data += JLS_SUMMARY_FSR_COUNT;
-
-            buf_offset = 0;
-            v_mean = 0.0;
-            v_min = DBL_MAX;
-            v_max = -DBL_MAX;
-            --data_length;
-        }
-    }
-    return 0;
-}
-
-int32_t jls_rd_annotations(struct jls_rd_s * self, uint16_t signal_id, int64_t timestamp,
-                           jls_rd_annotation_cbk_fn cbk_fn, void * cbk_user_data) {
-    struct jls_annotation_s * annotation;
-    if (!cbk_fn) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (!is_signal_defined(self, signal_id)) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-
-    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
-    timestamp += sample_id_offset;
-
-    int32_t rv = ts_seek(self, signal_id, 0, JLS_TRACK_TYPE_ANNOTATION, timestamp);
-    if (rv == JLS_ERROR_NOT_FOUND) {
-        return 0;  // no annotations, and that's just fine
-    } else if (rv) {
-        return rv;
-    }
-
-    // iterate
-    int64_t pos = jls_raw_chunk_tell(self->raw);
-    while (pos) {
-        ROE(jls_raw_chunk_seek(self->raw, pos));
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_ANNOTATION_DATA) {
-            return JLS_ERROR_NOT_FOUND;
-        }
-        annotation = (struct jls_annotation_s *) self->payload.start;
-        annotation->timestamp -= sample_id_offset;
-        if (cbk_fn(cbk_user_data, annotation)) {
-            return 0;
-        }
-        pos = self->chunk_cur.hdr.item_next;
-    }
-    return 0;
-}
-
-int32_t jls_rd_user_data(struct jls_rd_s * self, jls_rd_user_data_cbk_fn cbk_fn, void * cbk_user_data) {
-    int32_t rv;
-    if (!cbk_fn) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    int64_t pos = self->user_data_head.hdr.item_next;
-    uint16_t chunk_meta;
-    while (pos) {
-        ROE(jls_raw_chunk_seek(self->raw, pos));
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag != JLS_TAG_USER_DATA) {
-            return JLS_ERROR_NOT_FOUND;
-        }
-        uint8_t storage_type = (uint8_t) ((self->chunk_cur.hdr.chunk_meta >> 12) & 0x0f);
-        switch (storage_type) {
-            case JLS_STORAGE_TYPE_BINARY:  // intentional fall-through
-            case JLS_STORAGE_TYPE_STRING:  // intentional fall-through
-            case JLS_STORAGE_TYPE_JSON:
-                break;
-            default:
-                return JLS_ERROR_PARAMETER_INVALID;
-        }
-        chunk_meta = self->chunk_cur.hdr.chunk_meta & 0x0fff;
-        rv = cbk_fn(cbk_user_data, chunk_meta, storage_type,
-                    self->payload.start, self->chunk_cur.hdr.payload_length);
-        if (rv) {  // iteration done
-            return 0;
-        }
-        pos = self->chunk_cur.hdr.item_next;
-    }
-    return 0;
-}
-
-JLS_API int32_t jls_rd_utc(struct jls_rd_s * self, uint16_t signal_id, int64_t sample_id,
-                           jls_rd_utc_cbk_fn cbk_fn, void * cbk_user_data) {
-    struct jls_utc_summary_s * utc;
-    if (!cbk_fn) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (!is_signal_defined(self, signal_id)) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-
-    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
-    sample_id += sample_id_offset;
-    int32_t rv = ts_seek(self, signal_id, 1, JLS_TRACK_TYPE_UTC, sample_id);
-    if (rv == JLS_ERROR_NOT_FOUND) {
-        return 0;  // no utc entries, and that's just fine
-    } else if (rv) {
-        return rv;
-    }
-
-    // iterate
-    struct jls_chunk_header_s hdr;
-    hdr.item_next = jls_raw_chunk_tell(self->raw);
-
-    while (hdr.item_next) {
-        ROE(jls_raw_chunk_seek(self->raw, hdr.item_next));
-        ROE(jls_raw_rd_header(self->raw, &hdr));
-        if (hdr.tag != JLS_TAG_TRACK_UTC_INDEX) {
-            return JLS_ERROR_NOT_FOUND;
-        }
-        ROE(jls_raw_chunk_next(self->raw));
-        ROE(rd(self));
-        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_UTC_SUMMARY) {
-            return JLS_ERROR_NOT_FOUND;
-        }
-        utc = (struct jls_utc_summary_s *) self->payload.start;
-        uint32_t idx = 0;
-        for (; (idx < utc->header.entry_count) && (sample_id > utc->entries[idx].sample_id); ++idx) {
-            // iterate
-        }
-        uint32_t size = utc->header.entry_count - idx;
-        for (uint32_t entry_idx = idx; entry_idx < utc->header.entry_count; ++entry_idx) {
-            utc->entries[entry_idx].sample_id -= sample_id_offset;
-        }
-        if (size) {
-            if (cbk_fn(cbk_user_data, utc->entries + idx, size)) {
-                return 0;
-            }
-        }
-    }
-    return 0;
-}
-
-static int32_t utc_load(struct jls_rd_s * self, uint16_t signal_id) {
-    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
-        return JLS_ERROR_NOT_FOUND;
-    }
-    struct signal_s * signal = &self->signals[signal_id];
-    if (NULL != signal->rd_fsr) {
-        return 0;
-    }
-    signal->rd_fsr = jls_rd_fsr_alloc(self->signal_def[signal_id].sample_rate);
-    if (NULL == signal->rd_fsr) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    int64_t sample_rate = self->signal_def[signal_id].sample_rate;
-    int64_t sample_start = -3600 * sample_rate;  // within the last hour
-    return jls_rd_utc(self, signal_id, sample_start, jls_rd_fsr_add_cbk, signal->rd_fsr);
-}
-
-int32_t jls_rd_sample_id_to_timestamp(struct jls_rd_s * self, uint16_t signal_id,
-                                      int64_t sample_id, int64_t * timestamp) {
-    ROE(utc_load(self, signal_id));
-    return jls_rd_fsr_sample_id_to_timestamp(self->signals[signal_id].rd_fsr, sample_id, timestamp);
-}
-
-int32_t jls_rd_timestamp_to_sample_id(struct jls_rd_s * self, uint16_t signal_id,
-                                              int64_t timestamp, int64_t * sample_id) {
-    ROE(utc_load(self, signal_id));
-    return jls_rd_fsr_timestamp_to_sample_id(self->signals[signal_id].rd_fsr, timestamp, sample_id);
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/reader.h"
+#include "jls/raw.h"
+#include "jls/format.h"
+#include "jls/datatype.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include "jls/crc32c.h"
+#include "jls/rd_fsr.h"
+#include "jls/statistics.h"
+#include "jls/bit_shift.h"
+#include "jls/util.h"
+#include <inttypes.h>
+#include <math.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <float.h>
+
+#define PAYLOAD_BUFFER_SIZE_DEFAULT (1 << 25)   // 32 MB
+#define STRING_BUFFER_SIZE_DEFAULT (1 << 23)    // 8 MB
+#define ANNOTATIONS_SIZE_DEFAULT (1 << 20)      // 1 MB
+#define F64_BUF_LENGTH_MIN (1 << 16)
+#define SIGNAL_MASK  (0x0fff)
+#define DECIMATE_PER_DURATION (25)
+
+
+#define ROE(x)  do {                        \
+    int32_t rc__ = (x);                     \
+    if (rc__) {                             \
+        return rc__;                        \
+    }                                       \
+} while (0)
+
+#define RLE(x)  do {                        \
+    int32_t rc__ = (x);                     \
+    if (rc__) {                             \
+        JLS_LOGE("error %d: " #x, rc__);    \
+        return rc__;                        \
+    }                                       \
+} while (0)
+
+#if 0
+struct source_s {
+    struct jls_source_def_s def;
+};
+
+struct signal_s {
+    struct jls_signal_def_s def;
+};
+
+struct jls_rd_s {
+    struct source_s * sources[JLS_SOURCE_COUNT];
+    struct signal_s * signals[JLS_SIGNAL_COUNT];
+    struct jls_chunk_header_s hdr;  // the header for the current chunk
+    uint8_t * chunk_buffer;         // storage for the
+    size_t chunk_buffer_sz;
+    FILE * f;
+};
+#endif
+
+
+struct chunk_s {
+    struct jls_chunk_header_s hdr;
+    int64_t offset;
+};
+
+struct payload_s {
+    uint8_t * start;
+    uint8_t * cur;
+    uint8_t * end;  // current end
+    size_t length;  // current length
+    size_t alloc_size;
+};
+
+struct strings_s {
+    struct strings_s * next;
+    char * start;
+    char * cur;
+    char * end;
+};
+
+struct f64_buf_s {
+    double * start;
+    double * end;
+    size_t alloc_length;  // in double
+    double buffer[];
+};
+
+struct signal_s {
+    int64_t timestamp_start;
+    int64_t timestamp_end;
+    int64_t track_defs[JLS_TRACK_TYPE_COUNT];
+    int64_t track_head_offsets[JLS_TRACK_TYPE_COUNT];
+    int64_t track_head_data[JLS_TRACK_TYPE_COUNT][JLS_SUMMARY_LEVEL_COUNT];
+    struct jls_rd_fsr_s * rd_fsr;
+};
+
+struct jls_rd_s {
+    struct jls_raw_s * raw;
+    struct jls_source_def_s source_def[JLS_SOURCE_COUNT];
+    struct jls_source_def_s source_def_api[JLS_SOURCE_COUNT];
+    struct jls_signal_def_s signal_def[JLS_SIGNAL_COUNT];
+    struct jls_signal_def_s signal_def_api[JLS_SOURCE_COUNT];
+    int64_t signal_length[JLS_SOURCE_COUNT];
+
+    struct signal_s signals[JLS_SIGNAL_COUNT];
+
+    struct chunk_s chunk_cur;
+    struct payload_s payload;
+    struct strings_s * strings_tail;
+    struct strings_s * strings_head;
+    struct f64_buf_s * f64_sample_buf;
+    struct f64_buf_s * f64_stats_buf;
+
+    struct chunk_s source_head;  // source_def
+    struct chunk_s signal_head;  // signal_det, track_*_def, track_*_head
+
+    struct chunk_s user_data_head;  // user_data, ignore first
+};
+
+static int32_t strings_alloc(struct jls_rd_s * self) {
+    struct strings_s * s = malloc(STRING_BUFFER_SIZE_DEFAULT);
+    if (!s) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    char * c8 = (char *) s;
+    s->next = NULL;
+    s->start = c8 + sizeof(struct strings_s);
+    s->cur = s->start;
+    s->end = c8 + STRING_BUFFER_SIZE_DEFAULT;
+    if (!self->strings_head) {
+        self->strings_head = s;
+        self->strings_tail = s;
+    } else {
+        self->strings_tail->next = s;
+    }
+    return 0;
+}
+
+static void strings_free(struct jls_rd_s * self) {
+    struct strings_s * s = self->strings_head;
+    while (s) {
+        struct strings_s * n = s->next;
+        free(s);
+        s = n;
+    }
+}
+
+static int32_t f64_buf_alloc(size_t length, struct f64_buf_s ** buf) {
+    if (*buf) {
+        if ((*buf)->alloc_length >= (size_t) length) {
+            return 0;
+        } else {
+            free(*buf);
+            *buf = NULL;
+        }
+    }
+
+    if (length < F64_BUF_LENGTH_MIN) {
+        length = F64_BUF_LENGTH_MIN;
+    }
+    struct f64_buf_s * b = malloc(sizeof(struct f64_buf_s) + length * sizeof(double));
+    if (!b) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    b->start = b->buffer;
+    b->end = b->buffer + length;
+    b->alloc_length = length;
+    *buf = b;
+    return 0;
+}
+
+static int32_t payload_skip(struct jls_rd_s * self, size_t count) {
+    if ((self->payload.cur + count) > self->payload.end) {
+        return JLS_ERROR_EMPTY;
+    }
+    self->payload.cur += count;
+    return 0;
+}
+
+static int32_t payload_parse_u8(struct jls_rd_s * self, uint8_t * value) {
+    if ((self->payload.cur + 1) > self->payload.end) {
+        return JLS_ERROR_EMPTY;
+    }
+    *value = self->payload.cur[0];
+    self->payload.cur += 1;
+    return 0;
+}
+
+static int32_t payload_parse_u16(struct jls_rd_s * self, uint16_t * value) {
+    if ((self->payload.cur + 2) > self->payload.end) {
+        return JLS_ERROR_EMPTY;
+    }
+    *value = ((uint16_t) self->payload.cur[0])
+            | (((uint16_t) self->payload.cur[1]) << 8);
+    self->payload.cur += 2;
+    return 0;
+}
+
+static int32_t payload_parse_u32(struct jls_rd_s * self, uint32_t * value) {
+    if ((self->payload.cur + 4) > self->payload.end) {
+        return JLS_ERROR_EMPTY;
+    }
+    *value = ((uint32_t) self->payload.cur[0])
+             | (((uint32_t) self->payload.cur[1]) << 8)
+             | (((uint32_t) self->payload.cur[2]) << 16)
+             | (((uint32_t) self->payload.cur[3]) << 24);
+    self->payload.cur += 4;
+    return 0;
+}
+
+#if 0
+
+static int32_t payload_parse_u64(struct jls_rd_s * self, uint64_t * value) {
+    if ((self->payload.cur + 8) > self->payload.end) {
+        return JLS_ERROR_EMPTY;
+    }
+    *value = ((uint64_t) self->payload.cur[0])
+             | (((uint64_t) self->payload.cur[1]) << 8)
+             | (((uint64_t) self->payload.cur[2]) << 16)
+             | (((uint64_t) self->payload.cur[3]) << 24)
+             | (((uint64_t) self->payload.cur[4]) << 32)
+             | (((uint64_t) self->payload.cur[5]) << 40)
+             | (((uint64_t) self->payload.cur[6]) << 48)
+             | (((uint64_t) self->payload.cur[7]) << 56);
+    self->payload.cur += 8;
+    return 0;
+}
+
+#endif
+
+static int32_t payload_parse_str(struct jls_rd_s * self, char ** value) {
+    struct strings_s * s = self->strings_tail;
+    char * str = s->cur;
+    char ch;
+    while (self->payload.cur != self->payload.end) {
+        if (s->cur >= s->end) {
+            ROE(strings_alloc(self));
+            // copy over partial.
+            while (str <= s->end) {
+                *self->strings_tail->cur++ = *str++;
+            }
+            s = self->strings_tail;
+            str = s->start;
+        }
+
+        ch = (char) *self->payload.cur++;
+        *s->cur++ = ch;
+        if (ch == 0) {
+            if (*self->payload.cur == 0x1f) {
+                self->payload.cur++;
+            }
+            *value = str;
+            return 0;
+        }
+    }
+
+    *value = NULL;
+    return JLS_ERROR_EMPTY;
+}
+
+static int32_t rd(struct jls_rd_s * self) {
+    while (1) {
+        self->chunk_cur.offset = jls_raw_chunk_tell(self->raw);
+        int32_t rc = jls_raw_rd(self->raw, &self->chunk_cur.hdr, (uint32_t) self->payload.alloc_size, self->payload.start);
+        if (rc == JLS_ERROR_TOO_BIG) {
+            size_t sz_new = self->payload.alloc_size;
+            while (sz_new < self->chunk_cur.hdr.payload_length) {
+                sz_new *= 2;
+            }
+            uint8_t *ptr = realloc(self->payload.start, sz_new);
+            if (!ptr) {
+                return JLS_ERROR_NOT_ENOUGH_MEMORY;
+            }
+            self->payload.start = ptr;
+            self->payload.cur = ptr;
+            self->payload.end = ptr;
+            self->payload.length = 0;
+            self->payload.alloc_size = sz_new;
+        } else if (rc == 0) {
+            self->payload.cur = self->payload.start;
+            self->payload.length = self->chunk_cur.hdr.payload_length;
+            self->payload.end = self->payload.start + self->payload.length;
+            return 0;
+        } else {
+            return rc;
+        }
+    }
+}
+
+static int32_t scan_sources(struct jls_rd_s * self) {
+    JLS_LOGD1("scan_sources");
+    ROE(jls_raw_chunk_seek(self->raw, self->source_head.offset));
+    while (1) {
+        ROE(rd(self));
+        uint16_t source_id = self->chunk_cur.hdr.chunk_meta;
+        if (source_id >= JLS_SOURCE_COUNT) {
+            JLS_LOGW("source_id %d too big - skip", (int) source_id);
+        } else {
+            struct jls_source_def_s *src = &self->source_def[source_id];
+            ROE(payload_skip(self, 64));
+            ROE(payload_parse_str(self, (char **) &src->name));
+            ROE(payload_parse_str(self, (char **) &src->vendor));
+            ROE(payload_parse_str(self, (char **) &src->model));
+            ROE(payload_parse_str(self, (char **) &src->version));
+            ROE(payload_parse_str(self, (char **) &src->serial_number));
+            src->source_id = source_id;  // indicate that this source is valid!
+            JLS_LOGD1("Found source %d : %s", (int) source_id, src->name);
+        }
+        if (!self->chunk_cur.hdr.item_next) {
+            break;
+        }
+        ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
+    }
+    return 0;
+}
+
+static int32_t signal_validate(struct jls_rd_s * self, uint16_t signal_id, struct jls_signal_def_s * s) {
+    if (signal_id >= JLS_SIGNAL_COUNT) {
+        JLS_LOGW("signal_id %d too big - skip", (int) signal_id);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (self->source_def[s->source_id].source_id != s->source_id) {
+        JLS_LOGW("signal %d: source_id %d not found", (int) signal_id, (int) s->source_id);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    switch (s->signal_type) {
+        case JLS_SIGNAL_TYPE_FSR: break;
+        case JLS_SIGNAL_TYPE_VSR: break;
+        default:
+            JLS_LOGW("signal %d: invalid signal_type: %d", (int) signal_id, (int) s->signal_type);
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    // todo check data_type
+    return 0;
+}
+
+static int32_t handle_signal_def(struct jls_rd_s * self) {
+    uint16_t signal_id = self->chunk_cur.hdr.chunk_meta;
+    if (signal_id >= JLS_SIGNAL_COUNT) {
+        JLS_LOGW("signal_id %d too big - skip", (int) signal_id);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    struct jls_signal_def_s *s = &self->signal_def[signal_id];
+    s->signal_id = signal_id;
+    ROE(payload_parse_u16(self, &s->source_id));
+    ROE(payload_parse_u8(self, &s->signal_type));
+    ROE(payload_skip(self, 1));
+    ROE(payload_parse_u32(self, &s->data_type));
+    ROE(payload_parse_u32(self, &s->sample_rate));
+    ROE(payload_parse_u32(self, &s->samples_per_data));
+    ROE(payload_parse_u32(self, &s->sample_decimate_factor));
+    ROE(payload_parse_u32(self, &s->entries_per_summary));
+    ROE(payload_parse_u32(self, &s->summary_decimate_factor));
+    ROE(payload_parse_u32(self, &s->annotation_decimate_factor));
+    ROE(payload_parse_u32(self, &s->utc_decimate_factor));
+    ROE(payload_skip(self, 92));
+    ROE(payload_parse_str(self, (char **) &s->name));
+    ROE(payload_parse_str(self, (char **) &s->units));
+    if (0 == signal_validate(self, signal_id, s)) {  // validate passed
+        s->signal_id = signal_id;  // indicate that this signal is valid
+        JLS_LOGD1("Found signal %d : %s", (int) signal_id, s->name);
+    }  // else skip
+    return 0;
+}
+
+static bool is_signal_defined(struct jls_rd_s * self, uint16_t signal_id) {
+    signal_id &= SIGNAL_MASK;  // mask off chunk_meta depth
+    if (signal_id >= JLS_SIGNAL_COUNT) {
+        JLS_LOGW("signal_id %d too big", (int) signal_id);
+        return false;
+    }
+    if (self->signal_def[signal_id].signal_id != signal_id) {
+        JLS_LOGW("signal_id %d not defined", (int) signal_id);
+        return false;
+    }
+    return true;
+}
+
+static bool is_signal_defined_type(struct jls_rd_s * self, uint16_t signal_id, enum jls_signal_type_e type) {
+    if (!is_signal_defined(self, signal_id)) {
+        return false;
+    }
+    return self->signal_def[signal_id].signal_type == type;
+}
+
+static inline uint8_t tag_parse_track_type(uint8_t tag) {
+    return (tag >> 3) & 3;
+}
+
+static int32_t validate_track_tag(struct jls_rd_s * self, uint16_t signal_id, uint8_t tag) {
+    if (!is_signal_defined(self, signal_id)) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
+    uint8_t track_type = tag_parse_track_type(tag);
+    switch (signal_def->signal_type) {
+        case JLS_SIGNAL_TYPE_FSR:
+            if ((track_type == JLS_TRACK_TYPE_FSR)
+                || (track_type == JLS_TRACK_TYPE_ANNOTATION)
+                || (track_type == JLS_TRACK_TYPE_UTC)) {
+                // good
+            } else {
+                JLS_LOGW("unsupported track %d for FSR signal", (int) track_type);
+                return JLS_ERROR_PARAMETER_INVALID;
+            }
+            break;
+        case JLS_SIGNAL_TYPE_VSR:
+            if ((track_type == JLS_TRACK_TYPE_VSR)
+                || (track_type == JLS_TRACK_TYPE_ANNOTATION)) {
+                // good
+            } else {
+                JLS_LOGW("unsupported track %d for VSR signal", (int) track_type);
+                return JLS_ERROR_PARAMETER_INVALID;
+            }
+            break;
+        default:
+            // should have already been checked.
+            JLS_LOGW("unsupported signal type: %d", (int) signal_def->signal_type);
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+    return 0;
+}
+
+static int32_t handle_track_def(struct jls_rd_s * self, int64_t pos) {
+    uint16_t signal_id = self->chunk_cur.hdr.chunk_meta & SIGNAL_MASK;
+    ROE(validate_track_tag(self, signal_id, self->chunk_cur.hdr.tag));
+    self->signals[signal_id].track_defs[tag_parse_track_type(self->chunk_cur.hdr.tag)] = pos;
+    return 0;
+}
+
+static int32_t handle_track_head(struct jls_rd_s * self, int64_t pos) {
+    uint16_t signal_id = self->chunk_cur.hdr.chunk_meta & SIGNAL_MASK;
+    ROE(validate_track_tag(self, signal_id, self->chunk_cur.hdr.tag));
+    uint8_t track_type = tag_parse_track_type(self->chunk_cur.hdr.tag);
+
+    self->signals[signal_id].track_head_offsets[track_type] = pos;
+    size_t expect_sz = JLS_SUMMARY_LEVEL_COUNT * sizeof(int64_t);
+
+    if (self->payload.length != expect_sz) {
+        JLS_LOGW("cannot parse signal %d head, sz=%zu, expect=%zu",
+                 (int) signal_id, self->payload.length, expect_sz);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    memcpy(self->signals[signal_id].track_head_data[track_type], self->payload.start, expect_sz);
+    return 0;
+}
+
+static int32_t scan_signals(struct jls_rd_s * self) {
+    JLS_LOGD1("scan_signals");
+    ROE(jls_raw_chunk_seek(self->raw, self->signal_head.offset));
+    while (1) {
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag == JLS_TAG_SIGNAL_DEF) {
+            handle_signal_def(self);
+        } else if ((self->chunk_cur.hdr.tag & 7) == JLS_TRACK_CHUNK_DEF) {
+            handle_track_def(self, self->chunk_cur.offset);
+        } else if ((self->chunk_cur.hdr.tag & 7) == JLS_TRACK_CHUNK_HEAD) {
+            handle_track_head(self, self->chunk_cur.offset);
+        } else {
+            JLS_LOGW("unknown tag %d in signal list", (int) self->chunk_cur.hdr.tag);
+        }
+        if (!self->chunk_cur.hdr.item_next) {
+            break;
+        }
+        ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
+    }
+    return 0;
+}
+
+static int32_t scan_fsr_sample_id(struct jls_rd_s * self) {
+    JLS_LOGD1("scan_fsr_sample_id");
+    for (uint32_t signal_id = 1; signal_id < JLS_SIGNAL_COUNT; ++signal_id) {
+        if ((self->signal_def[signal_id].signal_id != signal_id)
+                || (self->signal_def[signal_id].signal_type != JLS_SIGNAL_TYPE_FSR)) {
+            continue;
+        }
+        struct signal_s * s = &self->signals[signal_id];
+        int64_t offset = s->track_head_data[JLS_TRACK_TYPE_FSR][0];
+        if (offset == 0) {
+            continue;  // no data
+        }
+        ROE(jls_raw_chunk_seek(self->raw, offset));
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_FSR_DATA) {
+            JLS_LOGW("scan_fsr_sample_id tag mismatch: %d", (int) self->chunk_cur.hdr.tag);
+            continue;
+        }
+
+        struct jls_fsr_data_s * r = (struct jls_fsr_data_s *) self->payload.start;
+        self->signal_def[signal_id].sample_id_offset = r->header.timestamp;
+    }
+    return 0;
+}
+
+static int32_t scan(struct jls_rd_s * self) {
+    int32_t rc = 0;
+    uint8_t found = 0;
+
+    for (int i = 0; found != 7; ++i) {
+        if (i == 3) {
+            JLS_LOGW("malformed JLS, continue searching");
+        }
+        int64_t pos = jls_raw_chunk_tell(self->raw);
+        rc = rd(self);
+        if (rc == JLS_ERROR_EMPTY) {
+            return 0;
+        } else if (rc) {
+            return rc;
+        }
+
+        JLS_LOGD1("scan tag %d : %s", self->chunk_cur.hdr.tag, jls_tag_to_name(self->chunk_cur.hdr.tag));
+        switch (self->chunk_cur.hdr.tag) {
+            case JLS_TAG_USER_DATA:
+                found |= 1;
+                if (!self->user_data_head.offset) {
+                    self->user_data_head.offset = pos;
+                    self->user_data_head.hdr = self->chunk_cur.hdr;
+                }
+                break;
+            case JLS_TAG_SOURCE_DEF:
+                found |= 2;
+                if (!self->source_head.offset) {
+                    self->source_head.offset = pos;
+                    self->source_head.hdr = self->chunk_cur.hdr;
+                }
+                break;
+            case JLS_TAG_SIGNAL_DEF:
+                found |= 4;
+                if (!self->signal_head.offset) {
+                    self->signal_head.offset = pos;
+                    self->signal_head.hdr = self->chunk_cur.hdr;
+                }
+                break;
+            default:
+                break;  // skip
+        }
+    }
+    JLS_LOGD1("found initial tags");
+    ROE(scan_sources(self));
+    ROE(scan_signals(self));
+    ROE(scan_fsr_sample_id(self));
+    return 0;
+}
+
+int32_t jls_rd_open(struct jls_rd_s ** instance, const char * path) {
+    if (!instance) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    struct jls_rd_s *self = calloc(1, sizeof(struct jls_rd_s));
+    if (!self) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+
+    for (int32_t k = 0; k < JLS_SOURCE_COUNT; ++k) {
+        self->signal_length[k] = -1;
+    }
+
+    self->payload.start = malloc(PAYLOAD_BUFFER_SIZE_DEFAULT);
+    strings_alloc(self);
+
+    if (!self->payload.start || !self->strings_head) {
+        jls_rd_close(self);
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    self->payload.alloc_size = PAYLOAD_BUFFER_SIZE_DEFAULT;
+    self->payload.cur = self->payload.start;
+    self->payload.end = self->payload.start;
+
+    int32_t rc = jls_raw_open(&self->raw, path, "r");
+    if (rc) {
+        jls_rd_close(self);
+        return rc;
+    }
+
+    if (jls_raw_version(self->raw).s.major < 1) {
+        JLS_LOGE("version < 1.x.x no longer supported");
+        return JLS_ERROR_UNSUPPORTED_FILE;
+    }
+
+    int64_t end_pos = jls_raw_chunk_tell_end(self->raw);
+    if (!end_pos) {
+        JLS_LOGW("not properly closed");
+        // Not properly closed.  Indices & summary may be incomplete.
+        // for most applications, will want to launch file reconstruction tool
+        return JLS_ERROR_MESSAGE_INTEGRITY;
+    }
+
+    ROE(scan(self));
+    *instance = self;
+    return rc;
+}
+
+void jls_rd_close(struct jls_rd_s * self) {
+    if (self) {
+        jls_raw_close(self->raw);
+        strings_free(self);
+        if (self->payload.start) {
+            free(self->payload.start);
+            self->payload.start = NULL;
+        }
+        if (self->f64_stats_buf) {
+            free(self->f64_stats_buf);
+            self->f64_stats_buf = NULL;
+        }
+        if (self->f64_sample_buf) {
+            free(self->f64_sample_buf);
+            self->f64_sample_buf = NULL;
+        }
+        self->raw = NULL;
+        free(self);
+    }
+}
+
+int32_t jls_rd_sources(struct jls_rd_s * self, struct jls_source_def_s ** sources, uint16_t * count) {
+    if (!self || !sources || !count) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    uint16_t c = 0;
+    for (uint16_t i = 0; i < JLS_SOURCE_COUNT; ++i) {
+        if (self->source_def[i].source_id == i) {
+            // Note: source 0 is always defined, so calloc is ok
+            self->source_def_api[c++] = self->source_def[i];
+        }
+    }
+    *sources = self->source_def_api;
+    *count = c;
+    return 0;
+}
+
+int32_t jls_rd_signals(struct jls_rd_s * self, struct jls_signal_def_s ** signals, uint16_t * count) {
+    if (!self || !signals || !count) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    uint16_t c = 0;
+    for (uint16_t i = 0; i < JLS_SIGNAL_COUNT; ++i) {
+        if (self->signal_def[i].signal_id == i) {
+            // Note: signal 0 is always defined, so calloc is ok
+            self->signal_def_api[c++] = self->signal_def[i];
+        }
+    }
+    *signals = self->signal_def_api;
+    *count = c;
+    return 0;
+}
+
+int32_t jls_rd_signal(struct jls_rd_s * self, uint16_t signal_id, struct jls_signal_def_s * signal) {
+    if (!is_signal_defined(self, signal_id)) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+    if (signal) {
+        *signal = self->signal_def[signal_id];
+    }
+    return 0;
+}
+
+static int32_t ts_seek(struct jls_rd_s * self, uint16_t signal_id, uint8_t level,
+                       enum jls_track_type_e track_type, int64_t timestamp) {
+    // timestamp in JLS units with possible non-zero offset
+    if (!is_signal_defined(self, signal_id)) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+    switch (track_type) {
+        case JLS_TRACK_TYPE_VSR: break;
+        case JLS_TRACK_TYPE_ANNOTATION: break;
+        case JLS_TRACK_TYPE_UTC: break;
+        default:
+            JLS_LOGW("ts_seek: unsupported track type: %d", (int) track_type);
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+    struct signal_s * s = &self->signals[signal_id];
+    int64_t offset = 0;
+    int64_t * offsets = s->track_head_data[track_type];
+
+    int initial_level = JLS_SUMMARY_LEVEL_COUNT - 1;
+    for (; initial_level >= 0; --initial_level) {
+        if (offsets[initial_level]) {
+            offset = offsets[initial_level];
+            break;
+        }
+    }
+    if (!offset) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+
+    for (int lvl = initial_level; lvl > level; --lvl) {
+        JLS_LOGD3("signal %d, level %d, offset=%" PRIi64, (int) signal_id, (int) lvl, offset);
+        ROE(jls_raw_chunk_seek(self->raw, offset));
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag != jls_track_tag_pack(track_type, JLS_TRACK_CHUNK_INDEX)) {
+            JLS_LOGW("seek tag mismatch: %d", (int) self->chunk_cur.hdr.tag);
+        }
+
+        struct jls_index_s * r = (struct jls_index_s *) self->payload.start;
+        uint8_t * p_end = (uint8_t *) &r->entries[r->header.entry_count];
+
+        if ((size_t) (p_end - self->payload.start) > self->payload.length) {
+            JLS_LOGE("invalid payload length");
+            return JLS_ERROR_PARAMETER_INVALID;
+        }
+        if ((r->header.entry_count == 0) || (r->header.entry_count & 0x80000000)) {
+            JLS_LOGE("invalid entry count");
+            return JLS_ERROR_PARAMETER_INVALID;
+        }
+
+        int32_t idx = 0;
+        for (; ; ++idx) {
+            if (idx >= (int32_t) r->header.entry_count) {
+                idx = ((int32_t) r->header.entry_count) - 1;
+                break;
+            } else if (r->entries[idx].timestamp> timestamp) {
+                --idx;
+                break;
+            } else if (r->entries[idx].timestamp == timestamp) {
+                break;
+            }
+        }
+        if (idx < 0) {
+            idx = 0;
+        }
+        offset = r->entries[idx].offset;
+    }
+
+    ROE(jls_raw_chunk_seek(self->raw, offset));
+    return 0;
+}
+
+static int32_t fsr_seek(struct jls_rd_s * self, uint16_t signal_id, uint8_t level, int64_t sample_id) {
+    // timestamp in JLS units with possible non-zero offset
+    if (!is_signal_defined(self, signal_id)) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
+    if (signal_def->signal_type != JLS_SIGNAL_TYPE_FSR) {
+        JLS_LOGW("fsr_seek not support for signal type %d", (int) signal_def->signal_type);
+        return JLS_ERROR_NOT_SUPPORTED;
+    }
+    struct signal_s * s = &self->signals[signal_id];
+    int64_t offset = 0;
+    int64_t * offsets = s->track_head_data[JLS_TRACK_TYPE_FSR];
+    int initial_level = JLS_SUMMARY_LEVEL_COUNT - 1;
+    for (; initial_level >= 0; --initial_level) {
+        if (offsets[initial_level]) {
+            offset = offsets[initial_level];
+            break;
+        }
+    }
+    if (!offset) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+
+    for (int lvl = initial_level; lvl > level; --lvl) {
+        // compute the step size in samples between each index entry.
+        int64_t step_size = signal_def->samples_per_data;  // each data chunk
+        if (lvl > 1) {
+            step_size *= signal_def->entries_per_summary /
+                    (signal_def->samples_per_data / signal_def->sample_decimate_factor);
+        }
+        for (int k = 3; k <= lvl; ++k) {
+            step_size *= signal_def->summary_decimate_factor;
+        }
+        JLS_LOGD3("signal %d, level %d, offset=%" PRIi64 ", step_size=%" PRIi64,
+                 (int) signal_id, lvl, offset, step_size);
+        ROE(jls_raw_chunk_seek(self->raw, offset));
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_FSR_INDEX) {
+            JLS_LOGW("seek tag mismatch: %d", (int) self->chunk_cur.hdr.tag);
+        }
+
+        struct jls_fsr_index_s * r = (struct jls_fsr_index_s *) self->payload.start;
+        int64_t chunk_timestamp = r->header.timestamp;
+        int64_t chunk_entries = r->header.entry_count;
+        JLS_LOGD3("timestamp=%" PRIi64 ", entries=%" PRIi64, chunk_timestamp, chunk_entries);
+        uint8_t * p_end = (uint8_t *) &r->offsets[r->header.entry_count];
+
+        if ((size_t) (p_end - self->payload.start) > self->payload.length) {
+            JLS_LOGE("invalid payload length");
+            return JLS_ERROR_PARAMETER_INVALID;
+        }
+
+        int64_t idx = (sample_id - chunk_timestamp) / step_size;
+        if ((idx < 0) || (idx >= chunk_entries)) {
+            JLS_LOGE("invalid index signal %d, level %d, sample_id=%"
+                     PRIi64 " offset=%" PRIi64 ": %" PRIi64 " >= %" PRIi64,
+                     (int) signal_id, lvl, sample_id,
+                     offset, idx, chunk_entries);
+            return JLS_ERROR_IO;
+        }
+        offset = r->offsets[idx];
+    }
+
+    ROE(jls_raw_chunk_seek(self->raw, offset));
+    return 0;
+}
+
+
+int32_t jls_rd_fsr_length(struct jls_rd_s * self, uint16_t signal_id, int64_t * samples) {
+    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (self->signal_length[signal_id] >= 0) {
+        *samples = self->signal_length[signal_id];
+        return 0;
+    }
+
+    struct signal_s * s = &self->signals[signal_id];
+    int64_t offset = 0;
+    int64_t * offsets = s->track_head_data[JLS_TRACK_TYPE_FSR];
+    int level = JLS_SUMMARY_LEVEL_COUNT - 1;
+    for (; level >= 0; --level) {
+        if (offsets[level]) {
+            offset = offsets[level];
+            break;
+        }
+    }
+    if (!offset) {
+        *samples = 0;
+        return 0;
+    }
+    struct jls_fsr_index_s * r;
+
+    for (int lvl = level; lvl > 0; --lvl) {
+        JLS_LOGD3("signal %d, level %d, index=%" PRIi64, (int) signal_id, (int) lvl, offset);
+        ROE(jls_raw_chunk_seek(self->raw, offset));
+        ROE(rd(self));
+
+        r = (struct jls_fsr_index_s *) self->payload.start;
+        if (r->header.entry_size_bits != (sizeof(r->offsets[0]) * 8)) {
+            JLS_LOGE("invalid FSR index entry size: %d bits", (int) r->header.entry_size_bits);
+            return JLS_ERROR_PARAMETER_INVALID;
+        }
+        size_t sz = sizeof(r->header) + r->header.entry_count * sizeof(r->offsets[0]);
+        if (sz > self->payload.length) {
+            JLS_LOGE("invalid payload length");
+            return JLS_ERROR_PARAMETER_INVALID;
+        }
+        if (r->header.entry_count > 0) {
+            offset = r->offsets[r->header.entry_count - 1];
+        }
+    }
+
+    ROE(jls_raw_chunk_seek(self->raw, offset));
+    ROE(rd(self));
+    r = (struct jls_fsr_index_s *) self->payload.start;
+    self->signal_length[signal_id] = r->header.timestamp + r->header.entry_count
+            - self->signal_def[signal_id].sample_id_offset;
+    *samples = self->signal_length[signal_id];
+    return 0;
+}
+
+int32_t jls_rd_fsr(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
+                   void * data, int64_t data_length) {
+    // start_sample_id is API zero-based
+    const int64_t data_length_orig = data_length;
+    int32_t rv = 0;
+    uint8_t * data_u8 = (uint8_t *) data;
+    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
+        JLS_LOGW("signal_id %d invalid", (int) signal_id);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    int64_t samples = 0;
+    ROE(jls_rd_fsr_length(self, signal_id, &samples));
+    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
+    if (data_length <= 0) {
+        return 0;
+    } else if (start_sample_id < 0) {
+        JLS_LOGW("rd_fsr %d %s: start_sample_id invalid %" PRIi64 " length=%" PRIi64,
+                 (int) signal_id, signal_def->name,
+                 start_sample_id, samples);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
+    uint8_t entry_size_bits = jls_datatype_parse_size(signal_def->data_type);
+
+    if ((start_sample_id + data_length) > samples) {
+        JLS_LOGW("rd_fsr %d %s: start=%" PRIi64 " length=%" PRIi64 " > %" PRIi64 " by %" PRIi64,
+                 (int) signal_id, signal_def->name,
+                 start_sample_id, data_length, samples,
+                 start_sample_id + data_length - samples);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    uint8_t shift_right_bits = 0;
+    if (entry_size_bits < 8) {
+        int64_t sample_id = start_sample_id;
+        switch (entry_size_bits) {
+            case 1:
+                sample_id &= ~0x07;
+                if (sample_id != start_sample_id) {
+                    shift_right_bits = (uint8_t) (start_sample_id - sample_id);
+                }
+                break;
+            case 4:
+                sample_id &= ~0x01;
+                if (sample_id != start_sample_id) {
+                    shift_right_bits = 4;
+                }
+                break;
+            default:
+                JLS_LOGW("entry_size_bits invalid: %d", (int) entry_size_bits);
+                return JLS_ERROR_PARAMETER_INVALID;
+        }
+        data_length += start_sample_id - sample_id;
+        start_sample_id = sample_id;
+    }
+
+    //JLS_LOGD3("jls_rd_fsr_f32(%d, %" PRIi64 ")", (int) signal_id, start_sample_id);
+    start_sample_id += sample_id_offset;  // file sample_id
+    ROE(fsr_seek(self, signal_id, 0, start_sample_id));
+    self->chunk_cur.hdr.item_next = jls_raw_chunk_tell(self->raw);
+    while (data_length > 0) {
+        if (jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next)) {
+            return JLS_ERROR_NOT_FOUND;
+        }
+        rv = rd(self);
+        if (rv == JLS_ERROR_EMPTY) {
+            return JLS_ERROR_NOT_FOUND;
+        } else if (rv) {
+            return rv;
+        }
+        struct jls_fsr_data_s * r = (struct jls_fsr_data_s *) self->payload.start;
+        int64_t chunk_sample_id = r->header.timestamp;
+        int64_t chunk_sample_count = r->header.entry_count;
+        if (r->header.entry_size_bits != entry_size_bits) {
+            JLS_LOGE("fsr entry size mismatch");
+            return JLS_ERROR_UNSPECIFIED;
+        }
+        int64_t idx_start = 0;
+        if (start_sample_id > chunk_sample_id) {
+            idx_start = start_sample_id - chunk_sample_id;
+        }
+        chunk_sample_count -= idx_start;
+        if (data_length < chunk_sample_count) {
+            chunk_sample_count = data_length;
+        }
+        uint8_t * u8 = (uint8_t *) &r->data[0];
+        size_t sz_bytes = (size_t) (chunk_sample_count * entry_size_bits + 7) / 8;
+        size_t u8_offset = (size_t) ((idx_start * entry_size_bits) / 8);
+        memcpy(data_u8, u8 + u8_offset, sz_bytes);
+        data_u8 += sz_bytes;
+        data_length -= chunk_sample_count;
+    }
+
+    if (shift_right_bits) {
+        jls_bit_shift_array_right(shift_right_bits, data, (size_t) ((data_length_orig * entry_size_bits + shift_right_bits + 7) / 8));
+    }
+
+    return 0;
+}
+
+JLS_API int32_t jls_rd_fsr_f32(struct jls_rd_s * self, uint16_t signal_id, int64_t start_sample_id,
+                               float * data, int64_t data_length) {
+    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (self->signal_def[signal_id].data_type != JLS_DATATYPE_F32) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    return jls_rd_fsr(self, signal_id, start_sample_id, data, data_length);
+}
+
+static inline void f32_to_stats(struct jls_statistics_s * stats, const float * data, int64_t count) {
+    stats->k = count;
+    stats->mean = data[JLS_SUMMARY_FSR_MEAN];
+    stats->min = data[JLS_SUMMARY_FSR_MIN];
+    stats->max = data[JLS_SUMMARY_FSR_MAX];
+    if (count > 1) {
+        stats->s = ((double) data[JLS_SUMMARY_FSR_STD]) * data[JLS_SUMMARY_FSR_STD] * (count - 1);
+    } else {
+        stats->s = 0.0;
+    }
+}
+
+static inline void stats_to_f64(double * data, struct jls_statistics_s * stats) {
+    data[JLS_SUMMARY_FSR_MEAN] = stats->mean;
+    data[JLS_SUMMARY_FSR_MIN] = stats->min;
+    data[JLS_SUMMARY_FSR_MAX] = stats->max;
+    data[JLS_SUMMARY_FSR_STD] = sqrt(jls_statistics_var(stats));
+}
+
+static inline void f64_to_stats(struct jls_statistics_s * stats, const double * data, int64_t count) {
+    stats->k = count;
+    stats->mean = data[JLS_SUMMARY_FSR_MEAN];
+    stats->min = data[JLS_SUMMARY_FSR_MIN];
+    stats->max = data[JLS_SUMMARY_FSR_MAX];
+    if (count > 1) {
+        stats->s = ((double) data[JLS_SUMMARY_FSR_STD]) * data[JLS_SUMMARY_FSR_STD] * (count - 1);
+    } else {
+        stats->s = 0.0;
+    }
+}
+
+static int32_t rd_stats_chunk(struct jls_rd_s * self, uint16_t signal_id, uint8_t level) {
+    ROE(rd(self));
+    if (JLS_TAG_TRACK_FSR_SUMMARY != self->chunk_cur.hdr.tag) {
+        JLS_LOGW("unexpected chunk tag %d", (int) self->chunk_cur.hdr.tag);
+        return JLS_ERROR_IO;
+    }
+    uint16_t metadata = (signal_id & SIGNAL_MASK) | (((uint16_t) level) << 12);
+    if (metadata != self->chunk_cur.hdr.chunk_meta) {
+        JLS_LOGW("unexpected chunk meta 0x%04x", (unsigned int) self->chunk_cur.hdr.chunk_meta);
+        return JLS_ERROR_IO;
+    }
+
+    /*
+    // display stats chunk data
+    int64_t *i64 = (int64_t *) self->payload.start;
+    JLS_LOGI("stats chunk: sample_id=%" PRIi64 ", entries=%" PRIi64, i64[0], i64[1]);
+    float * d = (float *) &i64[2];
+    for (int64_t i = 0; i < i64[1] * 4; i += 4) {
+        JLS_LOGI("stats: mean=%f min=%f max=%f std=%f",
+            d[i + JLS_SUMMARY_FSR_MEAN],
+            d[i + JLS_SUMMARY_FSR_MIN],
+            d[i + JLS_SUMMARY_FSR_MAX],
+            d[i + JLS_SUMMARY_FSR_STD]);
+    }
+    */
+    return 0;
+}
+
+static int32_t fsr_statistics(struct jls_rd_s * self, uint16_t signal_id,
+                              int64_t start_sample_id, int64_t increment, uint8_t level,
+                              double * data, int64_t data_length) {
+    // start_sample_id in JLS units with possible non-zero offset
+    JLS_LOGD2("fsr_f32_statistics(signal_id=%d, start_id=%" PRIi64 ", incr=%" PRIi64 ", level=%d, len=%" PRIi64 ")",
+              (int) signal_id, start_sample_id, increment, (int) level, data_length);
+    bool is_f32;
+    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
+    int64_t step_size = signal_def->sample_decimate_factor;
+    for (uint8_t lvl = 2; lvl <= level; ++lvl) {
+        step_size *= signal_def->summary_decimate_factor;
+    }
+    double f64_tmp4[JLS_SUMMARY_FSR_COUNT];
+    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
+
+    ROE(fsr_seek(self, signal_id, level, start_sample_id)); // returns the index
+    ROE(jls_raw_chunk_next(self->raw));  // statistics
+    int64_t pos = jls_raw_chunk_tell(self->raw);
+    ROE(rd_stats_chunk(self, signal_id, level));
+
+    struct jls_fsr_f32_summary_s * f32_summary = (struct jls_fsr_f32_summary_s *) self->payload.start;
+    struct jls_fsr_f64_summary_s * f64_summary = (struct jls_fsr_f64_summary_s *) self->payload.start;
+    int64_t chunk_sample_id = f32_summary->header.timestamp;
+    if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(float) * 8) {
+        is_f32 = true;  // 32-bit float summaries
+    } else if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(double) * 8) {
+        is_f32 = false; // 64-bit float summaries
+    } else {
+        JLS_LOGE("invalid summary entry size: %d", (int) f32_summary->header.entry_size_bits);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    int64_t src_offset = 0;
+    int64_t src_end = f32_summary->header.entry_count;
+    int64_t entry_offset = ((start_sample_id - chunk_sample_id + step_size - 1) / step_size);
+    int64_t entry_sample_id = entry_offset * step_size + chunk_sample_id;
+
+    struct jls_statistics_s stats_accum;
+    jls_statistics_reset(&stats_accum);
+    struct jls_statistics_s stats_next;
+
+    int64_t incr_remaining = increment;
+
+    if (entry_sample_id != start_sample_id) {
+        int64_t incr = entry_sample_id - start_sample_id;
+        // invalidates stats, need to reload, providing API sample_id
+        ROE(jls_rd_fsr_statistics(self, signal_id, start_sample_id - sample_id_offset,
+                                  incr, f64_tmp4, 1));
+        ROE(jls_raw_chunk_seek(self->raw, pos));
+        ROE(rd_stats_chunk(self, signal_id, level));
+        f64_to_stats(&stats_accum, f64_tmp4, incr);
+        incr_remaining -= incr;
+        start_sample_id += incr;
+    }
+    src_offset += entry_offset;
+
+    while (data_length) {
+        if (src_offset >= src_end) {
+            if (self->chunk_cur.hdr.item_next) {
+                ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
+                ROE(rd_stats_chunk(self, signal_id, level));
+                f32_summary = (struct jls_fsr_f32_summary_s *) self->payload.start;
+                f64_summary = (struct jls_fsr_f64_summary_s *) self->payload.start;
+                if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(float) * 8) {
+                    is_f32 = true;  // 32-bit float summaries
+                } else if (f32_summary->header.entry_size_bits == JLS_SUMMARY_FSR_COUNT * sizeof(double) * 8) {
+                    is_f32 = false; // 64-bit float summaries
+                } else {
+                    JLS_LOGE("invalid summary entry size: %d", (int) f32_summary->header.entry_size_bits);
+                    return JLS_ERROR_PARAMETER_INVALID;
+                }
+                src_offset = 0;
+                src_end = f32_summary->header.entry_count;
+            } else {
+                if ((incr_remaining <= step_size) && (data_length == 1)) {
+                    // not a problem, will fetch from lower statistics
+                } else {
+                    JLS_LOGW("cannot get final %" PRIi64 " samples", data_length);
+                    for (int64_t idx = 0; idx < (JLS_SUMMARY_FSR_COUNT * data_length); ++idx) {
+                        data[idx] = NAN;
+                    }
+                    return JLS_ERROR_PARAMETER_INVALID;
+                }
+            }
+        }
+
+        if (incr_remaining <= step_size) {
+            if (data_length == 1) {
+                ROE(jls_rd_fsr_statistics(self, signal_id, start_sample_id - sample_id_offset,
+                                          incr_remaining, f64_tmp4, 1));
+                f64_to_stats(&stats_next, f64_tmp4, incr_remaining);
+            } else if (is_f32) {
+                f32_to_stats(&stats_next, f32_summary->data[src_offset], incr_remaining);
+            } else {
+                f64_to_stats(&stats_next, f64_summary->data[src_offset], incr_remaining);
+            }
+            jls_statistics_combine(&stats_accum, &stats_accum, &stats_next);
+            stats_to_f64(data, &stats_accum);
+            data += JLS_SUMMARY_FSR_COUNT;
+            --data_length;
+            int64_t incr = step_size - incr_remaining;
+            if (incr < 0) {
+                JLS_LOGE("internal error");
+                incr = 0;
+                jls_statistics_reset(&stats_accum);
+            } else if (incr == 0) {
+                jls_statistics_reset(&stats_accum);
+            } else if (is_f32) {
+                f32_to_stats(&stats_accum, f32_summary->data[src_offset], incr);
+            } else {
+                f64_to_stats(&stats_accum, f64_summary->data[src_offset], incr);
+            }
+            incr_remaining = increment - incr;
+        } else {
+            if (is_f32) {
+                f32_to_stats(&stats_next, f32_summary->data[src_offset], step_size);
+            } else {
+                f64_to_stats(&stats_next, f64_summary->data[src_offset], step_size);
+            }
+            jls_statistics_combine(&stats_accum, &stats_accum, &stats_next);
+            incr_remaining -= step_size;
+        }
+        start_sample_id += step_size;
+        ++src_offset;
+    }
+    return 0;
+}
+
+int32_t jls_rd_fsr_statistics(struct jls_rd_s * self, uint16_t signal_id,
+                              int64_t start_sample_id, int64_t increment,
+                              double * data, int64_t data_length) {
+    // API zero-based start_sample_id
+    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
+        JLS_LOGW("signal_id %d invalid", (int) signal_id);
+        return JLS_ERROR_PARAMETER_INVALID;
+    } else if (increment <= 0) {
+        JLS_LOGW("invalid increment: %" PRIi64, increment);
+        return JLS_ERROR_PARAMETER_INVALID;
+    } else if (data_length <= 0) {
+        JLS_LOGW("invalid length: %" PRIi64, data_length);
+        return 0;
+    } else if (start_sample_id < 0) {
+        JLS_LOGW("invalid start_sample_id: %" PRIi64, start_sample_id);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    int64_t samples = 0;
+    ROE(jls_rd_fsr_length(self, signal_id, &samples));
+    int64_t end_sample_id = start_sample_id + increment * data_length;
+    if (end_sample_id > samples) {
+        JLS_LOGW("invalid length: %" PRIi64 " > %" PRIi64, end_sample_id, samples);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
+
+    struct jls_signal_def_s * signal_def = &self->signal_def[signal_id];
+    uint8_t level = 0;
+    int64_t sample_multiple_next = signal_def->sample_decimate_factor;
+    int64_t duration = increment * data_length;
+    while ((increment >= sample_multiple_next)
+            && (duration >= (DECIMATE_PER_DURATION * sample_multiple_next))) {
+        ++level;
+        sample_multiple_next *= signal_def->summary_decimate_factor;
+    }
+    start_sample_id += sample_id_offset; // JLS file sample_id
+
+    if (level) {  // use summaries
+        return fsr_statistics(self, signal_id, start_sample_id, increment, level, data, data_length);
+    }  // else, use sample data
+    JLS_LOGD2("f32(signal_id=%d, start_id=%" PRIi64 ", incr=%" PRIi64 ", level=0, len=%" PRIi64 ")",
+              (int) signal_id, start_sample_id, increment, data_length);
+
+    ROE(f64_buf_alloc((size_t) increment, &self->f64_stats_buf));
+    ROE(f64_buf_alloc((size_t) signal_def->samples_per_data, &self->f64_sample_buf));
+    int64_t buf_offset = 0;
+    uint8_t entry_size_bits = jls_datatype_parse_size(signal_def->data_type);
+    if (entry_size_bits > 32) {
+        JLS_LOGE("entry_size > 64 (float64 stats) not yet supported");
+        return JLS_ERROR_UNSUPPORTED_FILE;
+    }
+
+    ROE(fsr_seek(self, signal_id, 0, start_sample_id));
+    ROE(rd(self));
+    struct jls_fsr_data_s * s = (struct jls_fsr_data_s *) self->payload.start;
+    int64_t chunk_sample_id = s->header.timestamp;
+    if (s->header.entry_size_bits != entry_size_bits) {
+        JLS_LOGE("invalid data entry size: %d", (int) s->header.entry_size_bits);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    jls_dt_buffer_to_f64(&s->data[0], signal_def->data_type, self->f64_sample_buf->start, signal_def->samples_per_data);
+    double * src = &self->f64_sample_buf->start[0];
+    double * src_end = &self->f64_sample_buf->start[s->header.entry_count];
+    if (start_sample_id > chunk_sample_id) {
+        src += start_sample_id - chunk_sample_id;
+    }
+    double v_mean = 0.0;
+    double v_min = DBL_MAX;
+    double v_max = -DBL_MAX;
+    double v_var = 0.0;
+    double mean_scale = 1.0 / increment;
+    double var_scale = 1.0;
+    if (increment > 1) {
+        var_scale = 1.0 / (increment - 1.0);
+    }
+    double v;
+
+    while (data_length > 0) {
+        if (src >= src_end) {
+            ROE(jls_raw_chunk_seek(self->raw, self->chunk_cur.hdr.item_next));
+            ROE(rd(self));
+            if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_FSR_DATA) {
+                JLS_LOGW("unexpected chunk tag: %d", (int) self->chunk_cur.hdr.tag);
+            }
+            if (self->chunk_cur.hdr.chunk_meta != signal_id) {
+                JLS_LOGW("unexpected chunk meta: %d", (int) self->chunk_cur.hdr.chunk_meta);
+            }
+            s = (struct jls_fsr_data_s *) self->payload.start;
+            if (s->header.entry_size_bits != entry_size_bits) {
+                JLS_LOGE("invalid data entry size: %d", (int) s->header.entry_size_bits);
+                return JLS_ERROR_PARAMETER_INVALID;
+            }
+            chunk_sample_id = s->header.timestamp;
+            jls_dt_buffer_to_f64(&s->data[0], signal_def->data_type, self->f64_sample_buf->start, signal_def->samples_per_data);
+            src = &self->f64_sample_buf->start[0];
+            src_end = &self->f64_sample_buf->start[s->header.entry_count];
+        }
+        v = *src++;
+        v_mean += v;
+        if (v < v_min) {
+            v_min = v;
+        }
+        if (v > v_max) {
+            v_max = v;
+        }
+        self->f64_stats_buf->start[buf_offset++] = v;
+
+        if (buf_offset >= increment) {
+            v_mean *= mean_scale;
+            v_var = 0.0;
+            for (int64_t i = 0; i < increment; ++i) {
+                double v_diff = self->f64_stats_buf->start[i] - v_mean;
+                v_var += v_diff * v_diff;
+            }
+            v_var *= var_scale;
+
+            data[JLS_SUMMARY_FSR_MEAN] = v_mean;
+            data[JLS_SUMMARY_FSR_MIN] = v_min;
+            data[JLS_SUMMARY_FSR_MAX] = v_max;
+            data[JLS_SUMMARY_FSR_STD] = sqrt(v_var);
+            data += JLS_SUMMARY_FSR_COUNT;
+
+            buf_offset = 0;
+            v_mean = 0.0;
+            v_min = DBL_MAX;
+            v_max = -DBL_MAX;
+            --data_length;
+        }
+    }
+    return 0;
+}
+
+int32_t jls_rd_annotations(struct jls_rd_s * self, uint16_t signal_id, int64_t timestamp,
+                           jls_rd_annotation_cbk_fn cbk_fn, void * cbk_user_data) {
+    struct jls_annotation_s * annotation;
+    if (!cbk_fn) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (!is_signal_defined(self, signal_id)) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+
+    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
+    timestamp += sample_id_offset;
+
+    int32_t rv = ts_seek(self, signal_id, 0, JLS_TRACK_TYPE_ANNOTATION, timestamp);
+    if (rv == JLS_ERROR_NOT_FOUND) {
+        return 0;  // no annotations, and that's just fine
+    } else if (rv) {
+        return rv;
+    }
+
+    // iterate
+    int64_t pos = jls_raw_chunk_tell(self->raw);
+    while (pos) {
+        ROE(jls_raw_chunk_seek(self->raw, pos));
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_ANNOTATION_DATA) {
+            return JLS_ERROR_NOT_FOUND;
+        }
+        annotation = (struct jls_annotation_s *) self->payload.start;
+        annotation->timestamp -= sample_id_offset;
+        if (cbk_fn(cbk_user_data, annotation)) {
+            return 0;
+        }
+        pos = self->chunk_cur.hdr.item_next;
+    }
+    return 0;
+}
+
+int32_t jls_rd_user_data(struct jls_rd_s * self, jls_rd_user_data_cbk_fn cbk_fn, void * cbk_user_data) {
+    int32_t rv;
+    if (!cbk_fn) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    int64_t pos = self->user_data_head.hdr.item_next;
+    uint16_t chunk_meta;
+    while (pos) {
+        ROE(jls_raw_chunk_seek(self->raw, pos));
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag != JLS_TAG_USER_DATA) {
+            return JLS_ERROR_NOT_FOUND;
+        }
+        uint8_t storage_type = (uint8_t) ((self->chunk_cur.hdr.chunk_meta >> 12) & 0x0f);
+        switch (storage_type) {
+            case JLS_STORAGE_TYPE_BINARY:  // intentional fall-through
+            case JLS_STORAGE_TYPE_STRING:  // intentional fall-through
+            case JLS_STORAGE_TYPE_JSON:
+                break;
+            default:
+                return JLS_ERROR_PARAMETER_INVALID;
+        }
+        chunk_meta = self->chunk_cur.hdr.chunk_meta & 0x0fff;
+        rv = cbk_fn(cbk_user_data, chunk_meta, storage_type,
+                    self->payload.start, self->chunk_cur.hdr.payload_length);
+        if (rv) {  // iteration done
+            return 0;
+        }
+        pos = self->chunk_cur.hdr.item_next;
+    }
+    return 0;
+}
+
+JLS_API int32_t jls_rd_utc(struct jls_rd_s * self, uint16_t signal_id, int64_t sample_id,
+                           jls_rd_utc_cbk_fn cbk_fn, void * cbk_user_data) {
+    struct jls_utc_summary_s * utc;
+    if (!cbk_fn) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (!is_signal_defined(self, signal_id)) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+
+    const int64_t sample_id_offset = self->signal_def[signal_id].sample_id_offset;
+    sample_id += sample_id_offset;
+    int32_t rv = ts_seek(self, signal_id, 1, JLS_TRACK_TYPE_UTC, sample_id);
+    if (rv == JLS_ERROR_NOT_FOUND) {
+        return 0;  // no utc entries, and that's just fine
+    } else if (rv) {
+        return rv;
+    }
+
+    // iterate
+    struct jls_chunk_header_s hdr;
+    hdr.item_next = jls_raw_chunk_tell(self->raw);
+
+    while (hdr.item_next) {
+        ROE(jls_raw_chunk_seek(self->raw, hdr.item_next));
+        ROE(jls_raw_rd_header(self->raw, &hdr));
+        if (hdr.tag != JLS_TAG_TRACK_UTC_INDEX) {
+            return JLS_ERROR_NOT_FOUND;
+        }
+        ROE(jls_raw_chunk_next(self->raw));
+        ROE(rd(self));
+        if (self->chunk_cur.hdr.tag != JLS_TAG_TRACK_UTC_SUMMARY) {
+            return JLS_ERROR_NOT_FOUND;
+        }
+        utc = (struct jls_utc_summary_s *) self->payload.start;
+        uint32_t idx = 0;
+        for (; (idx < utc->header.entry_count) && (sample_id > utc->entries[idx].sample_id); ++idx) {
+            // iterate
+        }
+        uint32_t size = utc->header.entry_count - idx;
+        for (uint32_t entry_idx = idx; entry_idx < utc->header.entry_count; ++entry_idx) {
+            utc->entries[entry_idx].sample_id -= sample_id_offset;
+        }
+        if (size) {
+            if (cbk_fn(cbk_user_data, utc->entries + idx, size)) {
+                return 0;
+            }
+        }
+    }
+    return 0;
+}
+
+static int32_t utc_load(struct jls_rd_s * self, uint16_t signal_id) {
+    if (!is_signal_defined_type(self, signal_id, JLS_SIGNAL_TYPE_FSR)) {
+        return JLS_ERROR_NOT_FOUND;
+    }
+    struct signal_s * signal = &self->signals[signal_id];
+    if (NULL != signal->rd_fsr) {
+        return 0;
+    }
+    signal->rd_fsr = jls_rd_fsr_alloc(self->signal_def[signal_id].sample_rate);
+    if (NULL == signal->rd_fsr) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    int64_t sample_rate = self->signal_def[signal_id].sample_rate;
+    int64_t sample_start = -3600 * sample_rate;  // within the last hour
+    return jls_rd_utc(self, signal_id, sample_start, jls_rd_fsr_add_cbk, signal->rd_fsr);
+}
+
+int32_t jls_rd_sample_id_to_timestamp(struct jls_rd_s * self, uint16_t signal_id,
+                                      int64_t sample_id, int64_t * timestamp) {
+    ROE(utc_load(self, signal_id));
+    return jls_rd_fsr_sample_id_to_timestamp(self->signals[signal_id].rd_fsr, sample_id, timestamp);
+}
+
+int32_t jls_rd_timestamp_to_sample_id(struct jls_rd_s * self, uint16_t signal_id,
+                                              int64_t timestamp, int64_t * sample_id) {
+    ROE(utc_load(self, signal_id));
+    return jls_rd_fsr_timestamp_to_sample_id(self->signals[signal_id].rd_fsr, timestamp, sample_id);
+}
```

### Comparing `pyjls-0.7.0/src/statistics.c` & `pyjls-0.7.1/src/statistics.c`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,160 +1,160 @@
-/*
- * Copyright 2020-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/statistics.h"
-#include <float.h>
-#include <math.h>
-
-void jls_statistics_reset(struct jls_statistics_s *s) {
-    s->k = 0;
-    s->mean = 0.0;
-    s->s = 0.0;
-    s->min = DBL_MAX;
-    s->max = -DBL_MAX;
-}
-
-void jls_statistics_invalid(struct jls_statistics_s *s) {
-    s->mean = NAN;
-    s->s = NAN;
-    s->min = NAN;
-    s->max = NAN;
-}
-
-void jls_statistics_compute_f32(struct jls_statistics_s * s, const float * x, uint64_t length) {
-    if (length <= 0) {
-        jls_statistics_reset(s);
-        return;
-    }
-    float v;
-    double v_mean = 0.0;
-    float v_min = FLT_MAX;
-    float v_max = -FLT_MAX;
-    double v_var = 0.0;
-    for (uint64_t i = 0; i < length; ++i) {
-        v = x[i];
-        v_mean += v;
-        if (v < v_min) {
-            v_min = v;
-        }
-        if (v > v_max) {
-            v_max = v;
-        }
-    }
-    v_mean /= length;
-    double m;
-    for (uint64_t i = 0; i < length; ++i) {
-        m = x[i] - v_mean;
-        v_var += (m * m);
-    }
-    s->k = length;
-    s->mean = v_mean;
-    s->s = v_var;
-    s->min = v_min;
-    s->max = v_max;
-}
-
-void jls_statistics_compute_f64(struct jls_statistics_s * s, const double * x, uint64_t length)  {
-    if (length <= 0) {
-        jls_statistics_reset(s);
-        return;
-    }
-    double v;
-    double v_mean = 0.0;
-    double v_min = DBL_MAX;
-    double v_max = -DBL_MAX;
-    double v_var = 0.0;
-    for (uint64_t i = 0; i < length; ++i) {
-        v = x[i];
-        v_mean += v;
-        if (v < v_min) {
-            v_min = v;
-        }
-        if (v > v_max) {
-            v_max = v;
-        }
-    }
-    v_mean /= length;
-    double m;
-    for (uint64_t i = 0; i < length; ++i) {
-        m = x[i] - v_mean;
-        v_var += (m * m);
-    }
-    s->k = length;
-    s->mean = v_mean;
-    s->s = v_var;
-    s->min = v_min;
-    s->max = v_max;
-}
-
-void jls_statistics_add(struct jls_statistics_s *s, double x) {
-    double m_old;
-    double m_new;
-    ++s->k;
-    m_old = s->mean;
-    m_new = s->mean + (x - s->mean) / (double) s->k;
-    s->mean = m_new;
-    s->s += (x - m_old) * (x - m_new);
-    if (x < s->min) {
-        s->min = x;
-    }
-    if (x > s->max) {
-        s->max = x;
-    }
-}
-
-double jls_statistics_var(struct jls_statistics_s *s) {
-    if (s->k <= 1) {
-        return 0.0;
-    }
-    return s->s / (double) (s->k - 1); // use k - 1 = Bessel's correction for sample variance
-}
-
-void jls_statistics_copy(struct jls_statistics_s *tgt,
-                         const struct jls_statistics_s *src) {
-    tgt->k = src->k;
-    tgt->mean = src->mean;
-    tgt->s = src->s;
-    tgt->min = src->min;
-    tgt->max = src->max;
-}
-
-void jls_statistics_combine(struct jls_statistics_s *tgt,
-                            const struct jls_statistics_s *a,
-                            const struct jls_statistics_s *b) {
-    uint64_t kt;
-    double f1;
-    double m1_diff;
-    double m2_diff;
-    kt = a->k + b->k;
-    if (kt == 0) {
-        jls_statistics_reset(tgt);
-    } else if (a->k == 0) {
-        jls_statistics_copy(tgt, b);
-    } else if (b->k == 0) {
-        jls_statistics_copy(tgt, a);
-    } else {
-        f1 = a->k / (double) kt;
-        double mean_new = f1 * a->mean + (1.0 - f1) * b->mean;
-        m1_diff = a->mean - mean_new;
-        m2_diff = b->mean - mean_new;
-        tgt->s = (a->s + a->k * m1_diff * m1_diff) +
-                 (b->s + b->k * m2_diff * m2_diff);
-        tgt->mean = mean_new;
-        tgt->min = (a->min < b->min) ? a->min : b->min;
-        tgt->max = (a->max > b->max) ? a->max : b->max;
-        tgt->k = kt;
-    }
-}
+/*
+ * Copyright 2020-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/statistics.h"
+#include <float.h>
+#include <math.h>
+
+void jls_statistics_reset(struct jls_statistics_s *s) {
+    s->k = 0;
+    s->mean = 0.0;
+    s->s = 0.0;
+    s->min = DBL_MAX;
+    s->max = -DBL_MAX;
+}
+
+void jls_statistics_invalid(struct jls_statistics_s *s) {
+    s->mean = NAN;
+    s->s = NAN;
+    s->min = NAN;
+    s->max = NAN;
+}
+
+void jls_statistics_compute_f32(struct jls_statistics_s * s, const float * x, uint64_t length) {
+    if (length <= 0) {
+        jls_statistics_reset(s);
+        return;
+    }
+    float v;
+    double v_mean = 0.0;
+    float v_min = FLT_MAX;
+    float v_max = -FLT_MAX;
+    double v_var = 0.0;
+    for (uint64_t i = 0; i < length; ++i) {
+        v = x[i];
+        v_mean += v;
+        if (v < v_min) {
+            v_min = v;
+        }
+        if (v > v_max) {
+            v_max = v;
+        }
+    }
+    v_mean /= length;
+    double m;
+    for (uint64_t i = 0; i < length; ++i) {
+        m = x[i] - v_mean;
+        v_var += (m * m);
+    }
+    s->k = length;
+    s->mean = v_mean;
+    s->s = v_var;
+    s->min = v_min;
+    s->max = v_max;
+}
+
+void jls_statistics_compute_f64(struct jls_statistics_s * s, const double * x, uint64_t length)  {
+    if (length <= 0) {
+        jls_statistics_reset(s);
+        return;
+    }
+    double v;
+    double v_mean = 0.0;
+    double v_min = DBL_MAX;
+    double v_max = -DBL_MAX;
+    double v_var = 0.0;
+    for (uint64_t i = 0; i < length; ++i) {
+        v = x[i];
+        v_mean += v;
+        if (v < v_min) {
+            v_min = v;
+        }
+        if (v > v_max) {
+            v_max = v;
+        }
+    }
+    v_mean /= length;
+    double m;
+    for (uint64_t i = 0; i < length; ++i) {
+        m = x[i] - v_mean;
+        v_var += (m * m);
+    }
+    s->k = length;
+    s->mean = v_mean;
+    s->s = v_var;
+    s->min = v_min;
+    s->max = v_max;
+}
+
+void jls_statistics_add(struct jls_statistics_s *s, double x) {
+    double m_old;
+    double m_new;
+    ++s->k;
+    m_old = s->mean;
+    m_new = s->mean + (x - s->mean) / (double) s->k;
+    s->mean = m_new;
+    s->s += (x - m_old) * (x - m_new);
+    if (x < s->min) {
+        s->min = x;
+    }
+    if (x > s->max) {
+        s->max = x;
+    }
+}
+
+double jls_statistics_var(struct jls_statistics_s *s) {
+    if (s->k <= 1) {
+        return 0.0;
+    }
+    return s->s / (double) (s->k - 1); // use k - 1 = Bessel's correction for sample variance
+}
+
+void jls_statistics_copy(struct jls_statistics_s *tgt,
+                         const struct jls_statistics_s *src) {
+    tgt->k = src->k;
+    tgt->mean = src->mean;
+    tgt->s = src->s;
+    tgt->min = src->min;
+    tgt->max = src->max;
+}
+
+void jls_statistics_combine(struct jls_statistics_s *tgt,
+                            const struct jls_statistics_s *a,
+                            const struct jls_statistics_s *b) {
+    uint64_t kt;
+    double f1;
+    double m1_diff;
+    double m2_diff;
+    kt = a->k + b->k;
+    if (kt == 0) {
+        jls_statistics_reset(tgt);
+    } else if (a->k == 0) {
+        jls_statistics_copy(tgt, b);
+    } else if (b->k == 0) {
+        jls_statistics_copy(tgt, a);
+    } else {
+        f1 = a->k / (double) kt;
+        double mean_new = f1 * a->mean + (1.0 - f1) * b->mean;
+        m1_diff = a->mean - mean_new;
+        m2_diff = b->mean - mean_new;
+        tgt->s = (a->s + a->k * m1_diff * m1_diff) +
+                 (b->s + b->k * m2_diff * m2_diff);
+        tgt->mean = mean_new;
+        tgt->min = (a->min < b->min) ? a->min : b->min;
+        tgt->max = (a->max > b->max) ? a->max : b->max;
+        tgt->k = kt;
+    }
+}
```

### Comparing `pyjls-0.7.0/src/threaded_writer.c` & `pyjls-0.7.1/src/threaded_writer.c`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,368 +1,368 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/threaded_writer.h"
-#include "jls/msg_ring_buffer.h"
-#include "jls/wr_prv.h"
-#include "jls/backend.h"
-#include "jls/cdef.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include "jls/time.h"
-#include "jls/writer.h"
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-
-
-#define MRB_BUFFER_SIZE (64 * 1024 * 1024)
-
-
-struct jls_twr_s {
-    struct jls_bkt_s * bk;  // REQUIRED first entry
-    struct jls_wr_s * wr;
-    volatile int quit;
-    volatile uint64_t flush_send_id;
-    volatile uint64_t flush_processed_id;
-    uint8_t fsr_entry_size_bits[JLS_SIGNAL_COUNT];
-    struct jls_mrb_s mrb;
-    uint8_t mrb_buffer[];
-};
-
-struct msg_header_user_data_s {
-    uint16_t chunk_meta;
-    uint8_t storage_type;
-};
-
-struct msg_header_fsr_s {
-    uint16_t signal_id;
-    int64_t sample_id;
-    uint32_t sample_count;
-};
-
-struct msg_header_annotation_s {
-    uint16_t signal_id;
-    int64_t timestamp;
-    uint8_t annotation_type;
-    uint8_t storage_type;
-    uint8_t group_id;
-    float y;
-};
-
-struct msg_header_utc_s {
-    uint16_t signal_id;
-    int64_t sample_id;
-    int64_t utc;
-};
-
-struct msg_header_s {
-    uint8_t msg_type;
-    union {
-        struct msg_header_user_data_s user_data;
-        struct msg_header_fsr_s fsr;
-        struct msg_header_annotation_s annotation;
-        struct msg_header_utc_s utc;
-    } h;
-    uint64_t d;
-};
-
-enum message_e {
-    MSG_CLOSE,          // no header data, no args
-    MSG_FLUSH,          // no header data, no args
-    MSG_USER_DATA,      // hdr.user_data, user_data
-    MSG_FSR,            // hdr.fsr_f32, data
-    MSG_ANNOTATION,     // hdr.annotation, data
-    MSG_UTC,            // hdr.utc, data
-    MSG_ITEM_COUNT,
-};
-
-const char * message_str[] = {
-        "close",
-        "flush",
-        "user_data",
-        "fsr",
-        "annotation",
-        "utc",
-};
-
-int32_t jls_twr_run(struct jls_twr_s * self) {
-    uint32_t msg_size = 0;
-    uint8_t * msg = NULL;
-    struct msg_header_s hdr;
-    uint8_t * payload;
-    int32_t rc = 0;
-    struct jls_time_counter_s counter_start = jls_time_counter();
-    struct jls_time_counter_s counter_end;
-    struct jls_time_counter_s counter_prev = counter_start;
-    uint64_t duration_ms;
-
-    JLS_LOGI("run start");
-    while (!self->quit) {
-        if (NULL == self->bk) {
-            JLS_LOGE("backend null, quit");  // should never happen
-            self->quit = true;
-            continue;
-        }
-        jls_bkt_msg_wait(self->bk);
-        while (1) {
-            jls_bkt_msg_lock(self->bk);
-            if (NULL != msg) {
-                jls_mrb_pop(&self->mrb, &msg_size);
-            }
-            msg = jls_mrb_peek(&self->mrb, &msg_size);
-            jls_bkt_msg_unlock(self->bk);
-            if (!msg) {
-                break;
-            }
-            counter_start = jls_time_counter();
-            if (((counter_start.value - counter_prev.value) / counter_start.frequency) >= 1) {
-                JLS_LOGD2("twr %" PRIu32 " msgs (%" PRIu32 " of %" PRIu32 " bytes)",
-                          self->mrb.count, jls_mrb_used_bytes(&self->mrb), self->mrb.buf_size);
-                counter_prev = counter_start;
-            }
-            payload = msg + sizeof(hdr);
-            uint32_t payload_sz = msg_size - sizeof(hdr);
-
-            memcpy(&hdr, msg, sizeof(hdr));
-            rc = 0;
-
-            jls_bkt_process_lock(self->bk);
-            switch (hdr.msg_type) {
-                case MSG_CLOSE:
-                    self->quit = 1;
-                    break;
-                case MSG_FLUSH:
-                    jls_wr_flush(self->wr);
-                    self->flush_processed_id = hdr.d > self->flush_processed_id ? hdr.d : self->flush_processed_id;
-                    break;
-                case MSG_USER_DATA:
-                    rc = jls_wr_user_data(self->wr, hdr.h.user_data.chunk_meta, hdr.h.user_data.storage_type,
-                                          payload, payload_sz);
-                    break;
-                case MSG_FSR:
-                    rc = jls_wr_fsr(self->wr, hdr.h.fsr.signal_id, hdr.h.fsr.sample_id, payload, hdr.h.fsr.sample_count);
-                    break;
-                case MSG_ANNOTATION:
-                    rc = jls_wr_annotation(self->wr, hdr.h.annotation.signal_id, hdr.h.annotation.timestamp,
-                                           hdr.h.annotation.y,
-                                           hdr.h.annotation.annotation_type,
-                                           hdr.h.annotation.group_id,
-                                           hdr.h.annotation.storage_type,
-                                           (const uint8_t *) payload, payload_sz);
-                    break;
-                case MSG_UTC:
-                    rc = jls_wr_utc(self->wr, hdr.h.utc.signal_id, hdr.h.utc.sample_id, hdr.h.utc.utc);
-                default:
-                    break;
-            }
-            jls_bkt_process_unlock(self->bk);
-            counter_end = jls_time_counter();
-            duration_ms = (1000 * (counter_end.value - counter_start.value)) / counter_end.frequency;
-            if (duration_ms > 250) {
-                JLS_LOGW("thread msg %d:%s took %" PRIu64 " ms",
-                         (int) hdr.msg_type,
-                         (hdr.msg_type < MSG_ITEM_COUNT) ? message_str[hdr.msg_type] : "unknown",
-                         duration_ms);
-            }
-
-            if (rc) {
-                JLS_LOGW("thread msg %d:%s returned %d:%s",
-                         (int) hdr.msg_type,
-                         (hdr.msg_type < MSG_ITEM_COUNT) ? message_str[hdr.msg_type] : "unknown",
-                         (int) rc, jls_error_code_name(rc));
-            }
-        }
-    }
-    JLS_LOGI("run done");
-    return 0;
-}
-
-int32_t jls_twr_open(struct jls_twr_s ** instance, const char * path) {
-    struct jls_wr_s * wr;
-    struct jls_twr_s * self;
-    ROE(jls_wr_open(&wr, path));
-
-    self = malloc(sizeof(struct jls_twr_s) + MRB_BUFFER_SIZE);
-    if (NULL == self) {
-        JLS_LOGE("jls_twr_open malloc failed");
-        jls_wr_close(wr);
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    self->quit = 0;
-    self->wr = wr;
-    self->flush_send_id = 0;
-    self->flush_processed_id = 0;
-
-    jls_mrb_init(&self->mrb, self->mrb_buffer, MRB_BUFFER_SIZE);
-    self->bk = jls_bkt_initialize(self);
-    if (!self->bk) {
-        JLS_LOGE("jls_bkt_initialize failed");
-        jls_wr_close(wr);
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-
-    *instance = self;
-    return 0;
-}
-
-int32_t msg_send(struct jls_twr_s * self, const struct msg_header_s * hdr, const uint8_t * payload, uint32_t payload_size) {
-    uint32_t sz = sizeof(*hdr) + payload_size;
-    for (uint32_t count = 0; count < (JLS_BK_MSG_WRITE_TIMEOUT_MS / 5); ++count) {
-        jls_bkt_msg_lock(self->bk);
-        uint8_t *msg = jls_mrb_alloc(&self->mrb, sz);
-        if (msg) {
-            memcpy(msg, hdr, sizeof(*hdr));
-            if (payload_size) {
-                memcpy(msg + sizeof(*hdr), payload, payload_size);
-            }
-            jls_bkt_msg_unlock(self->bk);
-            jls_bkt_msg_signal(self->bk);
-            return 0;
-        }
-        jls_bkt_msg_unlock(self->bk);
-        jls_bkt_sleep_ms(5);
-    }
-    return JLS_ERROR_BUSY;
-}
-
-int32_t jls_twr_flush(struct jls_twr_s * self) {
-    uint64_t flush_id;
-    struct msg_header_s hdr = { .msg_type = MSG_FLUSH };
-    jls_bkt_msg_lock(self->bk);
-    flush_id = self->flush_send_id + 1;
-    self->flush_send_id = flush_id;
-    jls_bkt_msg_unlock(self->bk);
-    hdr.d = flush_id;
-    msg_send(self, &hdr, NULL, 0);
-
-    int64_t t_start = jls_now();
-    int64_t t_stop = t_start + JLS_TIME_MILLISECOND * (int64_t) JLS_BK_FLUSH_TIMEOUT_MS;
-    while (self->flush_processed_id < flush_id) {
-        jls_bkt_sleep_ms(10);
-        if (jls_now() >= t_stop) {
-            JLS_LOGE("flush timed out");
-            return JLS_ERROR_TIMED_OUT;
-        }
-    }
-    return 0;
-}
-
-int32_t jls_twr_close(struct jls_twr_s * self) {
-    if (self) {
-        JLS_LOGI("jls_twr_close start");
-        struct msg_header_s hdr = { .msg_type = MSG_CLOSE };
-        msg_send(self, &hdr, NULL, 0);
-        jls_bkt_finalize(self->bk);
-        JLS_LOGI("jls_bkt_finalize done");
-        // jls_wr_flush(self->wr);  // takes too long & blocks UI
-        // JLS_LOGI("jls_wr_flush done");
-        jls_wr_close(self->wr);
-        self->wr = NULL;
-        free(self);
-        JLS_LOGI("jls_wr_close done");
-    }
-    return 0;
-}
-
-int32_t jls_twr_source_def(struct jls_twr_s * self, const struct jls_source_def_s * source) {
-    jls_bkt_process_lock(self->bk);
-    int32_t rv = jls_wr_source_def(self->wr, source);
-    jls_bkt_process_unlock(self->bk);
-    return rv;
-}
-
-int32_t jls_twr_signal_def(struct jls_twr_s * self, const struct jls_signal_def_s * signal) {
-    jls_bkt_process_lock(self->bk);
-    self->fsr_entry_size_bits[signal->signal_id] = jls_datatype_parse_size(signal->data_type);
-    int32_t rv = jls_wr_signal_def(self->wr, signal);
-    jls_bkt_process_unlock(self->bk);
-    return rv;
-}
-
-int32_t jls_twr_user_data(struct jls_twr_s * self, uint16_t chunk_meta,
-                          enum jls_storage_type_e storage_type, const uint8_t * data, uint32_t data_size) {
-    struct msg_header_s hdr = {
-            .msg_type = MSG_USER_DATA,
-            .h = {
-                    .user_data = {
-                            .chunk_meta = chunk_meta,
-                            .storage_type = storage_type,
-                    }
-            },
-            .d = 0
-    };
-    return msg_send(self, &hdr, data, data_size);
-}
-
-int32_t jls_twr_fsr(struct jls_twr_s * self, uint16_t signal_id,
-                    int64_t sample_id, const void * data, uint32_t data_length) {
-    struct msg_header_s hdr = {
-            .msg_type = MSG_FSR,
-            .h = {
-                    .fsr = {
-                            .signal_id = signal_id,
-                            .sample_id = sample_id,
-                            .sample_count = data_length,
-                    }
-            },
-            .d = 0
-    };
-    uint32_t length = (data_length * self->fsr_entry_size_bits[signal_id] + 7) / 8;
-    return msg_send(self, &hdr, (const uint8_t *) data, length);
-}
-
-int32_t jls_twr_fsr_f32(struct jls_twr_s * self, uint16_t signal_id,
-                        int64_t sample_id, const float * data, uint32_t data_length) {
-    return jls_twr_fsr(self, signal_id, sample_id, data, data_length);
-}
-
-int32_t jls_twr_annotation(struct jls_twr_s * self, uint16_t signal_id, int64_t timestamp,
-                           float y,
-                           enum jls_annotation_type_e annotation_type,
-                           uint8_t group_id,
-                           enum jls_storage_type_e storage_type,
-                           const uint8_t * data, uint32_t data_size) {
-    struct msg_header_s hdr = {
-            .msg_type = MSG_ANNOTATION,
-            .h = {
-                    .annotation = {
-                            .signal_id = signal_id,
-                            .timestamp = timestamp,
-                            .annotation_type = annotation_type,
-                            .storage_type = storage_type,
-                            .group_id = group_id,
-                            .y = y
-                    }
-            },
-            .d = 0
-    };
-    return msg_send(self, &hdr, data, data_size);
-}
-
-JLS_API int32_t jls_twr_utc(struct jls_twr_s * self, uint16_t signal_id, int64_t sample_id, int64_t utc) {
-    struct msg_header_s hdr = {
-            .msg_type = MSG_UTC,
-            .h = {
-                    .utc = {
-                            .signal_id = signal_id,
-                            .sample_id = sample_id,
-                            .utc = utc
-                    }
-            },
-            .d = 0
-    };
-    return msg_send(self, &hdr, NULL, 0);
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/threaded_writer.h"
+#include "jls/msg_ring_buffer.h"
+#include "jls/wr_prv.h"
+#include "jls/backend.h"
+#include "jls/cdef.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include "jls/time.h"
+#include "jls/writer.h"
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+
+#define MRB_BUFFER_SIZE (64 * 1024 * 1024)
+
+
+struct jls_twr_s {
+    struct jls_bkt_s * bk;  // REQUIRED first entry
+    struct jls_wr_s * wr;
+    volatile int quit;
+    volatile uint64_t flush_send_id;
+    volatile uint64_t flush_processed_id;
+    uint8_t fsr_entry_size_bits[JLS_SIGNAL_COUNT];
+    struct jls_mrb_s mrb;
+    uint8_t mrb_buffer[];
+};
+
+struct msg_header_user_data_s {
+    uint16_t chunk_meta;
+    uint8_t storage_type;
+};
+
+struct msg_header_fsr_s {
+    uint16_t signal_id;
+    int64_t sample_id;
+    uint32_t sample_count;
+};
+
+struct msg_header_annotation_s {
+    uint16_t signal_id;
+    int64_t timestamp;
+    uint8_t annotation_type;
+    uint8_t storage_type;
+    uint8_t group_id;
+    float y;
+};
+
+struct msg_header_utc_s {
+    uint16_t signal_id;
+    int64_t sample_id;
+    int64_t utc;
+};
+
+struct msg_header_s {
+    uint8_t msg_type;
+    union {
+        struct msg_header_user_data_s user_data;
+        struct msg_header_fsr_s fsr;
+        struct msg_header_annotation_s annotation;
+        struct msg_header_utc_s utc;
+    } h;
+    uint64_t d;
+};
+
+enum message_e {
+    MSG_CLOSE,          // no header data, no args
+    MSG_FLUSH,          // no header data, no args
+    MSG_USER_DATA,      // hdr.user_data, user_data
+    MSG_FSR,            // hdr.fsr_f32, data
+    MSG_ANNOTATION,     // hdr.annotation, data
+    MSG_UTC,            // hdr.utc, data
+    MSG_ITEM_COUNT,
+};
+
+const char * message_str[] = {
+        "close",
+        "flush",
+        "user_data",
+        "fsr",
+        "annotation",
+        "utc",
+};
+
+int32_t jls_twr_run(struct jls_twr_s * self) {
+    uint32_t msg_size = 0;
+    uint8_t * msg = NULL;
+    struct msg_header_s hdr;
+    uint8_t * payload;
+    int32_t rc = 0;
+    struct jls_time_counter_s counter_start = jls_time_counter();
+    struct jls_time_counter_s counter_end;
+    struct jls_time_counter_s counter_prev = counter_start;
+    uint64_t duration_ms;
+
+    JLS_LOGI("run start");
+    while (!self->quit) {
+        if (NULL == self->bk) {
+            JLS_LOGE("backend null, quit");  // should never happen
+            self->quit = true;
+            continue;
+        }
+        jls_bkt_msg_wait(self->bk);
+        while (1) {
+            jls_bkt_msg_lock(self->bk);
+            if (NULL != msg) {
+                jls_mrb_pop(&self->mrb, &msg_size);
+            }
+            msg = jls_mrb_peek(&self->mrb, &msg_size);
+            jls_bkt_msg_unlock(self->bk);
+            if (!msg) {
+                break;
+            }
+            counter_start = jls_time_counter();
+            if (((counter_start.value - counter_prev.value) / counter_start.frequency) >= 1) {
+                JLS_LOGD2("twr %" PRIu32 " msgs (%" PRIu32 " of %" PRIu32 " bytes)",
+                          self->mrb.count, jls_mrb_used_bytes(&self->mrb), self->mrb.buf_size);
+                counter_prev = counter_start;
+            }
+            payload = msg + sizeof(hdr);
+            uint32_t payload_sz = msg_size - sizeof(hdr);
+
+            memcpy(&hdr, msg, sizeof(hdr));
+            rc = 0;
+
+            jls_bkt_process_lock(self->bk);
+            switch (hdr.msg_type) {
+                case MSG_CLOSE:
+                    self->quit = 1;
+                    break;
+                case MSG_FLUSH:
+                    jls_wr_flush(self->wr);
+                    self->flush_processed_id = hdr.d > self->flush_processed_id ? hdr.d : self->flush_processed_id;
+                    break;
+                case MSG_USER_DATA:
+                    rc = jls_wr_user_data(self->wr, hdr.h.user_data.chunk_meta, hdr.h.user_data.storage_type,
+                                          payload, payload_sz);
+                    break;
+                case MSG_FSR:
+                    rc = jls_wr_fsr(self->wr, hdr.h.fsr.signal_id, hdr.h.fsr.sample_id, payload, hdr.h.fsr.sample_count);
+                    break;
+                case MSG_ANNOTATION:
+                    rc = jls_wr_annotation(self->wr, hdr.h.annotation.signal_id, hdr.h.annotation.timestamp,
+                                           hdr.h.annotation.y,
+                                           hdr.h.annotation.annotation_type,
+                                           hdr.h.annotation.group_id,
+                                           hdr.h.annotation.storage_type,
+                                           (const uint8_t *) payload, payload_sz);
+                    break;
+                case MSG_UTC:
+                    rc = jls_wr_utc(self->wr, hdr.h.utc.signal_id, hdr.h.utc.sample_id, hdr.h.utc.utc);
+                default:
+                    break;
+            }
+            jls_bkt_process_unlock(self->bk);
+            counter_end = jls_time_counter();
+            duration_ms = (1000 * (counter_end.value - counter_start.value)) / counter_end.frequency;
+            if (duration_ms > 250) {
+                JLS_LOGW("thread msg %d:%s took %" PRIu64 " ms",
+                         (int) hdr.msg_type,
+                         (hdr.msg_type < MSG_ITEM_COUNT) ? message_str[hdr.msg_type] : "unknown",
+                         duration_ms);
+            }
+
+            if (rc) {
+                JLS_LOGW("thread msg %d:%s returned %d:%s",
+                         (int) hdr.msg_type,
+                         (hdr.msg_type < MSG_ITEM_COUNT) ? message_str[hdr.msg_type] : "unknown",
+                         (int) rc, jls_error_code_name(rc));
+            }
+        }
+    }
+    JLS_LOGI("run done");
+    return 0;
+}
+
+int32_t jls_twr_open(struct jls_twr_s ** instance, const char * path) {
+    struct jls_wr_s * wr;
+    struct jls_twr_s * self;
+    ROE(jls_wr_open(&wr, path));
+
+    self = malloc(sizeof(struct jls_twr_s) + MRB_BUFFER_SIZE);
+    if (NULL == self) {
+        JLS_LOGE("jls_twr_open malloc failed");
+        jls_wr_close(wr);
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    self->quit = 0;
+    self->wr = wr;
+    self->flush_send_id = 0;
+    self->flush_processed_id = 0;
+
+    jls_mrb_init(&self->mrb, self->mrb_buffer, MRB_BUFFER_SIZE);
+    self->bk = jls_bkt_initialize(self);
+    if (!self->bk) {
+        JLS_LOGE("jls_bkt_initialize failed");
+        jls_wr_close(wr);
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+
+    *instance = self;
+    return 0;
+}
+
+int32_t msg_send(struct jls_twr_s * self, const struct msg_header_s * hdr, const uint8_t * payload, uint32_t payload_size) {
+    uint32_t sz = sizeof(*hdr) + payload_size;
+    for (uint32_t count = 0; count < (JLS_BK_MSG_WRITE_TIMEOUT_MS / 5); ++count) {
+        jls_bkt_msg_lock(self->bk);
+        uint8_t *msg = jls_mrb_alloc(&self->mrb, sz);
+        if (msg) {
+            memcpy(msg, hdr, sizeof(*hdr));
+            if (payload_size) {
+                memcpy(msg + sizeof(*hdr), payload, payload_size);
+            }
+            jls_bkt_msg_unlock(self->bk);
+            jls_bkt_msg_signal(self->bk);
+            return 0;
+        }
+        jls_bkt_msg_unlock(self->bk);
+        jls_bkt_sleep_ms(5);
+    }
+    return JLS_ERROR_BUSY;
+}
+
+int32_t jls_twr_flush(struct jls_twr_s * self) {
+    uint64_t flush_id;
+    struct msg_header_s hdr = { .msg_type = MSG_FLUSH };
+    jls_bkt_msg_lock(self->bk);
+    flush_id = self->flush_send_id + 1;
+    self->flush_send_id = flush_id;
+    jls_bkt_msg_unlock(self->bk);
+    hdr.d = flush_id;
+    msg_send(self, &hdr, NULL, 0);
+
+    int64_t t_start = jls_now();
+    int64_t t_stop = t_start + JLS_TIME_MILLISECOND * (int64_t) JLS_BK_FLUSH_TIMEOUT_MS;
+    while (self->flush_processed_id < flush_id) {
+        jls_bkt_sleep_ms(10);
+        if (jls_now() >= t_stop) {
+            JLS_LOGE("flush timed out");
+            return JLS_ERROR_TIMED_OUT;
+        }
+    }
+    return 0;
+}
+
+int32_t jls_twr_close(struct jls_twr_s * self) {
+    if (self) {
+        JLS_LOGI("jls_twr_close start");
+        struct msg_header_s hdr = { .msg_type = MSG_CLOSE };
+        msg_send(self, &hdr, NULL, 0);
+        jls_bkt_finalize(self->bk);
+        JLS_LOGI("jls_bkt_finalize done");
+        // jls_wr_flush(self->wr);  // takes too long & blocks UI
+        // JLS_LOGI("jls_wr_flush done");
+        jls_wr_close(self->wr);
+        self->wr = NULL;
+        free(self);
+        JLS_LOGI("jls_wr_close done");
+    }
+    return 0;
+}
+
+int32_t jls_twr_source_def(struct jls_twr_s * self, const struct jls_source_def_s * source) {
+    jls_bkt_process_lock(self->bk);
+    int32_t rv = jls_wr_source_def(self->wr, source);
+    jls_bkt_process_unlock(self->bk);
+    return rv;
+}
+
+int32_t jls_twr_signal_def(struct jls_twr_s * self, const struct jls_signal_def_s * signal) {
+    jls_bkt_process_lock(self->bk);
+    self->fsr_entry_size_bits[signal->signal_id] = jls_datatype_parse_size(signal->data_type);
+    int32_t rv = jls_wr_signal_def(self->wr, signal);
+    jls_bkt_process_unlock(self->bk);
+    return rv;
+}
+
+int32_t jls_twr_user_data(struct jls_twr_s * self, uint16_t chunk_meta,
+                          enum jls_storage_type_e storage_type, const uint8_t * data, uint32_t data_size) {
+    struct msg_header_s hdr = {
+            .msg_type = MSG_USER_DATA,
+            .h = {
+                    .user_data = {
+                            .chunk_meta = chunk_meta,
+                            .storage_type = storage_type,
+                    }
+            },
+            .d = 0
+    };
+    return msg_send(self, &hdr, data, data_size);
+}
+
+int32_t jls_twr_fsr(struct jls_twr_s * self, uint16_t signal_id,
+                    int64_t sample_id, const void * data, uint32_t data_length) {
+    struct msg_header_s hdr = {
+            .msg_type = MSG_FSR,
+            .h = {
+                    .fsr = {
+                            .signal_id = signal_id,
+                            .sample_id = sample_id,
+                            .sample_count = data_length,
+                    }
+            },
+            .d = 0
+    };
+    uint32_t length = (data_length * self->fsr_entry_size_bits[signal_id] + 7) / 8;
+    return msg_send(self, &hdr, (const uint8_t *) data, length);
+}
+
+int32_t jls_twr_fsr_f32(struct jls_twr_s * self, uint16_t signal_id,
+                        int64_t sample_id, const float * data, uint32_t data_length) {
+    return jls_twr_fsr(self, signal_id, sample_id, data, data_length);
+}
+
+int32_t jls_twr_annotation(struct jls_twr_s * self, uint16_t signal_id, int64_t timestamp,
+                           float y,
+                           enum jls_annotation_type_e annotation_type,
+                           uint8_t group_id,
+                           enum jls_storage_type_e storage_type,
+                           const uint8_t * data, uint32_t data_size) {
+    struct msg_header_s hdr = {
+            .msg_type = MSG_ANNOTATION,
+            .h = {
+                    .annotation = {
+                            .signal_id = signal_id,
+                            .timestamp = timestamp,
+                            .annotation_type = annotation_type,
+                            .storage_type = storage_type,
+                            .group_id = group_id,
+                            .y = y
+                    }
+            },
+            .d = 0
+    };
+    return msg_send(self, &hdr, data, data_size);
+}
+
+JLS_API int32_t jls_twr_utc(struct jls_twr_s * self, uint16_t signal_id, int64_t sample_id, int64_t utc) {
+    struct msg_header_s hdr = {
+            .msg_type = MSG_UTC,
+            .h = {
+                    .utc = {
+                            .signal_id = signal_id,
+                            .sample_id = sample_id,
+                            .utc = utc
+                    }
+            },
+            .d = 0
+    };
+    return msg_send(self, &hdr, NULL, 0);
+}
```

### Comparing `pyjls-0.7.0/src/wr_ts.c` & `pyjls-0.7.1/src/wr_ts.c`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,267 +1,267 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/wr_ts.h"
-#include "jls/cdef.h"
-#include "jls/wr_prv.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include <inttypes.h>
-#include <limits.h>
-#include <math.h>
-#include <stdlib.h>
-#include <string.h>
-#include <float.h>
-
-
-enum commit_mode_e {
-    COMMIT_MODE_NORMAL = 0,
-    COMMIT_MODE_CLOSE
-};
-
-struct jls_wr_ts_s {
-    struct jls_wr_s * wr;
-    uint16_t signal_id;
-    enum jls_track_type_e track_type;
-    uint32_t decimate_factor;
-    struct jls_index_s * index[JLS_SUMMARY_LEVEL_COUNT];                // level 0 not used
-    struct jls_payload_header_s * summary[JLS_SUMMARY_LEVEL_COUNT];     // level 0 not used
-};
-
-static void ts_free(struct jls_wr_ts_s * self) {
-    if (self) {
-        for (int i = 0; i < JLS_SUMMARY_LEVEL_COUNT; ++i) {
-            if (self->index[i]) {
-                free(self->index[i]);
-                self->index[i] = 0;
-            }
-            if (self->summary[i]) {
-                free(self->summary[i]);
-                self->summary[i] = 0;
-            }
-        }
-        free(self);
-    }
-}
-
-static int32_t index_alloc(struct jls_wr_ts_s * self, uint8_t level) {
-    if ((level < 1) || (level >= JLS_SUMMARY_LEVEL_COUNT)) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (self->index[level]) {
-        return 0;
-    }
-    size_t sz = sizeof(struct jls_payload_header_s) + sizeof(struct jls_index_entry_s) * self->decimate_factor;
-    struct jls_index_s * index = malloc(sz);
-    if (!index) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    index->header.timestamp = 0;
-    index->header.entry_count = 0;
-    index->header.entry_size_bits = sizeof(struct jls_index_entry_s) * 8;
-    index->header.rsv16 = 0;
-    self->index[level] = index;
-    return 0;
-}
-
-static int32_t summary_alloc(struct jls_wr_ts_s * self, uint8_t level) {
-    if ((level < 1) || (level >= JLS_SUMMARY_LEVEL_COUNT)) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (self->summary[level]) {
-        return 0;
-    }
-    size_t entry_sz = 0;
-    switch (self->track_type) {
-        case JLS_TRACK_TYPE_VSR:
-            entry_sz = sizeof(float) * 5;  // duration, mean, std, min, max
-            break;
-        case JLS_TRACK_TYPE_ANNOTATION:
-            entry_sz = sizeof(struct jls_annotation_summary_entry_s);
-            break;
-        case JLS_TRACK_TYPE_UTC:
-            entry_sz = sizeof(struct jls_utc_summary_entry_s);
-            break;
-        default:
-            JLS_LOGE("unsupported track type %d", (int) self->track_type);
-            break;
-    }
-    size_t sz = sizeof(struct jls_payload_header_s) + self->decimate_factor * entry_sz;
-    sz = ((sz + 7) / 8) * 8;
-    struct jls_payload_header_s * summary = malloc(sz);
-    if (!summary) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    summary->timestamp = 0;
-    summary->entry_count = 0;
-    summary->entry_size_bits = (uint16_t) (8 * entry_sz);
-    summary->rsv16 = 0;
-    self->summary[level] = summary;
-    return 0;
-}
-
-static int32_t alloc(struct jls_wr_ts_s * self, uint8_t level) {
-    ROE(index_alloc(self, level));
-    ROE(summary_alloc(self, level));
-    return 0;
-}
-
-int32_t jls_wr_ts_open(
-        struct jls_wr_ts_s ** instance,
-        struct jls_wr_s * wr,
-        uint16_t signal_id,
-        enum jls_track_type_e track_type,
-        uint32_t decimate_factor) {
-    struct jls_wr_ts_s * self = calloc(1, sizeof(struct jls_wr_ts_s));
-    if (!self) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    self->wr = wr;
-    self->signal_id = signal_id;
-    self->track_type = track_type;
-    self->decimate_factor = decimate_factor;
-    *instance = self;
-    return 0;
-}
-
-static int32_t commit(struct jls_wr_ts_s * self, int level, int mode) {
-    if ((level < 1) || (level > JLS_SUMMARY_LEVEL_COUNT)) {
-        JLS_LOGE("invalid level");
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    struct jls_index_s * index = self->index[level];
-    struct jls_payload_header_s * summary_header = self->summary[level];
-
-    if (!index || !summary_header || !index->header.entry_count) {
-        return 0;
-    } else if (mode == COMMIT_MODE_NORMAL) {
-        ROE(alloc(self, level + 1));
-    }
-
-    // update headers
-    index->header.timestamp = index->entries[0].timestamp;
-    summary_header->timestamp = index->entries[0].timestamp;
-
-    // write index
-    uint8_t * p_end = (uint8_t *) &index->entries[index->header.entry_count];
-    uint8_t * p_start = (uint8_t *) index;
-    uint32_t len = (uint32_t) (p_end - p_start);
-    uint64_t offset = jls_wr_tell_prv(self->wr);
-    ROE(jls_wr_index_prv(self->wr, self->signal_id, self->track_type, level, p_start, len));
-
-    // add to upper level and compute summary write
-    struct jls_index_s * index_up = self->index[level + 1];
-    struct jls_payload_header_s * summary_header_up = self->summary[level + 1];
-    if (index_up) {
-        struct jls_index_entry_s * index_up_entry = &index_up->entries[index_up->header.entry_count++];
-        index_up_entry->timestamp = index->entries[0].timestamp;
-        index_up_entry->offset = offset;
-    }
-    if (self->track_type == JLS_TRACK_TYPE_ANNOTATION) {
-        struct jls_annotation_summary_s * summary = (struct jls_annotation_summary_s *) summary_header;
-        p_end = (uint8_t *) &summary->entries[summary->header.entry_count];
-        p_start = (uint8_t *) summary;
-        if (mode != COMMIT_MODE_CLOSE) {
-            struct jls_annotation_summary_s *summary_up = (struct jls_annotation_summary_s *) summary_header_up;
-            summary_up->entries[summary_up->header.entry_count++] = summary->entries[0];
-        }
-    } else if (self->track_type == JLS_TRACK_TYPE_UTC) {
-        struct jls_utc_summary_s * summary = (struct jls_utc_summary_s *) summary_header;
-        p_end = (uint8_t *) &summary->entries[summary->header.entry_count];
-        p_start = (uint8_t *) summary;
-        if (mode != COMMIT_MODE_CLOSE) {
-            struct jls_utc_summary_s *summary_up = (struct jls_utc_summary_s *) summary_header_up;
-            summary_up->entries[summary_up->header.entry_count++] = summary->entries[0];
-        }
-    }
-
-    // write summary.
-    len = (uint32_t) (p_end - p_start);
-    ROE(jls_wr_summary_prv(self->wr, self->signal_id, self->track_type, level, p_start, len));
-
-    // When up is full, commit it
-    if (index_up && (index_up->header.entry_count >= self->decimate_factor)) {
-        ROE(commit(self, level + 1, mode));
-    }
-
-    // Reset our entry count since all have been written.
-    index->header.entry_count = 0;
-    summary_header->entry_count = 0;
-    return 0;
-}
-
-int32_t jls_wr_ts_close(struct jls_wr_ts_s * self) {
-    if (self) {
-        for (uint8_t level = 1; level < JLS_SUMMARY_LEVEL_COUNT; ++level) {
-            commit(self, level, COMMIT_MODE_CLOSE);
-        }
-        ts_free(self);
-    }
-    return 0;
-}
-
-int32_t jls_wr_ts_anno(struct jls_wr_ts_s * self, int64_t timestamp, int64_t offset,
-                       enum jls_annotation_type_e annotation_type, uint8_t group_id, float y) {
-    if (self->track_type != JLS_TRACK_TYPE_ANNOTATION) {
-        JLS_LOGE("track_type mismatch");
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    ROE(alloc(self, 1));
-    struct jls_index_s * index = self->index[1];
-    struct jls_annotation_summary_s * summary = (struct jls_annotation_summary_s *) self->summary[1];
-
-    struct jls_index_entry_s * index_entry = &index->entries[index->header.entry_count++];
-    index_entry->timestamp = timestamp;
-    index_entry->offset = offset;
-
-    struct jls_annotation_summary_entry_s * summary_entry = &summary->entries[summary->header.entry_count++];
-    summary_entry->timestamp = timestamp;
-    summary_entry->annotation_type = annotation_type;
-    summary_entry->group_id = group_id;
-    summary_entry->rsv8_1 = 0;
-    summary_entry->rsv8_2 = 0;
-    summary_entry->y = y;
-
-    if (index->header.entry_count >= self->decimate_factor) {
-        ROE(commit(self, 1, COMMIT_MODE_NORMAL));
-    }
-
-    return 0;
-}
-
-int32_t jls_wr_ts_utc(struct jls_wr_ts_s * self, int64_t sample_id, int64_t offset, int64_t utc) {
-    if (self->track_type != JLS_TRACK_TYPE_UTC) {
-        JLS_LOGE("track_type mismatch");
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    ROE(alloc(self, 1));
-    struct jls_index_s * index = self->index[1];
-    struct jls_utc_summary_s * summary = (struct jls_utc_summary_s *) self->summary[1];
-
-    struct jls_index_entry_s * index_entry = &index->entries[index->header.entry_count++];
-    index_entry->timestamp = sample_id;
-    index_entry->offset = offset;
-
-    struct jls_utc_summary_entry_s * summary_entry = &summary->entries[summary->header.entry_count++];
-    summary_entry->sample_id = sample_id;
-    summary_entry->timestamp = utc;
-
-    if (index->header.entry_count >= self->decimate_factor) {
-        ROE(commit(self, 1, COMMIT_MODE_NORMAL));
-    }
-
-    return 0;
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/wr_ts.h"
+#include "jls/cdef.h"
+#include "jls/wr_prv.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include <inttypes.h>
+#include <limits.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include <float.h>
+
+
+enum commit_mode_e {
+    COMMIT_MODE_NORMAL = 0,
+    COMMIT_MODE_CLOSE
+};
+
+struct jls_wr_ts_s {
+    struct jls_wr_s * wr;
+    uint16_t signal_id;
+    enum jls_track_type_e track_type;
+    uint32_t decimate_factor;
+    struct jls_index_s * index[JLS_SUMMARY_LEVEL_COUNT];                // level 0 not used
+    struct jls_payload_header_s * summary[JLS_SUMMARY_LEVEL_COUNT];     // level 0 not used
+};
+
+static void ts_free(struct jls_wr_ts_s * self) {
+    if (self) {
+        for (int i = 0; i < JLS_SUMMARY_LEVEL_COUNT; ++i) {
+            if (self->index[i]) {
+                free(self->index[i]);
+                self->index[i] = 0;
+            }
+            if (self->summary[i]) {
+                free(self->summary[i]);
+                self->summary[i] = 0;
+            }
+        }
+        free(self);
+    }
+}
+
+static int32_t index_alloc(struct jls_wr_ts_s * self, uint8_t level) {
+    if ((level < 1) || (level >= JLS_SUMMARY_LEVEL_COUNT)) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (self->index[level]) {
+        return 0;
+    }
+    size_t sz = sizeof(struct jls_payload_header_s) + sizeof(struct jls_index_entry_s) * self->decimate_factor;
+    struct jls_index_s * index = malloc(sz);
+    if (!index) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    index->header.timestamp = 0;
+    index->header.entry_count = 0;
+    index->header.entry_size_bits = sizeof(struct jls_index_entry_s) * 8;
+    index->header.rsv16 = 0;
+    self->index[level] = index;
+    return 0;
+}
+
+static int32_t summary_alloc(struct jls_wr_ts_s * self, uint8_t level) {
+    if ((level < 1) || (level >= JLS_SUMMARY_LEVEL_COUNT)) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (self->summary[level]) {
+        return 0;
+    }
+    size_t entry_sz = 0;
+    switch (self->track_type) {
+        case JLS_TRACK_TYPE_VSR:
+            entry_sz = sizeof(float) * 5;  // duration, mean, std, min, max
+            break;
+        case JLS_TRACK_TYPE_ANNOTATION:
+            entry_sz = sizeof(struct jls_annotation_summary_entry_s);
+            break;
+        case JLS_TRACK_TYPE_UTC:
+            entry_sz = sizeof(struct jls_utc_summary_entry_s);
+            break;
+        default:
+            JLS_LOGE("unsupported track type %d", (int) self->track_type);
+            break;
+    }
+    size_t sz = sizeof(struct jls_payload_header_s) + self->decimate_factor * entry_sz;
+    sz = ((sz + 7) / 8) * 8;
+    struct jls_payload_header_s * summary = malloc(sz);
+    if (!summary) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    summary->timestamp = 0;
+    summary->entry_count = 0;
+    summary->entry_size_bits = (uint16_t) (8 * entry_sz);
+    summary->rsv16 = 0;
+    self->summary[level] = summary;
+    return 0;
+}
+
+static int32_t alloc(struct jls_wr_ts_s * self, uint8_t level) {
+    ROE(index_alloc(self, level));
+    ROE(summary_alloc(self, level));
+    return 0;
+}
+
+int32_t jls_wr_ts_open(
+        struct jls_wr_ts_s ** instance,
+        struct jls_wr_s * wr,
+        uint16_t signal_id,
+        enum jls_track_type_e track_type,
+        uint32_t decimate_factor) {
+    struct jls_wr_ts_s * self = calloc(1, sizeof(struct jls_wr_ts_s));
+    if (!self) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    self->wr = wr;
+    self->signal_id = signal_id;
+    self->track_type = track_type;
+    self->decimate_factor = decimate_factor;
+    *instance = self;
+    return 0;
+}
+
+static int32_t commit(struct jls_wr_ts_s * self, int level, int mode) {
+    if ((level < 1) || (level > JLS_SUMMARY_LEVEL_COUNT)) {
+        JLS_LOGE("invalid level");
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    struct jls_index_s * index = self->index[level];
+    struct jls_payload_header_s * summary_header = self->summary[level];
+
+    if (!index || !summary_header || !index->header.entry_count) {
+        return 0;
+    } else if (mode == COMMIT_MODE_NORMAL) {
+        ROE(alloc(self, level + 1));
+    }
+
+    // update headers
+    index->header.timestamp = index->entries[0].timestamp;
+    summary_header->timestamp = index->entries[0].timestamp;
+
+    // write index
+    uint8_t * p_end = (uint8_t *) &index->entries[index->header.entry_count];
+    uint8_t * p_start = (uint8_t *) index;
+    uint32_t len = (uint32_t) (p_end - p_start);
+    uint64_t offset = jls_wr_tell_prv(self->wr);
+    ROE(jls_wr_index_prv(self->wr, self->signal_id, self->track_type, level, p_start, len));
+
+    // add to upper level and compute summary write
+    struct jls_index_s * index_up = self->index[level + 1];
+    struct jls_payload_header_s * summary_header_up = self->summary[level + 1];
+    if (index_up) {
+        struct jls_index_entry_s * index_up_entry = &index_up->entries[index_up->header.entry_count++];
+        index_up_entry->timestamp = index->entries[0].timestamp;
+        index_up_entry->offset = offset;
+    }
+    if (self->track_type == JLS_TRACK_TYPE_ANNOTATION) {
+        struct jls_annotation_summary_s * summary = (struct jls_annotation_summary_s *) summary_header;
+        p_end = (uint8_t *) &summary->entries[summary->header.entry_count];
+        p_start = (uint8_t *) summary;
+        if (mode != COMMIT_MODE_CLOSE) {
+            struct jls_annotation_summary_s *summary_up = (struct jls_annotation_summary_s *) summary_header_up;
+            summary_up->entries[summary_up->header.entry_count++] = summary->entries[0];
+        }
+    } else if (self->track_type == JLS_TRACK_TYPE_UTC) {
+        struct jls_utc_summary_s * summary = (struct jls_utc_summary_s *) summary_header;
+        p_end = (uint8_t *) &summary->entries[summary->header.entry_count];
+        p_start = (uint8_t *) summary;
+        if (mode != COMMIT_MODE_CLOSE) {
+            struct jls_utc_summary_s *summary_up = (struct jls_utc_summary_s *) summary_header_up;
+            summary_up->entries[summary_up->header.entry_count++] = summary->entries[0];
+        }
+    }
+
+    // write summary.
+    len = (uint32_t) (p_end - p_start);
+    ROE(jls_wr_summary_prv(self->wr, self->signal_id, self->track_type, level, p_start, len));
+
+    // When up is full, commit it
+    if (index_up && (index_up->header.entry_count >= self->decimate_factor)) {
+        ROE(commit(self, level + 1, mode));
+    }
+
+    // Reset our entry count since all have been written.
+    index->header.entry_count = 0;
+    summary_header->entry_count = 0;
+    return 0;
+}
+
+int32_t jls_wr_ts_close(struct jls_wr_ts_s * self) {
+    if (self) {
+        for (uint8_t level = 1; level < JLS_SUMMARY_LEVEL_COUNT; ++level) {
+            commit(self, level, COMMIT_MODE_CLOSE);
+        }
+        ts_free(self);
+    }
+    return 0;
+}
+
+int32_t jls_wr_ts_anno(struct jls_wr_ts_s * self, int64_t timestamp, int64_t offset,
+                       enum jls_annotation_type_e annotation_type, uint8_t group_id, float y) {
+    if (self->track_type != JLS_TRACK_TYPE_ANNOTATION) {
+        JLS_LOGE("track_type mismatch");
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    ROE(alloc(self, 1));
+    struct jls_index_s * index = self->index[1];
+    struct jls_annotation_summary_s * summary = (struct jls_annotation_summary_s *) self->summary[1];
+
+    struct jls_index_entry_s * index_entry = &index->entries[index->header.entry_count++];
+    index_entry->timestamp = timestamp;
+    index_entry->offset = offset;
+
+    struct jls_annotation_summary_entry_s * summary_entry = &summary->entries[summary->header.entry_count++];
+    summary_entry->timestamp = timestamp;
+    summary_entry->annotation_type = annotation_type;
+    summary_entry->group_id = group_id;
+    summary_entry->rsv8_1 = 0;
+    summary_entry->rsv8_2 = 0;
+    summary_entry->y = y;
+
+    if (index->header.entry_count >= self->decimate_factor) {
+        ROE(commit(self, 1, COMMIT_MODE_NORMAL));
+    }
+
+    return 0;
+}
+
+int32_t jls_wr_ts_utc(struct jls_wr_ts_s * self, int64_t sample_id, int64_t offset, int64_t utc) {
+    if (self->track_type != JLS_TRACK_TYPE_UTC) {
+        JLS_LOGE("track_type mismatch");
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    ROE(alloc(self, 1));
+    struct jls_index_s * index = self->index[1];
+    struct jls_utc_summary_s * summary = (struct jls_utc_summary_s *) self->summary[1];
+
+    struct jls_index_entry_s * index_entry = &index->entries[index->header.entry_count++];
+    index_entry->timestamp = sample_id;
+    index_entry->offset = offset;
+
+    struct jls_utc_summary_entry_s * summary_entry = &summary->entries[summary->header.entry_count++];
+    summary_entry->sample_id = sample_id;
+    summary_entry->timestamp = utc;
+
+    if (index->header.entry_count >= self->decimate_factor) {
+        ROE(commit(self, 1, COMMIT_MODE_NORMAL));
+    }
+
+    return 0;
+}
```

### Comparing `pyjls-0.7.0/src/writer.c` & `pyjls-0.7.1/src/writer.c`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,806 +1,806 @@
-/*
- * Copyright 2021-2022 Jetperch LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "jls/writer.h"
-#include "jls/raw.h"
-#include "jls/format.h"
-#include "jls/wr_prv.h"
-#include "jls/wr_fsr.h"
-#include "jls/wr_ts.h"
-#include "jls/cdef.h"
-#include "jls/ec.h"
-#include "jls/log.h"
-#include "jls/crc32c.h"
-#include "jls/util.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-
-
-#define BUFFER_SIZE (1 << 20)
-
-
-struct chunk_s {
-    struct jls_chunk_header_s hdr;
-    int64_t offset;
-};
-
-struct track_info_s {
-    uint16_t signal_id;
-    uint8_t track_type;  // enum jls_track_type_e
-
-    struct chunk_s def;
-    struct chunk_s head;
-    int64_t head_offsets[JLS_SUMMARY_LEVEL_COUNT];  // offset of first chunk at each summary level
-
-    // holder for most recent to construct doubly linked list
-    struct chunk_s index[JLS_SUMMARY_LEVEL_COUNT];
-    struct chunk_s data;
-    struct chunk_s summary[JLS_SUMMARY_LEVEL_COUNT];
-
-    struct jls_wr_ts_s * ts;  // for ANNOTATION & UTC tracks only
-};
-
-struct signal_info_s {
-    struct chunk_s chunk_def;
-    struct jls_signal_def_s signal_def;
-    char name[1024];
-    char units[128];
-    struct track_info_s tracks[JLS_TRACK_TYPE_COUNT];   // array index is jls_track_type_e
-    struct jls_wr_fsr_s * signal_writer;
-};
-
-struct buf_s {
-    uint8_t * cur;
-    uint8_t * start;
-    uint8_t * end;
-};
-
-struct jls_wr_s {
-    struct jls_raw_s * raw;
-    uint8_t buffer[BUFFER_SIZE];
-    struct buf_s buf;
-
-    struct chunk_s source_info[JLS_SOURCE_COUNT];
-    struct chunk_s source_mra;  // most recently added
-
-    struct signal_info_s signal_info[JLS_SIGNAL_COUNT];
-    struct chunk_s signal_mra;
-    struct chunk_s user_data_mra;
-    uint32_t payload_prev_length;
-};
-
-struct jls_source_def_s SOURCE_0 = {
-        .source_id = 0,
-        .name = "global_annotation_source",
-        .vendor = "jls",
-        .model = "-",
-        .version = "1.0.0",
-        .serial_number = "-"
-};
-
-struct jls_signal_def_s SIGNAL_0 = {       // 0 reserved for VSR annotations
-        .signal_id = 0,
-        .source_id = 0,
-        .signal_type = JLS_SIGNAL_TYPE_VSR,
-        .data_type = JLS_DATATYPE_F32,
-        .sample_rate = 0,
-        .samples_per_data = 10,
-        .sample_decimate_factor = 10,
-        .entries_per_summary = 10,
-        .summary_decimate_factor = 10,
-        .annotation_decimate_factor = 100,
-        .utc_decimate_factor = 100,
-        .name = "global_annotation_signal",
-        .units = "",
-};
-
-int32_t jls_wr_open(struct jls_wr_s ** instance, const char * path) {
-    if (!instance) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    struct jls_wr_s * self = calloc(1, sizeof(struct jls_wr_s));
-    if (!self) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-
-    for (uint16_t signal_id = 0; signal_id < JLS_SIGNAL_COUNT; ++signal_id) {
-        for (uint8_t track_type = 0; track_type < 4; ++track_type) {
-            struct track_info_s * t = &self->signal_info[signal_id].tracks[track_type];
-            t->signal_id = signal_id;
-            t->track_type = track_type;
-        }
-    }
-
-    int32_t rc = jls_raw_open(&self->raw, path, "w");
-    if (rc) {
-        free(self);
-        return rc;
-    }
-
-    ROE(jls_wr_user_data(self, 0, JLS_STORAGE_TYPE_INVALID, NULL, 0));
-    ROE(jls_wr_source_def(self, &SOURCE_0));
-    ROE(jls_wr_signal_def(self, &SIGNAL_0));
-
-    *instance = self;
-    return 0;
-}
-
-static int32_t wr_end(struct jls_wr_s * self) {
-    // construct header
-    struct chunk_s chunk;
-    chunk.hdr.item_next = 0;
-    chunk.hdr.item_prev = 0;
-    chunk.hdr.tag = JLS_TAG_END;
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = 0;
-    chunk.hdr.payload_length = 0;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, NULL));
-    self->payload_prev_length = 0;
-    return 0;
-}
-
-int32_t jls_wr_close(struct jls_wr_s * self) {
-    if (self) {
-        for (size_t i = 0; i < JLS_SIGNAL_COUNT; ++i) {
-            struct signal_info_s * signal_info = &self->signal_info[i];
-            if (signal_info->signal_writer) {
-                jls_wr_fsr_close(signal_info->signal_writer);
-            }
-            for (size_t track_id = 0; track_id < JLS_TRACK_TYPE_COUNT; track_id++) {
-                struct jls_wr_ts_s * ts = signal_info->tracks[track_id].ts;
-                if (ts) {
-                    jls_wr_ts_close(ts);
-                    signal_info->tracks[track_id].ts = NULL;
-                }
-            }
-        }
-        wr_end(self);
-        int32_t rc = jls_raw_close(self->raw);
-        free(self);
-        return rc;
-    }
-    return 0;
-}
-
-JLS_API int32_t jls_wr_flush(struct jls_wr_s * self) {
-    return jls_raw_flush(self->raw);
-}
-
-static void buf_reset(struct jls_wr_s * self) {
-    self->buf.start = self->buffer;
-    self->buf.cur = self->buffer;
-    self->buf.end = self->buffer + BUFFER_SIZE;
-}
-
-static int32_t buf_add_zero(struct jls_wr_s * self, uint32_t count) {
-    struct buf_s * buf = &self->buf;
-    if ((buf->cur + count) > buf->end) {
-        JLS_LOGE("buffer to small");
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    for (uint32_t i = 0; i < count; ++i) {
-        *buf->cur++ = 0;
-    }
-    return 0;
-}
-
-static int32_t buf_add_str(struct jls_wr_s * self, const char * cstr) {
-    // Strings end with {0, 0x1f} = {null, unit separator}
-    struct buf_s * buf = &self->buf;
-    uint8_t * end = buf->end - 2;
-    while (buf->cur < end) {
-        if (cstr && *cstr) {
-            *buf->cur++ = *cstr++;
-        } else {
-            *buf->cur++ = 0;
-            *buf->cur++ = 0x1f;
-            return 0;
-        }
-    }
-    JLS_LOGE("buffer to small");
-    return JLS_ERROR_NOT_ENOUGH_MEMORY;
-}
-
-static int32_t buf_add_bin(struct jls_wr_s * self, const uint8_t * data, uint32_t data_size) {
-    struct buf_s * buf = &self->buf;
-    if ((buf->cur + data_size) > buf->end) {
-        JLS_LOGE("buffer to small");
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    memcpy(buf->cur, data, data_size);
-    buf->cur += data_size;
-    return 0;
-}
-
-static uint32_t buf_size(struct jls_wr_s * self) {
-    return (uint32_t) (self->buf.cur - self->buf.start);
-}
-
-static int32_t buf_wr_u8(struct jls_wr_s * self, uint8_t value) {
-    struct buf_s * buf = &self->buf;
-    if ((buf->cur + 1) > buf->end) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    *buf->cur++ = value;
-    return 0;
-}
-
-static int32_t buf_wr_u16(struct jls_wr_s * self, uint16_t value) {
-    struct buf_s * buf = &self->buf;
-    if ((buf->cur + 2) > buf->end) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    *buf->cur++ = (uint8_t) (value & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 8) & 0xff);
-    return 0;
-}
-
-static int32_t buf_wr_u32(struct jls_wr_s * self, uint32_t value) {
-    struct buf_s * buf = &self->buf;
-    if ((buf->cur + 4) > buf->end) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    *buf->cur++ = (uint8_t) (value & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 8) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 16) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 24) & 0xff);
-    return 0;
-}
-
-static int32_t buf_wr_f32(struct jls_wr_s * self, float value) {
-    struct buf_s * buf = &self->buf;
-    uint8_t * p = (uint8_t *) &value;
-    if ((buf->cur + 4) > buf->end) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    *buf->cur++ = *p++;
-    *buf->cur++ = *p++;
-    *buf->cur++ = *p++;
-    *buf->cur++ = *p++;
-    return 0;
-}
-
-static int32_t buf_wr_i64(struct jls_wr_s * self, int64_t value) {
-    struct buf_s * buf = &self->buf;
-    if ((buf->cur + 8) > buf->end) {
-        return JLS_ERROR_NOT_ENOUGH_MEMORY;
-    }
-    *buf->cur++ = (uint8_t) (value & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 8) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 16) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 24) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 32) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 40) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 48) & 0xff);
-    *buf->cur++ = (uint8_t) ((value >> 56) & 0xff);
-    return 0;
-}
-
-static int32_t update_mra(struct jls_wr_s * self, struct chunk_s * mra, struct chunk_s * update) {
-    if (mra->offset) {
-        int64_t current_pos = jls_raw_chunk_tell(self->raw);
-        mra->hdr.item_next = update->offset;
-        ROE(jls_raw_chunk_seek(self->raw, mra->offset));
-        ROE(jls_raw_wr_header(self->raw, &mra->hdr));
-        ROE(jls_raw_chunk_seek(self->raw, current_pos));
-    }
-    *mra = *update;
-    return 0;
-}
-
-int32_t jls_wr_source_def(struct jls_wr_s * self, const struct jls_source_def_s * source) {
-    if (!self || !source) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (source->source_id >= JLS_SOURCE_COUNT) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (self->source_info[source->source_id].offset) {
-        JLS_LOGE("Duplicate source: %d", (int) source->source_id);
-        return JLS_ERROR_ALREADY_EXISTS;
-    }
-
-    // construct payload
-    buf_reset(self);
-    buf_add_zero(self, 64);  // reserve space for future use.
-    ROE(buf_add_str(self, source->name));
-    ROE(buf_add_str(self, source->vendor));
-    ROE(buf_add_str(self, source->model));
-    ROE(buf_add_str(self, source->version));
-    ROE(buf_add_str(self, source->serial_number));
-    uint32_t payload_length = buf_size(self);
-
-    // construct header
-    struct chunk_s * chunk = &self->source_info[source->source_id];
-    chunk->hdr.item_next = 0;  // update later
-    chunk->hdr.item_prev = self->source_mra.offset;
-    chunk->hdr.tag = JLS_TAG_SOURCE_DEF;
-    chunk->hdr.rsv0_u8 = 0;
-    chunk->hdr.chunk_meta = source->source_id;
-    chunk->hdr.payload_length = payload_length;
-    chunk->hdr.payload_prev_length = self->payload_prev_length;
-    chunk->offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk->hdr, self->buffer));
-    self->payload_prev_length = payload_length;
-    return update_mra(self, &self->source_mra, chunk);
-}
-
-static int32_t track_wr_def(struct jls_wr_s * self, struct track_info_s * track_info) {
-    // construct header
-    struct chunk_s * chunk = &track_info->def;
-    if (chunk->offset) {
-        return 0;  // no need to update
-    }
-    chunk->hdr.item_next = 0;  // update later
-    chunk->hdr.item_prev = self->signal_mra.offset;
-    chunk->hdr.tag = jls_track_tag_pack(track_info->track_type, JLS_TRACK_CHUNK_DEF);
-    chunk->hdr.rsv0_u8 = 0;
-    chunk->hdr.chunk_meta = track_info->signal_id;
-    chunk->hdr.payload_length = 0;
-    chunk->hdr.payload_prev_length = self->payload_prev_length;
-    chunk->offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk->hdr, NULL));
-    self->payload_prev_length = 0;
-    return update_mra(self, &self->signal_mra, chunk);
-}
-
-static int32_t track_wr_head(struct jls_wr_s * self, struct track_info_s * track_info) {
-    // construct header
-    struct chunk_s * chunk = &track_info->head;
-    if (!chunk->offset) {
-        chunk->hdr.item_next = 0;  // update later
-        chunk->hdr.item_prev = self->signal_mra.offset;
-        chunk->hdr.tag = jls_track_tag_pack(track_info->track_type, JLS_TRACK_CHUNK_HEAD);
-        chunk->hdr.rsv0_u8 = 0;
-        chunk->hdr.chunk_meta = track_info->signal_id;
-        chunk->hdr.payload_length = sizeof(track_info->head_offsets);
-        chunk->hdr.payload_prev_length = self->payload_prev_length;
-        chunk->offset = jls_raw_chunk_tell(self->raw);
-        JLS_LOGD1("track_wr_head %d 0x%02x new %" PRIi64, (int) chunk->hdr.chunk_meta, chunk->hdr.tag, chunk->offset);
-        ROE(jls_raw_wr(self->raw, &chunk->hdr, (uint8_t *) track_info->head_offsets));
-        self->payload_prev_length = sizeof(track_info->head_offsets);
-        track_info->head = *chunk;
-        return update_mra(self, &self->signal_mra, chunk);
-    } else {
-        JLS_LOGD1("track_wr_head %d 0x%02x update %" PRIi64, (int) chunk->hdr.chunk_meta, chunk->hdr.tag, chunk->offset);
-        int64_t pos = jls_raw_chunk_tell(self->raw);
-        ROE(jls_raw_chunk_seek(self->raw, chunk->offset));
-        ROE(jls_raw_wr_payload(self->raw, sizeof(track_info->head_offsets), (uint8_t *) track_info->head_offsets));
-        ROE(jls_raw_chunk_seek(self->raw, pos));
-    }
-    return 0;
-}
-
-int32_t jls_wr_signal_def(struct jls_wr_s * self, const struct jls_signal_def_s * signal) {
-    if (!self || !signal) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    uint16_t signal_id = signal->signal_id;
-    if (signal_id >= JLS_SIGNAL_COUNT) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (signal->source_id >= JLS_SOURCE_COUNT) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (!self->source_info[signal->source_id].offset) {
-        JLS_LOGW("source %d not found", signal->source_id);
-        return JLS_ERROR_NOT_FOUND;
-    }
-
-    struct signal_info_s * info = &self->signal_info[signal_id];
-    if (info->chunk_def.offset) {
-        JLS_LOGE("Duplicate signal: %d", (int) signal_id);
-        return JLS_ERROR_ALREADY_EXISTS;
-    }
-    if ((signal->signal_type != JLS_SIGNAL_TYPE_FSR) && (signal->signal_type != JLS_SIGNAL_TYPE_VSR)) {
-        JLS_LOGE("Invalid signal type: %d", (int) signal->signal_type);
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    // copy signal def
-    info->signal_def = *signal;
-    snprintf(info->name, sizeof(info->name), "%s", signal->name);
-    snprintf(info->units, sizeof(info->units), "%s", signal->units);
-    info->signal_def.name = info->name;
-
-    struct jls_signal_def_s * def = &info->signal_def;
-    ROE(jls_wr_fsr_validate(def));
-
-    switch (def->signal_type) {
-        case JLS_SIGNAL_TYPE_FSR:
-            if (!def->sample_rate) {
-                JLS_LOGE("FSR requires sample rate");
-                return JLS_ERROR_PARAMETER_INVALID;
-            }
-            break;
-        case JLS_SIGNAL_TYPE_VSR:
-            if (def->sample_rate) {
-                JLS_LOGE("VSR but sample rate specified, ignoring");
-                def->sample_rate = 0;
-            }
-            break;
-        default:
-            JLS_LOGE("Invalid signal type: %d", (int) def->signal_type);
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    // construct payload
-    buf_reset(self);
-    ROE(buf_wr_u16(self, def->source_id));
-    ROE(buf_wr_u8(self, def->signal_type));
-    ROE(buf_wr_u8(self, 0));  // reserved
-    ROE(buf_wr_u32(self, def->data_type));
-    ROE(buf_wr_u32(self, def->sample_rate));
-    ROE(buf_wr_u32(self, def->samples_per_data));
-    ROE(buf_wr_u32(self, def->sample_decimate_factor));
-    ROE(buf_wr_u32(self, def->entries_per_summary));
-    ROE(buf_wr_u32(self, def->summary_decimate_factor));
-    ROE(buf_wr_u32(self, def->annotation_decimate_factor));
-    ROE(buf_wr_u32(self, def->utc_decimate_factor));
-    ROE(buf_add_zero(self, 92));  // reserve space for future use.
-    ROE(buf_add_str(self, def->name));
-    ROE(buf_add_str(self, def->units));
-    uint32_t payload_length = buf_size(self);
-
-    // construct header
-    struct chunk_s * chunk = &info->chunk_def;
-    chunk->hdr.item_next = 0;  // update later
-    chunk->hdr.item_prev = self->signal_mra.offset;
-    chunk->hdr.tag = JLS_TAG_SIGNAL_DEF;
-    chunk->hdr.rsv0_u8 = 0;
-    chunk->hdr.chunk_meta = signal_id;
-    chunk->hdr.payload_length = payload_length;
-    chunk->hdr.payload_prev_length = self->payload_prev_length;
-    chunk->offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk->hdr, self->buffer));
-    self->payload_prev_length = payload_length;
-    ROE(update_mra(self, &self->signal_mra, chunk));
-
-    if (def->signal_type == JLS_SIGNAL_TYPE_FSR) {
-        info->tracks[JLS_TRACK_TYPE_FSR].track_type = JLS_TRACK_TYPE_FSR;
-        info->tracks[JLS_TRACK_TYPE_ANNOTATION].track_type = JLS_TRACK_TYPE_ANNOTATION;
-        info->tracks[JLS_TRACK_TYPE_UTC].track_type = JLS_TRACK_TYPE_UTC;
-        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_FSR]));
-        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_FSR]));
-        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
-        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
-        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_UTC]));
-        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_UTC]));
-    } else if (def->signal_type == JLS_SIGNAL_TYPE_VSR) {
-        info->tracks[JLS_TRACK_TYPE_VSR].track_type = JLS_TRACK_TYPE_VSR;
-        info->tracks[JLS_TRACK_TYPE_ANNOTATION].track_type = JLS_TRACK_TYPE_ANNOTATION;
-        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_VSR]));
-        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_VSR]));
-        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
-        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
-    }
-
-    ROE(jls_wr_fsr_open(&info->signal_writer, self, def));
-    return 0;
-}
-
-int32_t jls_wr_user_data(struct jls_wr_s * self, uint16_t chunk_meta,
-                         enum jls_storage_type_e storage_type, const uint8_t * data, uint32_t data_size) {
-    if (!self) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (data_size && !data) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if (chunk_meta & 0xf000) {
-        JLS_LOGW("chunk_meta[15:12] nonzero.  Will be modified.");
-        chunk_meta &= 0x0fff;
-    }
-
-    switch (storage_type) {
-        case JLS_STORAGE_TYPE_INVALID:
-            data_size = 0; // allowed, but should only be used for the initial chunk.
-            break;
-        case JLS_STORAGE_TYPE_BINARY:
-            break;
-        case JLS_STORAGE_TYPE_STRING:  // intentional fall-through
-        case JLS_STORAGE_TYPE_JSON:
-            data_size = (uint32_t) strlen((const char *) data) + 1;
-            break;
-        default:
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-    chunk_meta |= ((uint16_t) storage_type) << 12;
-
-    // construct header
-    struct chunk_s chunk;
-    chunk.hdr.item_next = 0;  // update later
-    chunk.hdr.item_prev = self->user_data_mra.offset;
-    chunk.hdr.tag = JLS_TAG_USER_DATA;
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = chunk_meta;
-    chunk.hdr.payload_length = data_size;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, data));
-    self->payload_prev_length = data_size;
-    return update_mra(self, &self->user_data_mra, &chunk);
-}
-
-static int32_t signal_validate(struct jls_wr_s * self, uint16_t signal_id) {
-    if (signal_id >= JLS_SIGNAL_COUNT) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    struct signal_info_s * signal_info = &self->signal_info[signal_id];
-    if (!signal_info->chunk_def.offset) {
-        JLS_LOGW("attempted to annotated an undefined signal %d", (int) signal_id);
-        return JLS_ERROR_NOT_FOUND;
-    }
-    return 0;
-}
-
-static int32_t signal_validate_typed(struct jls_wr_s * self, uint16_t signal_id, enum jls_signal_type_e signal_type) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * signal_info = &self->signal_info[signal_id];
-    if (signal_info->signal_def.signal_type != signal_type) {
-        return JLS_ERROR_NOT_SUPPORTED;
-    }
-    return 0;
-}
-
-int64_t jls_wr_tell_prv(struct jls_wr_s * self) {
-    return jls_raw_chunk_tell(self->raw);
-}
-
-int32_t jls_wr_data_prv(struct jls_wr_s * self, uint16_t signal_id, enum jls_track_type_e track_type,
-                        const uint8_t * payload, uint32_t payload_length) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * info = &self->signal_info[signal_id];
-    struct track_info_s * track = &info->tracks[track_type];
-    struct chunk_s chunk;
-
-    chunk.hdr.item_next = 0;  // update later
-    chunk.hdr.item_prev = track->data.offset;
-    chunk.hdr.tag = jls_track_tag_pack(track->track_type, JLS_TRACK_CHUNK_DATA);
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = signal_id | (0 << 12);
-    chunk.hdr.payload_length = payload_length;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = jls_raw_chunk_tell(self->raw);
-
-    if (JLS_LOG_CHECK_STATIC(JLS_LOG_LEVEL_DEBUG3)) {
-        struct jls_payload_header_s * hdr = (struct jls_payload_header_s *) payload;
-        JLS_LOGD3("wr_data(signal_id=%d, timestamp=%" PRIi64 ", entries=%" PRIu32 ") => offset=%" PRIi64,
-                  (int) signal_id, hdr->timestamp, hdr->entry_count,
-                  jls_raw_chunk_tell(self->raw));
-    }
-
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, payload));
-    self->payload_prev_length = chunk.hdr.payload_length;
-    ROE(update_mra(self, &track->data, &chunk));
-
-    if (!track->head_offsets[0]) {
-        track->head_offsets[0] = chunk.offset;
-        ROE(track_wr_head(self, track));
-    }
-
-    return 0;
-}
-
-int32_t jls_wr_summary_prv(struct jls_wr_s * self, uint16_t signal_id, enum jls_track_type_e track_type, uint8_t level,
-                           const uint8_t * payload, uint32_t payload_length) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * info = &self->signal_info[signal_id];
-    struct track_info_s * track = &info->tracks[track_type];
-    struct chunk_s chunk;
-
-    chunk.hdr.item_next = 0;  // update later
-    chunk.hdr.item_prev = track->summary[level].offset;
-    chunk.hdr.tag = jls_track_tag_pack(track->track_type, JLS_TRACK_CHUNK_SUMMARY);
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = signal_id | (((uint16_t) level) << 12);
-    chunk.hdr.payload_length = payload_length;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, payload));
-    self->payload_prev_length = chunk.hdr.payload_length;
-    ROE(update_mra(self, &track->summary[level], &chunk));
-    return 0;
-}
-
-static inline int32_t update_track(struct jls_wr_s * self, struct track_info_s * track, uint8_t level, int64_t pos) {
-    if (!track->head_offsets[level]) {
-        track->head_offsets[level] = pos;
-        ROE(track_wr_head(self, track));
-    }
-    return 0;
-}
-
-int32_t jls_wr_index_prv(struct jls_wr_s * self, uint16_t signal_id, enum jls_track_type_e track_type, uint8_t level,
-                         const uint8_t * payload, uint32_t payload_length) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * info = &self->signal_info[signal_id];
-    struct track_info_s * track = &info->tracks[track_type];
-    struct chunk_s chunk;
-
-    chunk.hdr.item_next = 0;  // update later
-    chunk.hdr.item_prev = track->index[level].offset;
-    chunk.hdr.tag = jls_track_tag_pack(track->track_type, JLS_TRACK_CHUNK_INDEX);
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = signal_id | (((uint16_t) level) << 12);;
-    chunk.hdr.payload_length = payload_length;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = jls_raw_chunk_tell(self->raw);
-
-    // write
-    if (JLS_LOG_CHECK_STATIC(JLS_LOG_LEVEL_DEBUG3)) {
-        struct jls_payload_header_s * hdr = (struct jls_payload_header_s *) payload;
-        JLS_LOGD3("wr_index(signal_id=%d, level=%d, timestamp=%" PRIi64 ", entries=%" PRIu32
-                  ") => offset=%" PRIi64,
-                  (int) signal_id, (int) level,
-                  hdr->timestamp, hdr->entry_count,
-                  jls_raw_chunk_tell(self->raw));
-    }
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, payload));
-    self->payload_prev_length = chunk.hdr.payload_length;
-    ROE(update_mra(self, &track->index[level], &chunk));
-    ROE(update_track(self, track, level, chunk.offset));
-
-    return 0;
-}
-
-JLS_API int32_t jls_wr_fsr(struct jls_wr_s * self, uint16_t signal_id,
-                           int64_t sample_id, const void * data, uint32_t data_length) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * info = &self->signal_info[signal_id];
-    return jls_wr_fsr_data(info->signal_writer, sample_id, data, data_length);
-}
-
-int32_t jls_wr_fsr_f32(struct jls_wr_s * self, uint16_t signal_id,
-                       int64_t sample_id, const float * data, uint32_t data_length) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * info = &self->signal_info[signal_id];
-    if (info->signal_def.data_type != JLS_DATATYPE_F32) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    return jls_wr_fsr_data(info->signal_writer, sample_id, data, data_length);
-}
-
-int32_t jls_wr_annotation(struct jls_wr_s * self, uint16_t signal_id, int64_t timestamp,
-                          float y,
-                          enum jls_annotation_type_e annotation_type,
-                          uint8_t group_id,
-                          enum jls_storage_type_e storage_type,
-                          const uint8_t * data, uint32_t data_size) {
-    ROE(signal_validate(self, signal_id));
-    struct signal_info_s * signal_info = &self->signal_info[signal_id];
-    struct track_info_s * track = &signal_info->tracks[JLS_TRACK_TYPE_ANNOTATION];
-    if ((annotation_type & 0xff) != annotation_type) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-    if ((storage_type & 0xff) != storage_type) {
-        return JLS_ERROR_PARAMETER_INVALID;
-    }
-
-    // construct payload
-    buf_reset(self);
-    ROE(buf_wr_i64(self, timestamp));
-    ROE(buf_wr_u32(self, 1));  // number of entries
-    ROE(buf_wr_u16(self, 0));  // unspecified entry length
-    ROE(buf_wr_u16(self, 0));  // reserved
-    ROE(buf_wr_u8(self, annotation_type));
-    ROE(buf_wr_u8(self, storage_type));
-    ROE(buf_wr_u8(self, group_id));
-    ROE(buf_wr_u8(self, 0));    // reserved
-    ROE(buf_wr_f32(self, y));
-    switch (storage_type) {
-        case JLS_STORAGE_TYPE_BINARY:
-            ROE(buf_wr_u32(self, data_size));
-            ROE(buf_add_bin(self, data, data_size));
-            break;
-        case JLS_STORAGE_TYPE_STRING:
-            ROE(buf_wr_u32(self, (uint32_t) (strlen((const char *) data) + 1)));
-            ROE(buf_add_str(self, (const char *) data));
-            break;
-        case JLS_STORAGE_TYPE_JSON:
-            ROE(buf_wr_u32(self, (uint32_t) (strlen((const char *) data) + 1)));
-            ROE(buf_add_str(self, (const char *) data));
-            break;
-        default:
-            return JLS_ERROR_PARAMETER_INVALID;
-    }
-    uint32_t payload_length = buf_size(self);
-
-    // construct header
-    struct chunk_s chunk;
-    uint64_t offset = jls_raw_chunk_tell(self->raw);
-    chunk.hdr.item_next = 0;  // update later
-    chunk.hdr.item_prev = signal_info->tracks[JLS_TRACK_TYPE_ANNOTATION].data.offset;
-    chunk.hdr.tag = JLS_TAG_TRACK_ANNOTATION_DATA;
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = signal_id;
-    chunk.hdr.payload_length = payload_length;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = offset;
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, self->buf.start));
-    self->payload_prev_length = payload_length;
-    ROE(update_mra(self, &signal_info->tracks[JLS_TRACK_TYPE_ANNOTATION].data, &chunk));
-    ROE(update_track(self, track, 0, offset));
-
-    if (!track->ts) {
-        ROE(jls_wr_ts_open(&track->ts, self, signal_id, JLS_TRACK_TYPE_ANNOTATION,
-                           signal_info->signal_def.annotation_decimate_factor));
-    }
-    ROE(jls_wr_ts_anno(track->ts, timestamp, offset, annotation_type, group_id, y));
-    return 0;
-}
-
-int32_t jls_wr_utc(struct jls_wr_s * self, uint16_t signal_id, int64_t sample_id, int64_t utc) {
-    ROE(signal_validate_typed(self, signal_id,  JLS_SIGNAL_TYPE_FSR));
-    struct signal_info_s * signal_info = &self->signal_info[signal_id];
-    struct track_info_s * track = &signal_info->tracks[JLS_TRACK_TYPE_UTC];
-
-    // Construct payload
-    struct jls_utc_data_s payload = {
-        .header = {
-                .timestamp=sample_id,
-                .entry_count=1,
-                .entry_size_bits=sizeof(utc) * 8,
-                .rsv16=0,
-        },
-        .timestamp=utc
-    };
-    uint32_t payload_length = sizeof(payload);
-
-    // construct header
-    struct chunk_s chunk;
-    uint64_t offset = jls_raw_chunk_tell(self->raw);
-    chunk.hdr.item_next = 0;  // update later
-    chunk.hdr.item_prev = signal_info->tracks[JLS_TRACK_TYPE_UTC].data.offset;
-    chunk.hdr.tag = JLS_TAG_TRACK_UTC_DATA;
-    chunk.hdr.rsv0_u8 = 0;
-    chunk.hdr.chunk_meta = signal_id;
-    chunk.hdr.payload_length = payload_length;
-    chunk.hdr.payload_prev_length = self->payload_prev_length;
-    chunk.offset = offset;
-
-    // write
-    ROE(jls_raw_wr(self->raw, &chunk.hdr, (uint8_t *) &payload));
-    self->payload_prev_length = payload_length;
-    ROE(update_mra(self, &signal_info->tracks[JLS_TRACK_TYPE_UTC].data, &chunk));
-    ROE(update_track(self, track, 0, offset));
-
-    if (!track->ts) {
-        ROE(jls_wr_ts_open(&track->ts, self, signal_id, JLS_TRACK_TYPE_UTC,
-                           signal_info->signal_def.utc_decimate_factor));
-    }
-    ROE(jls_wr_ts_utc(track->ts, sample_id, offset, utc));
-    return 0;
-}
+/*
+ * Copyright 2021-2022 Jetperch LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "jls/writer.h"
+#include "jls/raw.h"
+#include "jls/format.h"
+#include "jls/wr_prv.h"
+#include "jls/wr_fsr.h"
+#include "jls/wr_ts.h"
+#include "jls/cdef.h"
+#include "jls/ec.h"
+#include "jls/log.h"
+#include "jls/crc32c.h"
+#include "jls/util.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+
+#define BUFFER_SIZE (1 << 20)
+
+
+struct chunk_s {
+    struct jls_chunk_header_s hdr;
+    int64_t offset;
+};
+
+struct track_info_s {
+    uint16_t signal_id;
+    uint8_t track_type;  // enum jls_track_type_e
+
+    struct chunk_s def;
+    struct chunk_s head;
+    int64_t head_offsets[JLS_SUMMARY_LEVEL_COUNT];  // offset of first chunk at each summary level
+
+    // holder for most recent to construct doubly linked list
+    struct chunk_s index[JLS_SUMMARY_LEVEL_COUNT];
+    struct chunk_s data;
+    struct chunk_s summary[JLS_SUMMARY_LEVEL_COUNT];
+
+    struct jls_wr_ts_s * ts;  // for ANNOTATION & UTC tracks only
+};
+
+struct signal_info_s {
+    struct chunk_s chunk_def;
+    struct jls_signal_def_s signal_def;
+    char name[1024];
+    char units[128];
+    struct track_info_s tracks[JLS_TRACK_TYPE_COUNT];   // array index is jls_track_type_e
+    struct jls_wr_fsr_s * signal_writer;
+};
+
+struct buf_s {
+    uint8_t * cur;
+    uint8_t * start;
+    uint8_t * end;
+};
+
+struct jls_wr_s {
+    struct jls_raw_s * raw;
+    uint8_t buffer[BUFFER_SIZE];
+    struct buf_s buf;
+
+    struct chunk_s source_info[JLS_SOURCE_COUNT];
+    struct chunk_s source_mra;  // most recently added
+
+    struct signal_info_s signal_info[JLS_SIGNAL_COUNT];
+    struct chunk_s signal_mra;
+    struct chunk_s user_data_mra;
+    uint32_t payload_prev_length;
+};
+
+struct jls_source_def_s SOURCE_0 = {
+        .source_id = 0,
+        .name = "global_annotation_source",
+        .vendor = "jls",
+        .model = "-",
+        .version = "1.0.0",
+        .serial_number = "-"
+};
+
+struct jls_signal_def_s SIGNAL_0 = {       // 0 reserved for VSR annotations
+        .signal_id = 0,
+        .source_id = 0,
+        .signal_type = JLS_SIGNAL_TYPE_VSR,
+        .data_type = JLS_DATATYPE_F32,
+        .sample_rate = 0,
+        .samples_per_data = 10,
+        .sample_decimate_factor = 10,
+        .entries_per_summary = 10,
+        .summary_decimate_factor = 10,
+        .annotation_decimate_factor = 100,
+        .utc_decimate_factor = 100,
+        .name = "global_annotation_signal",
+        .units = "",
+};
+
+int32_t jls_wr_open(struct jls_wr_s ** instance, const char * path) {
+    if (!instance) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    struct jls_wr_s * self = calloc(1, sizeof(struct jls_wr_s));
+    if (!self) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+
+    for (uint16_t signal_id = 0; signal_id < JLS_SIGNAL_COUNT; ++signal_id) {
+        for (uint8_t track_type = 0; track_type < 4; ++track_type) {
+            struct track_info_s * t = &self->signal_info[signal_id].tracks[track_type];
+            t->signal_id = signal_id;
+            t->track_type = track_type;
+        }
+    }
+
+    int32_t rc = jls_raw_open(&self->raw, path, "w");
+    if (rc) {
+        free(self);
+        return rc;
+    }
+
+    ROE(jls_wr_user_data(self, 0, JLS_STORAGE_TYPE_INVALID, NULL, 0));
+    ROE(jls_wr_source_def(self, &SOURCE_0));
+    ROE(jls_wr_signal_def(self, &SIGNAL_0));
+
+    *instance = self;
+    return 0;
+}
+
+static int32_t wr_end(struct jls_wr_s * self) {
+    // construct header
+    struct chunk_s chunk;
+    chunk.hdr.item_next = 0;
+    chunk.hdr.item_prev = 0;
+    chunk.hdr.tag = JLS_TAG_END;
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = 0;
+    chunk.hdr.payload_length = 0;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, NULL));
+    self->payload_prev_length = 0;
+    return 0;
+}
+
+int32_t jls_wr_close(struct jls_wr_s * self) {
+    if (self) {
+        for (size_t i = 0; i < JLS_SIGNAL_COUNT; ++i) {
+            struct signal_info_s * signal_info = &self->signal_info[i];
+            if (signal_info->signal_writer) {
+                jls_wr_fsr_close(signal_info->signal_writer);
+            }
+            for (size_t track_id = 0; track_id < JLS_TRACK_TYPE_COUNT; track_id++) {
+                struct jls_wr_ts_s * ts = signal_info->tracks[track_id].ts;
+                if (ts) {
+                    jls_wr_ts_close(ts);
+                    signal_info->tracks[track_id].ts = NULL;
+                }
+            }
+        }
+        wr_end(self);
+        int32_t rc = jls_raw_close(self->raw);
+        free(self);
+        return rc;
+    }
+    return 0;
+}
+
+JLS_API int32_t jls_wr_flush(struct jls_wr_s * self) {
+    return jls_raw_flush(self->raw);
+}
+
+static void buf_reset(struct jls_wr_s * self) {
+    self->buf.start = self->buffer;
+    self->buf.cur = self->buffer;
+    self->buf.end = self->buffer + BUFFER_SIZE;
+}
+
+static int32_t buf_add_zero(struct jls_wr_s * self, uint32_t count) {
+    struct buf_s * buf = &self->buf;
+    if ((buf->cur + count) > buf->end) {
+        JLS_LOGE("buffer to small");
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    for (uint32_t i = 0; i < count; ++i) {
+        *buf->cur++ = 0;
+    }
+    return 0;
+}
+
+static int32_t buf_add_str(struct jls_wr_s * self, const char * cstr) {
+    // Strings end with {0, 0x1f} = {null, unit separator}
+    struct buf_s * buf = &self->buf;
+    uint8_t * end = buf->end - 2;
+    while (buf->cur < end) {
+        if (cstr && *cstr) {
+            *buf->cur++ = *cstr++;
+        } else {
+            *buf->cur++ = 0;
+            *buf->cur++ = 0x1f;
+            return 0;
+        }
+    }
+    JLS_LOGE("buffer to small");
+    return JLS_ERROR_NOT_ENOUGH_MEMORY;
+}
+
+static int32_t buf_add_bin(struct jls_wr_s * self, const uint8_t * data, uint32_t data_size) {
+    struct buf_s * buf = &self->buf;
+    if ((buf->cur + data_size) > buf->end) {
+        JLS_LOGE("buffer to small");
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    memcpy(buf->cur, data, data_size);
+    buf->cur += data_size;
+    return 0;
+}
+
+static uint32_t buf_size(struct jls_wr_s * self) {
+    return (uint32_t) (self->buf.cur - self->buf.start);
+}
+
+static int32_t buf_wr_u8(struct jls_wr_s * self, uint8_t value) {
+    struct buf_s * buf = &self->buf;
+    if ((buf->cur + 1) > buf->end) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    *buf->cur++ = value;
+    return 0;
+}
+
+static int32_t buf_wr_u16(struct jls_wr_s * self, uint16_t value) {
+    struct buf_s * buf = &self->buf;
+    if ((buf->cur + 2) > buf->end) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    *buf->cur++ = (uint8_t) (value & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 8) & 0xff);
+    return 0;
+}
+
+static int32_t buf_wr_u32(struct jls_wr_s * self, uint32_t value) {
+    struct buf_s * buf = &self->buf;
+    if ((buf->cur + 4) > buf->end) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    *buf->cur++ = (uint8_t) (value & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 8) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 16) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 24) & 0xff);
+    return 0;
+}
+
+static int32_t buf_wr_f32(struct jls_wr_s * self, float value) {
+    struct buf_s * buf = &self->buf;
+    uint8_t * p = (uint8_t *) &value;
+    if ((buf->cur + 4) > buf->end) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    *buf->cur++ = *p++;
+    *buf->cur++ = *p++;
+    *buf->cur++ = *p++;
+    *buf->cur++ = *p++;
+    return 0;
+}
+
+static int32_t buf_wr_i64(struct jls_wr_s * self, int64_t value) {
+    struct buf_s * buf = &self->buf;
+    if ((buf->cur + 8) > buf->end) {
+        return JLS_ERROR_NOT_ENOUGH_MEMORY;
+    }
+    *buf->cur++ = (uint8_t) (value & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 8) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 16) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 24) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 32) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 40) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 48) & 0xff);
+    *buf->cur++ = (uint8_t) ((value >> 56) & 0xff);
+    return 0;
+}
+
+static int32_t update_mra(struct jls_wr_s * self, struct chunk_s * mra, struct chunk_s * update) {
+    if (mra->offset) {
+        int64_t current_pos = jls_raw_chunk_tell(self->raw);
+        mra->hdr.item_next = update->offset;
+        ROE(jls_raw_chunk_seek(self->raw, mra->offset));
+        ROE(jls_raw_wr_header(self->raw, &mra->hdr));
+        ROE(jls_raw_chunk_seek(self->raw, current_pos));
+    }
+    *mra = *update;
+    return 0;
+}
+
+int32_t jls_wr_source_def(struct jls_wr_s * self, const struct jls_source_def_s * source) {
+    if (!self || !source) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (source->source_id >= JLS_SOURCE_COUNT) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (self->source_info[source->source_id].offset) {
+        JLS_LOGE("Duplicate source: %d", (int) source->source_id);
+        return JLS_ERROR_ALREADY_EXISTS;
+    }
+
+    // construct payload
+    buf_reset(self);
+    buf_add_zero(self, 64);  // reserve space for future use.
+    ROE(buf_add_str(self, source->name));
+    ROE(buf_add_str(self, source->vendor));
+    ROE(buf_add_str(self, source->model));
+    ROE(buf_add_str(self, source->version));
+    ROE(buf_add_str(self, source->serial_number));
+    uint32_t payload_length = buf_size(self);
+
+    // construct header
+    struct chunk_s * chunk = &self->source_info[source->source_id];
+    chunk->hdr.item_next = 0;  // update later
+    chunk->hdr.item_prev = self->source_mra.offset;
+    chunk->hdr.tag = JLS_TAG_SOURCE_DEF;
+    chunk->hdr.rsv0_u8 = 0;
+    chunk->hdr.chunk_meta = source->source_id;
+    chunk->hdr.payload_length = payload_length;
+    chunk->hdr.payload_prev_length = self->payload_prev_length;
+    chunk->offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk->hdr, self->buffer));
+    self->payload_prev_length = payload_length;
+    return update_mra(self, &self->source_mra, chunk);
+}
+
+static int32_t track_wr_def(struct jls_wr_s * self, struct track_info_s * track_info) {
+    // construct header
+    struct chunk_s * chunk = &track_info->def;
+    if (chunk->offset) {
+        return 0;  // no need to update
+    }
+    chunk->hdr.item_next = 0;  // update later
+    chunk->hdr.item_prev = self->signal_mra.offset;
+    chunk->hdr.tag = jls_track_tag_pack(track_info->track_type, JLS_TRACK_CHUNK_DEF);
+    chunk->hdr.rsv0_u8 = 0;
+    chunk->hdr.chunk_meta = track_info->signal_id;
+    chunk->hdr.payload_length = 0;
+    chunk->hdr.payload_prev_length = self->payload_prev_length;
+    chunk->offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk->hdr, NULL));
+    self->payload_prev_length = 0;
+    return update_mra(self, &self->signal_mra, chunk);
+}
+
+static int32_t track_wr_head(struct jls_wr_s * self, struct track_info_s * track_info) {
+    // construct header
+    struct chunk_s * chunk = &track_info->head;
+    if (!chunk->offset) {
+        chunk->hdr.item_next = 0;  // update later
+        chunk->hdr.item_prev = self->signal_mra.offset;
+        chunk->hdr.tag = jls_track_tag_pack(track_info->track_type, JLS_TRACK_CHUNK_HEAD);
+        chunk->hdr.rsv0_u8 = 0;
+        chunk->hdr.chunk_meta = track_info->signal_id;
+        chunk->hdr.payload_length = sizeof(track_info->head_offsets);
+        chunk->hdr.payload_prev_length = self->payload_prev_length;
+        chunk->offset = jls_raw_chunk_tell(self->raw);
+        JLS_LOGD1("track_wr_head %d 0x%02x new %" PRIi64, (int) chunk->hdr.chunk_meta, chunk->hdr.tag, chunk->offset);
+        ROE(jls_raw_wr(self->raw, &chunk->hdr, (uint8_t *) track_info->head_offsets));
+        self->payload_prev_length = sizeof(track_info->head_offsets);
+        track_info->head = *chunk;
+        return update_mra(self, &self->signal_mra, chunk);
+    } else {
+        JLS_LOGD1("track_wr_head %d 0x%02x update %" PRIi64, (int) chunk->hdr.chunk_meta, chunk->hdr.tag, chunk->offset);
+        int64_t pos = jls_raw_chunk_tell(self->raw);
+        ROE(jls_raw_chunk_seek(self->raw, chunk->offset));
+        ROE(jls_raw_wr_payload(self->raw, sizeof(track_info->head_offsets), (uint8_t *) track_info->head_offsets));
+        ROE(jls_raw_chunk_seek(self->raw, pos));
+    }
+    return 0;
+}
+
+int32_t jls_wr_signal_def(struct jls_wr_s * self, const struct jls_signal_def_s * signal) {
+    if (!self || !signal) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    uint16_t signal_id = signal->signal_id;
+    if (signal_id >= JLS_SIGNAL_COUNT) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (signal->source_id >= JLS_SOURCE_COUNT) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (!self->source_info[signal->source_id].offset) {
+        JLS_LOGW("source %d not found", signal->source_id);
+        return JLS_ERROR_NOT_FOUND;
+    }
+
+    struct signal_info_s * info = &self->signal_info[signal_id];
+    if (info->chunk_def.offset) {
+        JLS_LOGE("Duplicate signal: %d", (int) signal_id);
+        return JLS_ERROR_ALREADY_EXISTS;
+    }
+    if ((signal->signal_type != JLS_SIGNAL_TYPE_FSR) && (signal->signal_type != JLS_SIGNAL_TYPE_VSR)) {
+        JLS_LOGE("Invalid signal type: %d", (int) signal->signal_type);
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    // copy signal def
+    info->signal_def = *signal;
+    snprintf(info->name, sizeof(info->name), "%s", signal->name);
+    snprintf(info->units, sizeof(info->units), "%s", signal->units);
+    info->signal_def.name = info->name;
+
+    struct jls_signal_def_s * def = &info->signal_def;
+    ROE(jls_wr_fsr_validate(def));
+
+    switch (def->signal_type) {
+        case JLS_SIGNAL_TYPE_FSR:
+            if (!def->sample_rate) {
+                JLS_LOGE("FSR requires sample rate");
+                return JLS_ERROR_PARAMETER_INVALID;
+            }
+            break;
+        case JLS_SIGNAL_TYPE_VSR:
+            if (def->sample_rate) {
+                JLS_LOGE("VSR but sample rate specified, ignoring");
+                def->sample_rate = 0;
+            }
+            break;
+        default:
+            JLS_LOGE("Invalid signal type: %d", (int) def->signal_type);
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    // construct payload
+    buf_reset(self);
+    ROE(buf_wr_u16(self, def->source_id));
+    ROE(buf_wr_u8(self, def->signal_type));
+    ROE(buf_wr_u8(self, 0));  // reserved
+    ROE(buf_wr_u32(self, def->data_type));
+    ROE(buf_wr_u32(self, def->sample_rate));
+    ROE(buf_wr_u32(self, def->samples_per_data));
+    ROE(buf_wr_u32(self, def->sample_decimate_factor));
+    ROE(buf_wr_u32(self, def->entries_per_summary));
+    ROE(buf_wr_u32(self, def->summary_decimate_factor));
+    ROE(buf_wr_u32(self, def->annotation_decimate_factor));
+    ROE(buf_wr_u32(self, def->utc_decimate_factor));
+    ROE(buf_add_zero(self, 92));  // reserve space for future use.
+    ROE(buf_add_str(self, def->name));
+    ROE(buf_add_str(self, def->units));
+    uint32_t payload_length = buf_size(self);
+
+    // construct header
+    struct chunk_s * chunk = &info->chunk_def;
+    chunk->hdr.item_next = 0;  // update later
+    chunk->hdr.item_prev = self->signal_mra.offset;
+    chunk->hdr.tag = JLS_TAG_SIGNAL_DEF;
+    chunk->hdr.rsv0_u8 = 0;
+    chunk->hdr.chunk_meta = signal_id;
+    chunk->hdr.payload_length = payload_length;
+    chunk->hdr.payload_prev_length = self->payload_prev_length;
+    chunk->offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk->hdr, self->buffer));
+    self->payload_prev_length = payload_length;
+    ROE(update_mra(self, &self->signal_mra, chunk));
+
+    if (def->signal_type == JLS_SIGNAL_TYPE_FSR) {
+        info->tracks[JLS_TRACK_TYPE_FSR].track_type = JLS_TRACK_TYPE_FSR;
+        info->tracks[JLS_TRACK_TYPE_ANNOTATION].track_type = JLS_TRACK_TYPE_ANNOTATION;
+        info->tracks[JLS_TRACK_TYPE_UTC].track_type = JLS_TRACK_TYPE_UTC;
+        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_FSR]));
+        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_FSR]));
+        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
+        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
+        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_UTC]));
+        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_UTC]));
+    } else if (def->signal_type == JLS_SIGNAL_TYPE_VSR) {
+        info->tracks[JLS_TRACK_TYPE_VSR].track_type = JLS_TRACK_TYPE_VSR;
+        info->tracks[JLS_TRACK_TYPE_ANNOTATION].track_type = JLS_TRACK_TYPE_ANNOTATION;
+        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_VSR]));
+        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_VSR]));
+        ROE(track_wr_def(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
+        ROE(track_wr_head(self, &info->tracks[JLS_TRACK_TYPE_ANNOTATION]));
+    }
+
+    ROE(jls_wr_fsr_open(&info->signal_writer, self, def));
+    return 0;
+}
+
+int32_t jls_wr_user_data(struct jls_wr_s * self, uint16_t chunk_meta,
+                         enum jls_storage_type_e storage_type, const uint8_t * data, uint32_t data_size) {
+    if (!self) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (data_size && !data) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if (chunk_meta & 0xf000) {
+        JLS_LOGW("chunk_meta[15:12] nonzero.  Will be modified.");
+        chunk_meta &= 0x0fff;
+    }
+
+    switch (storage_type) {
+        case JLS_STORAGE_TYPE_INVALID:
+            data_size = 0; // allowed, but should only be used for the initial chunk.
+            break;
+        case JLS_STORAGE_TYPE_BINARY:
+            break;
+        case JLS_STORAGE_TYPE_STRING:  // intentional fall-through
+        case JLS_STORAGE_TYPE_JSON:
+            data_size = (uint32_t) strlen((const char *) data) + 1;
+            break;
+        default:
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+    chunk_meta |= ((uint16_t) storage_type) << 12;
+
+    // construct header
+    struct chunk_s chunk;
+    chunk.hdr.item_next = 0;  // update later
+    chunk.hdr.item_prev = self->user_data_mra.offset;
+    chunk.hdr.tag = JLS_TAG_USER_DATA;
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = chunk_meta;
+    chunk.hdr.payload_length = data_size;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, data));
+    self->payload_prev_length = data_size;
+    return update_mra(self, &self->user_data_mra, &chunk);
+}
+
+static int32_t signal_validate(struct jls_wr_s * self, uint16_t signal_id) {
+    if (signal_id >= JLS_SIGNAL_COUNT) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    struct signal_info_s * signal_info = &self->signal_info[signal_id];
+    if (!signal_info->chunk_def.offset) {
+        JLS_LOGW("attempted to annotated an undefined signal %d", (int) signal_id);
+        return JLS_ERROR_NOT_FOUND;
+    }
+    return 0;
+}
+
+static int32_t signal_validate_typed(struct jls_wr_s * self, uint16_t signal_id, enum jls_signal_type_e signal_type) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * signal_info = &self->signal_info[signal_id];
+    if (signal_info->signal_def.signal_type != signal_type) {
+        return JLS_ERROR_NOT_SUPPORTED;
+    }
+    return 0;
+}
+
+int64_t jls_wr_tell_prv(struct jls_wr_s * self) {
+    return jls_raw_chunk_tell(self->raw);
+}
+
+int32_t jls_wr_data_prv(struct jls_wr_s * self, uint16_t signal_id, enum jls_track_type_e track_type,
+                        const uint8_t * payload, uint32_t payload_length) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * info = &self->signal_info[signal_id];
+    struct track_info_s * track = &info->tracks[track_type];
+    struct chunk_s chunk;
+
+    chunk.hdr.item_next = 0;  // update later
+    chunk.hdr.item_prev = track->data.offset;
+    chunk.hdr.tag = jls_track_tag_pack(track->track_type, JLS_TRACK_CHUNK_DATA);
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = signal_id | (0 << 12);
+    chunk.hdr.payload_length = payload_length;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = jls_raw_chunk_tell(self->raw);
+
+    if (JLS_LOG_CHECK_STATIC(JLS_LOG_LEVEL_DEBUG3)) {
+        struct jls_payload_header_s * hdr = (struct jls_payload_header_s *) payload;
+        JLS_LOGD3("wr_data(signal_id=%d, timestamp=%" PRIi64 ", entries=%" PRIu32 ") => offset=%" PRIi64,
+                  (int) signal_id, hdr->timestamp, hdr->entry_count,
+                  jls_raw_chunk_tell(self->raw));
+    }
+
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, payload));
+    self->payload_prev_length = chunk.hdr.payload_length;
+    ROE(update_mra(self, &track->data, &chunk));
+
+    if (!track->head_offsets[0]) {
+        track->head_offsets[0] = chunk.offset;
+        ROE(track_wr_head(self, track));
+    }
+
+    return 0;
+}
+
+int32_t jls_wr_summary_prv(struct jls_wr_s * self, uint16_t signal_id, enum jls_track_type_e track_type, uint8_t level,
+                           const uint8_t * payload, uint32_t payload_length) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * info = &self->signal_info[signal_id];
+    struct track_info_s * track = &info->tracks[track_type];
+    struct chunk_s chunk;
+
+    chunk.hdr.item_next = 0;  // update later
+    chunk.hdr.item_prev = track->summary[level].offset;
+    chunk.hdr.tag = jls_track_tag_pack(track->track_type, JLS_TRACK_CHUNK_SUMMARY);
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = signal_id | (((uint16_t) level) << 12);
+    chunk.hdr.payload_length = payload_length;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, payload));
+    self->payload_prev_length = chunk.hdr.payload_length;
+    ROE(update_mra(self, &track->summary[level], &chunk));
+    return 0;
+}
+
+static inline int32_t update_track(struct jls_wr_s * self, struct track_info_s * track, uint8_t level, int64_t pos) {
+    if (!track->head_offsets[level]) {
+        track->head_offsets[level] = pos;
+        ROE(track_wr_head(self, track));
+    }
+    return 0;
+}
+
+int32_t jls_wr_index_prv(struct jls_wr_s * self, uint16_t signal_id, enum jls_track_type_e track_type, uint8_t level,
+                         const uint8_t * payload, uint32_t payload_length) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * info = &self->signal_info[signal_id];
+    struct track_info_s * track = &info->tracks[track_type];
+    struct chunk_s chunk;
+
+    chunk.hdr.item_next = 0;  // update later
+    chunk.hdr.item_prev = track->index[level].offset;
+    chunk.hdr.tag = jls_track_tag_pack(track->track_type, JLS_TRACK_CHUNK_INDEX);
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = signal_id | (((uint16_t) level) << 12);;
+    chunk.hdr.payload_length = payload_length;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = jls_raw_chunk_tell(self->raw);
+
+    // write
+    if (JLS_LOG_CHECK_STATIC(JLS_LOG_LEVEL_DEBUG3)) {
+        struct jls_payload_header_s * hdr = (struct jls_payload_header_s *) payload;
+        JLS_LOGD3("wr_index(signal_id=%d, level=%d, timestamp=%" PRIi64 ", entries=%" PRIu32
+                  ") => offset=%" PRIi64,
+                  (int) signal_id, (int) level,
+                  hdr->timestamp, hdr->entry_count,
+                  jls_raw_chunk_tell(self->raw));
+    }
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, payload));
+    self->payload_prev_length = chunk.hdr.payload_length;
+    ROE(update_mra(self, &track->index[level], &chunk));
+    ROE(update_track(self, track, level, chunk.offset));
+
+    return 0;
+}
+
+JLS_API int32_t jls_wr_fsr(struct jls_wr_s * self, uint16_t signal_id,
+                           int64_t sample_id, const void * data, uint32_t data_length) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * info = &self->signal_info[signal_id];
+    return jls_wr_fsr_data(info->signal_writer, sample_id, data, data_length);
+}
+
+int32_t jls_wr_fsr_f32(struct jls_wr_s * self, uint16_t signal_id,
+                       int64_t sample_id, const float * data, uint32_t data_length) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * info = &self->signal_info[signal_id];
+    if (info->signal_def.data_type != JLS_DATATYPE_F32) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    return jls_wr_fsr_data(info->signal_writer, sample_id, data, data_length);
+}
+
+int32_t jls_wr_annotation(struct jls_wr_s * self, uint16_t signal_id, int64_t timestamp,
+                          float y,
+                          enum jls_annotation_type_e annotation_type,
+                          uint8_t group_id,
+                          enum jls_storage_type_e storage_type,
+                          const uint8_t * data, uint32_t data_size) {
+    ROE(signal_validate(self, signal_id));
+    struct signal_info_s * signal_info = &self->signal_info[signal_id];
+    struct track_info_s * track = &signal_info->tracks[JLS_TRACK_TYPE_ANNOTATION];
+    if ((annotation_type & 0xff) != annotation_type) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+    if ((storage_type & 0xff) != storage_type) {
+        return JLS_ERROR_PARAMETER_INVALID;
+    }
+
+    // construct payload
+    buf_reset(self);
+    ROE(buf_wr_i64(self, timestamp));
+    ROE(buf_wr_u32(self, 1));  // number of entries
+    ROE(buf_wr_u16(self, 0));  // unspecified entry length
+    ROE(buf_wr_u16(self, 0));  // reserved
+    ROE(buf_wr_u8(self, annotation_type));
+    ROE(buf_wr_u8(self, storage_type));
+    ROE(buf_wr_u8(self, group_id));
+    ROE(buf_wr_u8(self, 0));    // reserved
+    ROE(buf_wr_f32(self, y));
+    switch (storage_type) {
+        case JLS_STORAGE_TYPE_BINARY:
+            ROE(buf_wr_u32(self, data_size));
+            ROE(buf_add_bin(self, data, data_size));
+            break;
+        case JLS_STORAGE_TYPE_STRING:
+            ROE(buf_wr_u32(self, (uint32_t) (strlen((const char *) data) + 1)));
+            ROE(buf_add_str(self, (const char *) data));
+            break;
+        case JLS_STORAGE_TYPE_JSON:
+            ROE(buf_wr_u32(self, (uint32_t) (strlen((const char *) data) + 1)));
+            ROE(buf_add_str(self, (const char *) data));
+            break;
+        default:
+            return JLS_ERROR_PARAMETER_INVALID;
+    }
+    uint32_t payload_length = buf_size(self);
+
+    // construct header
+    struct chunk_s chunk;
+    uint64_t offset = jls_raw_chunk_tell(self->raw);
+    chunk.hdr.item_next = 0;  // update later
+    chunk.hdr.item_prev = signal_info->tracks[JLS_TRACK_TYPE_ANNOTATION].data.offset;
+    chunk.hdr.tag = JLS_TAG_TRACK_ANNOTATION_DATA;
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = signal_id;
+    chunk.hdr.payload_length = payload_length;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = offset;
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, self->buf.start));
+    self->payload_prev_length = payload_length;
+    ROE(update_mra(self, &signal_info->tracks[JLS_TRACK_TYPE_ANNOTATION].data, &chunk));
+    ROE(update_track(self, track, 0, offset));
+
+    if (!track->ts) {
+        ROE(jls_wr_ts_open(&track->ts, self, signal_id, JLS_TRACK_TYPE_ANNOTATION,
+                           signal_info->signal_def.annotation_decimate_factor));
+    }
+    ROE(jls_wr_ts_anno(track->ts, timestamp, offset, annotation_type, group_id, y));
+    return 0;
+}
+
+int32_t jls_wr_utc(struct jls_wr_s * self, uint16_t signal_id, int64_t sample_id, int64_t utc) {
+    ROE(signal_validate_typed(self, signal_id,  JLS_SIGNAL_TYPE_FSR));
+    struct signal_info_s * signal_info = &self->signal_info[signal_id];
+    struct track_info_s * track = &signal_info->tracks[JLS_TRACK_TYPE_UTC];
+
+    // Construct payload
+    struct jls_utc_data_s payload = {
+        .header = {
+                .timestamp=sample_id,
+                .entry_count=1,
+                .entry_size_bits=sizeof(utc) * 8,
+                .rsv16=0,
+        },
+        .timestamp=utc
+    };
+    uint32_t payload_length = sizeof(payload);
+
+    // construct header
+    struct chunk_s chunk;
+    uint64_t offset = jls_raw_chunk_tell(self->raw);
+    chunk.hdr.item_next = 0;  // update later
+    chunk.hdr.item_prev = signal_info->tracks[JLS_TRACK_TYPE_UTC].data.offset;
+    chunk.hdr.tag = JLS_TAG_TRACK_UTC_DATA;
+    chunk.hdr.rsv0_u8 = 0;
+    chunk.hdr.chunk_meta = signal_id;
+    chunk.hdr.payload_length = payload_length;
+    chunk.hdr.payload_prev_length = self->payload_prev_length;
+    chunk.offset = offset;
+
+    // write
+    ROE(jls_raw_wr(self->raw, &chunk.hdr, (uint8_t *) &payload));
+    self->payload_prev_length = payload_length;
+    ROE(update_mra(self, &signal_info->tracks[JLS_TRACK_TYPE_UTC].data, &chunk));
+    ROE(update_track(self, track, 0, offset));
+
+    if (!track->ts) {
+        ROE(jls_wr_ts_open(&track->ts, self, signal_id, JLS_TRACK_TYPE_UTC,
+                           signal_info->signal_def.utc_decimate_factor));
+    }
+    ROE(jls_wr_ts_utc(track->ts, sample_id, offset, utc));
+    return 0;
+}
```

